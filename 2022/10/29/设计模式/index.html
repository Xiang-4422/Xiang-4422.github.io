

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/rideordie.png">
  <link rel="icon" href="/img/rideordie.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="XiangYU">
  <meta name="keywords" content="">
  
    <meta name="description" content="设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。 使用设计者模式的目的：  为了实现软件开发的可维护、可扩展 尽量复用代码 降低代码的耦合度  设计模式主要是基于OOP编程提炼的，它基于以下几个原则：  开闭原则  软件应对扩展开放，而对修改关闭。 具体指的是，在增加新功能的时候，最好不要通过修改原有代码来增加功能，而是通过增加新的代码来完成新的功能。">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Ride_or_DIE">
<meta property="og:description" content="设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。 使用设计者模式的目的：  为了实现软件开发的可维护、可扩展 尽量复用代码 降低代码的耦合度  设计模式主要是基于OOP编程提炼的，它基于以下几个原则：  开闭原则  软件应对扩展开放，而对修改关闭。 具体指的是，在增加新功能的时候，最好不要通过修改原有代码来增加功能，而是通过增加新的代码来完成新的功能。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030102323353.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030184005805.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030185415196.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030191508298.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030192800637.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031114411897.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031190100636.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031190609564.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205600593.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205849415.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205959983.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031213754596.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031214337749.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031224335921.png">
<meta property="og:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031231737824-16672294603681.png">
<meta property="article:published_time" content="2022-10-29T15:27:48.000Z">
<meta property="article:modified_time" content="2022-11-01T01:25:47.811Z">
<meta property="article:author" content="XiangYU">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030102323353.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>设计模式 - Ride_or_DIE</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"oJgRmRSoMnXMSzk2FSqr3T8l-gzGzoHsz","app_key":"2rUmLcHtDRExt0YFmed3951e","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ride_or_DIE</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="设计模式"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-29 23:27" pubdate>
          2022年10月29日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          53k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          444 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年11月1日 上午
                  
                
              </p>
            
            <div class="markdown-body">
              
              <p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。</p>
<p>使用设计者模式的<strong>目的</strong>：</p>
<ul>
<li>为了实现软件开发的可维护、可扩展</li>
<li>尽量复用代码</li>
<li>降低代码的耦合度</li>
</ul>
<p>设计模式主要是基于OOP编程提炼的，它基于以下几个<strong>原则</strong>：</p>
<ul>
<li><p>开闭原则</p>
<blockquote>
<p>软件应对扩展开放，而对修改关闭。</p>
<p>具体指的是，在增加新功能的时候，最好不要通过修改原有代码来增加功能，而是通过增加新的代码来完成新的功能。</p>
</blockquote>
</li>
<li><p>里氏替换原则</p>
<blockquote>
<p>如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行</p>
</blockquote>
</li>
</ul>
<p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计地复杂度和灵活性，并意识到设计模式并不是完成的。</p>
<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>关注点：如何创建对象。</p>
<p>核心思想：要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>
<h2 id="1-工厂方法（Factory-Method）"><a href="#1-工厂方法（Factory-Method）" class="headerlink" title="1. 工厂方法（Factory Method）"></a>1. 工厂方法（Factory Method）</h2><blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。</p>
</blockquote>
<h3 id="Number工厂方法"><a href="#Number工厂方法" class="headerlink" title="Number工厂方法"></a>Number工厂方法</h3><p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品。</p>
<p>以解析String到Number的工厂为例，解释工厂方法。</p>
<p>Number工厂定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象工厂：NumberFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-comment">//抽象产品：Number</span><br>    Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span>;<br>&#125;<br><span class="hljs-comment">//实际工厂：NumberFactoryImpl</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//实际产品；BigDecimal</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端获取实际工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在抽象工厂接口中定义一个静态方法getFactory来获取真正的工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-comment">// 创建方法:</span><br>    Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span>;<br><br>    <span class="hljs-comment">// 获取工厂实例:</span><br>    <span class="hljs-keyword">static</span> NumberFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> impl;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">NumberFactory</span> <span class="hljs-variable">impl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFactoryImpl</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在客户端中，只需要和工厂接口NumberFactory和抽象产品交互：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NumberFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> NumberFactory.getFactory();<br><span class="hljs-type">Number</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> factory.parse(<span class="hljs-string">&quot;123.456&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>调用方可以完全忽略真正的工厂和实际的产品，这样即使创建产品的代码变化也不会影响到调用方。</p>
<h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><blockquote>
<p>很多时候我们不需要抽象工厂，而是直接通过工厂类的静态方法来返回产品</p>
</blockquote>
<p>去掉抽象工厂接口后的静态工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java标准库中就有很多静态工厂方法设计的类，比如Integer和List。</p>
<h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><p>Integer即是产品又是静态工厂。它提供了静态方法valueOf()来创建Integer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>缓存优化：</strong></p>
<p>使用Integer.valueOf()和new Integer()之间的区别：</p>
<ul>
<li><p>使用new来获取一个Integer一定是新建一个对象。</p>
</li>
<li><p>而使用valueOf()来获取一个对象，工厂方法可以选择new一个新的Integer，也可以返回一个缓存的Integer。这样就可以避免创建过多重复的Integer对象。因为对于调用方而言，它不关心Integer的创建细节。</p>
</li>
</ul>
<p>工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p>
<h4 id="lIST"><a href="#lIST" class="headerlink" title="lIST"></a>lIST</h4><p>这个静态工厂方法接收可变参数，然后返回List接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>注意：调用方获取的产品总是List接口，而且并不关心它的实际类型（里氏替换原则）。</p>
<h2 id="2-抽象工厂（Abstract-Factory）"><a href="#2-抽象工厂（Abstract-Factory）" class="headerlink" title="2. 抽象工厂（Abstract Factory）"></a>2. 抽象工厂（Abstract Factory）</h2><blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>
<p>抽象工厂模式和工厂方法不太一样，它需要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建。因此这个抽象工厂会对应到多个实际工厂，而每个实际工厂负责创建多个实际产品。</p>
<p>关系示意图如下：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030102323353.png" srcset="/img/loading.gif" lazyload alt="image-20221030102323353"></p>
<p>这种模式有点类似于多个供应商提供一系列类型的产品。</p>
<p>举个例子，我们希望位用户提供一个Markdown文本转HTML和Word的服务，其接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象工厂接口：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-comment">// 创建Html文档:</span><br>    HtmlDocument <span class="hljs-title function_">createHtml</span><span class="hljs-params">(String md)</span>;<br>    <span class="hljs-comment">// 创建Word文档:</span><br>    WordDocument <span class="hljs-title function_">createWord</span><span class="hljs-params">(String md)</span>;<br>&#125;<br><br><span class="hljs-comment">//抽象产品接口：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HtmlDocument</span> &#123;<br>    String <span class="hljs-title function_">toHtml</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WordDocument</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面只是定义了接口，对于用户而言，只需要接触上面的接口。具体的实现比较困难，由供应商来完成。</p>
<p>供应商FastDoc Soft的产品便宜，并且转换速度快。供应商GoodDoc Soft的产品贵，但是转换效果好。我们可以同时使用这两家供应商的产品，以便给免费用户和付费用户提供差异化的服务。</p>
<p>FaseDoc Soft的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实际的产品</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastHtmlDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HtmlDocument</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toHtml</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastWordDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WordDocument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ...<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实际的工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> HtmlDocument <span class="hljs-title function_">createHtml</span><span class="hljs-params">(String md)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastHtmlDocument</span>(md);<br>    &#125;<br>    <span class="hljs-keyword">public</span> WordDocument <span class="hljs-title function_">createWord</span><span class="hljs-params">(String md)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastWordDocument</span>(md);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端调用Fast Doc的服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建AbstractFactory，实际类型是FastFactory:</span><br><span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastFactory</span>();<br><span class="hljs-comment">// 生成Html文档:</span><br><span class="hljs-type">HtmlDocument</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> factory.createHtml(<span class="hljs-string">&quot;#Hello\nHello, world!&quot;</span>);<br>html.save(Paths.get(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;fast.html&quot;</span>));<br><span class="hljs-comment">// 生成Word文档:</span><br><span class="hljs-type">WordDocument</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> factory.createWord(<span class="hljs-string">&quot;#Hello\nHello, world!&quot;</span>);<br>word.save(Paths.get(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;fast.doc&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>如果客户端要调用不同的服务，只需要把new FastFactory换成new其他的实际工厂即可。</p>
<p>如果将获取实际工厂的代码封装到AbstractFactory中，那么在客户端则可以和实际工厂完全解耦，要调用不同的服务只需要不同过的名字即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建AbstractFactory，实际类型是FastFactory:</span><br><span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> FastFactory.createFactory(<span class="hljs-string">&quot;fast&quot;</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractFactory <span class="hljs-title function_">createFactory</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (name.equalsIgnoreCase(<span class="hljs-string">&quot;fast&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.equalsIgnoreCase(<span class="hljs-string">&quot;good&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GoodFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid factory name&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-生成器-Builder"><a href="#3-生成器-Builder" class="headerlink" title="3. 生成器(Builder)"></a>3. 生成器(Builder)</h2><blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>生成器模式是使用多个“小型”工厂来最终创建出一个完成对象。当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<h3 id="Markdown转HTML"><a href="#Markdown转HTML" class="headerlink" title="Markdown转HTML"></a>Markdown转HTML</h3><p>如果说是针对以下一行文本的转换，使用一个转换器即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markd"># this is a heading<br></code></pre></td></tr></table></figure>

<p>如果将整个Markdown文档转HTML看作一行一行的转换，每一行根据语法，调用不同的转换器：</p>
<ul>
<li>#开头，使用HeadingBuilder转换</li>
<li>&gt;开头，使用QuoteBuilder转换</li>
<li>—开头，使用HrBuider转换</li>
<li>其余使用ParagraphBuilder转换</li>
</ul>
<p>HtmlBuider写出来如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HtmlBuilder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HeadingBuilder</span> <span class="hljs-variable">headingBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeadingBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HrBuilder</span> <span class="hljs-variable">hrBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HrBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ParagraphBuilder</span> <span class="hljs-variable">paragraphBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParagraphBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">QuoteBuilder</span> <span class="hljs-variable">quoteBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuoteBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toHtml</span><span class="hljs-params">(String markdown)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">//读取每一行，根据不同的语法，调用不同的子Builder</span><br>        markdown.lines().forEach(line -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;#&quot;</span>)) &#123;<br>                buffer.append(headingBuilder.buildHeading(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;&gt;&quot;</span>)) &#123;<br>                buffer.append(quoteBuilder.buildQuote(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;---&quot;</span>)) &#123;<br>                buffer.append(hrBuilder.buildHr(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                buffer.append(paragraphBuilder.buildParagraph(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，我们只需要针对每一种类型编写对应的Builder，如果需要修改或增加一种语法，只需要修改或增加一个Builder即可，不需要对整个HtmlBuilder进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeadingBuilder</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">buildHeading</span><span class="hljs-params">(String line)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (line.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            n++;<br>            line = line.substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;&lt;h%d&gt;%s&lt;/h%d&gt;&quot;</span>, n, line.strip(), n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可见，使用Builder模式，适用于创建比较复杂的对象，先一步一步构造出零件，最后再将零件组装成一个整体对象。</p>
<h3 id="MimeMessage"><a href="#MimeMessage" class="headerlink" title="MimeMessage"></a>MimeMessage</h3><p>JavaMail的MimeMessage就可以看作是一个Builder模式，只不过它既是Builder也是最终产品：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 构造产品</span><br><span class="hljs-type">Multipart</span> <span class="hljs-variable">multipart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMultipart</span>();<br><span class="hljs-comment">// 添加text:</span><br><span class="hljs-type">BodyPart</span> <span class="hljs-variable">textpart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeBodyPart</span>();<br>textpart.setContent(body, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>multipart.addBodyPart(textpart);<br><span class="hljs-comment">// 添加image:</span><br><span class="hljs-type">BodyPart</span> <span class="hljs-variable">imagepart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeBodyPart</span>();<br>imagepart.setFileName(fileName);<br>imagepart.setDataHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayDataSource</span>(input, <span class="hljs-string">&quot;application/octet-stream&quot;</span>)));<br>multipart.addBodyPart(imagepart);<br><br><span class="hljs-comment">// 2. 发送邮件</span><br><span class="hljs-type">MimeMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMessage</span>(session);<br><span class="hljs-comment">// 设置发送方地址:</span><br>message.setFrom(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InternetAddress</span>(<span class="hljs-string">&quot;me@example.com&quot;</span>));<br><span class="hljs-comment">// 设置接收方地址:</span><br>message.setRecipient(Message.RecipientType.TO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternetAddress</span>(<span class="hljs-string">&quot;xiaoming@somewhere.com&quot;</span>));<br><span class="hljs-comment">// 设置邮件主题:</span><br>message.setSubject(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">// 设置邮件内容为multipart:</span><br>message.setContent(multipart);<br></code></pre></td></tr></table></figure>

<h3 id="链式调用的构造器"><a href="#链式调用的构造器" class="headerlink" title="链式调用的构造器"></a>链式调用的构造器</h3><p>很多时候，可以简化Builder模式，以链式调用的方式来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>builder.append(secure ? <span class="hljs-string">&quot;https://&quot;</span> : <span class="hljs-string">&quot;http://&quot;</span>)<br>       .append(<span class="hljs-string">&quot;www.liaoxuefeng.com&quot;</span>)<br>       .append(<span class="hljs-string">&quot;/&quot;</span>)<br>       .append(<span class="hljs-string">&quot;?t=0&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> builder.toString();<br></code></pre></td></tr></table></figure>

<p>例如构造URL字符串，可以适用Builder模式编写URLBuilder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> URLBuilder.builder() <span class="hljs-comment">// 创建Builder</span><br>        .setDomain(<span class="hljs-string">&quot;www.liaoxuefeng.com&quot;</span>) <span class="hljs-comment">// 设置domain</span><br>        .setScheme(<span class="hljs-string">&quot;https&quot;</span>) <span class="hljs-comment">// 设置scheme</span><br>        .setPath(<span class="hljs-string">&quot;/&quot;</span>) <span class="hljs-comment">// 设置路径</span><br>        .setQuery(Map.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;K&amp;R&quot;</span>)) <span class="hljs-comment">// 设置query</span><br>        .build(); <span class="hljs-comment">// 完成build</span><br></code></pre></td></tr></table></figure>

<h2 id="4-原型（Prototype）"><a href="#4-原型（Prototype）" class="headerlink" title="4. 原型（Prototype）"></a>4. 原型（Prototype）</h2><blockquote>
<p>用原型实例指定创建对象的类型，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p>JDK中的原型模式：</p>
<p>如果我们已经有一个String[]数组，想要再创建一个一摸一样的String[]数组该如何实现？</p>
<p>实际上创建过程很简单，创建一个同样大小的新数组，然后将数组元素一一复制到新数组即可。如果我们将这个过程封装一下，那么就是原型模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原型:</span><br>String[] original = &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span> &#125;;<br><span class="hljs-comment">// 新对象:</span><br>String[] copy = Arrays.copyOf(original, original.length);<br></code></pre></td></tr></table></figure>

<p>Object的clone() 方法：</p>
<p>对于一个普通类，要实现原型的拷贝，可以通过Object提供的clone()方法，需要实现一个Cloneable接口标记来标识对象是“可复制的”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-comment">// 复制新对象并返回:</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        std.id = <span class="hljs-built_in">this</span>.id;<br>        std.name = <span class="hljs-built_in">this</span>.name;<br>        std.score = <span class="hljs-built_in">this</span>.score;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>clone()方法的缺点：</p>
<p>因为clone()的方法签名是在Object中，返回的类型也是Object，所以需要强制转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">std1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>std1.setId(<span class="hljs-number">123</span>);<br>std1.setName(<span class="hljs-string">&quot;Bob&quot;</span>);<br>std1.setScore(<span class="hljs-number">88</span>);<br><span class="hljs-comment">// 复制新对象:</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">std2</span> <span class="hljs-operator">=</span> (Student) std1.clone();<span class="hljs-comment">//clone得到是Object对象，需要强制转型</span><br>System.out.println(std1);<br>System.out.println(std2);<br>System.out.println(std1 == std2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>所以说使用原型模式的更好方法是定义一个copy()方法，返回明确的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        std.id = <span class="hljs-built_in">this</span>.id;<br>        std.name = <span class="hljs-built_in">this</span>.name;<br>        std.score = <span class="hljs-built_in">this</span>.score;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给拎一个对象共享的。只有存储简单类型的“值”对象可以复制。</p>
<h2 id="5-单例"><a href="#5-单例" class="headerlink" title="5. 单例"></a>5. 单例</h2><blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<h3 id="单例创建与获取"><a href="#单例创建与获取" class="headerlink" title="单例创建与获取"></a>单例创建与获取</h3><p>如何创建单例：</p>
<p>因为这个类只有一个实例，一次不能通过new来创建实例。所以，单例的构造方法必须是private，这样就防止调用方通过new来创建实例，但是再类的内部，可以用一个静态字段来引用唯一创建的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如何获取单例：</p>
<ul>
<li><p>对外提供一个静态方法，直接放回实例</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 通过静态方法返回实例:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>直接把static变量暴露给外部</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>综上，单例模式的实现只需要如下操作：</p>
<ul>
<li>只有private构造方法，确保外部无法实例化；</li>
<li>通过private static变量持有唯一实例，确保全局唯一性；</li>
<li>通过public static方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ul>
<h3 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h3><h4 id="延迟加载单例的实现"><a href="#延迟加载单例的实现" class="headerlink" title="延迟加载单例的实现"></a>延迟加载单例的实现</h4><p>延迟加载，即在调用方第一次调用getInstance()时才初始化全局唯一实例，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在多线程中，上面这种写法是错误的，在多线程竞争中会创建多个实例，必须对整个方法加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>加锁严重影响性能，可以使用双重检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于Java内存模型的重排序，上面的双重检查会导致实例还未初始化完成，引用就被暴露，还需要使用volatile修饰单例变量。要实现线程安全的延时加载，可以通过Java的ClassLoader机制完成。</p>
<p>如果没有特殊需求，使用Singleton模式的时候，最好不要使用延迟加载，这样更简单。</p>
<h4 id="通过枚举类的实现"><a href="#通过枚举类的实现" class="headerlink" title="通过枚举类的实现"></a>通过枚举类的实现</h4><p>因为Java保证枚举类的每个枚举都是单例，所以编写一个只有一个枚举的类即可实现单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">World</span> &#123;<br>    <span class="hljs-comment">// 唯一枚举:</span><br>	INSTANCE;<br>    <br>	<span class="hljs-comment">//枚举类可以定义自己的字段、方法</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;world&quot;</span>;<br><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>		<span class="hljs-built_in">this</span>.name = name;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>枚举类的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> World.INSTANCE.getName();<br></code></pre></td></tr></table></figure>

<p>枚举实现单例模式还避免了第一种方法实现单例模式的一个潜在问题：即序列化和反序列化会绕过普通类的private构造方法从而创建多个实例。而枚举类就没有这个问题。</p>
<h4 id="通过约定实现"><a href="#通过约定实现" class="headerlink" title="通过约定实现"></a>通过约定实现</h4><p>何时使用Singleton？</p>
<p>实际上，很多应用程序，尤其是Web程序，大部分服务类都应该被视作Singleton。</p>
<p>如果全部都按照Singleton的写法来实现这些服务会很麻烦，所以，通常 通过约定让框（例如Spring）来实例化这些类，让框架来保证只有一个实例，调用方自觉通过框架获取实例，而不是new操作符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 表示一个单例组件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，除非确实有必要，否则Singleton模式一般以“约定”为主，不会可以去实现它。</p>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式主要设计如何组合各种对象以便获得更好、更灵活得结构。</p>
<p>虽然面向对象得继承机制提供了最基本得子类扩展父类得功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p>
<h2 id="6-适配器（Adapter）"><a href="#6-适配器（Adapter）" class="headerlink" title="6. 适配器（Adapter）"></a>6. 适配器（Adapter）</h2><blockquote>
<p>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>如果一个接口需要B接口，但是传入的对象缺是A接口，需要如何解决？</p>
<p>例如：我们已有一个Task类，实现了Callable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Long&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> num;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> &#123;<br>        <span class="hljs-built_in">this</span>.num = num;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; n &lt;= <span class="hljs-built_in">this</span>.num; n++) &#123;<br>            r = r + n;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + r);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>若我们想通过一个线程去执行它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-number">123450000L</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(callable); <span class="hljs-comment">// compile error!</span><br>thread.start();<br></code></pre></td></tr></table></figure>

<p>上面的代码无法编译，因为Thread接收Runable接口，不能接收Callable接口。怎么解决？</p>
<p>方法一、改写Task类，把实现Callable接口改为Runable接口。</p>
<blockquote>
<p>这样做可以让Thread这儿的代码正常运行，但是Task在其他地方可能正作为Callable被引用，改写Task的接口会导致其他正常工作的代码无法编译。即牵一发而动全身。</p>
</blockquote>
<p>方法二、不改写Task类，而是用一个新建一个Adapter类来包装Task</p>
<blockquote>
<p>首先，Adapter实现Runable接口，作为参数传入Thread</p>
<p>然后，Adapter通过持有Task实例，实际的方法调用是调用被Adapter包装的Task</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-number">123450000L</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>(callable));<br>thread.start();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 引用待转换接口:</span><br>    <span class="hljs-keyword">private</span> Callable&lt;?&gt; callable;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RunnableAdapter</span><span class="hljs-params">(Callable&lt;?&gt; callable)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callable = callable;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现指定接口:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 将指定接口调用委托给转换接口调用:</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            callable.call();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java标准库中适配器模式的应用：</p>
<ul>
<li><p>List[] Arrays.asList(T[])</p>
<blockquote>
<p>若我们持有一个String[]，但是需要的是List接口，则可以通过一个Adapter来转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;Good&quot;</span>, <span class="hljs-string">&quot;morning&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>&#125;;<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(exist));<br></code></pre></td></tr></table></figure>

<p>List[] Arrays.asList([])就相当于一个转换器，可以把数组转换为List</p>
</blockquote>
</li>
<li><p>InputStreamReader</p>
<blockquote>
<p>若我们持有一个InputStream，但是希望调用readText(Reader)方法，需要的是一个Reader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> Files.newInputStream(Paths.get(<span class="hljs-string">&quot;/path/to/file&quot;</span>));<br><span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(input, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>readText(reader);<br></code></pre></td></tr></table></figure>

<p>InputStreamReader就是Java标准库提供的Adapter，它负责将InputStream适配为Reader</p>
</blockquote>
</li>
</ul>
<p>面向抽象编程原则（面向抽象编程）：</p>
<p>如果上面的readText(Reader)方法参数从Reader改为FileReader，那么我们需要将InputStream适配为FileReader，直接使用inputStreamReader进行转换得到的是Reader，无法使用，这个时候就会跟麻烦。所以说，我们需要面向抽象编程，持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类型，想要做一些改动就会很困难。</p>
<h2 id="7-桥接"><a href="#7-桥接" class="headerlink" title="7. 桥接"></a>7. 桥接</h2><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
</blockquote>
<p>假设某汽车厂商生产三个品牌地汽车：Big、Tiny和Boss，每个品牌又可以选择燃油、纯电和混合动力。</p>
<p>若使用传统的继承来表示最终车型，则有三个抽象类和九个最终子类：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030184005805.png" srcset="/img/loading.gif" lazyload alt="image-20221030184005805"></p>
<p>若要新增一个品牌，或新增新引擎的车（比如核动力），那么子类的数量增长更快。</p>
<p>桥接模式就是为了避免直接继承带来的子类数量暴增问题。</p>
<p>桥接模式的解决办法：</p>
<ul>
<li><p>首先把Car按品牌进行子类化，但是每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br> <span class="hljs-comment">// 引用Engine:</span><br> <span class="hljs-keyword">protected</span> Engine engine;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Engine engine)</span> &#123;<br>     <span class="hljs-built_in">this</span>.engine = engine;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>紧接着，在一个“修正”的抽象类RefindeCar中定义一些额外操作：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RefinedCar</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">super</span>(engine);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.engine.start();<br>        System.out.println(<span class="hljs-string">&quot;Drive &quot;</span> + getBrand() + <span class="hljs-string">&quot; car...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getBrand</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>最终，不同品牌的继承自RefinderCar。不同的引擎继承自Engine</p>
</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RefinedCar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BossCar</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">super</span>(engine);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBrand</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Boss&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HybridEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Start Hybrid Engine...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<ul>
<li>客户端通过自己选择一个品牌，在配合一种引擎，得到最终的Car：</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RefinedCar</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BossCar</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HybridEngine</span>());<br>car.drive();<br></code></pre></td></tr></table></figure>
</blockquote>
<p>桥接模式的好处在于，如果要增加一种引擎，只需要针对Engine派生一个新的子类，如果需要增加一个品牌，只需要针对RefindedCar派生一个子类。任何RefindedCar的子类和任何Engine都可以自由组合，即一辆车的两个维度：品牌和引擎都可以独立地变化。</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030185415196.png" srcset="/img/loading.gif" lazyload alt="image-20221030185415196"></p>
<p>桥接模式实现比较复杂，实际应用也非常少，但是它提供的设计思想值得借鉴，即：</p>
<p><strong>不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</strong></p>
<h2 id="8-组合（Composite）"><a href="#8-组合（Composite）" class="headerlink" title="8. 组合（Composite）"></a>8. 组合（Composite）</h2><blockquote>
<p>将对象组合成树形结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>组合模式经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p>
<p>以XML的树形表示为例：</p>
<p>在XML或HTML中，从根节点开始，每个节点都能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。</p>
<p>若要以树的结构抽象XML，我们先抽象出节点Node：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 添加一个节点为子节点:</span><br>    Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>;<br>    <span class="hljs-comment">// 获取子节点:</span><br>    List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 输出为XML:</span><br>    String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于&lt;abc&gt;这样的节点，我们称之为ElementNode，它可以作为容器包含多个子节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElementNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ElementNode</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br>        list.add(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;&quot;</span> + name + <span class="hljs-string">&quot;&gt;\n&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;/&quot;</span> + name + <span class="hljs-string">&quot;&gt;\n&quot;</span>;<br>        <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;&quot;</span>, start, end);<br>        list.forEach(node -&gt; &#123;<br>            sj.add(node.toXml() + <span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> sj.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于普通文本，我们把它看作TextNode，它没有子节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br>	<span class="hljs-keyword">private</span> String text;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">TextNode</span><span class="hljs-params">(String text)</span> &#123;<br>		<span class="hljs-built_in">this</span>.text = text;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> List.of();<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> text;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此外，还可以有注释节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br>	<span class="hljs-keyword">private</span> String text;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">CommentNode</span><span class="hljs-params">(String text)</span> &#123;<br>		<span class="hljs-built_in">this</span>.text = text;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> List.of();<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;!-- &quot;</span> + text + <span class="hljs-string">&quot; --&gt;&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过ElementNode、TextNode和CommentNode，我们就可以构造出一颗树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;school&quot;</span>);<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;classA&quot;</span>)<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Tom&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Alice&quot;</span>)));<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;classB&quot;</span>)<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Bob&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Grace&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommentNode</span>(<span class="hljs-string">&quot;comment...&quot;</span>)));<br>System.out.println(root.toXml());<br></code></pre></td></tr></table></figure>

<p>最后通过root节点输出的XML如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">classA</span>&gt;</span><br>Tom<br>Alice<br><span class="hljs-tag">&lt;/<span class="hljs-name">classA</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">classB</span>&gt;</span><br>Bob<br>Grace<br><span class="hljs-comment">&lt;!-- comment... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">classB</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可见，使用Composite模式，需要先统一单个节点以及“容器”节点的接口：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030191508298.png" srcset="/img/loading.gif" lazyload alt="image-20221030191508298"></p>
<p>作为容器节点的ElementNode又可以添加任意个Node，这样就可以构成层级结构。</p>
<p>类似的，像是文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p>
<h2 id="9-装饰器（Decorator）"><a href="#9-装饰器（Decorator）" class="headerlink" title="9. 装饰器（Decorator）"></a>9. 装饰器（Decorator）</h2><blockquote>
<p>动态地给一个对象添加一些额外地职责。就增加功能来说，相比生成子类更灵活。</p>
</blockquote>
<p>装饰器模式，是一种在运行期动态地给某个对象的实例增加功能的方法。</p>
<p>在Java标准库中，InputStream是抽象类，FileInputStream、ServletInputStream、Socket.getInputStream ()这些都是最终数据源。如果说现在，我们要给不同的数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加数据源或功能，那么子类数量会暴涨。</p>
<p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最汇总通过醋和获得我们想要地功能。</p>
<p>例如：给FileInputStream增加缓冲和解压缩功能，用Decorator模式地写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建原始的数据源:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.gz&quot;</span>);<br><span class="hljs-comment">// 增加缓冲功能:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br><span class="hljs-comment">// 增加解压缩功能:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">gis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GZIPInputStream</span>(bis);<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GZIPInputStream</span>( <span class="hljs-comment">// 第二层装饰</span><br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>( <span class="hljs-comment">// 第一层装饰</span><br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.gz&quot;</span>) <span class="hljs-comment">// 核心功能</span><br>                        ));<br></code></pre></td></tr></table></figure>

<p>观察BufferedInputStream和GZIPInputStream的继承关系，它们都是从FilterInputStream继承来的，而FilterInputStream是一个抽象类。</p>
<p>用图表示Decorator模式：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030192800637.png" srcset="/img/loading.gif" lazyload alt="image-20221030192800637"></p>
<ul>
<li><p>最顶层的Component是接口。对应到IO就是InputStream这个抽象类。</p>
</li>
<li><p>ComponentA、ComponentB则是实际的子类。对应到IO就是FileInputStream、ServletInputStream这些数据源。</p>
</li>
<li><p>Decorator是用于实现各个附加功能的抽象装饰器。对应到IO就是FileInputStream</p>
</li>
<li><p>而从Decorator派生的就是一个个的装饰器，它们每个都有独立的功能。对应到IO就是BufferedInputStream、GZIPInputStream等</p>
</li>
</ul>
<p>Decorator模式有什么好处？</p>
<p>它实际把核心功能和附加功能给分开了。核心功能指FileInputStream这些真正读取数据的数据源，附加功能指的是缓冲、压缩、解密这些功能。如果我们要增加核心功能，就增加Component的子类，例如ByteInputStream。如果我们要增加附加功能，就增加Decorator的子类，例如CipherInputStream。两个部分可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
<p>如何设计完整地Decorator模式？</p>
<p>以HTML文本渲染为例，文本可以附加一些效果，如加粗、变斜体、加下划线等。为了实现动态地附加效果，可以采用Decorator模式。</p>
<ul>
<li><p>定义顶层接口TextNode：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-comment">// 设置text:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span>;<br>    <span class="hljs-comment">// 获取text:</span><br>    String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>核心节点：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpanNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-keyword">private</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;span&gt;&quot;</span> + text + <span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>抽象的Decorator类：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-comment">//持有一个TextNode</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> TextNode target;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">NodeDecorator</span><span class="hljs-params">(TextNode target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target.setText(text);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>具体的Decorator类：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BoldDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NodeDecorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BoldDecorator</span><span class="hljs-params">(TextNode target)</span> &#123;<br>        <span class="hljs-built_in">super</span>(target);<br>    &#125;<br>	<span class="hljs-comment">//附加功能</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;b&gt;&quot;</span> + target.getText() + <span class="hljs-string">&quot;&lt;/b&gt;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>客户端组合使用Decorator：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>();<br><span class="hljs-type">TextNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoldDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UnderlineDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>()));<br><span class="hljs-type">TextNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItalicDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BoldDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>()));<br>n1.setText(<span class="hljs-string">&quot;Hello&quot;</span>);<br>n2.setText(<span class="hljs-string">&quot;Decorated&quot;</span>);<br>n3.setText(<span class="hljs-string">&quot;World&quot;</span>);<br>System.out.println(n1.getText());<br><span class="hljs-comment">// 输出&lt;span&gt;Hello&lt;/span&gt;</span><br><br>System.out.println(n2.getText());<br><span class="hljs-comment">// 输出&lt;b&gt;&lt;u&gt;&lt;span&gt;Decorated&lt;/span&gt;&lt;/u&gt;&lt;/b&gt;</span><br><br>System.out.println(n3.getText());<br><span class="hljs-comment">// 输出&lt;i&gt;&lt;b&gt;&lt;span&gt;World&lt;/span&gt;&lt;/b&gt;&lt;/i&gt;</span><br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="10-外观（Facade）"><a href="#10-外观（Facade）" class="headerlink" title="10. 外观（Facade）"></a>10. 外观（Facade）</h2><blockquote>
<p>为系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<p>外观模式的基本思想：</p>
<p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p>
<p>以注册公司为例，假设组测公司需要三步：</p>
<ol>
<li>向工商局申请营业执照；</li>
<li>在银行开设账户；</li>
<li>在税务局开设纳税号；</li>
</ol>
<p>三个接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工商注册:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminOfIndustry</span> &#123;<br>    <span class="hljs-keyword">public</span> Company <span class="hljs-title function_">register</span><span class="hljs-params">(String name)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 银行开户:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">openAccount</span><span class="hljs-params">(String companyId)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 纳税登记:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Taxation</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">applyTaxCode</span><span class="hljs-params">(String companyId)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用户为了注册公司，需要逐步的去调用这些接口，比较麻烦，这个时候，直接将这些流程全部委托给中介：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>    <span class="hljs-keyword">public</span> Company <span class="hljs-title function_">openCompany</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Company</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.admin.register(name);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.bank.openAccount(c.getId());<br>        c.setBankAccount(bankAccount);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">taxCode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.taxation.applyTaxCode(c.getId());<br>        c.setTaxCode(taxCode);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，用户需要注册公司，只需要调用中介这一个接口，再由中介去执行其他具体流程，用户不需要关心中介如何完成注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用户委托中介注册公司</span><br><span class="hljs-type">Company</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> facade.openCompany(<span class="hljs-string">&quot;Facade Software Ltd.&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>很多Web程序，内部由多个子系统提供服务，经常使用一个统一的Facade入口，例如一个RestApiController，使得外部用户调用的时候，只需要关系Facade提供的接口，不用管内部是哪个子系统处理的。</p>
<p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，其本质也是一个Facade（外观的外观），但可以附加一些用户认证、限流限速的额外服务。</p>
<h2 id="11-享元（Flyweight）"><a href="#11-享元（Flyweight）" class="headerlink" title="11. 享元（Flyweight）"></a>11. 享元（Flyweight）</h2><blockquote>
<p>运用共享技术有效地支持大量细粒度地对象。</p>
</blockquote>
<p>核心思想：</p>
<p>如果一个对象实例一经创建就不可变，那么反复创建相同地实例就没有必要，直接向调用方返回一个共享地实例就行，这样既节省内粗，又可以减少创建对象地过程，提高运行速度。</p>
<p>享元模式在Java标准库中地应用：Byte、Integer都是不变类。以Integer为例，通过Integer.valueOf()这个静态方法创建Integer实例，当传入地int范围在-128~到+127之间时，会直接返回缓存地Integer实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>        System.out.println(n1 == n2); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于Byte来说，因为Byte只有256个状态，所以通过Byte.valueOf()创建地Byte实例全部都是缓存对象。</p>
<p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓冲地实例，而不是新建实例，从而实现不可变实例的复用。（总是使用工厂方法来获取实例，而不是通过new创建实例，可以更好地复用对象）。</p>
<p>在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不被每次查询数据库或者读取文件，而是直接返回内存中缓存地数据。</p>
<p>以Student为例，设计一个静态工厂方法，在内部可以返回缓存的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 持有缓存:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Student&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 静态工厂方法:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> id + <span class="hljs-string">&quot;\n&quot;</span> + name;<br>        <span class="hljs-comment">// 先查找缓存:</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-comment">// 若没有缓存：</span><br>        <span class="hljs-keyword">if</span> (std == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 创建新对象</span><br>            System.out.println(String.format(<span class="hljs-string">&quot;create new Student(%s, %s)&quot;</span>, id, name));<br>            std = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, name);<br>            <span class="hljs-comment">// 放入缓存</span><br>            cache.put(key, std);<br>        <span class="hljs-comment">// 若已缓存：</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(String.format(<span class="hljs-string">&quot;return cached Student(%s, %s)&quot;</span>, std.id, std.name));<br>        &#125;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br>	<span class="hljs-comment">// Student属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>	<br>    <span class="hljs-comment">// Student构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在实际的应用中，我们经常使用成熟的缓存库，例如Guava的Cache，因为它提供了最大缓存数量限制、定时过期等实用功能。</p>
<h2 id="12-代理（Proxy）"><a href="#12-代理（Proxy）" class="headerlink" title="12. 代理（Proxy）"></a>12. 代理（Proxy）</h2><blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<h3 id="Proxy对比Adapter"><a href="#Proxy对比Adapter" class="headerlink" title="Proxy对比Adapter"></a>Proxy对比Adapter</h3><p>Adapter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BAdapter</span><span class="hljs-params">(A a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        a.a();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Proxy:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AProxy</span><span class="hljs-params">(A a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//do somthing</span><br>        <span class="hljs-built_in">this</span>.a.a();<br>        <span class="hljs-comment">//do somthing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li><p>Adapter是将接口A转换为接口B（适配）</p>
<blockquote>
<p>目的是为例让只能调用接口B的方法,通过Adapter的转换可以调用接口A。</p>
</blockquote>
</li>
<li><p>Proxy只是将接口A再包了一层（增强）</p>
<blockquote>
<p>目的是在不修改原有接口的前提下，对原有接口的方法进行增强。</p>
<p>可以在调用原接口方法的前后执行扩展操作。</p>
</blockquote>
</li>
</ul>
<p>可以通过Proxy设计方法进行权限检查，只有拥有对应权限的用户才可以真正调用目标接口方法。</p>
<p>为什么实用Proxy，而不是直接将权限检查写到接口A的内部？</p>
<ul>
<li>编写代码的原则：<ul>
<li>职责清晰：一个类只负责一件事</li>
<li>易于测试：一次只测一个功能</li>
</ul>
</li>
<li>代码解耦<ul>
<li>实用Proxy实现权限检查，代码更加清晰、简介<ul>
<li>A接口：只定义接口</li>
<li>ABusinuess类：实现A接口的业务逻辑</li>
<li>APermissionProxy类：只实现A接口的权限检查代理</li>
</ul>
</li>
<li>如果需要增加其他类型的代理，比如日志记录的代理。不需要对现有A接口、ABusiness类进行修改，只需要再写一个Proxy类即可</li>
</ul>
</li>
</ul>
<h3 id="Peoxy的应用："><a href="#Peoxy的应用：" class="headerlink" title="Peoxy的应用："></a>Peoxy的应用：</h3><ul>
<li><p>远程代理（Remote Proxy）</p>
<blockquote>
<p>本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法的访问转换成远程调用，然后返回结果。</p>
<p>Java内置的RMI机制就是一个完整的代理模式</p>
</blockquote>
</li>
<li><p>虚代理（Virtual Proxy）</p>
<blockquote>
<p>让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。</p>
<p>JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>
</blockquote>
</li>
<li><p>保护代理（Protection Proxy）</p>
<blockquote>
<p>用于控制对原始对象的访问，常用于权限鉴定</p>
</blockquote>
</li>
<li><p>智能引用（Smart Reference）</p>
<blockquote>
<p>如果有很多客户端对它进行访问，通过内部的计数器可以再外部调用者都不使用后自动释放。</p>
</blockquote>
</li>
</ul>
<h3 id="通过代理模式编写一个JDBC连接池："><a href="#通过代理模式编写一个JDBC连接池：" class="headerlink" title="通过代理模式编写一个JDBC连接池："></a>通过代理模式编写一个JDBC连接池：</h3><p>调用者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataSource</span> <span class="hljs-variable">lazyDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyDataSource</span>(jdbcUrl, jdbcUsername, jdbcPassword);<br><br>System.out.println(<span class="hljs-string">&quot;get lazy connection...&quot;</span>);<br><span class="hljs-comment">//没有真正打开Connection</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> lazyDataSource.getConnection()) &#123;<br>    <span class="hljs-comment">// 打开了真正的Connection</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> conn.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM students&quot;</span>)) &#123; <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> ps.executeQuery()) &#123;<br>            <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>                System.out.println(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="虚代理LazyConnectionProxy的实现"><a href="#虚代理LazyConnectionProxy的实现" class="headerlink" title="虚代理LazyConnectionProxy的实现"></a>虚代理LazyConnectionProxy的实现</h4><p>首先针对Connection接口实现一个抽象代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractConnectionProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br><br>    <span class="hljs-comment">// 抽象方法获取实际的Connection:</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 实现Connection接口的每一个方法:</span><br>    <span class="hljs-keyword">public</span> Statement <span class="hljs-title function_">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> getRealConnection().createStatement();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> getRealConnection().prepareStatement(sql);<br>    &#125;<br><br>    ...其他代理方法...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>AbstractConnectionProxy抽象代理类的作用时把Connection接口定义的方法全部实现一遍，后面编写LazyConnectionProxy只需要继承它，就不需要再一一实现Connection接口方法。</p>
<p>LazyConnectionProxy实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyConnectionProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConnectionProxy</span> &#123;<br>    <span class="hljs-keyword">private</span> Supplier&lt;Connection&gt; supplier;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LazyConnectionProxy</span><span class="hljs-params">(Supplier&lt;Connection&gt; supplier)</span> &#123;<br>        <span class="hljs-built_in">this</span>.supplier = supplier;<br>    &#125;<br><br>    <span class="hljs-comment">// 覆写close方法：只有target不为null时才需要关闭:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Close connection: &quot;</span> + target);<br>            <span class="hljs-built_in">super</span>.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) &#123;<br>            target = supplier.get();<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果没有执行任何SQL语句，那么target字段始终为null。只有第一次执行SQL语句时（调用prepareStatement()方法时，会触发getRealConnection()调用），才会真正打开实际的JDBC连接。</p>
<h4 id="编写LazyDateSource"><a href="#编写LazyDateSource" class="headerlink" title="编写LazyDateSource"></a>编写LazyDateSource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataSource</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LazyDataSource</span><span class="hljs-params">(String url, String username, String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyConnectionProxy</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>                System.out.println(<span class="hljs-string">&quot;Open connection: &quot;</span> + conn);<br>                <span class="hljs-keyword">return</span> conn;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="重复使用连接"><a href="#重复使用连接" class="headerlink" title="重复使用连接"></a>重复使用连接</h4><p>连接池实现复用Connection也是使用的代理模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledConnectionProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConnectionProxy</span> &#123;<br>    <span class="hljs-comment">// 实际的Connection:</span><br>    Connection target;<br>    <span class="hljs-comment">// 空闲队列:</span><br>    Queue&lt;PooledConnectionProxy&gt; idleQueue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PooledConnectionProxy</span><span class="hljs-params">(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.idleQueue = idleQueue;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fake close and released to idle queue for future reuse: &quot;</span> + target);<br>        <span class="hljs-comment">// 并没有调用实际Connection的close()方法,</span><br>        <span class="hljs-comment">// 而是把自己放入空闲队列:</span><br>        idleQueue.offer(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>复用连接的关键在于覆写close()方法，它并没有真正关闭底层JDBC连接，而是将自己放回一个空闲队列，以便下次使用。</p>
<p>空闲队列由PooledDataSource维护：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataSource</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">// 维护一个空闲队列:</span><br>    <span class="hljs-keyword">private</span> Queue&lt;PooledConnectionProxy&gt; idleQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>);<br>	<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PooledDataSource</span><span class="hljs-params">(String url, String username, String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br>	<span class="hljs-comment">// 获取一个连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">// 首先试图获取一个空闲连接:</span><br>        <span class="hljs-type">PooledConnectionProxy</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> idleQueue.poll();<br>        <span class="hljs-comment">// 没有空闲连接时，打开一个新连接:</span><br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>            conn = openNewConnection();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Return pooled connection: &quot;</span> + conn.target);<br>        &#125;<br>        <span class="hljs-keyword">return</span> conn;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> PooledConnectionProxy <span class="hljs-title function_">openNewConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>        System.out.println(<span class="hljs-string">&quot;Open new connection: &quot;</span> + conn);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledConnectionProxy</span>(idleQueue, conn);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们实际使用的DataSource，都是基于代理模式实现的，原理同上，但是增加了更多的如动态伸缩功能（一个连接空闲一段时间后自动关闭）。</p>
<p>Proxy模式与Decorater的区别：</p>
<ul>
<li>Decorator模式让调用者自己创建核心类，然后组和各种功能</li>
<li>Proxy模式绝不能让调用者自己创建再组合，否则就是失去了代理的功能。Proxy模式让调用者认为自己获取到的是核心接口，但实际是代理类。</li>
</ul>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式主要设计算法和对象之间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p>
<h2 id="13-责任链（Chain-of-Responsibility）"><a href="#13-责任链（Chain-of-Responsibility）" class="headerlink" title="13. 责任链（Chain of Responsibility）"></a>13. 责任链（Chain of Responsibility）</h2><blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</blockquote>
<p>责任链模式是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到某个处理成功为止。</p>
<p>责任链模式把多个处理器串成链，然后让请求在链上传递：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031114411897.png" srcset="/img/loading.gif" lazyload alt="image-20221031114411897"></p>
<p>在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：</p>
<ul>
<li>Manager：只能审核1000元以下的报销</li>
<li>Director：只能审核10000元以下的报销</li>
<li>CEO：可以审核任意额度</li>
</ul>
<p>用责任链模式设计这个报销流程时，每个审核者只关心自己责任范围内的请求，并处理它。对于超过自己责任范围的，扔给下一个审核者处理，这样，将来需要添加审核者的时候，不用改动现有逻辑。</p>
<p>责任链模式的实现：</p>
<ol>
<li><p>抽象出请求对象，它将在责任链上传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Request</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> BigDecimal amount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Request</span><span class="hljs-params">(String name, BigDecimal amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>抽象出处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-comment">// 返回Boolean.TRUE = 成功</span><br>    <span class="hljs-comment">// 返回Boolean.FALSE = 拒绝</span><br>    <span class="hljs-comment">// 返回null = 交下一个处理</span><br>	Boolean <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>做好约定：如果返回Boolean.TRUE，表示处理成功，如果返回Boolean.FALSE，表示处理失败（请求被拒绝），如果返回null，则交由下一个Handler处理。</p>
</li>
<li><p>编写具体的处理器：ManagerHandler、DirectorHandler和CEOHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManagerHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">// 如果超过1000元，处理不了，交下一个处理:</span><br>        <span class="hljs-keyword">if</span> (request.getAmount().compareTo(BigDecimal.valueOf(<span class="hljs-number">1000</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对Bob有偏见:</span><br>        <span class="hljs-keyword">return</span> !request.getName().equalsIgnoreCase(<span class="hljs-string">&quot;bob&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>将Handler组合起来，变成一个链，通过一个统一入口处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-comment">// 持有所有Handler:</span><br>    <span class="hljs-keyword">private</span> List&lt;Handler&gt; handlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handlers.add(handler);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">// 依次调用每个Handler:</span><br>        <span class="hljs-keyword">for</span> (Handler handler : handlers) &#123;<br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> handler.process(request);<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果返回TRUE或FALSE，处理结束:</span><br>                System.out.println(request + <span class="hljs-string">&quot; &quot;</span> + (r ? <span class="hljs-string">&quot;Approved by &quot;</span> : <span class="hljs-string">&quot;Denied by &quot;</span>) + handler.getClass().getSimpleName());<br>                <span class="hljs-keyword">return</span> r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Could not handle request: &quot;</span> + request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在客户端组装责任链，然后用责任链处理请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造责任链:</span><br><span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ManagerHandler</span>());<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectorHandler</span>());<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CEOHandler</span>());<br><span class="hljs-comment">// 处理请求:</span><br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.45&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1234.56&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;12345.67&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123456.78&quot;</span>)));<br></code></pre></td></tr></table></figure></li>
</ol>
<p>责任链中Handler添加的顺序很重要，如果顺序不对，处理结果可能不符合要求。</p>
<p>责任链模式变种：</p>
<ul>
<li><p>有些责任链的实现方式是通过Handler手动调用下一个Handler来传递Request，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!canProcess(request)) &#123;<br>            <span class="hljs-comment">// 手动交给下一个Handler处理:</span><br>            next.process(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>还有的责任链模式，每个Handler都有机会处理Request，通常这种责任链被称为拦截器（Interceptor）或过滤器（Filter），它们的目的不是找到某个Handler处理掉Request，而是每个Handler都做一些工作，比如：</p>
<ul>
<li>记录日志</li>
<li>检查权限</li>
<li>准备相关资源</li>
<li>…</li>
</ul>
<p>例如JavaEE的Servlet规范定义的Filter就是一种责任链。它不但允许每个Filter都有机会处理请求，还允许每个Filter决定是否将请求“放行”给下一个Filter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuditFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        log(req);<br>        <span class="hljs-keyword">if</span> (check(req)) &#123;<br>            <span class="hljs-comment">// 放行:</span><br>            chain.doFilter(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 拒绝:</span><br>            sendError(resp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种模式不但允许一个Filter自行决定处理ServletRequest和ServletResponse，还可以“伪造”ServletRequest和ServletResponse以便让下一个Filter处理，能实现非常复杂的功能。</p>
</li>
</ul>
<h2 id="14-命令（Command）"><a href="#14-命令（Command）" class="headerlink" title="14. 命令（Command）"></a>14. 命令（Command）</h2><blockquote>
<p>将一个请求封装成一个对象，从而使你可用不同的请求对客户端进行参数化，对请求判定或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>命令模式是指把一个请求封装成一个命令，然后执行该命令。</p>
<p>以一个编辑器为例子，看看如何实现简单的编辑操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paste</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> getFromClipBoard();<br>        add(text);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;<br>        buffer.append(s);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (buffer.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.deleteCharAt(buffer.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用一个StringBuilder模拟一个文本编辑器，它支持copy() 、paste ()、add()、delete()等方法。</p>
<p>上面这个TextEditor的调用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>editor.add(<span class="hljs-string">&quot;Command pattern in text editor.\n&quot;</span>);<br>editor.copy();<br>editor.paste();<br>System.out.println(editor.getState());<br></code></pre></td></tr></table></figure>

<p>调用方需要了解TextEditor的所有接口信息。</p>
<p>如果改成命令模式，我们需要将调用方发送命令，和执行命令分开。通过引入一个Command接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用方创建一个对应的Command，然后执行，并不关心内部是如何执行的：</p>
<ul>
<li><p>实现具体的Command</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-comment">// 持有执行者对象:</span><br>    <span class="hljs-keyword">private</span> TextEditor receiver;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyCommand</span><span class="hljs-params">(TextEditor receiver)</span> &#123;<br>        <span class="hljs-built_in">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        receiver.copy();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasteCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> TextEditor receiver;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PasteCommand</span><span class="hljs-params">(TextEditor receiver)</span> &#123;<br>        <span class="hljs-built_in">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        receiver.paste();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>将Command和TextEditor组装一下，调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>editor.add(<span class="hljs-string">&quot;Command pattern in text editor.\n&quot;</span>);<br><br><span class="hljs-comment">// 执行一个CopyCommand:</span><br><span class="hljs-type">Command</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyCommand</span>(editor);<br>copy.execute();<br>editor.add(<span class="hljs-string">&quot;----\n&quot;</span>);<br><br><span class="hljs-comment">// 执行一个PasteCommand:</span><br><span class="hljs-type">Command</span> <span class="hljs-variable">paste</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasteCommand</span>(editor);<br>paste.execute();<br>System.out.println(editor.getState());<br></code></pre></td></tr></table></figure></li>
</ul>
<p>命令模式的结构：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031190100636.png" srcset="/img/loading.gif" lazyload alt="image-20221031190100636"></p>
<p>使用命令模式增加了一定的复杂度，对于简单系统，直接调用会更直观且简单。但是当系统复杂到一定程度的时候，比如要给TextEditor增加Undo、Redo功能，则使用命令行模式逻辑会清晰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>把执行过的一系列命令使用List保存起来，这样就能支持Undo和Redo。这个时候我们又需要一个Invoker对象，负责执行命令并保存历史命令：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031190609564.png" srcset="/img/loading.gif" lazyload alt="image-20221031190609564"></p>
<h2 id="15-解释器（Interpreter）"><a href="#15-解释器（Interpreter）" class="headerlink" title="15. 解释器（Interpreter）"></a>15. 解释器（Interpreter）</h2><blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</blockquote>
<p>解释模式是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。</p>
<p>例如，针对以下的匹配条件：</p>
<ul>
<li>以+开头的数字表示的区号和电话号码，如+8615566666666</li>
<li>以英文开头，后接英文和数字，并以.分隔的域名，如<a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a></li>
<li>以&#x2F;开头的文件路径，如&#x2F;path&#x2F;to&#x2F;file.txt</li>
<li>…</li>
</ul>
<p>因此，需要一种通用的表达方式——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p>
<p>实现一个完成的正则表达式解释器很复杂，但是使用解释器模式很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;+861012345678&quot;</span>;<br>System.out.println(s.matches(<span class="hljs-string">&quot;^\\+\\d+$&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也很复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p>
<h2 id="16-迭代器（Iterator）"><a href="#16-迭代器（Iterator）" class="headerlink" title="16. 迭代器（Iterator）"></a>16. 迭代器（Iterator）</h2><blockquote>
<p> 提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。</p>
</blockquote>
<p>迭代器模式实际上在Java集合类汇中已经广泛使用了。</p>
<p>我们以List为例，要遍历ArrayList，即使我们直到它的内部存储了一个Object[]数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。</p>
<p>如果使用Iterator遍历，那么，ArrayList和LinkedList都可以以一种统一的接口来遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = ...<br>Iterator&lt;String&gt; it = list.iterator()<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>&#125;<br><br><span class="hljs-comment">//Iterator模式十分有用，Java允许把任何支持Iterator的集合对象用foreach来遍历</span><br>List&lt;String&gt; list = ...<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>Iterator模式的实现：</p>
<p>实现Iterator模式的关键是返回一个Iterator对象。该对象知道集合内部结构，它可以实现倒序遍历。</p>
<p>自定义一个集合，通过Iterator模式实现倒序遍历，使用Java的内部类实现Iterator：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseArrayCollection</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">private</span> T[] array;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReverseArrayCollection</span><span class="hljs-params">(T... objs)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = Arrays.copyOfRange(objs, <span class="hljs-number">0</span>, objs.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReverseIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>        <span class="hljs-comment">// 索引位置:</span><br>        <span class="hljs-type">int</span> index;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReverseIterator</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 创建Iterator时,索引在数组末尾:</span><br>            <span class="hljs-built_in">this</span>.index = ReverseArrayCollection.<span class="hljs-built_in">this</span>.array.length;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):</span><br>            <span class="hljs-keyword">return</span> index &gt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 将索引移动到下一个元素并返回(倒序往前移动):</span><br>            index--;<br>            <span class="hljs-keyword">return</span> array[index];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用内部类的好处是内部类隐含地持有一个它所在对象地this引用，可以通过ReverseArrayCollection.this引用到它所在地集合。</p>
<p>上述的地代码实现地逻辑非常简单，但是在实际的应用中，如果考虑多线程访问，则需要仔细设计避免多线程安全问题。</p>
<h2 id="17-中介（Meiator）"><a href="#17-中介（Meiator）" class="headerlink" title="17. 中介（Meiator）"></a>17. 中介（Meiator）</h2><blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互。</p>
</blockquote>
<p>中介模式又称调停者模式，它地目的是把多方会谈变成双方会谈，从而实现多方地松耦合。</p>
<p>一个多选框的例子：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205600593.png" srcset="/img/loading.gif" lazyload alt="image-20221031205600593"></p>
<p>这个小系统有4个参与对象：</p>
<ul>
<li>多选框</li>
<li>“选择全部”按钮</li>
<li>“取消所有”按钮</li>
<li>反选按钮</li>
</ul>
<p>它的复杂性在于，当多选框变化时，它会影响”选择全部“和”取消所有“按钮的状态（是否可点击），当用户点击某个按钮时，又会影响多选框和其他按钮的状态。</p>
<p>所以说这是一个多方会谈，逻辑写起来很复杂：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205849415.png" srcset="/img/loading.gif" lazyload alt="image-20221031205849415"></p>
<p>如果我们引入一个中介，把多方会谈变成多个单方会谈，虽然多了一个对象，但对象之间的关系就变得简单了：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205959983.png" srcset="/img/loading.gif" lazyload alt="image-20221031205959983"></p>
<p>使用中介模式来实现上面得UI组件交互：</p>
<ol>
<li><p>首先把UI组件画出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderFrame</span>(<span class="hljs-string">&quot;Hanburger&quot;</span>, <span class="hljs-string">&quot;Nugget&quot;</span>, <span class="hljs-string">&quot;Chip&quot;</span>, <span class="hljs-string">&quot;Coffee&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFrame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span> &#123;<br>    <span class="hljs-comment">//Frame</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderFrame</span><span class="hljs-params">(String... names)</span> &#123;<br>        setTitle(<span class="hljs-string">&quot;Order&quot;</span>);<br>        setSize(<span class="hljs-number">460</span>, <span class="hljs-number">200</span>);<br>        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>        <span class="hljs-type">Container</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getContentPane();<br>        c.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>(FlowLayout.LEADING, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>));<br>        c.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;Use Mediator Pattern&quot;</span>));<br>        <span class="hljs-comment">//添加多选框</span><br>        List&lt;JCheckBox&gt; checkboxList = addCheckBox(names);<br>        <span class="hljs-comment">//添加三个按钮</span><br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectAll</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Select All&quot;</span>);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectNone</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Select None&quot;</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectInverse</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Inverse Select&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mediator</span>(checkBoxList, selectAll, selectNone, selectInverse);<br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>	<span class="hljs-comment">//多选框</span><br>    <span class="hljs-keyword">private</span> List&lt;JCheckBox&gt; <span class="hljs-title function_">addCheckBox</span><span class="hljs-params">(String... names)</span> &#123;<br>        <span class="hljs-type">JPanel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>        panel.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;Menu:&quot;</span>));<br>        List&lt;JCheckBox&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-type">JCheckBox</span> <span class="hljs-variable">checkbox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JCheckBox</span>(name);<br>            list.add(checkbox);<br>            panel.add(checkbox);<br>        &#125;<br>        getContentPane().add(panel);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>	<span class="hljs-comment">//按钮</span><br>    <span class="hljs-keyword">private</span> JButton <span class="hljs-title function_">addButton</span><span class="hljs-params">(String label)</span> &#123;<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(label);<br>        getContentPane().add(button);<br>        <span class="hljs-keyword">return</span> button;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>设计Mediator类，它引用4个UI组件，并负责跟它们交互：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-comment">// 引用UI组件:</span><br>    <span class="hljs-keyword">private</span> List&lt;JCheckBox&gt; checkBoxList;<br>    <span class="hljs-keyword">private</span> JButton selectAll;<br>    <span class="hljs-keyword">private</span> JButton selectNone;<br>    <span class="hljs-keyword">private</span> JButton selectInverse;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mediator</span><span class="hljs-params">(List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse)</span> &#123;<br>        <span class="hljs-built_in">this</span>.checkBoxList = checkBoxList;<br>        <span class="hljs-built_in">this</span>.selectAll = selectAll;<br>        <span class="hljs-built_in">this</span>.selectNone = selectNone;<br>        <span class="hljs-built_in">this</span>.selectInverse = selectInverse;<br>        <span class="hljs-comment">// 绑定事件:</span><br>        <span class="hljs-built_in">this</span>.checkBoxList.forEach(checkBox -&gt; &#123;<br>            checkBox.addChangeListener(<span class="hljs-built_in">this</span>::onCheckBoxChanged);<br>        &#125;);<br>        <span class="hljs-built_in">this</span>.selectAll.addActionListener(<span class="hljs-built_in">this</span>::onSelectAllClicked);<br>        <span class="hljs-built_in">this</span>.selectNone.addActionListener(<span class="hljs-built_in">this</span>::onSelectNoneClicked);<br>        <span class="hljs-built_in">this</span>.selectInverse.addActionListener(<span class="hljs-built_in">this</span>::onSelectInverseClicked);<br>    &#125;<br><br>    <span class="hljs-comment">// 当checkbox有变化时:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCheckBoxChanged</span><span class="hljs-params">(ChangeEvent event)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">allChecked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">allUnchecked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> checkBox : checkBoxList) &#123;<br>            <span class="hljs-keyword">if</span> (checkBox.isSelected()) &#123;<br>                allUnchecked = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                allChecked = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        selectAll.setEnabled(!allChecked);<br>        selectNone.setEnabled(!allUnchecked);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select all:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectAllClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="hljs-literal">true</span>));<br>        selectAll.setEnabled(<span class="hljs-literal">false</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select none:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectNoneClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="hljs-literal">false</span>));<br>        selectAll.setEnabled(<span class="hljs-literal">true</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select inverse:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectInverseClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));<br>        onCheckBoxChanged(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>使用Mediator模式后的好处：</p>
<ul>
<li>各个UI组件互不引用，这样就减少了组件之间的耦合关系</li>
<li>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件</li>
<li>如果新增一个UI组件，我们只需要修改Mediator更新状&#x3D;状态的逻辑，现有的其他UI组件代码不变</li>
</ul>
<p>Mediator模式经常用在有众多交互组件的UI上。为例简化UI程序，MVC模式以及MVVM模式都可以看作时Mediator模式的扩展。</p>
<h2 id="18-备忘录（Memento）"><a href="#18-备忘录（Memento）" class="headerlink" title="18. 备忘录（Memento）"></a>18. 备忘录（Memento）</h2><blockquote>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
</blockquote>
<p>备忘录模式，主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p>
<p>其实我们使用的几乎所有软件都用到了备忘录模式。</p>
<ul>
<li>最简单的备忘录模式就是保存到文件，打开文件。</li>
<li>对于文本编辑器来说，保存就是把TextEditor类的字符串存储到文件，打开就是恢复TextEditor类的状态。</li>
<li>对于图像编辑器来说，原理也是一样，只是保存和恢复的数据格式比较复杂而已。</li>
<li>java的序列化也可以看作是备忘录模式</li>
<li>文本编辑器的Redo、Undo功能也可以使用备忘录模式实现</li>
</ul>
<p>标准的备忘录模式有这么几个角色：</p>
<ul>
<li>Memonto： 存储的内部状态</li>
<li>Originator：创建一个备忘录并设置其状态</li>
<li>Caretake：负责保存备忘录</li>
</ul>
<p>在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似TextEditor的类，增加getState() 和setState()就可以了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        buffer.append(ch);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;<br>        buffer.append(s);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (buffer.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.deleteCharAt(buffer.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//备忘录功能：</span><br>    <span class="hljs-comment">// 获取状态</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 恢复状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.buffer.delete(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.buffer.length());<br>        <span class="hljs-built_in">this</span>.buffer.append(state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="19-观察者（Observer）"><a href="#19-观察者（Observer）" class="headerlink" title="19. 观察者（Observer）"></a>19. 观察者（Observer）</h2><blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p>观察者模式又称发布-订阅模式。它时一种通知机制，让发送方（被观察者）和接收房间（观察者）能彼此分离，互不影响。</p>
<p>一个例子，假设一个电商网站，有多个Product，同时Customer和Admin对商品上架、价格修改都感兴趣，希望第一时间获得通知。于是Store可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    Customer customer;<br>    Admin admin;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, Product&gt; products = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>	<br>    <span class="hljs-comment">//新增商品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNewProduct</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(name, price);<br>        products.put(p.getName(), p);<br>        <span class="hljs-comment">// 通知用户:</span><br>        customer.onPublished(p);<br>        <span class="hljs-comment">// 通知管理员:</span><br>        admin.onPublished(p);<br>    &#125;<br>    <br>	<span class="hljs-comment">//修改商品价格</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProductPrice</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> products.get(name);<br>        p.setPrice(price);<br>        <span class="hljs-comment">// 通知用户:</span><br>        customer.onPriceChanged(p);<br>        <span class="hljs-comment">// 通知管理员:</span><br>        admin.onPriceChanged(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Store类的问题：它直接引用了Cunstomer和Admin。如果要新加入观察者需要修改整个Store类，属性、构造方法、每一个通知方法。问题的根源在于Store希望发送通知给关系Product的对象，但Store并不想知道这些人是谁。</p>
<p>观察者模式就是要分离被观察者和观察者之间的耦合关系。想要实现这一目标很简单，Store不直接引用Customer和Admin，它引用一个ProductObserver接口的List即可，任何想要观察Store，只要实现这一接口，并把自己注册到Store即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;ProductObserver&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Map&lt;String, Product&gt; products = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 注册观察者:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(ProductObserver observer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.observers.add(observer);<br>    &#125;<br><br>    <span class="hljs-comment">// 取消注册:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(ProductObserver observer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNewProduct</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(name, price);<br>        products.put(p.getName(), p);<br>        <span class="hljs-comment">// 通知观察者:</span><br>        observers.forEach(o -&gt; o.onPublished(p));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProductPrice</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> products.get(name);<br>        p.setPrice(price);<br>        <span class="hljs-comment">// 通知观察者:</span><br>        observers.forEach(o -&gt; o.onPriceChanged(p));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样要增加新的观察者就不需要改动Store类的代码，只需要在客户端调用的时候注册观察者，如果要创建新型的额观察者，也只需要实现Productor接口，并在客户端注册即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// observer:</span><br><span class="hljs-type">Admin</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Admin</span>();<br><span class="hljs-type">Customer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br><span class="hljs-comment">// store:</span><br><span class="hljs-type">Store</span> <span class="hljs-variable">store</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>();<br><span class="hljs-comment">// 注册观察者:</span><br>store.addObserver(a);<br>store.addObserver(c);<br><span class="hljs-comment">// 注册匿名观察者</span><br>store.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductObserver</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPublished</span><span class="hljs-params">(Product product)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[Log] on product published: &quot;</span> + product);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPriceChanged</span><span class="hljs-params">(Product product)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[Log] on product price changed: &quot;</span> + product);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>观察者模式图示：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031213754596.png" srcset="/img/loading.gif" lazyload alt="image-20221031213754596"></p>
<p>观察者模式变体：</p>
<ol>
<li><p>将被观察者也抽象为接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//被观察者接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductObservable</span> &#123; <span class="hljs-comment">// 注意此处拼写是Observable不是Observer!</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(ProductObserver observer)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(ProductObserver observer)</span>;<br>&#125;<br><span class="hljs-comment">//对应的被观察者实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductObservable</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>把通知变成一个Event对象。不再由多种通知，而是统一为Event通知，观察者在自己从Event对象中读取通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductObserver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(ProductEvent event)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>广义上的观察者模式包括所有的消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031214337749.png" srcset="/img/loading.gif" lazyload alt="image-20221031214337749"></p>
<p>消息发送方称为Producer，消息接收方称为Consumer。Producer发送消息的时候必须选择发送到哪个Topic，Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。使用消息系统实现观察者模式的时候，Producer和Consumer甚至经常不是在同一台机器上，并且双方对彼此一无所知，以为注册观察者这个动作都是在消息系统中完成的，而不是在Producer内部完成。</p>
<p>此外，观察者模式中的通知Observe是依靠语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">observers.forEach(o -&gt; o.onPublished(p));<br></code></pre></td></tr></table></figure>

<p>这说明，各个观察者是依次获取同步通知，需要一个观察者处理完通知后，下一个观察者才能获取到通知。</p>
<ul>
<li>如果观察者处理通知很慢，下一个观察者就不能及时获取通知。</li>
<li>如果观察者在处理通知的时候出现异常，那么还需要被观察者来处理异常</li>
</ul>
<p>Java标准库由Java.util.Observable类和Observer接口，用于帮助实现观察者模式，但是很难用，不推荐使用。</p>
<h2 id="20-状态（State）"><a href="#20-状态（State）" class="headerlink" title="20. 状态（State）"></a>20. 状态（State）</h2><blockquote>
<p>允许一个对象在其内部状态改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>状态模式经常用在带有状态的对象中。</p>
<p>什么是状态？以QQ为例，一个用户的QQ的几种状态：</p>
<ul>
<li>离线</li>
<li>正在登录</li>
<li>在线</li>
<li>忙</li>
</ul>
<p>如何表示状态？定义一个enum就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (state == ONLINE) &#123;<br>    <span class="hljs-comment">// 闪烁图标</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BUSY) &#123;<br>    reply(<span class="hljs-string">&quot;现在忙，稍后回复&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...<br></code></pre></td></tr></table></figure>

<p>状态模式的目的就是把上面一大堆的if…else… 的逻辑拆分到不同的状态中，将来增加状态就只需要再多写一个状态类即可。</p>
<p>例如，设计一个聊天机器人，有两个状态：未连接、已连接。</p>
<p>未连接状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisconnectedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bye!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reply</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>已连接状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, I&#x27;m Bob.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reply</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-keyword">if</span> (input.endsWith(<span class="hljs-string">&quot;?&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Yes. &quot;</span> + input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;!&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (input.endsWith(<span class="hljs-string">&quot;.&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;!&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;?&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>状态模式的关键设计思想在于状态切换，引入BotContext完成状态转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BotContext</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisconnectedState</span>();<br><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">chat</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-comment">// 收到hello切换到在线状态:</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;hello&quot;</span>.equalsIgnoreCase(input)) &#123;<br>			state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectedState</span>();<br>			<span class="hljs-keyword">return</span> state.init();<br>       	<span class="hljs-comment">//  收到bye切换到离线状态:</span><br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bye&quot;</span>.equalsIgnoreCase(input)) &#123;<br>			state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisconnectedState</span>();<br>			<span class="hljs-keyword">return</span> state.init();<br>		&#125;<br>        <br>        <span class="hljs-comment">// 调用state的reply方法</span><br>		<span class="hljs-keyword">return</span> state.reply(input);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="21-策略（Strategy）"><a href="#21-策略（Strategy）" class="headerlink" title="21. 策略（Strategy）"></a>21. 策略（Strategy）</h2><blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。使得算法可以独立于使用它的客户而变化。</p>
</blockquote>
<p>策略模式指定义一组算法，并将其封装到一个对象中。然后在运行时，可以灵活地使用其中一个算法。</p>
<h3 id="Arrays-sort-方法中的策略模式"><a href="#Arrays-sort-方法中的策略模式" class="headerlink" title="Arrays.sort()方法中的策略模式"></a>Arrays.sort()方法中的策略模式</h3><p>Java标准库中策略模式的应用：</p>
<p>以排序为例，看看Arrays.sort()的排序实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        String[] array = &#123; <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span> &#125;;<br>        Arrays.sort(array, String::compareToIgnoreCase);<br>        System.out.println(Arrays.toString(array));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>sort()中的策略：</p>
<ul>
<li>String::compareToIgnoreCase就是一个算法，它忽略大小写排序。</li>
<li>若我们想要倒序排序，就传入(s1, s2) -&gt; s1.compareTo(s2)</li>
</ul>
<p>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)，观察方法，它在内部实现了TimSort排序（归并排序优化版本），但是排序算法在比较两个元素大小的时候，需要我们传入的Comparator对象，才能完成比较。因此，这里的策略指的是比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以是根据字符串长度比较。</p>
<p>上面排序中的策略模式，实际指的是，在方法中，流程是确定的，但是某些关键步骤的算法依赖调用方传入的策略。这样，传入不同的策略，即可获得不同的结果，大大增强系统的灵活性。</p>
<h3 id="购物结算的折扣策略"><a href="#购物结算的折扣策略" class="headerlink" title="购物结算的折扣策略"></a>购物结算的折扣策略</h3><p>一个完整的策略模式所需：</p>
<ul>
<li>定义策略</li>
<li>使用策略的上下文。</li>
</ul>
<p>以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>先定义打折策略接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-comment">// 计算折扣额度:</span><br>    BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现各种策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通用户策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-comment">// 普通会员打九折:</span><br>        <span class="hljs-keyword">return</span> total.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.1&quot;</span>)).setScale(<span class="hljs-number">2</span>, RoundingMode.DOWN);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//满减策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-comment">// 满100减20优惠:</span><br>        <span class="hljs-keyword">return</span> total.compareTo(BigDecimal.valueOf(<span class="hljs-number">100</span>)) &gt;= <span class="hljs-number">0</span> ? BigDecimal.valueOf(<span class="hljs-number">20</span>) : BigDecimal.ZERO;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>要使用策略，需要一个上下文：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountContext</span> &#123;<br>    <span class="hljs-comment">// 持有某个策略:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DiscountStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDiscountStrategy</span>();<br><br>    <span class="hljs-comment">// 允许客户端设置新策略:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(DiscountStrategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-keyword">return</span> total.subtract(<span class="hljs-built_in">this</span>.strategy.getDiscount(total)).setScale(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>调用方必须先创建一个DiscountContext，并指定一个策略（或使用默认策略），再调用DiscountContext的获取折扣后价格方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DiscountContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiscountContext</span>();<br><br><span class="hljs-comment">// 默认使用普通会员折扣:</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay1</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay1);<br><br><span class="hljs-comment">// 使用满减折扣:</span><br>ctx.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OverDiscountStrategy</span>());<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay2</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay2);<br><br><span class="hljs-comment">// 使用Prime会员折扣:</span><br>ctx.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrimeDiscountStrategy</span>());<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay3</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay3);<br></code></pre></td></tr></table></figure>

<p>完整的策略模式图示如下：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031224335921.png" srcset="/img/loading.gif" lazyload alt="image-20221031224335921"></p>
<p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽象出来作为”策略“参数传入，从而使得新增策略不必修改原有逻辑。</p>
<h2 id="22-模板方法（Templat-Method）"><a href="#22-模板方法（Templat-Method）" class="headerlink" title="22. 模板方法（Templat Method）"></a>22. 模板方法（Templat Method）</h2><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<p>模板方法的主要思想：定义一个操作的一系列步骤，对于某些暂不确定的步骤，留给子类实现，这样不同过的子类就可以定义出不同的步骤。</p>
<p>因此，模板方法的核心在于定义一个”骨架“。</p>
<p>加入我们开发一个从数据库读取设置的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Setting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> readFromDatabase(key);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>	<span class="hljs-keyword">private</span> String <span class="hljs-title function_">readFromDatabase</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库读取</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于从数据库读取数据比较满，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库。但是怎么实现缓存，暂时还没想好，但是不妨碍我们写出使用缓存的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Setting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 先从缓存读取:</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> lookupCache(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在缓存中未找到,从数据库读取:</span><br>            value = readFromDatabase(key);<br>            System.out.println(<span class="hljs-string">&quot;[DEBUG] load from db: &quot;</span> + key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>            <span class="hljs-comment">// 放入缓存:</span><br>            putIntoCache(key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;[DEBUG] load from cache: &quot;</span> + key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>整个流程没问题，但是，lookupCache(Key)和putIntoCache(Key, value)这两个方法还根本没有实现，无法通过编译。我们可以声明两个抽象方法，并将Setting也改为抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> lookupCache(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            value = readFromDatabase(key);<br>            putIntoCache(key, value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，整个类为抽象类，如何实现lookupCache(Key)和putIntoCache(key, value)这两个方法就交给子类即可。子类不需要关系核心代码getSetting(Key)的逻辑，它只需要关心如何完成两个子任务。</p>
<p>假设我们希望用一个Map做缓存，那么可以写一个LocalSetting：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalSetting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        cache.put(key, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们要使用Redis做缓存，那么可以再写一个RedisSetting：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisSetting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">RedisClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> RedisClient.create(<span class="hljs-string">&quot;redis://localhost:6379&quot;</span>);<br><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;<br>            RedisCommands&lt;String, String&gt; commands = connection.sync();<br>            <span class="hljs-keyword">return</span> commands.get(key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        <span class="hljs-keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;<br>            RedisCommands&lt;String, String&gt; commands = connection.sync();<br>            commands.set(key, value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端使用缓存：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用本地缓存</span><br><span class="hljs-type">AbstractSetting</span> <span class="hljs-variable">setting1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalSetting</span>();<br>System.out.println(<span class="hljs-string">&quot;test = &quot;</span> + setting1.getSetting(<span class="hljs-string">&quot;test&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;test = &quot;</span> + setting1.getSetting(<span class="hljs-string">&quot;test&quot;</span>));<br><span class="hljs-comment">// 使用Redis缓存</span><br><span class="hljs-type">AbstractSetting</span> <span class="hljs-variable">setting2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisSetting</span>();<br>System.out.println(<span class="hljs-string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="hljs-string">&quot;autosave&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="hljs-string">&quot;autosave&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>模板方法的核心思想：父类定义骨架，子类实现细节。</p>
<p>安全问题：</p>
<ul>
<li><p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用final。</p>
</li>
<li><p>对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见。</p>
</li>
</ul>
<p>Java标准库中模板方法的应用：</p>
<ul>
<li>AbstractList</li>
<li>AbstractQueuedSynchronizer</li>
</ul>
<h2 id="23-访问者（Visitor）"><a href="#23-访问者（Visitor）" class="headerlink" title="23. 访问者（Visitor）"></a>23. 访问者（Visitor）</h2><blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使哪可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p>访问者模式是一种操作一组操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p>
<p>访问者模式的设计比较复杂，Gof原始的访问者模式：</p>
<p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031231737824-16672294603681.png" srcset="/img/loading.gif" lazyload alt="image-20221031231737824"></p>
<p>上述模式的复杂之处在于上述访问者模式为了实现所谓的”双重分派“，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出”双重分派“反而加大了代码的复杂性。</p>
<p>简化的访问者模式：</p>
<p>假设我们要递归遍历某个文件夹的所有子文件和文件夹，然后找出.java文件。</p>
<p>一般做法，写个递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(File dir, List&lt;File&gt; collector)</span> &#123;<br>    <span class="hljs-keyword">for</span> (File file : dir.listFiles()) &#123;<br>        <span class="hljs-keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>            collector.add(file);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isDir()) &#123;<br>            <span class="hljs-comment">// 递归调用:</span><br>            scan(file, collector);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的问题在于，扫描目录和处理.java文件的逻辑混在一起。如果下次需要增加一个清理.class文件的功能，那么就必须重写扫描逻辑。</p>
<p>因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离，以后如果要新增操作（例如清理.class文件），只需要新增访问者，不需要改变现有逻辑。</p>
<p>用访问者模式改写：</p>
<ol>
<li><p>定义访问者接口，即定义访问者能干的事儿：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-comment">// 访问文件夹:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span>;<br>    <span class="hljs-comment">// 访问文件:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>定义能持有文件夹和文件的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStructure</span> &#123;<br>    <span class="hljs-comment">// 根目录:</span><br>    <span class="hljs-keyword">private</span> File path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileStructure</span><span class="hljs-params">(File path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>为FileStructure增加一个handle()方法，传入一个访问者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStructure</span> &#123;<br>    ...<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>		scan(<span class="hljs-built_in">this</span>.path, visitor);<br>	&#125;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(File file, Visitor visitor)</span> &#123;<br>		<span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>            <span class="hljs-comment">// 让访问者处理文件夹:</span><br>			visitor.visitDir(file);<br>			<span class="hljs-keyword">for</span> (File sub : file.listFiles()) &#123;<br>                <span class="hljs-comment">// 递归处理子文件夹:</span><br>				scan(sub, visitor);<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>            <span class="hljs-comment">// 让访问者处理文件:</span><br>			visitor.visitFile(file);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样访问者的行为抽象出来了。若要实现一种操作，例如查找.class文件，就传入JavaFileVisitor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileStructure</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileStructure</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;.&quot;</span>));<br>fs.handle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaFileVisitor</span>());<br></code></pre></td></tr></table></figure>
</li>
<li><p>实现Visitor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查找.class文件的Visitor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaFileVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Visit dir: &quot;</span> + dir);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span> &#123;<br>        <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Found java file: &quot;</span> + file);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//清理.class文件的Visitor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassFileCleanerVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span> &#123;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span> &#123;<br>		<span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;<br>			System.out.println(<span class="hljs-string">&quot;Will clean class file: &quot;</span> + file);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>可见，访问者模式的核心就是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在”访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p>
<p>Java标准库提供的Files.walkFileTree()已经实现了一个访问者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.walkFileTree(Paths.get(<span class="hljs-string">&quot;.&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFileVisitor</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现一个FileVisitor:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt; &#123;<br>    <span class="hljs-comment">// 处理Directory:</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre visit dir: &quot;</span> + dir);<br>        <span class="hljs-comment">// 返回CONTINUE表示继续访问:</span><br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理File:</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;visit file: &quot;</span> + file);<br>        <span class="hljs-comment">// 返回CONTINUE表示继续访问:</span><br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Files.walkFileTree()允许访问者返回FileVisitResult.CONTINUE以便继续访问，或者返回FileVisitResult.TERMINATE停止访问。</p>
<p>类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Hanlder作为访问者处理XML的各个节点。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>设计模式</div>
      <div>http://example.com/2022/10/29/设计模式/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>XiangYU</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月29日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2022年11月1日</div>
        </div>
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/25/%E6%B3%9B%E5%9E%8B/" title="泛型">
                        <span class="hidden-mobile">泛型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"oJgRmRSoMnXMSzk2FSqr3T8l-gzGzoHsz","appKey":"2rUmLcHtDRExt0YFmed3951e","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
