

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/rideordie.png">
  <link rel="icon" href="/img/rideordie.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="XiangYU">
  <meta name="keywords" content="">
  
    <meta name="description" content="运行时数据区内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分和管理存在部分差异。 下图是JVM整体架构，中间部分就是Java虚拟机定义的运行时数据区：  Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-内存结构">
<meta property="og:url" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Ride_or_DIE">
<meta property="og:description" content="运行时数据区内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分和管理存在部分差异。 下图是JVM整体架构，中间部分就是Java虚拟机定义的运行时数据区：  Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/007S8ZIlly1gg9kuge8ovj32150tt7cd.jpg">
<meta property="og:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc6fz21n8kj30u00wpn5v.jpg">
<meta property="og:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc5kmznm1sj31m50u0wph.jpg">
<meta property="og:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc9s12g5wlj31li0owdm9.jpg">
<meta property="og:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc8tjehg8bj318m0lbtbu.jpg">
<meta property="og:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gca4k4gndgj31d20o2td0.jpg">
<meta property="og:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg">
<meta property="og:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg">
<meta property="article:published_time" content="2022-11-14T14:10:13.000Z">
<meta property="article:modified_time" content="2022-11-22T00:40:40.957Z">
<meta property="article:author" content="XiangYU">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/007S8ZIlly1gg9kuge8ovj32150tt7cd.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>JVM-内存结构 - Ride_or_DIE</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"oJgRmRSoMnXMSzk2FSqr3T8l-gzGzoHsz","app_key":"2rUmLcHtDRExt0YFmed3951e","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ride_or_DIE</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JVM-内存结构"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-14 22:10" pubdate>
          2022年11月14日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          105 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM-内存结构</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年11月22日 早上
                  
                
              </p>
            
            <div class="markdown-body">
              
              <p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/007S8ZIlly1gg9kuge8ovj32150tt7cd.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分和管理存在部分差异。</p>
<p>下图是JVM整体架构，中间部分就是Java虚拟机定义的运行时数据区：</p>
<p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" srcset="/img/loading.gif" lazyload alt="jvm-framework"></p>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另一些则是于线程一一对应的，这些与线程一一对应的数据区域会随着线程的开始和结束而创建和销毁。</p>
<ul>
<li>线程私有：程序计数器、虚拟机栈、本地方法栈</li>
<li>线程共享：堆、方法区、堆外内存（Java7的永久代或Java8的元空间、代码缓存）</li>
</ul>
<h1 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h1><p>程序计数寄存器（Program Counter Register），Register的命名源自于CPU的寄存器，寄存器存储指令相关的线程信息，CPU只有把数据装载到寄存器才能运行。</p>
<p>这里并非是广义上所指的物理寄存器，叫程序计数器会更贴切。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。程序计数器是一块较小的内存空间，<strong>可以看作是当前线程所执行的字节码的行号指示器</strong>。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote>
<p>PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>
</blockquote>
<p>通过<code>javap -v xx.class</code> 命令反编译（或通过IDEA插件Jclasslib直接查看），可以看到当前类对应的Code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。如图：</p>
<p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc5kmznm1sj31m50u0wph.jpg" srcset="/img/loading.gif" lazyload alt="jvm-pc-counter"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过两个关于PC寄存器的问题了解PC寄存器：</p>
<ul>
<li><p>使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址？</p>
<blockquote>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就需要知道接着从哪儿开始继续执行。JVM得字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</blockquote>
</li>
<li><p>PC寄存器为什么会被设定为线程私有的？</p>
<blockquote>
<p>多线程在一个特定的时间段内只会执行其中某一个线程，CPU会不停的做任务切换，这样必然会导致经常中断和恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p>
</blockquote>
</li>
</ul>
<p>关于PC寄存器的一些总结：</p>
<ul>
<li><p>占用空间小，运行速度最快</p>
<blockquote>
<p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</p>
</blockquote>
</li>
<li><p>线程私有，生命周期同线程一致</p>
<blockquote>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致。</p>
</blockquote>
</li>
<li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。</p>
<blockquote>
<p>如果当前线程正在执行的是Java方法，程序计数器记录的是JVM字节码指令地址，如果是执行native方法，则是未指定值（undefined）</p>
</blockquote>
</li>
<li><p>它是程序控制流的指示器</p>
<blockquote>
<p>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖于计数器完成</p>
</blockquote>
</li>
<li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>
</li>
<li><p>它时唯一一个在JVM规范中没有规定任何<code>OutOfMemeoryError</code>情况的区域</p>
</li>
</ul>
<h1 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h1><blockquote>
<p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次Java方法调用，是线程私有的，生命周期和线程一致。</p>
</blockquote>
<p>作用：</p>
<ul>
<li>主管java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li>
</ul>
<p>特点：</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM直接对虚拟机栈的操作只有两个：方法执行，入栈；方法执行结束，出栈</li>
<li>栈不存在垃圾回收问题</li>
</ul>
<p>栈中可能出现的异常：</p>
<ul>
<li><p><code>StackOverflowError</code>异常</p>
<blockquote>
<p>如果虚拟机采用固定大小的虚拟机栈，那每个线程的Java虚拟机栈容量可以在线程创建时独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常</p>
</blockquote>
</li>
<li><p><code>OutOfMemoryError</code>异常</p>
<blockquote>
<p>如果虚拟机采用可动态扩展的虚拟机栈，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机会抛出OutOfMemoryError异常</p>
</blockquote>
</li>
</ul>
<p>栈大小设置：</p>
<ul>
<li>可以通过参数<code>-Xss</code> 来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</li>
</ul>
<h2 id="栈的运行原理"><a href="#栈的运行原理" class="headerlink" title="栈的运行原理"></a>栈的运行原理</h2><ul>
<li>JVM对Java栈的操作只有两个，对栈帧的压栈和出栈。</li>
<li>在一个活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧对应的方法是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧。</li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用的是return指令，另一种是抛出异常。不管是哪种方式退出函数，都会导致栈帧被弹出。</li>
</ul>
<p>IDEA在debug的时候，可以在debug窗口看到Frames中各种方法的压栈和出栈情况：</p>
<p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc9s12g5wlj31li0owdm9.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="栈的存储单位（栈帧）"><a href="#栈的存储单位（栈帧）" class="headerlink" title="栈的存储单位（栈帧）"></a>栈的存储单位（栈帧）</h2><h3 id="栈帧简介"><a href="#栈帧简介" class="headerlink" title="栈帧简介"></a>栈帧简介</h3><ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li>
<li>在这个线程上正在执行的每一个方法都各自对应一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）</li>
<li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li>
<li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" srcset="/img/loading.gif" lazyload alt="jvm-stack-frame"></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><blockquote>
<p>局部变量表也被称为局部变量数组或者本地变量表。是一组变量值存储空间，主要存储方法参数和定义在方法体内的局部变量。</p>
</blockquote>
<h5 id="关于局部变量表的一些："><a href="#关于局部变量表的一些：" class="headerlink" title="关于局部变量表的一些："></a>关于局部变量表的一些：</h5><ul>
<li>由于局部变量表是建立在线程的栈上，是线程私有数据，因此不存在数据安全问题。</li>
<li>局部变量表所需的容量大小是在编译器确定下来的，并保存在方法的Code属性的<code>maximum localvariables</code>数据项中。在方法运行期间局部变量表的大小不会改变。</li>
<li>方法嵌套的最大次数由栈的和栈帧决定。一般来说，栈越大，方法嵌套次数越多。对一个函数而言，它的参数和局部变量越多，局部变量表越大，它的栈帧越大，会导致其嵌套调用次数减少。</li>
<li>局部变量表中的变量只有在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li>
<li>参数值的存放总是在局部变量数组的index0开始的，到数组长度-1的索引结束。</li>
<li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量直接或间接引用的对象都不会被回收。</li>
</ul>
<h5 id="局部变量表的最基本存储单位：Slot（变量槽）"><a href="#局部变量表的最基本存储单位：Slot（变量槽）" class="headerlink" title="局部变量表的最基本存储单位：Slot（变量槽）"></a>局部变量表的最基本存储单位：Slot（变量槽）</h5><ul>
<li><p>在局部变量表中，32位以内的类型只占用一个Slot，64位的占用两个连续的Slot。</p>
<blockquote>
<ul>
<li>byte、shor、char、boolean在存储前被转换为int，占用一个Slot</li>
<li>returnAddress类型也占用一个Slot</li>
<li>long和double则占据两个Slot</li>
</ul>
</blockquote>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上。</p>
</li>
<li><p>如果访问一个64位占用两个Slot的局部变量，只需要使用其前一个索引即可。</p>
</li>
<li><p>如果当前栈帧是由构造方法或实例方法创建的，那么该对象引用this将会被存放在index为0的Slot处，其余参数按照参数表顺序继续排列。这也是静态方法中不可以引用this的原因，因为静态方法的局部变量表中不存在this变量。</p>
</li>
<li><p>栈帧中的局部变量表的槽位是可以重用的。如果一个局部变量过了其作用域，那么在其作用域后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
</li>
</ul>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><blockquote>
<p>操作数栈，也可以称为表达式栈（Expression Stack）。主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。</p>
</blockquote>
<ul>
<li>操作数栈，在方法执行过程中，根据字节码指令往操作数栈中写入或提取数据，即入栈和出栈。</li>
<li>某些字节码指令将值压入操作数栈。其余的字节码指令将操作数取出栈，使用后再将结果压入栈。例如执行复制、交换、求和等操作。</li>
</ul>
<h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><ul>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，此时这个方法的操作数栈是空的。</li>
<li>每个操作数栈会拥有一个明确的栈深度用于存储数值，其中所需的最大深度再编译器就定义好了，保存在方法的Code属性的<code>max_stack</code>数据项中。</li>
<li>栈中的元素可以是任意的Java数据类型，一个栈单位深度可以保存32位数据。</li>
<li>操作数栈只能通过入栈和出栈操作来完成数据访问，不能使用索引访问数据。</li>
<li>如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</li>
<li>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，这里的栈指的就是操作数栈。</li>
</ul>
<h5 id="栈顶缓存（Top-of-stack-Cashing）"><a href="#栈顶缓存（Top-of-stack-Cashing）" class="headerlink" title="栈顶缓存（Top-of-stack-Cashing）"></a>栈顶缓存（Top-of-stack-Cashing）</h5><p>HotSpot的执行引擎采用的并非是基于寄存器的架构，但这并不代表HotSpot VM的实现没有间接利用到寄存器。</p>
<p>寄存器是物理CPU中的组成部分之一，它同时也是CPU中非常重要的高速存储资源。一般来说寄存器的读写速度是内粗的几十倍不止，不过寄存器资源十分有限，不同平台下的CPU寄存器数量不同。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p>
<p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读写次数。由于操作数是存储在内存中的，因此频繁的执行内存读写操作必然影响执行速度。</p>
<p>为了解决这个问题，HotSpot VM的设计者们提出了栈顶缓存计数，将栈顶元素全部缓存到物理CPU的寄存器中，以此降低对内粗的读写次数，提升执行引擎的执行效率</p>
<h4 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h4><h5 id="动态链接简介"><a href="#动态链接简介" class="headerlink" title="动态链接简介"></a>动态链接简介</h5><ul>
<li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都所谓符号引用（Symbolic Reference）保存到Class文件的常量池中。描述一个方法调用了其他的方法时，就是通过常量池中指向方法的符号引用来表示的，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</li>
</ul>
<p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gca4k4gndgj31d20o2td0.jpg" srcset="/img/loading.gif" lazyload alt="jvm-dynamic-linking"></p>
<h5 id="JVM时如何执行方法调用的"><a href="#JVM时如何执行方法调用的" class="headerlink" title="JVM时如何执行方法调用的"></a>JVM时如何执行方法调用的</h5><p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</p>
<p>Class文件的编译过程不包括传统编译器中的链接步骤，一切方法调用在Class文件里面存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用）。也就是在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p>
<p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关（绑定是一个字段、方法或类在符号引用被替换为直接引用的过程，这仅发生一次）。</p>
<p>JVM中的绑定机制：</p>
<ul>
<li><p>早期绑定（静态链接）</p>
<blockquote>
<p>早期绑定就是指被调用的目标方法如果在编译器可知，且运行期保持不变，即可将这个方法与所属的类型进行绑定。这样一来，由于明确了被调用的目标方法究竟是哪一个，因此就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</blockquote>
</li>
<li><p>晚期绑定（动态链接）</p>
<blockquote>
<p>如果被调用的方法在编译期无法被确定下来，只能在程序运行期根据实际的类型绑定相关的方法，这种绑定方式被称为晚期绑定。</p>
</blockquote>
</li>
</ul>
<p>虚方法和非虚方法：</p>
<ul>
<li><p>非虚方法</p>
<blockquote>
<p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</p>
</blockquote>
</li>
<li><p>虚方法</p>
<blockquote>
<p>其他的方法称为虚方法。</p>
<p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标，有可能会影响到执行效率。</p>
<p>为了提高性能，JVM采用在类的方法区建立一个 虚方法表（virtual method table），使用索引表来代替查找。每个类中都有一个虚方法表，表中存放着各个方法的实际入口。虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方法表也初始化完毕。</p>
</blockquote>
</li>
</ul>
<h4 id="方法返回地址（return-address）"><a href="#方法返回地址（return-address）" class="headerlink" title="方法返回地址（return address）"></a>方法返回地址（return address）</h4><blockquote>
<p>用来存放调用该方法的PC寄存器的值。</p>
</blockquote>
<p>方法的结束有两种方式：</p>
<ul>
<li><p>正常执行完成</p>
<blockquote>
<p>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称正常完成出口。</p>
</blockquote>
</li>
<li><p>出现异常退出</p>
<blockquote>
<p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便再发生异常的时候找到异常处理的代码。</p>
</blockquote>
</li>
</ul>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表和操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>两种方法结束方式的区别在于：通过异常完成出口退出方法不会给它的上层调用者产生任何返回值。</p>
<h4 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息还取决于具体的虚拟机实现。</p>
<h1 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h1><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><blockquote>
<p>一个Native Method就是一个Java调用非Java代码的接口。例如Unsafe类就有很多本地方法。</p>
</blockquote>
<p>为什么需要使用本地方法？</p>
<p>有些层次的任务使用Java不好实现，或者说效率不高，例如：</p>
<ul>
<li><p>与Java环境外交互</p>
<blockquote>
<p>有时Java应用需要与Java外面的环境交互，这就是本地方法存在的原因。</p>
</blockquote>
</li>
<li><p>与操作系统交互</p>
<blockquote>
<p>JVM支持Java语言本身和运行时库，但是有时需要依赖一些底层系统的支持。通过本地方法，我们可以实现用Java与实现了jre的底层系统交互，JVM的一部分就是C语言写的。</p>
</blockquote>
</li>
<li><p>Sun‘s Java</p>
<blockquote>
<p>Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用Java实现的，它也通过一些本地方法与外界交互。比如，类<code>java.lang.Thread</code> 的<code>setPriority</code> 的方法是用Java实现的，但它的实现是调用该类的本地方法<code>setPriority()</code>，该方法是C实现的，并被植入JVM内部。</p>
</blockquote>
</li>
</ul>
<h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><blockquote>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
</blockquote>
<ul>
<li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。跟Java虚拟机栈一样是线程私有的，且同样可以固定栈大小或可动态扩展栈大小（取决于虚拟机实现）。</li>
<li>本地方法使用C语言实现</li>
<li>它的具体做法是：本地方法栈中等级native方法，在执行引擎执行时加载本地方法库。当某线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限。</li>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存。</li>
<li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li>
</ul>
<h1 id="四、堆内存"><a href="#四、堆内存" class="headerlink" title="四、堆内存"></a>四、堆内存</h1><blockquote>
<p>栈是运行时的单位。解决程序的运行问题，即程序如何执行，或者说如何处理数据。</p>
<p>堆是存储的单位。解决的是数据存储的问题，即数据怎么放、放在哪儿。</p>
</blockquote>
<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><blockquote>
<p>分代的唯一理由就是优化GC性能。</p>
</blockquote>
<p>对于大多数应用，Java堆是Java虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分为三块区域：</p>
<ul>
<li>新生代：新对象和没达到一定年龄的对象都在新生代。</li>
<li>老年代：被长时间使用的对象在老年代，老年代的内存空间比新生代更大。</li>
<li>元空间：存放一些方法中的临时操作对象等。（JDK1.8之前叫永久代，占用JVM内存，JDK1.8之后直接使用物理内存）</li>
</ul>
<p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg" srcset="/img/loading.gif" lazyload alt="JDK7"></p>
<p>Java虚拟机规定，Java堆可以是物理上不连续的内存空间，只要逻辑上是连续的即可，像磁盘空间一样。JVM实现时既可以时固定大小的，也可以时扩展的，主流虚拟机都是可扩展的（通过<code>-Xmx</code>和<code>-Xms</code>参数控制）。如果堆中共没有完成实例分配，且堆无法再扩展时，就会抛出<code>OutOfMemoryError</code>异常。</p>
<h3 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h3><p>新生代是新对象创建的地方。当新生代满后，执行垃圾回收，这种垃圾回收称为Minor GC。</p>
<p>新生代被分为三部分：伊甸区（Eden Memory）和两个幸存区（Surviver Memory），默认比例8：1：1</p>
<ul>
<li>大多数新建对象都位于Eden内存空间</li>
<li>两个幸存区标记为From&#x2F;To区，To区总是空的。</li>
<li>当Eden空间满后，执行Minor GC，将Eden和From区中所有幸存者移动到To区，然后反转两个幸存区的From&#x2F;To标记。</li>
<li>经过多轮GC后存活下来的对象会被移动到老年代。通常是通过设置新生代对象的年龄阈值实现。</li>
</ul>
<h3 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h3><p>老年代的对象主要是两类：</p>
<ul>
<li><p>一类是经过多轮GC后仍然存活的新生代对象。</p>
</li>
<li><p>还有一类是大对象。</p>
<blockquote>
<p>大对象是指需要大量连续内存空间的对象。直接将大对象放入老年代是为了避免在Minor GC的时候频繁的将大对象在Eden区和两个Survivor区之间移动，从而避免大量的内存拷贝。</p>
</blockquote>
</li>
</ul>
<p>在老年代满后，会发生Major GC，Major GC通常会比Minor GC花费更多时间。</p>
<h3 id="元空间（Meta-Space）"><a href="#元空间（Meta-Space）" class="headerlink" title="元空间（Meta Space）"></a>元空间（Meta Space）</h3><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>不管是JDK8之前的永久代，还是JDK8及以后的元空间，都可以看作是Java虚拟机规范中方法区的实现。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名Non-Heap，应该与Java堆区分开。 </p>
<h2 id="对象在堆中的内存分配与生命周期"><a href="#对象在堆中的内存分配与生命周期" class="headerlink" title="对象在堆中的内存分配与生命周期"></a>对象在堆中的内存分配与生命周期</h2><ol>
<li>new的对象先放到Eden区，若是大对象则直接放到Old区</li>
<li>当Eden区空间不足，又需要新建对象时，JVM会对Eden区进行Minor GC，将Eden区中存活的对象移动到Surviver To区，并将对象年龄+1</li>
<li>To区接收了存活对象后和From区交换身份，变为From区。在下一轮的Minor GC中回收Eden区和From区，将存活对象移动到To区如此反复</li>
<li>当新生代中的对象年龄大于15（默认回收标记），就会被放到老年代</li>
<li>当老年代的内存不足后，会触发Major GC，进行老年代内存的回收</li>
<li>若老年代执行了Major GC后，剩余空间仍无法保存对象，就会产生OOM异常</li>
</ol>
<h2 id="GC垃圾回收简介"><a href="#GC垃圾回收简介" class="headerlink" title="GC垃圾回收简介"></a>GC垃圾回收简介</h2><p>针对HotSpot VM的实现，GC按照回收区域主要分为两大类：</p>
<ul>
<li><p>部分收集：</p>
<ul>
<li><p>Minor GC：只是新生代的垃圾收集</p>
</li>
<li><p>Major GC：只是老年代的垃圾收集</p>
<blockquote>
<p>只有CMS GC会又单独收集老年代的行为。很多时候Major GC会和Full GC混合使用。</p>
</blockquote>
</li>
<li><p>Mixed GC：收集整个新生代以及部分老年代的垃圾</p>
</li>
</ul>
</li>
<li><p>整堆收集：</p>
<ul>
<li>Full GC：收集整个Java堆和方法区的垃圾</li>
</ul>
</li>
</ul>
<h2 id="JVM针对堆区的一些优化"><a href="#JVM针对堆区的一些优化" class="headerlink" title="JVM针对堆区的一些优化"></a>JVM针对堆区的一些优化</h2><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><h4 id="什么是TLAB（Thread-Local-Allocation-Buffer）？"><a href="#什么是TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="什么是TLAB（Thread Local Allocation Buffer）？"></a>什么是TLAB（Thread Local Allocation Buffer）？</h4><ul>
<li>从内存模型而不是垃圾回收的角度，对Eden区域进行继续划分，为每个线程分配了一个私有的缓存区域，它包含在Eden空间中</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li>
<li>OpenJDK衍生出来的JVM大都提供TLAB设计</li>
</ul>
<h4 id="为什么要使用TLAB？"><a href="#为什么要使用TLAB？" class="headerlink" title="为什么要使用TLAB？"></a>为什么要使用TLAB？</h4><blockquote>
<p>避免为对象实例分配地址时加锁，提高分配速度。</p>
</blockquote>
<p>堆区时线程共享的，任何线程都可以访问到堆区的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中共划分内存空间是不安全的。为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<p>TLAB的设计为每个线程分配一个私有的缓存区域，线程创建对象时默认在该缓存区域创建，这样就不存在多线程冲突，也就不需要加锁。一旦对象在TLAB空间分配内存失败，JVM则会尝试通过加锁机制在Eden空间中直接为对象分配内存保证操作的原子性。</p>
<p>控制参数：</p>
<ul>
<li><code>-XX:UseTLAB</code>：设置是否开启TLAB空间</li>
<li><code>-XX:TLABWasteTargetPercent</code>：设置TLAB空间所占Eden空间的百分比（默认1%）</li>
</ul>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析的基本行为就是分析对象动态所用域：当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。若它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方，称为方法逃逸。</p>
<p>使用逃逸分析，编译器可以对代码做优化：</p>
<ul>
<li><p>栈上分配</p>
<blockquote>
<p>若一个对象在方法中被分配，且指向该对象的指针不会逃逸，对象可能会直接在栈中分配内存。这样该对象所占空间随着栈帧出栈而销毁，就减轻了GC压力。</p>
</blockquote>
</li>
<li><p>同步省略（锁消除）</p>
<blockquote>
<p>若一个对象只能被一个线程访问到，那么对于这个对象的一些同步操作可以消除。</p>
</blockquote>
</li>
<li><p>标量替换</p>
<blockquote>
<p>标量（Scalar）指一个无法再分解的数据，例如Java中的基本数据类型就是标量。哪些还可以被分解的就叫做聚合量（Aggregate），例如Java对象。</p>
<p>若一个对象不会被方法方法外部访问，那么JVM不会创建该对象，而是将该对象分解成若干被这个方法使用的成员变量替代。这些替代的成员变量再栈帧或寄存器上分配空间。这个过程就是标量替换。</p>
</blockquote>
</li>
</ul>
<h1 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h1><h2 id="关于方法区"><a href="#关于方法区" class="headerlink" title="关于方法区"></a>关于方法区</h2><h3 id="方法区简介"><a href="#方法区简介" class="headerlink" title="方法区简介"></a>方法区简介</h3><ul>
<li><p>方法区（Method Area）与java堆一样，是所有线程共享的内存区域。</p>
</li>
<li><p>方法区的大小和堆空间一样，可以选择固定大小，也可以选择可扩展。方法区的大小决定了系统可以放多少个类，如果系统中类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误。</p>
</li>
<li><p>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫Non-Heap，目的是将其与Java堆区分开</p>
</li>
<li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本&#x2F;字段&#x2F;方法&#x2F;接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能会有新的常量放入池中，这种特性被开发者利用的比较多的时String.intern()方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出OOM异常。</p>
</li>
</ul>
<h3 id="方法区、永久代和元数据区之间的关系"><a href="#方法区、永久代和元数据区之间的关系" class="headerlink" title="方法区、永久代和元数据区之间的关系"></a>方法区、永久代和元数据区之间的关系</h3><ul>
<li><p>方法区</p>
<blockquote>
<p>方法区只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据。并没有规定如何实现方法区，不同厂商有不同的实现。永久代和元空间都可以理解为方法区的具体实现。</p>
</blockquote>
</li>
<li><p>永久代（PermGen）</p>
<blockquote>
<p>永久代是Hotspot虚拟机特有的概念。永久代物理上是堆的一部分，和新生代、老年代地址是连续的（受垃圾回收期管理）。永久代存储类的元信息、静态变量和常量池等数据。</p>
</blockquote>
</li>
<li><p>元空间（Metaspace）</p>
<blockquote>
<p>在JDK8之后移除了永久代，替换为元空间。元空间物理上是属于本地内存（堆外内存，不受垃圾回收器管理）。元空间只存储类的元信息，而静态变量和常量池则并入堆中。</p>
</blockquote>
</li>
</ul>
<h3 id="设置方法区的大小"><a href="#设置方法区的大小" class="headerlink" title="设置方法区的大小"></a>设置方法区的大小</h3><p>在JDK8后方法区的实现是元空间，元空间有两个大小设定参数：</p>
<ul>
<li><p><code>-XX:MetaspaceSize</code></p>
<blockquote>
<p>默认21M。<code>-XX:MetaspaceSize</code>是初始的高水位线，一旦触及该水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线会被重置。新的高水位线的值取决于GC后释放的元空间内存大小，如果释放的空间不足，则会适当提高，如果释放的空间过多，则会适当降低。</p>
</blockquote>
</li>
<li><p><code>-XX:MaxMetaspaceSize</code></p>
<blockquote>
<p>默认-1，即没有限制。所以若不指定大小，虚拟机可能会耗尽所有的系统可用内存。如果元空间发生溢出，虚拟机同样会抛出异常<code>OutOfMemoryError:Metaspace</code>。</p>
</blockquote>
</li>
</ul>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><blockquote>
<p> 方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
</blockquote>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><h4 id="类型信息-1"><a href="#类型信息-1" class="headerlink" title="类型信息"></a>类型信息</h4><p>对于每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>该类型的完整有效名称（全名 &#x3D; 包名.类名）</li>
<li>该类型直接父类的有效名（interface和Object没有父类）</li>
<li>该类型的修饰符（public，abstrac，final的某个子集）</li>
<li>该类型直接接口的一个有序列表</li>
</ul>
<h4 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h4><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序，域的相关信息包括：</p>
<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符（public、private、protected、static、final、volatile、transient的某个子集）</li>
</ul>
<h4 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4><p>JVM必须保存所有的方法，方法的相关信息包括：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法的参数数量和类型</li>
<li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstrace的一个子集）</li>
<li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstrac和native方法除外）</li>
<li>异常表（每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量索引）</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。要理解运行时常量池需要先了解字节码文件中的常量池。</p>
</blockquote>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>一个有效额字节码文件中除了包含类的版本信息、字段、方法、以及接口等描述信息外，还包含一项重要的信息：常量池表（Constant Pool Table）。常量池表包含各种字面量和对类型、域、方法的符号引用。</p>
<p>一个Java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接保存到字节码中，而是存入常量池，字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池，常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型数据。</p>
<h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li>
<li>常量池表是Class文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li>
<li>JVM为每个已加载的类型（类或接口）单独维护一个常量池，池中的数据项像数组项一样，是通过索引访问的</li>
<li>运行时常量池中包含各种不同的常量。包括编译器就已经明确的数值字面量，也包括运行期解析后才能获得的方法或字段引用（此时不再是常量池中的符号地址，而是已经转换为真实地址）。 </li>
<li>运行时常量池，相对于Class文件常量池的另一个重要特征时：动态性。Java语言并不要求常量一定只有编译器间才能产生，运行期间也可以将新的常量放入池中，String类的<code>intern()</code>方法就是这样的</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，则JVM会抛出OOM异常。</li>
</ul>
<h2 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h2><ul>
<li><p>JDK1.6及之前</p>
<blockquote>
<p>有永久代，静态变量存放在永久代上</p>
</blockquote>
</li>
<li><p>JDK1.7</p>
<blockquote>
<p>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移动到堆中</p>
</blockquote>
</li>
<li><p>JDK1.8及之后</p>
<blockquote>
<p>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</p>
</blockquote>
</li>
</ul>
<p>移除永久代的原因：</p>
<ul>
<li><p>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。</p>
<blockquote>
<p>如果某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，可能会经常出现OOM。而元空间和永久代最大的区别在于元空间不在虚拟机中，而是使用本地内存，所以在默认情况下，元空间的大小仅受本地内存限制。</p>
</blockquote>
</li>
<li><p>对永久代进行调优较困难</p>
</li>
</ul>
<h2 id="方法区的内存回收"><a href="#方法区的内存回收" class="headerlink" title="方法区的内存回收"></a>方法区的内存回收</h2><p>方法区的垃圾回收的主要两部分内容：</p>
<ul>
<li>常量池中废弃的常量</li>
<li>不再使用的类型</li>
</ul>
<h3 id="常量池中废弃常量的回收"><a href="#常量池中废弃常量的回收" class="headerlink" title="常量池中废弃常量的回收"></a>常量池中废弃常量的回收</h3><p>方法区内常量池中主要存放的两大类常量：</p>
<ul>
<li><p>字面量</p>
<blockquote>
<p>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值</p>
</blockquote>
</li>
<li><p>符号引用</p>
<blockquote>
<p>而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</blockquote>
</li>
</ul>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中常量没有被任何地方引用，就可以被回收。</p>
<h3 id="不再使用的类型的回收"><a href="#不再使用的类型的回收" class="headerlink" title="不再使用的类型的回收"></a>不再使用的类型的回收</h3><p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：</p>
<ol>
<li><p>该类所有实例都已经被回收。</p>
<blockquote>
<p>也就是Java堆中不存在该类及其任何派生子类的实例。</p>
</blockquote>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用。</p>
<blockquote>
<p>这样就无法在任何地方通过反射访问该类的方法。</p>
</blockquote>
</li>
<li><p>加载该类的类加载器已经被回收。</p>
<blockquote>
<p>这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常很难达成。</p>
</blockquote>
</li>
</ol>
<p>Java虚拟机被允许堆满足上述三个条件的无用类进行回收。这里说的是“被允许”，而不是和对象一样，不使用了就必然会回收，是否对类回收通过<code>-Xnoclassgc</code>参数控制。还可以使用<code>-verbose:class</code>、<code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/JVM/" class="category-chain-item">JVM</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JVM-内存结构</div>
      <div>http://example.com/2022/11/14/JVM-内存结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>XiangYU</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月14日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2022年11月22日</div>
        </div>
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="JVM-内存模型">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM-内存模型</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/" title="JVM-类加载">
                        <span class="hidden-mobile">JVM-类加载</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"oJgRmRSoMnXMSzk2FSqr3T8l-gzGzoHsz","appKey":"2rUmLcHtDRExt0YFmed3951e","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
