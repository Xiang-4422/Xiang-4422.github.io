

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/rideordie.png">
  <link rel="icon" href="/img/rideordie.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="XiangYU">
  <meta name="keywords" content="">
  
    <meta name="description" content="索引简介索引是什么 索引就是数据的目录。  当我们想要查阅书中的某个只是的内容的时候，使用目录可以快速定位要找的知识的位置，如果没有目录那么就需要一页一页的找。 书中的目录，就是充当索引的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。对应到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的来说索引就是数据的目录。 所谓的存储引擎，就是如何存储数据、如何为存">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-索引">
<meta property="og:url" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name" content="Ride_or_DIE">
<meta property="og:description" content="索引简介索引是什么 索引就是数据的目录。  当我们想要查阅书中的某个只是的内容的时候，使用目录可以快速定位要找的知识的位置，如果没有目录那么就需要一页一页的找。 书中的目录，就是充当索引的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。对应到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的来说索引就是数据的目录。 所谓的存储引擎，就是如何存储数据、如何为存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/q4-2.drawio.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E5%8C%BA%E5%88%86%E5%BA%A6.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/824c43b801c64e81acb0a9b042d50311.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/btree.drawio.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E5%9B%9E%E8%A1%A8.drawio.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/f01bb5e7e940231c4f39e7f1cfb449f3.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/dd076212a7637b9032c97a615c39dcd7.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/243b1466779a9e107ae3ef0155604a17.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/fabd6dadd61a0aa342d7107213955a72.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/557d17e05ce90f18591c2305871af665.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/261011d237bec993821aa198b97ae8ce.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/7c635d682bd3cdc421bb9eea33a5a413.png">
<meta property="og:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/798ab1331d1d6dff026e262e788f1a28.png">
<meta property="article:published_time" content="2022-11-05T03:38:48.000Z">
<meta property="article:modified_time" content="2022-11-05T15:33:43.443Z">
<meta property="article:author" content="XiangYU">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>MySQL-索引 - Ride_or_DIE</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"oJgRmRSoMnXMSzk2FSqr3T8l-gzGzoHsz","app_key":"2rUmLcHtDRExt0YFmed3951e","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ride_or_DIE</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL-索引"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-05 11:38" pubdate>
          2022年11月5日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          97 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL-索引</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年11月5日 晚上
                  
                
              </p>
            
            <div class="markdown-body">
              
              <h1 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><blockquote>
<p>索引就是数据的目录。</p>
</blockquote>
<p>当我们想要查阅书中的某个只是的内容的时候，使用目录可以快速定位要找的知识的位置，如果没有目录那么就需要一页一页的找。</p>
<p>书中的目录，就是充当索引的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。对应到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的来说索引就是数据的目录。</p>
<p>所谓的存储引擎，就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p>
<h2 id="索引的分类与介绍"><a href="#索引的分类与介绍" class="headerlink" title="索引的分类与介绍"></a>索引的分类与介绍</h2><p>按不同角度分类：</p>
<p>数据结构：B+Tree索引、Hash索引、Full-text索引</p>
<p>物理存储：聚簇索引（主键索引）、二级索引（辅助索引）</p>
<p>字段特性：主键索引、唯一索引、普通索引、前缀索引</p>
<p>字段个数：单列索引、联合索引</p>
<h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><p>从数据结构的角度来看，MySQL常见的索引有B+tree索引、Hash索引、Full-text索引。</p>
<p>不同存储引擎支持的所以类型不同，支持如下：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>MySQL的默认引擎是InnoDB，InnoDB的默认索引类型是B+tree索引。</p>
<h3 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h3><p>从物理存储的角度看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p>
<p>主键索引的B+ Tree和二级索引的B+ Tree的区别：</p>
<ul>
<li>主键索引的B+ Tree的叶子节点存放的是实际数据，所有的行数据都存放在主键索引的B+ Tree的叶子节点中</li>
<li>二级索引的B+ Tree的叶子节点存放的是主键值，而不是实际数据</li>
</ul>
<p>二者的创建：</p>
<ul>
<li><p>聚簇索引：</p>
<blockquote>
<p>在创建表时，InnoDB会根据不同场景选择不同列作为索引生成聚簇索引</p>
<ul>
<li>若有主键。默认选择使用主键作为聚簇索引的索引键</li>
<li>若没有主键。则选择第一个不包含NULL值的唯一列作为聚簇索引的索引键</li>
<li>若上面二者都没有。InnoDB则会生成一个隐式自增id列作为聚簇索引的索引键</li>
</ul>
</blockquote>
</li>
<li><p>非聚簇索引：</p>
<blockquote>
<p>其他的索引都属于辅助索引（Secondary Index），也称为二级索引或非聚簇索引。</p>
</blockquote>
</li>
</ul>
<h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><blockquote>
<p>主键索引就是建立在主键字段上的索引。通常在创建表的时候一起创建，一张表只有一个主键索引，索引列的值不能为空值。</p>
</blockquote>
<p>在创建表时，创建主键索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  PRIMARY KEY (index_column_1) USING BTREE<br>);<br></code></pre></td></tr></table></figure>

<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><blockquote>
<p>唯一索引是建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值。</p>
</blockquote>
<p>创建表时，创建唯一索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  UNIQUE KEY(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure>

<p>建表后，添加唯一索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE UNIQUE INDEX index_name<br>ON table_name(index_column_1,index_column_2,...); <br></code></pre></td></tr></table></figure>

<h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><blockquote>
<p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为UNIQUE。</p>
</blockquote>
<p>建表时，创建普通索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  INDEX(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure>

<p> 建表后，添加普通索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_name<br>ON table_name(index_column_1,index_column_2,...); <br></code></pre></td></tr></table></figure>

<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><blockquote>
<p>前缀索引是指字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引。前缀索引可以建立子啊字段类型为char、varchar、binary、varbinary的列上。</p>
<p>使用前缀索引的目的是为了减少索引占用的存储空间，并提升查询效率。</p>
</blockquote>
<p>创建表时，创建前缀索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name(<br>    column_list,<br>    INDEX(column_name(length))<br>); <br></code></pre></td></tr></table></figure>

<p>建表后添加前缀索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_name<br>ON table_name(column_name(length)); <br></code></pre></td></tr></table></figure>

<h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><p>从字段个数的角度来看，索引分为单列索引、联合索引。</p>
<ul>
<li>建立在单列上的索引称为单列索引，比如主键索引</li>
<li>建立在多列上的索引称为联合索引</li>
</ul>
<h4 id="联合索引简介："><a href="#联合索引简介：" class="headerlink" title="联合索引简介："></a>联合索引简介：</h4><p>若将上面商品表中的product_no和name字段组合成联合索引（product_no, name）。</p>
<p>创建联合索引的方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_product_no_name ON product(product_no, name);<br></code></pre></td></tr></table></figure>

<p>联合索引（product_no, name）的B+ Tree示意图：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png" srcset="/img/loading.gif" lazyload alt="联合索引"></p>
<p>可以看到，联合索引的非叶子节点用两个字段的值作为B+ Tree的Key值。</p>
<p>当在联合索引查询数据时，先按照product_no字段比较，在product_no字段相同的情况下再按name字段比较。也就是说来联合索引中的B+Tree是先按product_no进行排序，再按name排序。</p>
<h4 id="最左匹配原则："><a href="#最左匹配原则：" class="headerlink" title="最左匹配原则："></a>最左匹配原则：</h4><p>在使用联合索引的时候，存在最左匹配原则，也就是按照最左优先的方式进行索引匹配。</p>
<p>在使用联合索引进行查询的时候，若不遵守最左匹配原则，联合索引会失效，这样就无法利用索引快速查询的特性了。</p>
<p>比如说有（a，b，c）这么三个字段组成的联合索引。</p>
<p>有效的查询条件：</p>
<ul>
<li>where a &#x3D; 1;</li>
<li>where a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3;</li>
<li>where b &#x3D; 1 and a &#x3D; 2;</li>
</ul>
<p>失效的查询条件：</p>
<ul>
<li>where b &#x3D; 2;</li>
<li>where c &#x3D; 3;</li>
<li>where b &#x3D; 2 and c &#x3D; 3;</li>
</ul>
<p>索引失效的原因（只有a字段是全局有序的，b和c字段是局部有序的）：</p>
<blockquote>
<p>因为联合索引（a, b, c）是按照a排序，a相同的情况下按b排序，b相同过的情况下按c排序。</p>
<p>所以说<strong>b和c是全局无序的，局部有序的。</strong></p>
<p>这样在没有遵守最左匹配原则的情况下，是无法利用到该联合索引的。</p>
</blockquote>
<h4 id="联合索引范围查询："><a href="#联合索引范围查询：" class="headerlink" title="联合索引范围查询："></a>联合索引范围查询：</h4><blockquote>
<p>范围查询的字段可以用到联合索引，范围查询后的字段无法用到联合查询。</p>
</blockquote>
<p>联合查询的最左匹配原则会一直向右匹配直到遇到范围查询就会停止匹配。</p>
<p>三条语句的联合索引使用情况（条件中的字段组成联合索引）：</p>
<ul>
<li><pre><code class="mysql">select * from t_table where a &gt; 1 and b = 2
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>  在符合<span class="hljs-keyword">a</span>&gt;<span class="hljs-number">1</span>条件的二级索引记录的范围中，b字段的值是无序的。<br><br>  进行范围扫描的起始记录时符合`<span class="hljs-keyword">a</span> &gt; <span class="hljs-number">1</span>`的第一条记录。<br><br>  所以说只有<span class="hljs-keyword">a</span>字段使用到了联合索引，b字段没有。<br><br>- ```mysql<br>  select * <span class="hljs-built_in">from</span> t_table where <span class="hljs-keyword">a</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

对于a=1的二级索引记录的范围中，b字段的值是有序的。

进行范围扫描的起始记录是符合`a = 1 and b = 2 `的第一条记录。

a字段和b字段都用到了联合索引。
</code></pre>
</li>
<li><p>&#96;&#96;&#96;mysql<br>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b &#x3D; 2</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>  在MySQL中<span class="hljs-keyword">BETWEEN</span>类似于大于等于和小于等于的查询。<br><br>- ```mysql<br>  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;j%&#x27;</span> <span class="hljs-keyword">and</span> age = <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure>

<p><code>like j%</code>形成的扫描区间是[‘j’, ‘k’]。所以说也同上面的范围查询类似。</p>
<p>虽然符合‘j’前缀的name字段中的二级索引记录范围中，age字段的值是无序的。但是对于符合name &#x3D; j的二级索引记录的范围里，age字段的值是有序的。</p>
<p>所以进行范围扫描的起始记录是<code>name = j and age = 22</code>的第一条记录。</p>
<p>所以这个查询语句也用到了name和age两个字段。</p>
<p>图示如下：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/q4-2.drawio.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>综上：</p>
<blockquote>
<p>联合索引的最左匹配原则，在遇到范围查询如（&gt;、&lt;）的时候，停止匹配剩余字段。</p>
<p>但是对于&gt;&#x3D;、&lt;&#x3D;、 BETWEEN、like前缀匹配的范围查询，并不会停止匹配。</p>
</blockquote>
</li>
</ul>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>对于联合索引（a，b），在执行<code>select * from table where a &gt; 1 and b = 2</code>语句的时候，只有a字段能使用a字段。那么在联合索引的B+Tree中找的了符合a字段条件的主键值后，如何判断b字段是否满足条件呢？</p>
<ul>
<li>在MySQL 5.6前，只能通过回表，通过主键id到主键索引中查找出数据行，再对比b字段。</li>
<li>在MySQL 5.6引入的<strong>索引下推优化</strong>（index condition pushdown），可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。（在查询语句的执行计划中共，Extra为Using index condition，那么说明使用了索引下推的优化）。</li>
</ul>
<h4 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h4><p>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高。在实际开发中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的SQL使用到。</p>
<p>区分度：某个字段column不同值得个数&#x2F;表得总行数</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E5%8C%BA%E5%88%86%E5%BA%A6.png" srcset="/img/loading.gif" lazyload alt="区分度计算公式"></p>
<p>例如，性别的区分度很小，不适合建立索引，或不适合排在联合索引列的靠前位置。而UUID这种字段区分度就高。</p>
<h4 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h4><blockquote>
<p>因为联合索引的有序性，所以说可以利用该特性来优化有排序的查询语句。</p>
</blockquote>
<p>例如该SQL语句的优化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from order where status = 1 order by create_time asc<br></code></pre></td></tr></table></figure>

<ul>
<li><p>方案一、给status建立一个索引</p>
<blockquote>
<p>在查询时，只用到status索引，还是需要对creat_time排序</p>
</blockquote>
</li>
<li><p>方案二、给status和create_time列建立一个联合索引</p>
<blockquote>
<p>因为在查询的时候根据statue &#x3D; 1筛选后的数据，已经是根据creat_time拍好序了的，不需要再额外执行排序操作。这样就可以避免MySQL数据库去进行排序操作。</p>
</blockquote>
</li>
</ul>
<h3 id="B-Tree索引在存储数据中的具体实现"><a href="#B-Tree索引在存储数据中的具体实现" class="headerlink" title="B+ Tree索引在存储数据中的具体实现"></a>B+ Tree索引在存储数据中的具体实现</h3><h4 id="表结构和表数据："><a href="#表结构和表数据：" class="headerlink" title="表结构和表数据："></a>表结构和表数据：</h4><p>先创建一张表，id为主键，表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `product`  (<br>  `id` int(11) NOT NULL,<br>  `product_no` varchar(20)  DEFAULT NULL,<br>  `name` varchar(255) DEFAULT NULL,<br>  `price` decimal(10, 2) DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE<br>) CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;<br></code></pre></td></tr></table></figure>

<p> 表数据如下：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/824c43b801c64e81acb0a9b042d50311.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="行数据在在B-Tree索引中存储的结构："><a href="#行数据在在B-Tree索引中存储的结构：" class="headerlink" title="行数据在在B+ Tree索引中存储的结构："></a>行数据在在B+ Tree索引中存储的结构：</h4><blockquote>
<p>B+ Tree是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每一个节点中的数据是按照主键顺序存放。</p>
<p>每一个父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。</p>
</blockquote>
<p>主键索引的B+ Tree如图：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/btree.drawio.png" srcset="/img/loading.gif" lazyload alt="主键索引 B+Tree"></p>
<h4 id="通过主键查询数据："><a href="#通过主键查询数据：" class="headerlink" title="通过主键查询数据："></a>通过主键查询数据：</h4><p>若我们执行了查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from product where id = 5;<br></code></pre></td></tr></table></figure>

<p>主键查询的查询过程如下：</p>
<ol>
<li>将5与根节点索引数据（1，10，20）比较，5在1-10之间，根据B+ Tree搜索逻辑，找到第二层（1，4，7）；</li>
<li>在第二层索引数据（1，4，7）中进行查找，因为5在4-7之间，所以找到第三层叶子节点数据（4，5，6）</li>
<li>在叶子节点数据（4，5，6）中进行查找，然后就找到了索引值为5的行数据</li>
</ol>
<p>数据的索引和数据都是存储在硬盘中。我们可以把读取一个节点当作一次磁盘I&#x2F;O操作，那么经过上面的查询进行了3次I&#x2F;O操作。</p>
<p>B+ Tree存储千万级的数据只需要3-4层高度，也就是说千万级的表查询也只需要3-4次的磁盘I&#x2F;O。</p>
<h4 id="通过二级索引查询数据："><a href="#通过二级索引查询数据：" class="headerlink" title="通过二级索引查询数据："></a>通过二级索引查询数据：</h4><p>我们将上表中的product_no字段设置为二级索引，那么该二级索引结构如下：</p>
<blockquote>
<p>叶子节点的key为product_no字段，Value为主键值id。</p>
</blockquote>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png" srcset="/img/loading.gif" lazyload alt="二级索引 B+Tree"></p>
<p>若通过二级索引查询商品，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from product where product_no = &#x27;0002&#x27;;<br></code></pre></td></tr></table></figure>

<p>二级索引的查询过程：</p>
<ol>
<li>先根据product_no值在二级索引的B+ Tree中找到对应得叶子节点，获取主键值</li>
<li>在根据主键值，在主键索引得B+ Tree中查询到对应得叶子节点，获取整行数据</li>
</ol>
<p>上面这个查询过程叫做<strong>回表</strong>，也就是要查询两个B+ Tree才能查到数据。过程如下：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E5%9B%9E%E8%A1%A8.drawio.png" srcset="/img/loading.gif" lazyload alt="回表"></p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果当查询得数据能在B+ Tree得叶子节点中查询到，这个时候就不用再通过主键索引查，例如执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id from product where product_no = &#x27;0002&#x27;;<br></code></pre></td></tr></table></figure>

<p>这种在二级索引得B+ Tree就能查询到结果得过程叫做                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              <strong>覆盖索引</strong>，也就是只需要查二级索引，不需要回表操作就能找到所需数据。</p>
<h2 id="什么时候需要索引"><a href="#什么时候需要索引" class="headerlink" title="什么时候需要索引"></a>什么时候需要索引</h2><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>索引的最大好处时提高查询速度。但是索引也有缺点，比如：</p>
<ul>
<li>空间占用。索引需要占用物理空间，数量越大，占用空间越大。</li>
<li>创建和维护索引需要消耗时间。消耗的时间随着数据量的增大而增大。</li>
<li>降低增删改速度。因为每次增删该索引，B+树为了维护索引的有序性，需要进行动态维护。</li>
</ul>
<h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul>
<li>字段有唯一性限制。例如商品编码。</li>
<li>经常用于<code>WHERE</code>查询条件的字段。这样可以提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于<code>GROUP BY</code>和<code>ORDER BY</code>的字段。这样在查询的时候就不需要再去做一次排序了，因为再建立了索引之后B+树中的记录都是排好序了的。</li>
</ul>
<h4 id="什么时候不需要索引？"><a href="#什么时候不需要索引？" class="headerlink" title="什么时候不需要索引？"></a>什么时候不需要索引？</h4><ul>
<li>WHERE条件、GROUP BY、ORDER BY里用不到的字段。索引的价值是快速定位，如果起不到定位作用的字段通常是不需要创建索引的。</li>
<li>区分度小的字段。区分度小的字段，例如性别，无论搜索哪一个值都得到一半左右的数据。再这种情况下，还不如不使用索引，因为查询优化器发现某种值在表中的数据行出现的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引。</li>
<li>经常更新的字段不用创建索引。例如电商项目中的用户余额字段不要建立索引。因为若索引字段需要频繁修改，由于要维护B+树的有序性，那么就需要频繁的重建索引，这个过程会影响数据库的性能。</li>
</ul>
<h1 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h1><h2 id="为什么采用B-树作为索引"><a href="#为什么采用B-树作为索引" class="headerlink" title="为什么采用B+树作为索引"></a>为什么采用B+树作为索引</h2><h3 id="作为索引的数据结构的要求"><a href="#作为索引的数据结构的要求" class="headerlink" title="作为索引的数据结构的要求"></a>作为索引的数据结构的要求</h3><p>MySQL的数据时持久化的，也就是数据（索引+记录）是保存在磁盘上的，这样即使设备断电，数据也不会丢失。</p>
<p>磁盘的访问速度很慢，磁盘中读取速度比内存满上万倍。磁盘存储数据的最小单位是扇区，扇区的大小只有512B。操作系统读取数据的最小单位是块，一个块包含多个扇区。在Linux中块为4KB，也就是一次磁盘I&#x2F;O操作会读取8个扇区。</p>
<p>由于数据库的索引是保存到磁盘上的，所以在通过索引查找行数据的时候，需要从磁盘中读取索引到内存，再通过索引从磁盘中找到行数据，然后读入内存。也就是说在查询过程中会发生多次磁盘I&#x2F;O，而磁盘I&#x2F;O次数越多，所消耗的时间越大。</p>
<p>所以，我们希望索引的数据结构能在尽可能少的磁盘I&#x2F;O操作中完成查询工作。另外，MySQL支持范围查找，所以索引的数据结构不仅要能高效地查询单条记录，也要能高效地执行范围查找。</p>
<p>所以适合MySQL索引的数据结构，需要满足的要求：</p>
<ul>
<li>要在尽可能少的磁盘I&#x2F;O操作中完成查询工作</li>
<li>要能高效的查询某一条记录，也要能高效地执行范围查找</li>
</ul>
<h3 id="数组二分查找"><a href="#数组二分查找" class="headerlink" title="数组二分查找"></a>数组二分查找</h3><p>假设使用数组存储索引，那么我们维护这个数组为有序数组，在定位数据的时候就可以使用二分查找法：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/f01bb5e7e940231c4f39e7f1cfb449f3.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>这样每次查询的时间复杂度就降为O(logN)。</p>
<p>数组二分查找的问题：</p>
<p>使用数组来存储和检索线性排序的数据简单好用，但是插入新元素的时候性能太差。在插入数据的时候，需要移动该数据后面的每一个元素，而且这个操作还是发生在磁盘中。而且在使用二分查找的时候，每次查找还需要计算中间的位置。</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树的特点就是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点。</p>
<p>这样我们在查询数据时，不需要计算中间节点的位置，只需要将查找的数据与节点数据进行比较。并且有序二叉查找树时非线性结构，插入节点的的时候可以放在任何位置，不需要像线性结构那样移动其余元素。</p>
<p>二分查找树的问题：</p>
<p>若每次插入的元素都是二叉查找树中的最大值，二叉查找树就会退化为一条链表。每访问一个节点就对应一次磁盘I&#x2F;O操作，树的高度越高，对应I&#x2F;O操作次数越多，性能越差。并且二分查找树不能范围查询。</p>
<h3 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h3><p>为例解决二叉树在极端情况下退化成链表，就提出了平衡二叉查找树（AVG）。也就是在二叉查找树的基础上增加了一些条件约束：每个节点的左子树和右子树的高度差不能超过1。这样查询操作的时间复杂度就会一直维持在O（logN）。</p>
<p>自平衡二叉树的问题：</p>
<p>随着插入元素的增多，导致树的高度变高，意味着磁盘的I&#x2F;O操作次数变多，影响整体查询效率。因为自平衡二叉树本质上是一颗二叉树，每个节点只能有两个子节点，节点增多，树高曾高，磁盘I&#x2F;O次数增多。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>为例降低树的高度，就提出了B树。它不再限制节点的子节点数量，而是允许M个子节点（M &gt; 2），从而降低树的高度。M称为B树的阶，所以B树是一个多叉树。</p>
<p>B树的问题：</p>
<p>B树的每一个节点都包含数据（索引+记录）。这就导致了在查询某节点记录的时候，加载了很多非该节点的记录数据，我们需要的是索引来判断查询节点的位置，但是由于索引和数据记录是绑定在一起的，所以无用的数据记录也被加载。这就导致了磁盘I&#x2F;O次数的增多，也占用了更多的内存资源。并且B树不支持范围查询。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树在B树的基础上做了升级：</p>
<ul>
<li>只有也只节点存放实际数据（索引+记录），非叶子节点只会存放索引</li>
<li>所有索引都会在叶子节点出现，叶子节点之间构成一个链表</li>
</ul>
<h5 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h5><p>B+树的非叶子节点只存放索引，所以说每个非叶子节点可以存放更多的子节点，那么B+树就比B树更加矮胖，查询底层节点的磁盘I&#x2F;O会更少。</p>
<h5 id="插入和删除效率"><a href="#插入和删除效率" class="headerlink" title="插入和删除效率"></a>插入和删除效率</h5><p>因为数据都存储在叶子节点，B+树有大量冗余节点，这样在删除一个节点的时候，可以直接从叶子节点删除，甚至可以不用动非叶子节点。而B树因为没有冗余节点，删除节点可能涉及复杂的树变形。插入也是同理。</p>
<h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><p>B树和B+树的等值查询原理一致，先从根节点查找，然后对比目标数据的范围，最后递归地进入子节点查找。</p>
<p>因为B+树地叶子节点之间通过链表连接。当需要进行范围查找地时候，可以先从根节点开始单点查找通过边界值，然后利用链表查找范围数据，不再需要从根节点查询，这样减少了大量地I&#x2F;O。</p>
<h3 id="Innodb中的B-树"><a href="#Innodb中的B-树" class="headerlink" title="Innodb中的B+树"></a>Innodb中的B+树</h3><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/dd076212a7637b9032c97a615c39dcd7.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>Innodb使用的B+树的一些特点：</p>
<ul>
<li>叶子节点之间使用双向链表连接</li>
<li>树节点的内容是数据页，数据页中存放着用户的记录以及各种信息，每个数据页默认大小为16KB</li>
</ul>
<p>Innodb根据索引类型分为：</p>
<ul>
<li>聚簇索引。叶子节点存放的是实际数据，所有完整的用户记录存放在聚簇索引的叶子节点</li>
<li>二级索引。叶子节点存放的是主键值，而不是实际数据</li>
</ul>
<p>因为表的数据都是存放在聚簇索引的叶子节点中，索引Innodb引擎一定会为表创建一个聚簇索引，而且由于数据只在物理上保存一根，所以聚簇索引有且仅有一个，而二级索引可以创建多个。</p>
<h2 id="从数据页的角度看B-树"><a href="#从数据页的角度看B-树" class="headerlink" title="从数据页的角度看B+树"></a>从数据页的角度看B+树</h2><p>记录是按行来存储的，但是数据库的读取并不是以行为单位。否则一次I&#x2F;O只读取一行数据，效率会很低。</p>
<p>因此，InnoDB的数据是以<strong>数据页</strong>为单位来读写的，也就是说，当需要读取一条记录的时候，并不是将这个记录本身从磁盘读取出来，而是将该记录所在页整体读入内存。</p>
<p>数据库I&#x2F;O操作的最小单位是页，默认数据页的大小为16KB。也就是说数据区每次I&#x2F;O最少读&#x2F;写16KB的数据。</p>
<h3 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h3><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/243b1466779a9e107ae3ef0155604a17.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>各部分作用：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/fabd6dadd61a0aa342d7107213955a72.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h4 id="File-Header（文件头）"><a href="#File-Header（文件头）" class="headerlink" title="File Header（文件头）"></a>File Header（文件头）</h4><p>File Header中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/557d17e05ce90f18591c2305871af665.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p> 采用链表的结构，让数据页之间不需要是物理连续的，而是逻辑连续的。</p>
<h4 id="Page-Directory（页目录）"><a href="#Page-Directory（页目录）" class="headerlink" title="Page Directory（页目录）"></a>Page Directory（页目录）</h4><p>数据页的作用是存储记录，所以说数据页的重点在于如何组织数据。</p>
<p>数据页中的记录按照主键顺序组成单向链表。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况需要遍历完链表上的所以节点才能完成检索。</p>
<p>因此，数据页中有一个页记录，起到记录的索引作用。就像读书时针对章节设立的目录，通过目录快速定位对应章节的页数。</p>
<h5 id="页目录与记录的关系："><a href="#页目录与记录的关系：" class="headerlink" title="页目录与记录的关系："></a>页目录与记录的关系：</h5><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/261011d237bec993821aa198b97ae8ce.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h5 id="页目录的创建过程："><a href="#页目录的创建过程：" class="headerlink" title="页目录的创建过程："></a>页目录的创建过程：</h5><ol>
<li>将所有记录划分为几个组，这些记录包括最大记录和虽小记录，但不包括”已删除“的记录。</li>
<li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为n_owned字段（图中粉色字段）</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些偏移量会按照先后顺序存储起来，每组的地址便宜量也被称为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
<h5 id="通过页目录查找记录："><a href="#通过页目录查找记录：" class="headerlink" title="通过页目录查找记录："></a>通过页目录查找记录：</h5><ol>
<li><p>页目录由多个槽组成，槽相当于分组记录的索引；</p>
</li>
<li><p>然后，记录按照主键值从小到大排序，索引可以通过二分法快速定位要查询记录所在槽；</p>
</li>
<li><p>定位到槽后，再遍历槽内的所有记录，找到对应的记录。无需从最小记录开始遍历整页中共的所有记录。</p>
</li>
</ol>
<p> 因为要遍历槽内数据，所以对每个槽（分组）中记录的条数有规定：</p>
<ul>
<li>第一个分组的记录只能有一条</li>
<li>最后一个分组中的记录条数范围只能在1-8条之间</li>
<li>剩余的分组中记录条数范围只能在4-8条之间</li>
</ul>
<h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+树是如何进行查询的？"></a>B+树是如何进行查询的？</h3><p>上面说的是在数据页中的记录的检索。因为一个数据页中的记录有限，且主键值时候有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索记录所在分组，来降低检索的时间复杂度。</p>
<p>当我们需要存储大量的记录时，就需要大量数据页，这个时候就需要为这些数据页建立索引，用于快速定位记录所在的页。</p>
<p>InnoDB采用B+树作为索引。B+树中每个节点都是一个数据页，结构示意图如下：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/7c635d682bd3cdc421bb9eea33a5a413.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>B+树特点：</p>
<ul>
<li>只有也只节点存放数据，非叶子节点仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量。</li>
<li>所有节点按照索引键的大小排序，构成一个双向链表，便于范围查询</li>
</ul>
<p>B+树搜索主键为6的记录的过程：</p>
<ol>
<li>从根节点，通过二分法快速定位到符合页内范围包含查询值得页。因为6在[1, 7)之间，所以到页30中查找；</li>
<li>在非叶子节点中，递归查找，主键值大于5，所以到叶子节点（页16）中查找</li>
<li>在叶子节点中，根据页目录定位记录所在槽，单位到槽后，遍历槽内记录，找到主键为6的记录</li>
</ol>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="一、前缀索引优化"><a href="#一、前缀索引优化" class="headerlink" title="一、前缀索引优化"></a>一、前缀索引优化</h2><blockquote>
<p>使用某字段中字符串的前几个字符建立索引。</p>
</blockquote>
<p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引个数，降低树的高度，有效的提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p>
<p>前缀索引的局限性：</p>
<ul>
<li>order by无法使用前缀索引</li>
<li>无法把前缀索引用作覆盖索引</li>
</ul>
<h2 id="二、覆盖索引优化"><a href="#二、覆盖索引优化" class="headerlink" title="二、覆盖索引优化"></a>二、覆盖索引优化</h2><blockquote>
<p>使用作为联合索引的字段覆盖查询语句中的所有字段。避免回表操作。</p>
</blockquote>
<p>当在二级索引的叶子节点中能找到查询语句中所需要的字段，那么就不需要再通过聚簇索引查询完整行记录来获取需要的字段。</p>
<p>例如查询商品的名称、价格，如何避免回表？</p>
<p>我们可以建立一个联合索引，即（商品ID、名称、价格）作为联合索引，索引中存在名称和价格字段，查询语句需要的字段可以直接在二级索引中获取，不需要再通过主键索引，避免了回表，减少了I&#x2F;O操作。</p>
<h2 id="三、主键索引自增"><a href="#三、主键索引自增" class="headerlink" title="三、主键索引自增"></a>三、主键索引自增</h2><blockquote>
<p>主键索引设置为自增，这样可以避免页分裂。</p>
</blockquote>
<p>InnoDB创建主键索引默认为聚簇索引，数据被存放到B+Tree的叶子节点上。也就是说，同一叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据被插入，数据库会根据主键将其插入对应的叶子节点中。</p>
<p>若使用自增主键：</p>
<p>每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当该叶子节点页写满后，会自动开辟一个新页面。因为每次插入一条新记录都是追加操作，不需要移动已有数据，因此插入的效率很高。</p>
<p>若不使用自增主键：</p>
<p>每次插入主键的索引值都是随机的，因此插入新的数据，可能会插入到现有数据页中间的位置，这样的话就需要移动其他数据来满足新数据的插入，甚至如果该页没有剩余空间，还需要从一个页面复制数据到另一个页面，我们称这种情况为<strong>页分裂</strong>。页分裂可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p>
<p><strong>此外需要注意：</strong>主键字段的长度不要太大。因为二级索引叶子节点存储的数据是主键字段值，所以说主键长度越短，二级索引占用的空间也就越小</p>
<h2 id="四、索引设置为NOT-NULL"><a href="#四、索引设置为NOT-NULL" class="headerlink" title="四、索引设置为NOT NULL"></a>四、索引设置为NOT NULL</h2><p>为了更好地利用索引，索引类要设置NOT NULL约束，原因如下：</p>
<ul>
<li>索引列存在NULL会使优化器做索引选择的时候更复杂，更难优化。因为可为NULL的列会使索引、索引统计和值比较都更复杂，比如进行索引统计的时候，count会省略值为NULL的行。</li>
<li>NULL值没有意义，但占用物理空间。允许为NULL会带来存储空间占用的问题。</li>
</ul>
<h2 id="五、防止索引失效"><a href="#五、防止索引失效" class="headerlink" title="五、防止索引失效"></a>五、防止索引失效</h2><p>常见索引失效场景：</p>
<ul>
<li>左模糊匹配</li>
<li>对索引列进行计算、函数、类型转换</li>
<li>没有遵循最左匹配原则</li>
<li>WHERE子句中，OR前条件为索引列，OR后条件不是索引列</li>
</ul>
<h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><p>可以使用使用explain来查看查询语句的执行计划，如图：</p>
<p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/798ab1331d1d6dff026e262e788f1a28.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>执行计划中的参数：</p>
<ul>
<li>type：数据扫描类型（重点关注）</li>
<li>possible_key：表示可能用到的索引</li>
<li>key：实际用到的索引</li>
<li>key_len：索引的长度</li>
<li>rows：预估扫描的数据行数</li>
</ul>
<h2 id="type参数"><a href="#type参数" class="headerlink" title="type参数"></a>type参数</h2><blockquote>
<p>type字段描述了找到所需数据时使用的扫描方式是什么。</p>
</blockquote>
<p>常见的扫描类型（根据执行效率从低到高排序）：</p>
<ul>
<li>ALL（全表扫描）</li>
<li>index（全索引扫描）</li>
<li>range（索引范围扫描）</li>
<li>ref（非唯一索引扫描）</li>
<li>eq_ref（唯一索引扫描）</li>
<li>const（结果只有一条的主键或唯一索引扫描）</li>
</ul>
<h3 id="index和all"><a href="#index和all" class="headerlink" title="index和all"></a>index和all</h3><p>二者差不多，all采用全表扫描。而index是对索引表进行全扫描，比all好在不需要再对数据进行排序，但是开销依然很大。所以要尽量避免全表扫描和全索引扫描。</p>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>range表示采用索引范围扫描，一般再WHERE子句中使用&lt;、&gt;、in、between等关键字，只检索给定范围的行，属于范围查找。</p>
<p>从这一几倍开始，索引的作用会越来越明显，因此我们要尽量让SQL查询可以使用到range这一级别及以上的type访问方式。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref类型标识采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据可能是多条。因为使用了索引，但该索引列的值并不唯一，有重复，这样即使使用索引快速找到了第一条符合条件的数据，但仍不能停止，要进行目标值附件的小范围扫描。但是它的好处是它只需要在一个很小的范围内扫描，因为索引是有序的。</p>
<h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>eq_ref类型是使用主键或唯一索引产生的访问方式，通常使用在多表联查中。</p>
<p>比如，对两张表进行联查，关联条件是两张表的user_id相等，且user_id是唯一索引，那么使用EXPLAIN进行执行计划查看的时候，type就会显式eq_ref。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const类型表示使用了主键或唯一索引与常量值进行比较，例如<code>select name from product where id = 1</code>。</p>
<p>const和eq_ref都使用了主键或唯一索引，不过这两个类型有所区别：const是与常量进行比较，查询效率更快，而eq_ref通常用于多表联查中。</p>
<h2 id="extra参数"><a href="#extra参数" class="headerlink" title="extra参数"></a>extra参数</h2><p>extra中的几个重要参考指标：</p>
<ul>
<li><p>Using filesort（使用排序算法）</p>
<blockquote>
<p>当查询语句中包含group by操作，而且无法利用索引完成排序操作的时候，这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率很低，所以要避免这种问题的出现。</p>
</blockquote>
</li>
<li><p>Using tmporary（使用临时表）</p>
<blockquote>
<p>使用了临时表保存中间结果，MySQL在对查询结果进行排序时使用临时表，常见于排序order by和分组查询group by。效率低，要避免这种问题的出现。</p>
</blockquote>
</li>
<li><p>Using index（使用索引覆盖）</p>
<blockquote>
<p>所需的数据只需在索引即可全部获得，无须再到表中去数据，也就是使用了索引覆盖，避免了回表操作，效率不错。</p>
</blockquote>
</li>
</ul>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL-索引</div>
      <div>http://example.com/2022/11/05/MySQL-索引/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>XiangYU</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月5日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2022年11月5日</div>
        </div>
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/" title="MySQL-事务">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL-事务</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" title="MySQL-select语句的执行过程">
                        <span class="hidden-mobile">MySQL-select语句的执行过程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"oJgRmRSoMnXMSzk2FSqr3T8l-gzGzoHsz","appKey":"2rUmLcHtDRExt0YFmed3951e","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
