<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>安卓开发-事件分发机制</title>
    <link href="/2022/12/07/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/12/07/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件分发机制概述"><a href="#事件分发机制概述" class="headerlink" title="事件分发机制概述"></a>事件分发机制概述</h1><blockquote><p>了解整套的事件分发机制，有助于更好的分析各种点击滑动失效问题，更好地去扩展控件地事件功能和开发自定义控件。</p></blockquote><h2 id="事件是什么"><a href="#事件是什么" class="headerlink" title="事件是什么"></a>事件是什么</h2><blockquote><p>我们对屏幕的点击、滑动、抬起等一系列动作都是由一个个MotionEvent对象组成，也就是所谓的“事件”。</p></blockquote><p>事件主要分为三种（手指在屏幕上的所有操作都是这三种事件的组合）：</p><ul><li>ACTION_DOWN</li><li>ACTION_MOVE</li><li>ACTION_UP</li></ul><h2 id="事件的分发"><a href="#事件的分发" class="headerlink" title="事件的分发"></a>事件的分发</h2><blockquote><p>当一个事件产生后，系统需要把这一系列的事件分发给一个具体的View。</p></blockquote><p>View中事件分发相关的三个重要方法：</p><ul><li><p>boolean dispatchTouchEvent(MotionEvent event)：事件分发</p><blockquote><p>当一个MotionEvent传递给了View，那么dispatchTouchEvent()方法一定会被调用。</p><p>返回值表示是否消费当前事件：</p><ul><li>返回true：可能是在当前View或子View的dispatchTouchEvent()方法中被消费。</li><li>返回false：未消费事件，将调用父View的onTouchEvent()方法。</li></ul></blockquote></li><li><p>boolean onInterceptTouchEvent(MotionEvent ev)：事件拦截</p><blockquote><p>当一个ViewGroup在接到一个事件时，会先调用此方法判断是否需要拦截（ViewGroup特有，View没有）。</p><p>返回值表示是否拦截事件传递：</p><ul><li>返回true：表示拦截事件，那么事件不再往下分发，而是调用View本身的onTouchEvent()方法。</li><li>返回false：表示不做拦截，事件将向下分发到子View的dispatchTouchEvent()方法。</li></ul></blockquote></li><li><p>boolean onTouchEvent(MotionEvent ev)：事件消费</p><blockquote><p>真正对MotionEvent进行处理（消费），在dispatchTouchEvent中被调用。</p><p>返回值表示是否消费事件：</p><ul><li>返回true：表示事件被消费，本次事件终止。</li><li>返回false：表示事件未消费，将调用父View的onTouchEvent()方法。</li></ul></blockquote></li></ul><p>上述三个方法之间的伪代码关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-comment">//事件是否被消费</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">consume</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">//调用onInterceptTouchEvent判断是否拦截事件</span><br>    <span class="hljs-keyword">if</span> (onInterceptTouchEvent(ev))&#123;<br>        <span class="hljs-comment">//如果拦截则调用自身的onTouchEvent方法</span><br>        consume = onTouchEvent(ev);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//不拦截调用子View的dispatchTouchEvent方法</span><br>        consume = child.dispatchTouchEvent(ev);<br>    &#125;<br>    <br>    <span class="hljs-comment">//返回值表示事件是否被消费，true事件终止，false调用父View的onTouchEvent方法</span><br>    <span class="hljs-keyword">return</span> consume;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件分发的一个流程图：</p><p><img src="/2022/12/07/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/sfy9ol0ecm.jpeg" alt="img"></p><ul><li>按照ViewGroup和View的默认方法实现，会走完整个U型流程。中间不会回溯、终止。</li></ul><h2 id="事件的拦截"><a href="#事件的拦截" class="headerlink" title="事件的拦截"></a>事件的拦截</h2><blockquote><p>ViewGroup在通过dispatchTouchEvent()方法分发事件的时候，会先通过onInterceptTouchEvent()方法判断是否需要将事件拦截下来交给自己的onTouchEvent。</p></blockquote><p>一个dispatchTouchEvent()方法在接收到一个事件后有四种选择：</p><ul><li><p>消费事件：</p><ol><li>消费事件，终结事件的传递。（return true）</li></ol></li><li><p>不消费事件：</p><ol start="2"><li><p>拦截事件，交给自己的onTouchEvent()方法处理。</p></li><li><p>传递事件，给子View处理。</p></li><li><p>回溯事件，给父View的onTouchEvent()方法处理。（return false）</p></li></ol></li></ul><p>一个onTouchEvent()方法在接收到一个事件后有两种选择：</p><ol><li>消费事件，终结事件的传递。（return true）</li><li>不消费事件，向上传递给父View的onTouchEvent()方法处理。（return false）</li></ol><p>拦截器是ViewGroup的所特有的，View没有拦截器。也就是说在View的dispatchTouchEvent()中方法中默认是将事件交给自己的onTouchEvent()方法处理。拦截器不能消费事件，只起到一个分流的作用。</p><h2 id="一些需要注意的点"><a href="#一些需要注意的点" class="headerlink" title="一些需要注意的点"></a>一些需要注意的点</h2><ul><li><p>子View可以干预父View的事件分发</p><blockquote><p>子View可以通过requestDisallowInterceptTouchEvent()方法干预父View的事件分发过程（ACTION_ DOWN事件除外）。而这就是我们处理滑动冲突的关键方法。</p></blockquote></li><li><p>onTouch方法的优先级</p><blockquote><p>如果我们对View设置了onTouchListener，那么OnTouchListener()方法中的onTouch()方法会被回调，再根据onTouch()的返回值决定是否调用onTouchEvent()方法（true调用），而onClick事件是在onTouchEvent中被调用的。</p><p>所以三者的优先级：onTouch -&gt; onTouchEvent -&gt; onClick</p></blockquote></li><li><p>onTouchEvent()方法默认消费事件</p><blockquote><p>View的onTouchEvent()方法默认会消费掉事件（返回true）。除非它是不可点击的，也就是clickable和longClickable都为false。</p></blockquote></li></ul><h1 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Class Activity：<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;<br>            onUserInteraction();<br>        &#125;<br>        <span class="hljs-comment">// 事件分发并返回结果</span><br>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<br>            <span class="hljs-comment">// 事件被消费</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 没有View可以处理，调用Activity onTouchEvent方法</span><br>        <span class="hljs-keyword">return</span> onTouchEvent(ev);<br>&#125;<br></code></pre></td></tr></table></figure><p>getWindow().superDispatchTouchEvent()，调用的是抽象的Window类，而该抽象类只有一个实现，也就是PhoneWindow：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneWindow</span><br>    <span class="hljs-keyword">private</span> DecorView mDecor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>        <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(event);<br>    &#125;<br></code></pre></td></tr></table></figure><p>DecorView是Window的顶级View。我们通过setContentView设置的View就是它的子View。</p><p>至此，事件就已经被传递到我们的顶级View中了（一般来说也就是ViewGroup）。</p><h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewGroup</span>:<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>        ...<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> ev.getAction();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">actionMasked</span> <span class="hljs-operator">=</span> action &amp; MotionEvent.ACTION_MASK;<br>        <br>        <span class="hljs-comment">// 1. 初始化操作</span><br>        <span class="hljs-comment">// 如果事件是ACTION_DOWN（表示开启了一个新的touch手势）</span><br>        <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;<br>            cancelAndClearTouchTargets(ev);<br>            <span class="hljs-comment">// 清除FLAG_DISALLOW_INTERCEPT标志位，并且将mFirstTouchTarget置为null</span><br>            resetTouchState();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 用以标记是否事件是否被拦截</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<br>        <br>        <span class="hljs-comment">// 2. 判断是否事件由ViewGroup本身处理</span><br>        <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 2.1 如果是ACTION_DOWN（ACTION_DOWN事件不会被拦截）</span><br>            <span class="hljs-comment">//或mFirstTouchTarget != null（事件由子View处理）</span><br>            <br>            <span class="hljs-comment">// FLAG_DISALLOW_INTERCEPT由子View的方法进行设置的</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">disallowIntercept</span> <span class="hljs-operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 判断事件允许被拦截</span><br>            <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>                <span class="hljs-comment">// 2.1.1 若事件允许被拦截，则将事件交给拦截器拦截判断是否需要被拦截</span><br>                intercepted = onInterceptTouchEvent(ev);<br>                ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 2.1.2 若事件不允许被拦截，则被拦截标记为false</span><br>                intercepted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 2.2 若事件不为ACTION_DOWN且为ViewGroup本身处理</span><br>            <br>            <span class="hljs-comment">// 显然该事件已经被拦截不会往下传递，被拦截标志为true</span><br>            intercepted = <span class="hljs-literal">true</span>;<br>        &#125;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>当ViewGroup不拦截事件，也就是说intercepted标志为false，那么事件将下发给子View进行处理，GroupView中事件分发的相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewGroup</span>:<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>        <br>        ...<br>        <br>        <span class="hljs-keyword">final</span> View[] children = mChildren;<br>        <br>        <span class="hljs-comment">//对子View进行遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childIndex</span> <span class="hljs-operator">=</span> getAndVerifyPreorderedIndex(<br>                    childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getAndVerifyPreorderedView(<br>                    preorderedList, children, childIndex);<br>            <br>            ...<br><br>            <span class="hljs-comment">// 判断条件：1、View可见并且没有播放动画；2、点击事件的坐标落在View的范围内</span><br>            <span class="hljs-comment">// 如果上述两个条件有一项不满足，则跳过该子View，遍历下一个</span><br>            <span class="hljs-keyword">if</span> (!canViewReceivePointerEvents(child)<br>                    || !isTransformedTouchPointInView(x, y, child, <span class="hljs-literal">null</span>)) &#123;<br>                ev.setTargetAccessibilityFocus(<span class="hljs-literal">false</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            newTouchTarget = getTouchTarget(child);<br>            <span class="hljs-comment">//如果有子View处理了事件（即newTouchTarget不为null），则停止遍历</span><br>            <span class="hljs-keyword">if</span> (newTouchTarget != <span class="hljs-literal">null</span>) &#123;<br>                newTouchTarget.pointerIdBits |= idBitsToAssign;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            resetCancelNextUpFlag(child);<br>            <br>            <span class="hljs-comment">// dispatchTransformedTouchEvent()方法会根据child进行递归调用</span><br>            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-literal">false</span>, child, idBitsToAssign)) &#123;<br>                <span class="hljs-comment">// dispatchTransformedTouchEvent内部的逻辑:</span><br>                <span class="hljs-comment">//     if (child == null) &#123;</span><br>            <span class="hljs-comment">//   handled = super.dispatchTouchEvent(event);</span><br>        <span class="hljs-comment">//   &#125; else &#123;</span><br>            <span class="hljs-comment">//   handled = child.dispatchTouchEvent(event);</span><br>        <span class="hljs-comment">//   &#125;</span><br>                <br>                mLastTouchDownTime = ev.getDownTime();<br>                <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; childrenCount; j++) &#123;<br>                        <span class="hljs-keyword">if</span> (children[childIndex] == mChildren[j]) &#123;<br>                            mLastTouchDownIndex = j;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mLastTouchDownIndex = childIndex;<br>                &#125;<br>                mLastTouchDownX = ev.getX();<br>                mLastTouchDownY = ev.getY();<br>                <br>                <span class="hljs-comment">//当child处理了点击事件，那么mFirstTouchTarget会在addTouchTarget被赋值</span><br>                newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>                alreadyDispatchedToNewTouchTarget = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//子View处理了事件，然后就跳出了for循环</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>        ...<br>        <br>        <span class="hljs-comment">// 若遍历完子View后都没有子View处理事件，此时mFirstTouchTarget为null</span><br>        <span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 进行递归调用，由super.dispatchTouchEvent(event)处理</span><br>            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-literal">null</span>,<br>                    TouchTarget.ALL_POINTER_IDS);<br>        &#125;    <br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>:<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>        <br>        ...<br>        <br><span class="hljs-comment">// 如果窗口没有被遮盖</span><br>        <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;<br>            <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;<br>                result = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前监听事件</span><br>            <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>            <br>            <span class="hljs-comment">// 判断是否设置了OnTouchListener</span><br>            <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-literal">null</span><br>                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED<br>                <span class="hljs-comment">// 调用OnTouchListener的onTouch()方法</span><br>                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-built_in">this</span>, event)) &#123;<br>                result = <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">// result为true表示没有设置OnTouchListener或者说设置了但是onTouch()方法返回的是true</span><br>            <span class="hljs-comment">// 则onTouchEvent()方法不会被调用</span><br>            <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>                result = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        ...<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>在调用onTouchEvent()之前会先执行onTouch()方法，并根据其执行结果决定是否执行onTouchEvent()。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>:<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>        <br>        ...<br>        <br>        <span class="hljs-comment">//1.如果View是设置成不可用的（DISABLED）仍然会消费点击事件</span><br>        <span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;<br>            ...<br>        &#125;<br>        ...<br>        <span class="hljs-comment">//2.CLICKABLE和LONG_CLICKABLE只要有一个为true就消费这个事件</span><br>        <span class="hljs-keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||<br>                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||<br>                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;<br>            <span class="hljs-keyword">switch</span> (action) &#123;<br>                <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>                    ...<br>                    <span class="hljs-comment">//3.在ACTION_UP方法发生时会触发performClick()方法</span><br>                    performClick();<br>                    ...<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ...<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>View的onTouchEvent()默认会消费掉事件，除非它是不可点击的。</li><li>在View的ACTION_UP中有perfromClick()方法，这个方法会回调我们为View设置的OnclickListener中的onClick()方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-其余的一些技巧</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%85%B6%E4%BD%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%85%B6%E4%BD%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p>通知（Notification） 是Android系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些提示信息，而给应用程序又没有在前台运行时，就可以借助通知来实现。发出通知后，状态栏会显示一个图标，下拉通知栏会显示通知的详细内容，点击通知还会跳转到设定的活动。</p><h2 id="通知的基本用法"><a href="#通知的基本用法" class="headerlink" title="通知的基本用法"></a>通知的基本用法</h2><p>通知一般在广播接收器和服务中创建，因为一般只有在程序进入后台后才需要使用通知（当然活动中也可以创建通知）。</p><h3 id="1-获取NotificationManager实例"><a href="#1-获取NotificationManager实例" class="headerlink" title="1. 获取NotificationManager实例"></a>1. 获取NotificationManager实例</h3><blockquote><p>通过Context的getSystemService()方法，通过传入指定字符串参数返回指定的系统服务管理器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NotificationManager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);<br></code></pre></td></tr></table></figure><h3 id="2-使用Builder构造器创建Notification对象"><a href="#2-使用Builder构造器创建Notification对象" class="headerlink" title="2. 使用Builder构造器创建Notification对象"></a>2. 使用Builder构造器创建Notification对象</h3><blockquote><p>由于Android系统升级的改动，通知部分的API不稳定。可以使用support库中的NotificaionCompat类来构建Notification对象，保证程序在不同Android版本都能正常工作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Notification</span> <span class="hljs-variable">notification</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationCompat</span>.Builder(context)<br>    <span class="hljs-comment">// 使用链式方法配置所构建的通知</span><br>    .setContentTitle(<span class="hljs-string">&quot;This is content title&quot;</span>)<br>    ...<br>    <span class="hljs-comment">// build()方法正式构建通知对象</span><br>    .build();<br></code></pre></td></tr></table></figure><p>一些配置通知的链式方法：</p><ul><li>setContentTitle()：通知标题</li><li>setContentText()：通知内容</li><li>setWhen()：通知被创建的事件（单位毫秒）</li><li>setSmallIron()：通知栏显示的小图标</li><li>setLargeIcon()：下拉通知栏显示的大图标</li></ul><h3 id="3-为通知绑定PendingIntent（让通知响应点击事件）"><a href="#3-为通知绑定PendingIntent（让通知响应点击事件）" class="headerlink" title="3. 为通知绑定PendingIntent（让通知响应点击事件）"></a>3. 为通知绑定PendingIntent（让通知响应点击事件）</h3><blockquote><p>通知一般是可以点击的，点击过后会跳转到app的界面，并且通知在点击后会消失。PendingIntent类似于Intent，可以理解为一个延迟执行的Intent。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造PendingIntent</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(thsi, NotificationActivity.class);<br><span class="hljs-type">PendingIntent</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingIntent</span>.getActivity(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>, intent, <span class="hljs-number">0</span>);<br><br><span class="hljs-type">Notification</span> <span class="hljs-variable">notification</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationCompat</span>.Builder(context)<br>    ...<br>    <span class="hljs-comment">// 为通知绑定PendingIntent</span><br>    .setContentIntent(pi)<br>    .build();<br></code></pre></td></tr></table></figure><p>在点击通知后，通知会消失，有两种方法可以实现：</p><ul><li><p>方法一：在构造Notification的时候设置点击后自动取消通知</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Notification</span> <span class="hljs-variable">notification</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationCompat</span>.Builder(context)<br>    ...<br>    .setAutoCancel()<br>    .build();<br></code></pre></td></tr></table></figure></li><li><p>方法二：点击通知后会跳转到Activity中，在Activity的onCreate()方法中通过NotificationaManager根据通知的id来关闭通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        ...<br>        <span class="hljs-type">NotificationManager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> (NorificationManager) getSystemService(NOTIFICATION_SERVICE);<br>        manager.cancel(<span class="hljs-number">1</span>);<span class="hljs-comment">//cancel方法传入参数的是使用NOtificationManager的notify发送通知时为通知指定的唯一id</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-通过获取的NotificationManager实例发送通知"><a href="#4-通过获取的NotificationManager实例发送通知" class="headerlink" title="4. 通过获取的NotificationManager实例发送通知"></a>4. 通过获取的NotificationManager实例发送通知</h3><blockquote><p>直接调用NorificationManager的notify()方法就可以让通知显示出来。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">manager.notify(<span class="hljs-number">1</span>, notification);<br></code></pre></td></tr></table></figure><p>两个参数：</p><ul><li>参数一：指定通知的唯一id</li><li>参数二：Norification对象</li></ul><h2 id="通知的进阶技巧"><a href="#通知的进阶技巧" class="headerlink" title="通知的进阶技巧"></a>通知的进阶技巧</h2><blockquote><p>NotificationCompat.Builder中提供了很多API，可以对通知进行更多的设置。</p></blockquote><h3 id="通知效果"><a href="#通知效果" class="headerlink" title="通知效果"></a>通知效果</h3><blockquote><p>一般来说通知都会有提示音、震动和LED灯闪烁的通知效果，下面这些API可供我们设置。</p></blockquote><ul><li><p>通知响铃</p><blockquote><p>setSound(Uri.from(new File(“&#x2F;system&#x2F;media&#x2F;audio&#x2F;ringtons&#x2F;Luna.ogg”)))</p><p>需要传入一个Uri对象来指定音频文件的URI。</p><p>手机的&#x2F;system&#x2F;media&#x2F;audio&#x2F;ringtons目录下有很多音频文件供选择。</p></blockquote></li><li><p>通知震动</p><blockquote><p>setVibrate(new long[] {1, 1000, 1000, 1000 })</p><p>传入的参数是一个long型数组，用以设置手机静止和震动的时长，以毫秒为单位。</p><p>下标为偶数表示手机静止时长，计数表示手机震动时长。</p></blockquote></li><li><p>通知LED消息灯闪烁</p><blockquote><p>setLights(Color.GREEN, 1000, 1000)</p><p>第一个参数是LED灯的颜色</p><p>第二&#x2F;三个参数是LED灯亮&#x2F;熄灭起的时长，以毫秒为单位</p></blockquote></li></ul><p>上面这些通知的设置很麻烦，但是也可以通过 <code>.setDefaults(Notification.DEFAULT_ALL)</code>来使用通知的默认效果，它根据手机环境来决定播放的铃声以及如何震动。</p><h3 id="构建富文本通知"><a href="#构建富文本通知" class="headerlink" title="构建富文本通知"></a>构建富文本通知</h3><blockquote><p>setStyle()方法让我们可以构建出富文本的通知内容。也就是说通知中不光可以有文字和图标，还可以包含更多东西，如长文字、图片等。</p></blockquote><p>setStyle()方法接收一个NotificationCompat.Style参数：</p><ul><li><p>长文本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Notification</span> <span class="hljs-variable">notification</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationCompat</span>.Builder(context)<br>    ...<br>    .setStyle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationCompat</span>.BigTextStyle(<span class="hljs-string">&quot;长文本内容&quot;</span>))<br>    .build();<br></code></pre></td></tr></table></figure></li><li><p>图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Notification</span> <span class="hljs-variable">notification</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationCompat</span>.Builder(context)<br>    ...<br>    .setStyle(<br>    <span class="hljs-comment">// 先创建一个NotificationCompat.BigPictureStyle对象</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationCompat</span>.BigPictureStyle()<br>        <span class="hljs-comment">// 调用它的bigPicture()方法将图片传入</span><br>    .bigPicture(<br>                <span class="hljs-comment">// 使用BitmapFactory的decodeResource()方法解析图片为Bitmap对象，再传入bigPicture()方法中</span><br>                BitmapFactory.decodeResource(getResources(), R.drawable.big_image)))<br>    .build();<br></code></pre></td></tr></table></figure></li></ul><h3 id="设置通知优先级"><a href="#设置通知优先级" class="headerlink" title="设置通知优先级"></a>设置通知优先级</h3><blockquote><p>setPriority()方法可以设置通知的重要程度。</p></blockquote><p>有五个常量值可选：</p><ul><li>PRIORITY_MAX：这类消息会弹出，让用户立马看到，甚至需要用户做出响应操作。</li><li>PRIORITY_HIGH：这类消息可能会将通知放大，或改变其显示的顺序，让其排在靠前的位置。</li><li>PRIORITY_DEFAULT：默认设置，与不设置效果一致。</li><li>PRIORITY_LOW：系统可能会折叠这类通知，或改变其显示的顺序，让其排在靠后的位置。</li><li>PRIORITY_MIN：系统可能只会在特定的场景才显示这类消息。</li></ul><h1 id="全局获取Context的技巧"><a href="#全局获取Context的技巧" class="headerlink" title="全局获取Context的技巧"></a>全局获取Context的技巧</h1><h2 id="全局获取Context的必要性"><a href="#全局获取Context的必要性" class="headerlink" title="全局获取Context的必要性"></a>全局获取Context的必要性</h2><p>在很多地方我们都会用到Context，例如弹出Toast通知、启动活动、发送广播、操作数据库、使用通知等等。</p><p>因为我们很多操作都是在活动中进行，而活动本身就是一个Context，所以获取Context很简单。但是当程序的架构开始复杂起来了，很多逻辑代码都将脱离Activity类，但是有很多操作又需要Context，这个时候获取Context就是一个问题了。</p><h2 id="一个不太优雅的全局Context获取的方案"><a href="#一个不太优雅的全局Context获取的方案" class="headerlink" title="一个不太优雅的全局Context获取的方案"></a>一个不太优雅的全局Context获取的方案</h2><p>例如我们有一个HttpUtil工具类，在它的某个方法中，若检测到无网络连接，就不能执行后面的代码。若我们想要在检测到无网络连接的时候，弹出一个Toast提示，这个时候我们就需要Context了。</p><p>一种不太优雅的解决方案：在这个方法中添加一个Context参数。这种解决方法有点推卸责任的意味，将Context获取的任务转移给了方法的调用者，方法只管接收传入的Context参数，而Context如何获取则由调用者自己解决。</p><h2 id="自定义Application类以实现全局Context获取"><a href="#自定义Application类以实现全局Context获取" class="headerlink" title="自定义Application类以实现全局Context获取"></a>自定义Application类以实现全局Context获取</h2><blockquote><p>Android提供了一个Application类，每当应用程序启动的时候，系统就会将这个类进行初始化。而我们可以定制一个自己的Application类替代它，以便于管理程序内一些全局状态信息，比如所全局Context。</p></blockquote><h3 id="自定义Application"><a href="#自定义Application" class="headerlink" title="自定义Application"></a>自定义Application</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Context context;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        context = getApplicationContext();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Context <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> context;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改注册文件"><a href="#修改注册文件" class="headerlink" title="修改注册文件"></a>修改注册文件</h3><p>由于我们要用自己的MyApplication类替换系统自带的Application类，所以还需要在AndroidManifest.xml文件中修改&lt;application&gt;标签的android:name属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.xy.test.MyApplication&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span> &gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="解决于LitePal配置的冲突"><a href="#解决于LitePal配置的冲突" class="headerlink" title="解决于LitePal配置的冲突"></a>解决于LitePal配置的冲突</h3><p>之前在配置LitePal的时候也修改了AndroidManifest.xml文件的&lt;application&gt;标签的android:name属性。因为LitePal也是通过将Application换成自定义的Application，使得LitePal可以在内部自动获取到Context。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;org.litepal.LitPalApplication&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">...</span> &gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><p>冲突的解决：</p><p>在我们自定义的MyApplication中调用LitePal的initialize()方法将context传给LitePal，效果和在AndroidManifest.xml中配置LitePalApplication一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Context context;<br>        <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        context = getApplicationContext();<br>        <span class="hljs-comment">// 初始化LitePal，传递context给LitePal</span><br>        LitePal.initialize(context);<br>    &#125;<br>    <br>    ...<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h1><p>我们可以借助Intent对象来启动活动、发送广播、启动服务等。我们在执行上述操作的时候，还可以在Intent中添加一些数据，以达到传值的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发送数据</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, AnotherActivity.class);<br>intent.putExtra(<span class="hljs-string">&quot;string_data&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>intent.putExtra(<span class="hljs-string">&quot;int_data&quot;</span>, <span class="hljs-number">100</span>);<br>startActivity(intent);<br><br><span class="hljs-comment">// 接收数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">stringData</span> <span class="hljs-operator">=</span> getIntent().getStringExtra(<span class="hljs-string">&quot;string_data&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">intData</span> <span class="hljs-operator">=</span> getIntent().getIntExtra(<span class="hljs-string">&quot;int_data&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用putExtra()方法传递的数据类型有限，当我们想要传递一些自定义对象的时候就无能为力了。</p><h2 id="Serializable方式"><a href="#Serializable方式" class="headerlink" title="Serializable方式"></a>Serializable方式</h2><blockquote><p>Serializable方式是将对象序列化后进行传输。</p></blockquote><ol><li><p>首先需要让需要被储传输的对象类实现Serializable接口。（这个接口只是一个标记接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    ...<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>然后使用intent的putExtra ()方法将对象传入intent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.setName(<span class="hljs-string">&quot;XY&quot;</span>);<br>person.setAge(<span class="hljs-number">20</span>);<br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, AnotherActivity.class);<br>intent.putExtra(<span class="hljs-string">&quot;person_data&quot;</span>, person);<br>startActivity(intent);<br></code></pre></td></tr></table></figure></li><li><p>最后使用intent的getSerializableExtra()方法将对象取出来，并向下转型成传输的对象类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) getIntent.getSerializableExtra(<span class="hljs-string">&quot;person_data&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h2 id="Parcelable方式（推荐）"><a href="#Parcelable方式（推荐）" class="headerlink" title="Parcelable方式（推荐）"></a>Parcelable方式（推荐）</h2><blockquote><p>Parcelable方式是将一个完整的对象进行分解，分解后的每个部分都是Intent所支持的数据类型，以此来实现传递对象的功能。</p></blockquote><ol><li><p>让需要被传输的对象实现Parcelable接口，并重写describeContens()方法和writeToParcel()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span> &#123;<br>    ...<br>        <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">describeContents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 该方法用于构造Parcel，将被传输的对象解构并写入Parcel中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToParcel</span><span class="hljs-params">(Parcel dest, <span class="hljs-type">int</span> flags)</span> &#123;<br>        dest.writeString(name);<br>        dest.writeInt(age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在被传输对象的内部创建一个名为CREATOR的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span> &#123;<br>    ...<br>        <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parcelable</span>.Creator&lt;Person&gt;() &#123;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 该方法用于解析Parcel，从中获取对象数据来构造出被传输的对象</span><br>        <span class="hljs-keyword">public</span> person <span class="hljs-title function_">createFromParcel</span><span class="hljs-params">(Parcel source)</span> &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>            person.name = source.readString();<br>            person.age = source.readInt();<br>            <span class="hljs-keyword">return</span> person;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Person[] newArray(<span class="hljs-type">int</span> size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[size];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Parcelable方式传递对象的方式同Serializable方式一样</p></li><li><p>取对象需要使用getParcelableExtra()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) getIntent.getParcelableExtra(<span class="hljs-string">&quot;person_data&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h1 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h1><blockquote><p>Android中的定时任务有两种实现方式：一是使用Java API中提供的Timer类，一种是使用Android的Alarm机制。</p><p>Android息屏后的休眠机制会让CPU进入睡眠状态，可能导致Timer中的定时任务失效，而Alarm则具有唤醒CPU的功能，它可以保证大多数的定时任务的执行。</p></blockquote><h2 id="Alarm机制"><a href="#Alarm机制" class="headerlink" title="Alarm机制"></a>Alarm机制</h2><h3 id="AlarmManager获取"><a href="#AlarmManager获取" class="headerlink" title="AlarmManager获取"></a>AlarmManager获取</h3><p>Alarm机制借助于AlarmManager类来实现。该类同Notifucationmanager类似，都是通过Context的getSystemService()方法获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AlarmManager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> (AlarmManager) getSystemService(Context.ALARM_SERVICE);<br></code></pre></td></tr></table></figure><h3 id="实现定时执行任务"><a href="#实现定时执行任务" class="headerlink" title="实现定时执行任务"></a>实现定时执行任务</h3><p>通过调用AlarmManager的set()方法就可以设置一个定时任务了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">triggerAtTime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime() + <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>;<br>manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);<br></code></pre></td></tr></table></figure><p>关于set方法的三个参数：</p><ul><li><p>参数一：指定AlarmManager的工作类型，共有4种</p><ul><li>ELAPSED_REALTIME：定时任务的触发时间从系统开机时间算起，不会唤醒CPU</li><li>ELAPSED_READTIME_WAKEUP：定时任务的触发时间从系统开机时间算起，会唤醒CPU</li><li>RTC：定时任务的触发时间从格林威治时间（1970.01.01.00:00）算起，不会唤醒CPU</li><li>RTC_WAKEUP：定时任务的触发时间从格林威治时间（1970.01.01.00:00）算起，不会唤醒CPU</li></ul></li><li><p>参数二：定时任务的触发事件，以毫秒为单位</p></li><li><p>参数三：PendingIntent</p><blockquote><p>这里我们一般传入一个通过getService()或getBroadcast()方法获得的PendingIntent。这样在定时任务被触发时，服务的onStartCommand()方法或广播接收器的onReceive()方法就可以得到执行。</p></blockquote></li></ul><h3 id="实现定时重复执行任务"><a href="#实现定时重复执行任务" class="headerlink" title="实现定时重复执行任务"></a>实现定时重复执行任务</h3><blockquote><p>通过在创建一个服务，在服务执行任务，并任务完成后再设置一个定时任务执行这个服务，形成永久循环，这样服务就定时重复执行。</p></blockquote><h4 id="1-创建定时重复任务服务"><a href="#1-创建定时重复任务服务" class="headerlink" title="1. 创建定时重复任务服务"></a>1. 创建定时重复任务服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongRunningService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBinde</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">onStartCommand</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> startId)</span> &#123;<br>        <br>        <span class="hljs-comment">// 执行定时任务</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// TODO，需要定时执行的任务</span><br>            &#125;<br>        &#125;).start();<br>        <br>        <span class="hljs-comment">// 设置定时任务</span><br>        <span class="hljs-type">AlarmManager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> (AlarmManager) getSystemService(ALARM_SERVICE);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">triggerAtTime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime() + <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, LongRunningService.class);<span class="hljs-comment">// 重点，将Intent的目标设置为服务自身，从而定时循环进入该服务</span><br>manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onStartCommand(intent, flags, startId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-定时任务的启动"><a href="#2-定时任务的启动" class="headerlink" title="2. 定时任务的启动"></a>2. 定时任务的启动</h4><blockquote><p>和启动一个普通服务一样</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(context, LongRunningService.class);<br>context.startService(intent);<br></code></pre></td></tr></table></figure><h2 id="确保Alarm任务的准时执行"><a href="#确保Alarm任务的准时执行" class="headerlink" title="确保Alarm任务的准时执行"></a>确保Alarm任务的准时执行</h2><h3 id="Alarm任务合并"><a href="#Alarm任务合并" class="headerlink" title="Alarm任务合并"></a>Alarm任务合并</h3><p>由于系统在耗电性方面的优化，系统会自动检测目前所有的Alarm任务，然后会将触发时间相近的几个任务放在一起执行，这样就可以大幅度减少CPU被唤醒的次数。但是这也就导致设定的Alarm任务的执行时间不是那么准确。</p><p>如果要求Alarm任务的执行时间必须准确无误，可以使用AlarmManager提供的setExact()方法来替代set()方法。</p><h3 id="Doze模式"><a href="#Doze模式" class="headerlink" title="Doze模式"></a>Doze模式</h3><p>当设备未接入电源，在屏幕关闭一段时间后，就会进入Doze模式。在该模式下，系统会对CPU、网络、Alarm等活动进行限制，从而延长续航。设备进入Doze模式后，会间歇性的退出Doze模式去完成一些同步，Alarm工作，随着设备进入Doze模式的时间越来越长，间歇退出Doze模式的时间间隔也越来越长，以此来减少CPU被唤醒的频率。</p><p>Doze模式下的功能限制：</p><ul><li>网络访问禁止</li><li>系统忽略唤醒CPU或屏幕操作</li><li>系统不再执行WIFI扫描</li><li>系统不再执行同步服务</li><li>Alarm任务将会在下次退出Doze模式的时候执行</li></ul><p>因为Doze模式的原因Alarm任务的执行时间也会变得不准。可以使用AlarmManager的setAndAllowWhileIdle()或setExactAndAllowWhileIdle()方法来设置定时任务。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-四大组件-Service</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Service/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Service/</url>
    
    <content type="html"><![CDATA[<p>服务（Service）是Android中实现程序后台运行的解决方案 ，它非常适合去执行哪些不需要和用户交互而且还要求长期运行的任务。</p><p>服务的运行不依赖于任何用户界面，但是服务并不是运行在一个独立的进程中，而是依赖于创建服务时所在的应用程序的进程。也就是说当程序被切到后台，服务任能保持运行，当程序被杀掉，依赖于它的服务也会停止运行。</p><p>服务运行在后台，但是服务并不会自动开启线程，服务所有的代码都是默认运行在主线程中的。也就是说我们需要在服务的内部手动创建子线程，并在子线程中执行具体的任务，否则主线程会被阻塞。</p><h1 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h1><p>当我们需要执行一些耗时操作时，例如发送一条网络请求，因为网速等其他原因，服务器不一定回立即响应请求，若这些不将这些操作放到子线程中运行，就会导致主线程被阻塞，从而影响用户正常使用软件。</p><h2 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h2><p>方法一：新建类继承自Thread，重写Thread的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行子线程操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>().start();<br></code></pre></td></tr></table></figure><p>方法二：新建类实现Runnable接口，实现接口的run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行子线程操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>()).start();<br></code></pre></td></tr></table></figure><p>方法三：匿名Runnable接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行子线程操作</span><br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><h2 id="异步消息处理机制"><a href="#异步消息处理机制" class="headerlink" title="异步消息处理机制"></a>异步消息处理机制</h2><h3 id="异步消息处理机制使用"><a href="#异步消息处理机制使用" class="headerlink" title="异步消息处理机制使用"></a>异步消息处理机制使用</h3><h4 id="子线程中UI更新的问题"><a href="#子线程中UI更新的问题" class="headerlink" title="子线程中UI更新的问题"></a>子线程中UI更新的问题</h4><p>Android的UI时线程不安全的，也就是说如果想要更新应用程序中的UI元素，必须在主线程中进行，否则回出现异常。但是很多时候我们必须在子线程中执行一些耗时的操作，然后根据子线程中操作的执行结果来更新相应的UI控件。Android提供了一套异步消息处理机制，完美的解决了在子线程中进行UI操作的问题。</p><h4 id="使用异步消息处理机制让子线程更新UI"><a href="#使用异步消息处理机制让子线程更新UI" class="headerlink" title="使用异步消息处理机制让子线程更新UI"></a>使用异步消息处理机制让子线程更新UI</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UPDATE_TEXT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> UPDATE_TEXT:<br>                    <span class="hljs-comment">// 执行UI操作</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (v.getId()) &#123;<br>            <span class="hljs-keyword">case</span> R.id.change_text:<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>                        message.what = UPDATE_TEXT;<br>                        handler.sendMessage(message);<br>                    &#125;<br>                &#125;).start();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子线程中构建了一个message对象，指定对象中的what字段为UPDATE_TEXT，然后通过Handler的sendMessage()方法将Message发送出去。</p><p>在主线程中Handler收到这条Message后，在handleMessage ()方法中对Message进行处理。handleMessage() 方法根据传入的Message对象中的what字段执行不同的UI操作。</p><h3 id="异步消息处理机制解析"><a href="#异步消息处理机制解析" class="headerlink" title="异步消息处理机制解析"></a>异步消息处理机制解析</h3><h4 id="异步消息处理的组成"><a href="#异步消息处理的组成" class="headerlink" title="异步消息处理的组成"></a>异步消息处理的组成</h4><p>Android中的异步消息处理主要由四个部分组成：Message、Handler、MessageQueue和Looper</p><ul><li><p>Message</p><blockquote><p>Message是在线程之间传递的消息，它在内部可以携带少量信息，用于在不同线程之间交换数据。前面用到了what字段用于让handle判断Message类型，还可以使用arg1和arg2字段携带整形数据，使用obj字段携带一个Object对象。</p></blockquote></li><li><p>Handler</p><blockquote><p>Handler主要用于发送和处理消息（Message）。发送消息使用Handler的sendMessage方法，而发出的消息最终会传递到Handler的handleMessage()方法中。</p></blockquote></li><li><p>MessageQueue</p><blockquote><p>MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。</p></blockquote></li><li><p>Looper</p><blockquote><p>Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无线循环当中，每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handlerMessage()方法中。每个线程也只会有一个Looper对象。</p></blockquote></li></ul><h4 id="异步消息处理的整个流程"><a href="#异步消息处理的整个流程" class="headerlink" title="异步消息处理的整个流程"></a>异步消息处理的整个流程</h4><ol><li><p>首先在主线程中创建一个Handler对象，并重写handleMessage()方法。</p></li><li><p>当子线程中需要进行UI操作时，就创建一个Message对象，并通过handler将这条消息发出去。</p></li><li><p>之后这条消息会被添加到MessageQueue的队列中等待被处理。</p></li><li><p>而Looper则会一直尝试从MessageQueue中取出待处理消息，最后分发回Handler的handleMessage()方法中。</p></li><li><p>由于Handler是在主线程中创建的，所以此时handleMessage()方法中的代码也是在主线程中进行，因此可以在此方法中进行UI操作。</p></li></ol><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Service/a6833a0373d62769b49dbc8ce2556fee_682x497.png" alt="img"></p><p>一条Message经过该流程，从子线程进入主线程，从不可更新UI变成可更新UI，整个异步消息处理的核心思想就是如此。</p><p>前面使用的runOnUiThread()方法就是一个异步消息处理机制的接口封装。</p><h3 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h3><blockquote><p>AsyncTask是Android提供的一个工具来方便我们在子线程中对UI进行操作。AsyncTask背后的实现原理也是基于异步消息处理机制，不过Android帮我们做了很好的封装。</p></blockquote><h4 id="1、子类继承AsyncTask"><a href="#1、子类继承AsyncTask" class="headerlink" title="1、子类继承AsyncTask"></a>1、子类继承AsyncTask</h4><p>AsyncTask是一个抽象类，如果我们要使用它，需要创建一个子类继承它。在继承时我们可以指定3个泛型参数：</p><ul><li>Params：执行任务时，需要传入参数，params指定泛型作为传入的参数类型</li><li>Progress：后台执行任务时，需要显示进度，progress指定泛型作为进度单位</li><li>Result：当任务执行完毕，需要返回一个执行结果，Result指定泛型作为返回值类型</li></ul><p>一个简单的自定义AsyncTask：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个泛型参数Void，表示不需要传入参数给后台任务</span><br><span class="hljs-comment">//第二个泛型参数Integer，表示使用整形数据作为进度显示单位</span><br><span class="hljs-comment">//第三个泛型参数Boolean，表示使用布尔型数据来反馈执行结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AsyncTask</span>&lt;Void, Integer, Boolean&gt; &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、子类重写AsyncTask方法"><a href="#2、子类重写AsyncTask方法" class="headerlink" title="2、子类重写AsyncTask方法"></a>2、子类重写AsyncTask方法</h4><p>常见的需要重写的方法：</p><ul><li><p>onPreExecute()：主线程执行。初始化界面。</p><blockquote><p>这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话。</p></blockquote></li><li><p>doInBackgroud(Params…)：子线程执行。完成耗时任务。</p><blockquote><p>这个方法中的所有代码都会在子线程中运行，我们应该在这里处理所有耗时的任务。任务一旦完成就可以通过return语句来将任务的执行结果返回。在该方法中不能更新UI元素，若需要更新UI元素，比如反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。</p></blockquote></li><li><p>onProgressUpdate(Progress…)：主线程执行。配合子线程，根据进度更新UI。</p><blockquote><p>当在后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate(Progress…)方法就会被调用。该方法中的参数就是后台任务中传递过来的。在这个方法中就可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p></blockquote></li><li><p>onPostExecute(Result)：主线程执行。根据结果更新UI，并执行一些收尾工作。</p><blockquote><p>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行结果，以及关闭掉进度条对话框等。</p></blockquote></li></ul><h4 id="3、使用AsyncTask"><a href="#3、使用AsyncTask" class="headerlink" title="3、使用AsyncTask"></a>3、使用AsyncTask</h4><p>当完成了上面自定义的AsyncTask的编写后，只需要执行如下代码即可启动这个任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadTask</span>().execute();<br></code></pre></td></tr></table></figure><h1 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h1><h2 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h2><p>使用Android Studio的右键快捷new一个Service，他会自动新建一个我们自己命名的Service类继承自Service，并在Manifest.xml中自动注册这个自定义的Service。在new的时候会有两个选项可供选择：Exported表示是否允许其他程序访问该服务，Enabled便是是否开启该服务。</p><p>一个Service有如下几个需要关注的方法：</p><ul><li><p>IBinder onBind(Intent intent)</p><blockquote><p>用于和活动之间的通信</p></blockquote></li><li><p>onCreate()</p><blockquote><p>在服务创建时调用</p></blockquote></li><li><p>int onStartCommand(Intent intent, int flags, int startId)</p><blockquote><p>在服务启动时调用</p></blockquote></li><li><p>onDestroy()</p><blockquote><p>在服务销毁时调用</p></blockquote></li></ul><h2 id="启动和停止服务"><a href="#启动和停止服务" class="headerlink" title="启动和停止服务"></a>启动和停止服务</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>在活动中启动服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">startIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, MyService.class);<br>startService(startIntent);<br></code></pre></td></tr></table></figure><h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><p>在活动中停止服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">stopIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, MyService.class);<br>stopService(stopIntent);<br></code></pre></td></tr></table></figure><p>服务自己停下来（在服务中调用stopSelf()方法，就可以让服务停下来）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stopSelf();<br></code></pre></td></tr></table></figure><h2 id="活动通过Binder控制服务"><a href="#活动通过Binder控制服务" class="headerlink" title="活动通过Binder控制服务"></a>活动通过Binder控制服务</h2><p>活动通过startService()启动服务后，服务收到启动信号就启动。服务启动后，活动并不知道服务到底做了什么事情。</p><p>onBind()方法就可以让活动和服务的关系更紧密，例如可以在活动中指挥服务。</p><h3 id="1、服务中的编写"><a href="#1、服务中的编写" class="headerlink" title="1、服务中的编写"></a>1、服务中的编写</h3><ol><li>在Service中新建一个自定义的Binder类继承自Binder，在Binder类中可以添加一些方法对服务进行一些操作</li><li>然后在onBind()方法中返回我们自定义的Binder类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DownloadService <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DownloadBinder</span> <span class="hljs-variable">mBinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadBinder</span>();<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadBinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Binder</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startDownload</span><span class="hljs-params">()</span> &#123;<br>            <br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getProgress</span><span class="hljs-params">()</span> &#123;<br>            <br>        &#125;<br>    &#125;<br>    <br>    ...<br>        <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> mBinder;<br>    &#125;<br>    <br>    ...<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、活动中的编写"><a href="#2、活动中的编写" class="headerlink" title="2、活动中的编写"></a>2、活动中的编写</h3><ol><li><p>在Activity中编写一个ServiceConnection匿名类，重写其两个方法</p><ul><li><p>onServiceConnected(ComponentName name, IBinder service)</p><blockquote><p>在活动和服务建立连接的时候调用。</p><p>通过该方法，我们可以在建立连接的时候获取Binder的onBind()方法返回的IBinder类，Activity有了该类后，就可以通过在该类来控制服务。</p></blockquote></li><li><p>onServiceDisconnected(ComponentName name)</p><blockquote><p>在活动和服务断开连接时调用。</p></blockquote></li></ul></li><li><p>绑定服务</p><ol><li>先new一个Service的Intent</li><li>使用bindService()方法为活动绑定服务</li></ol></li><li><p>通过绑定服务时获取的Binder操控服务</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br>    <br>    <span class="hljs-comment">// 在Activity中存储Binder</span><br>    <span class="hljs-keyword">private</span> MyService.DownloadBinder downloadBinder;<br>    <br>    <span class="hljs-comment">// ServiceConnection匿名类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 在活动和服务建立连接时获取Binder</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>            downloadBinder = (MyService.DownloadBinder) service;<br>            <br>            <span class="hljs-comment">//获取了Binder后，就可以操作服务了</span><br>            downloadBinder.startDownload();<br>            downloadBinder.getProgress();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br>        &#125;<br>    &#125;;<br>    <br>    ...<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (v.getId()) &#123;<br>                <br>            ...<br>            <br>            <span class="hljs-comment">// 点击事件：为活动绑定服务    </span><br>            <span class="hljs-keyword">case</span> R.id.bind_service:<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">bindIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, MyService.class);<br>                bindService(bindIntent, connection, BIND_AUTO_CREATE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 点击事件：为活动解绑服务      </span><br>            <span class="hljs-keyword">case</span> R.id.unbind_service:<br>                unbindService(connection);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="服务的生命周期"></a>服务的生命周期</h1><h2 id="调用Context的startService-方法启动服务"><a href="#调用Context的startService-方法启动服务" class="headerlink" title="调用Context的startService()方法启动服务"></a>调用Context的startService()方法启动服务</h2><ol><li>服务首次启动，则先回调服务的onCreate()方法，然后回调服务的onStartCommand()方法</li><li>服务启动后，若再调用startService()，onStartCommand()方法会被再执行一次。但是每个服务只会存在一个实例。</li><li>当调用一次Context的stopService()或Service的stopSelf()方法，服务就会停止，回调onDestory()方法</li></ol><h2 id="调用Context的bindService-方法获得一个服务的持久连接"><a href="#调用Context的bindService-方法获得一个服务的持久连接" class="headerlink" title="调用Context的bindService()方法获得一个服务的持久连接"></a>调用Context的bindService()方法获得一个服务的持久连接</h2><ol><li>当活动与服务连接后，若服务还未创建过，同样会先回调服务的OnCreate()方法，然后会回调服务的onBind()方法</li><li>然后调用方就可以获取到onBind()方法中返回的IBinder对象的实例，通过该对象与服务自由地进行通信</li><li>调用Context地unbindService()方法，服务会停止，并回调onDestory()方法</li></ol><p>注意：根据Android的机制，一个服务只要被启动或是被绑定之后，就会一直处于运行状态。也就是说若是对一个服务既调用了startService()方法，又调用了bindService()方法，则需要同时调用stopService()和unbindService()方法，服务才会停止，onDestoty()方法才会被回调。</p><h1 id="服务的一些技巧"><a href="#服务的一些技巧" class="headerlink" title="服务的一些技巧"></a>服务的一些技巧</h1><h2 id="使用前台服务"><a href="#使用前台服务" class="headerlink" title="使用前台服务"></a>使用前台服务</h2><blockquote><p>服务几乎都是在后台运行，但是服务的优先级比较低，当系统出现内存不足的时候，可能会回收掉在后台运行的服务。可以使用前台服务来避免被回收。</p></blockquote><p>前台服务和普通服务的区别在于，前台服务会有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到详细信息，效果类似于通知。</p><p>前台服务有两种功能：</p><ul><li>防止服务被回</li><li>显示一些信息或控制栏，例如天气应用、音乐软件的快捷控制</li></ul><p>创建一个前台服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <br>    ...<br>        <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>        <br>        <span class="hljs-comment">// 构建PendingIntent，在与通知绑定后，点击通知会根据该Intent跳转</span><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(This, MainActivity.class);<br>        <span class="hljs-type">PendingIntent</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> PendingIntent.getActivity(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>, intent, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 构建通知</span><br>        <span class="hljs-type">Notification</span> <span class="hljs-variable">notification</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationCompat</span>.Builder(<span class="hljs-built_in">this</span>)<br>            .setContentTitle(<span class="hljs-string">&quot;&quot;</span>)<br>            .setContentText(<span class="hljs-string">&quot;&quot;</span>)<br>            .setWhen(<span class="hljs-string">&quot;&quot;</span>)<br>            .setSamllIcon()<br>            .setLargeIcon()<br>            <span class="hljs-comment">//为通知绑定PendingIntent</span><br>            .setContentIntent(pi)<br>            .build();<br>        <span class="hljs-comment">//startForeground会让服务变成一个前台服务，并在通知栏中显示</span><br>        startForeground(<span class="hljs-number">1</span>, notification);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h2><h3 id="使用服务时遇到的问题"><a href="#使用服务时遇到的问题" class="headerlink" title="使用服务时遇到的问题"></a>使用服务时遇到的问题</h3><p>服务中的代码默认都是运行在主线程中的，若直接在服务中处理一些耗时的逻辑可能会出现ANR（Application Not Responding）的错误。所以前面介绍了多线程的编程来避免在主线程中执行耗时操作，尽管如此在编写或使用服务可能会遇到两个问题：</p><ul><li>编写服务时可能忘记开启一个子线程来执行耗时操作</li><li>使用或编写服务时忘记调用stopService()或stopSelf()来停止服务。</li></ul><h3 id="使用IntentService解决上述问题"><a href="#使用IntentService解决上述问题" class="headerlink" title="使用IntentService解决上述问题"></a>使用IntentService解决上述问题</h3><blockquote><p>Android专门提供了一个IntentService类，使用该类可以简单的创建一个异步的、会自动停止的服务。这个类就很好的解决了前面提到的两个问题。</p></blockquote><p>编写IntentService（注意和普通Service一样要在AndroidManifest.xml中注册）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIntentService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IntentService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyIntentService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;MyIntentService&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 该方法运行在一个自动创建的子线程中</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onHandleIntent</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-comment">// 处理一些具体逻辑</span><br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 在onHandleIntent执行完后，该服务会自动销毁，调用该方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestory();<br>        <span class="hljs-comment">// 销毁服务时的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动IntentService（和普通Service启动方法一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intentService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, MyIntentService.class);<br>startService(intentService);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-网络技术</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="WebView的用法"><a href="#WebView的用法" class="headerlink" title="WebView的用法"></a>WebView的用法</h1><ol><li><p>在布局文件中嵌入WebView组件，并为其指定id</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">...</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">WebView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@id/web_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在Activity中获取WebView对象，并执行一些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">WebView</span> <span class="hljs-variable">webView</span> <span class="hljs-operator">=</span> findViewById(R.id.web_view);<br>webView.getSettings().setJavaScriptEnabled(<span class="hljs-literal">true</span>);<br>webVeiw.setWebViewClient(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebViewClient</span>());<br>webView.loadUrl(<span class="hljs-string">&quot;http://www.google.com&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>在AndroidManifest.xml文件中添加网络权限声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">use-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="使用HTTP协议访问网络"><a href="#使用HTTP协议访问网络" class="headerlink" title="使用HTTP协议访问网络"></a>使用HTTP协议访问网络</h1><blockquote><p>前面的WebView的一个执行流程：客户端发送一个HTTP请求，服务器收到请求后返回网页的HTML代码，然后WebView再调用手机浏览器内核对返回的HTML代码进行解析，最终展示网页。</p></blockquote><p>WebView已经在后台帮我们处理好了发送HTTP请求、接收服务响应、解析返回数据，页面展示等一系列操作。后面我们使用HttpURLConnection和OkHttp手动发送HTTP请求。</p><h2 id="使用-HttpURLConnection"><a href="#使用-HttpURLConnection" class="headerlink" title="使用 HttpURLConnection"></a>使用 HttpURLConnection</h2><blockquote><p>Android自带的发送HTTP请求的方式只有一种，也就是HttpURLConnection（曾经还有HttpClient但已经被完全移除）。</p></blockquote><p>发送HTTP请求（代码中的发送GET&#x2F;POST请求部分二选一）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取连接（也就是获取HttpURLConnction对象）</span><br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://www.google.com&quot;</span>);<br><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br><br><span class="hljs-comment">// 1 发送GET请求</span><br><span class="hljs-comment">// 1.1 设置请求方法</span><br>connection.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br><span class="hljs-comment">// 1.2 定制请求参数（可选）</span><br>connection.setConnectTimeout(<span class="hljs-number">8000</span>);<br>connection.setReadTimeout(<span class="hljs-number">8000</span>);<br><br><span class="hljs-comment">// 2 发送POST请求</span><br><span class="hljs-comment">// 2.1 设置请求方法</span><br>connection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br><span class="hljs-comment">// 2.2 获取输出流</span><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutPutStream</span>(connection.getOutputStream());<br><span class="hljs-comment">// 2.3 往请求中写入要提交的数据（数据以键值对形式存在，数据之间以“&amp;”符号分隔）</span><br>out.writeBytes(<span class="hljs-string">&quot;username=admin&amp;password=123456&quot;</span>);<br><br><span class="hljs-comment">// 获取服务器返回的输入流</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> connection.getInputStream();<br><span class="hljs-comment">// TODO 读取输入流</span><br><br><span class="hljs-comment">// 断开连接</span><br>connection.disconnect();<br></code></pre></td></tr></table></figure><p>处理HTTP请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一般来说会开启一个子线程，在子线程中发起网络请求。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRequestWithHttpURLConnection</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runable</span>() &#123;<br>        <span class="hljs-comment">//TODO，发送网络请求，获取请求结果String response</span><br>        showResponse(response);<br>    &#125;).start();<br>&#125;<br><br><span class="hljs-comment">//获取到请求结果后，不能在这个子线程中执行UI操作，需要调用一个runOnUiThread()方法，在这个方法的匿名类参数中进行操作，将返回的数据显示到界面上。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showResponse</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String response)</span> &#123;<br>    runOnUiThread(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runable</span>() &#123;<br>       <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//TODO，执行UI操作，将结果显示到界面上</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-OkHttp"><a href="#使用-OkHttp" class="headerlink" title="使用 OkHttp"></a>使用 OkHttp</h2><blockquote><p>OkHttp是Android开源网络通信库中最优秀的一个。其接口封装得简单易用，底层实现也自成一派。</p></blockquote><p>因为是开源项目，所以需要先引入依赖，依赖会自动引入两个库：OkHttp库和Okio库，后者是前者的通信基础。</p><p>OkHttp的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 获取一个OKHttpClient实例</span><br><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<br><br><span class="hljs-comment">// 2. 构造Request对象</span><br><br><span class="hljs-comment">// 构造GET请求对象</span><br><span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<span class="hljs-comment">//通过方法链来构造Request对象，进行一系列配置</span><br>    .url(<span class="hljs-string">&quot;htttp://www.google.com&quot;</span>)<br>    ...<br>    .build();<br><br><span class="hljs-comment">// 构造POST请求</span><br><span class="hljs-type">RequestBody</span> <span class="hljs-variable">requestBody</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormBody</span>.Builder()<span class="hljs-comment">// 先构造RequestBody来存放待提交的数据</span><br>    .add(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>)<br>    .add(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>)<br>    ...<br>    .build();<br><span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<span class="hljs-comment">//将构造的RequstBody放入Request中</span><br>    .url(<span class="hljs-string">&quot;http://www.google.com&quot;</span>)<br>    .post(requestBody)<br>    .build();<br><br><span class="hljs-comment">// 3. 调用OkHttpClient的newCall()方法创建一个Call对象，并调用其execute()方法发送请求并获取服务器返回结果</span><br><span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).execute();<br><span class="hljs-comment">// 4. 获取结果对象中的数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">responseData</span> <span class="hljs-operator">=</span> response.body().string();<br></code></pre></td></tr></table></figure><p>回调处理返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">okhttp3</span>.Callback() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(Call call, Response response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">responseData</span> <span class="hljs-operator">=</span> response.body().string();<br>        <span class="hljs-comment">// 处理服务器返回结果</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> &#123;<br>        <span class="hljs-comment">//对异常情况进行处理</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的enqueue()方法回自动开启一个子线程，在子线程内执行HTTP请求，并且重写的回调方法也是在子线程中执行的，所以说在回调方法中不能直接执行UI操作，若需要UI操作需要借助于runOnUiThread ()方法。</p><h1 id="网络传输数据解析"><a href="#网络传输数据解析" class="headerlink" title="网络传输数据解析"></a>网络传输数据解析</h1><p>一般来说每个需要访问网络的应用程序都会有自己的一个服务器，应用程序可以向服务器提交数据，也可以从服务器获取数据。数据在应用程序和服务器之间传输 若直接传递文本，这样的话接收数据的一方根本就不知道文本的用途，该如何从文本中获取需要的信息。需要一定的格式化，从而在收到数据后可以按照格式进行解析，从而取出需要的内容。</p><p>主流的网络传输数据的格式有两种：XML和JSON。（客户端Http请求收到的结果是String文本，这两个格式都是对收到的文本进行解析）</p><h2 id="解析XML格式数据"><a href="#解析XML格式数据" class="headerlink" title="解析XML格式数据"></a>解析XML格式数据</h2><p>假设服务器返回的XML格式数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">apps</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">app</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Google Maps<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">app</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Chrome<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">app</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Google Play<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">apps</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Pull解析方式"><a href="#Pull解析方式" class="headerlink" title="Pull解析方式"></a>Pull解析方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">responseData</span> <span class="hljs-operator">=</span> response.body().String();<br>parseXMLWithPull(responseData);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseXMLWithPull</span><span class="hljs-params">(String xmlData)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">XmlPullParserFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> XmlPullParserFactory.newInstance();<br>        <span class="hljs-type">XmlPullParser</span> <span class="hljs-variable">xmlPullParser</span> <span class="hljs-operator">=</span> factory.newPullParser();<br>        xmlPullParser.setInput(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader</span>(xmlData));<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 获取事件类型（指的是&lt;&gt;和&lt;/&gt;，一个是节点开头，一个是节点结束）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">eventType</span> <span class="hljs-operator">=</span> xmlPullParser.getEventType();<br><br>        <span class="hljs-keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;<br>            <span class="hljs-comment">// 获取节点的名称（指的是在&lt;&gt;中的节点名称）</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">nodeName</span> <span class="hljs-operator">=</span> xmlPullParser.getName();<br>            <span class="hljs-comment">// 根据事件类型执行不同操作</span><br>            <span class="hljs-keyword">switch</span> (eventType) &#123;<br>                <span class="hljs-comment">// 若遇到节点开头事件</span><br>                <span class="hljs-keyword">case</span> XmlPullParser.START_TAG: &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;id&quot;</span>.equals(nodeName)) &#123;<br>                        id = xmlPullParser.nextText();<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;name&quot;</span>.equals(nodeName)) &#123;<br>                        name = xmlPullParser.nextText();<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 若遇到节点结尾事件</span><br>                <span class="hljs-keyword">case</span> XmlPullParser.END_TAG: &#123;<br>                    <span class="hljs-comment">// 如果是&lt;app/&gt;结尾，处理获取的在app节点之间的数据id和name</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;app&quot;</span>.equals(nodeName)) &#123;<br>                        <span class="hljs-comment">//TODO,处理一个app节点内的数据</span><br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 获取下一个事件类型</span><br>            eventType = xmlPullParser.next();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// do nothing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SAX解析方式"><a href="#SAX解析方式" class="headerlink" title="SAX解析方式"></a>SAX解析方式</h3><p>新建一个类实现DefaultHandler，并重写父类的5个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContentHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String nodeName;<br><br>    <span class="hljs-keyword">private</span> StringBuilder id;<br>    <span class="hljs-keyword">private</span> StringBuilder name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 开始解析XML文档时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 开始解析某节点时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startElement</span><span class="hljs-params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        nodeName = localName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 获取节点内容时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">characters</span><span class="hljs-params">(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> length)</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;id&quot;</span>.equals(nodeName)) &#123;<br>            id.append(ch, start, length);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;name&quot;</span>.equals(nodeName)) &#123;<br>            name.append(ch, start, length);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 结束解析某节点时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endElement</span><span class="hljs-params">(String uri, String localName, String qName)</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;app&quot;</span>.equals(localName)) &#123;<br>            <span class="hljs-comment">//TODO,处理一个app节点内的数据</span><br>            <br>            <span class="hljs-comment">//清空用于存储一个app节点内数据的id和name，避免影响下一个app节点的读取</span><br>            id.setLength(<span class="hljs-number">0</span>);<br>            name.setLength(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 结束解析XML文档时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        <span class="hljs-built_in">super</span>.endDocument();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用SAX方法解析请求结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">responseData</span> <span class="hljs-operator">=</span> response.body().String();<br>parseXMLWithSAX(responseData);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseXMLWithSAX</span><span class="hljs-params">(String xmlData)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SAXParserFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXParserFactory</span>().newInstance();<br>        <span class="hljs-type">XMLReader</span> <span class="hljs-variable">xmlReader</span> <span class="hljs-operator">=</span> factory.newSAXParser().getXMLReader();<br>        <span class="hljs-type">ContentHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentHandler</span>();<br>        xmlReader.setContentHandler(handler);<br>        xmlReader.parse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader</span>(xmlData)));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// do nothing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析JSON格式数据"><a href="#解析JSON格式数据" class="headerlink" title="解析JSON格式数据"></a>解析JSON格式数据</h2><p>假设服务器返回的json数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Google Maps&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Chrome&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Google Play&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h3 id="使用JSONObject"><a href="#使用JSONObject" class="headerlink" title="使用JSONObject"></a>使用JSONObject</h3><blockquote><p>JSONObject是Android自带的，可以直接使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">responseData</span> <span class="hljs-operator">=</span> response.body().String();<br>parseJSONWithJSONObject(responseData);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseJSONWithJSONObject</span><span class="hljs-params">(String jsonData)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>(jsonData);<br>        <span class="hljs-comment">// 遍历获取每一组数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; jsonArray.length(); i++) &#123;<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> jsonArray.getJSONObject(i);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-comment">// 处理一组数据</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用GSON"><a href="#使用GSON" class="headerlink" title="使用GSON"></a>使用GSON</h3><blockquote><p>GSON由谷歌开源提供，使用前需要先添加依赖。</p></blockquote><p>首先对应JSON数据定义一个数据模型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-comment">//getter和setter方法</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用Gson对象即可解析json数据，映射成一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">responseData</span> <span class="hljs-operator">=</span> response.body().String();<br><br><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-comment">// 解析非JSON数组</span><br><span class="hljs-type">App</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> gson.fromJson(responseData, App.class);<br><span class="hljs-comment">// 机械JSON数组</span><br>List&lt;App&gt; apps = gson.fromJson(responseData, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;List&lt;App&gt;&gt;()&#123;&#125;.getType());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-四大组件-ContentProvider</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-ContentProvider/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-ContentProvider/</url>
    
    <content type="html"><![CDATA[<ul><li>程序间共享数据的必要性：</li></ul><p>有些程序中拥有可供其他程序进行二次开发的基础性数据，例如电话簿中的联系人信息以及短信和媒体库等。若没有这些程序共享数据，那么很多应用的功能都要大打折扣。</p><ul><li>使用内容提供器的必要性：</li></ul><p>原本的Android持久化技术，包括文件存储、SharedPreferences存储都提供了MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE两种操作模式，用于供其他程序访问当前应用的数据。但是在Android 4.2版本中已经被废弃了，因为Android提供了更为安全的跨程序数据共享技术，也就是内容提供器技术。</p><ul><li>内容提供器简介：</li></ul><p>内容提供器主要用于在不同的应用程序之间实现数据共享的功能。它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性（内容提供器可以选择只对部分数据进行分享，保证我们程序中的隐私数据不会被泄漏）。目前内容提供器时Android实现跨程序共享数据的标准方式。</p><h1 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h1><h2 id="Android的权限机制"><a href="#Android的权限机制" class="headerlink" title="Android的权限机制"></a>Android的权限机制</h2><p>在低于6.0的安卓系统中，应用权限会统一在安装应用时获取，如果你不接受应用申请的权限，可以拒绝安装。但是离不开的日常软件，普遍存在权限滥用，你不得不使用该软件，所以你也不得不接收它所申请的一切权限。在6.0加入了运行时权限功能，用户不需要在安装软件的时候对所有申请的权限授权，可以在软件运行时再对用到的权限授权，我们呢即使拒绝运行时申请的权限我们也能使用应用的其他功能。</p><p>Android将权限分为两类：</p><ul><li><p>普通权限</p><blockquote><p>普通权限指的是不会直接威胁到用户的安全和隐私的权限，系统会自动进行授权。</p></blockquote></li><li><p>危险权限</p><blockquote><p>危险权限指的是可能触及用户隐私或对设备安全造成影响的权限，例如联系人信息、设备定位信息等，对于这部分权限的申请，必须要由用户手动点击授权才行。</p><p>系统权限很多，危险权限总共就9组24个，每个权限都属于一个权限组，我们申请时使用的是权限名，但是用户统一后，同组的其他权限也会被授权。</p></blockquote></li></ul><h2 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h2><p>普通权限的获取：在AndroidManifest.xml中添加以下权限声明即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CALL_PHONE&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>而对于危险权限则需要在声明的同时，还需要在代码中动态获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 权限检查</span><br><span class="hljs-keyword">if</span> (ContextCompat.checkSelfPermission(MainActivity.<span class="hljs-built_in">this</span>, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123;<br>    <span class="hljs-comment">// 未获取权限</span><br>    <span class="hljs-comment">// 动态申请权限（三个参数：1. Context，2. 申请的权限数组，3. 唯一的请求码）</span><br>    Activity.requestPermissions(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;Manifest.permission.CALL_PHONE&#125;, <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 已经获取权限</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-comment">//动态申请权限的回调方法（当动态申请权限时，会弹出权限申请对话框，用户选择同意或拒绝授权后，会回调该方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRequestPermissionResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode, String[] permissions, <span class="hljs-type">int</span>[] grantResults)</span> &#123;<br>    <span class="hljs-comment">//根据上面的请求码，执行不同的回调操作</span><br>    <span class="hljs-keyword">switch</span> (requestCode) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> (grantResults.length &gt; <span class="hljs-number">0</span> &amp;&amp; grantResult[<span class="hljs-number">0</span>] == PackagerManager.PERMISSION_GRANTED) &#123;<br>                <span class="hljs-comment">// 用户同意授权</span><br>                <span class="hljs-comment">// do something</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 用户拒绝授权</span><br>                <span class="hljs-comment">// do somthing</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="通过ContentResolver访问其他程序中的数据"><a href="#通过ContentResolver访问其他程序中的数据" class="headerlink" title="通过ContentResolver访问其他程序中的数据"></a>通过ContentResolver访问其他程序中的数据</h1><blockquote><p>对于应用程序来说，若要访问内容提供器中共享的数据，一定要借助于ContentResolver类。可以通过Context的getContentResolver()方法获取该类实例。</p></blockquote><p>ContentResoler提供了一系列方法用于对数据进行CRUD操作：insert()、update()、delete()、query()。</p><h2 id="内容URI"><a href="#内容URI" class="headerlink" title="内容URI"></a>内容URI</h2><blockquote><p>ContentResolver与SQLiteDatabase的使用类似。但是ContentResolver的CRUD方法不接受表名参数，而是使用一个Uri对象参数代替，这个参数被称为内容URI。</p></blockquote><p>Uri对象通过Uri的静态方法parse()解析内容URI获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.parse(<span class="hljs-string">&quot;content://com.example.app.provider/table1&quot;</span>)<br></code></pre></td></tr></table></figure><p>内容URI由两部分组成，为内容提供器中的数据建立了唯一的标识符（注意要在开头加上<code>content://</code>协议说明）：</p><ul><li>authority：用于对不同应用程序做区分</li><li>path：用于对同一应用程序中的不同表做区分</li></ul><h2 id="ContentResolver方法的使用"><a href="#ContentResolver方法的使用" class="headerlink" title="ContentResolver方法的使用"></a>ContentResolver方法的使用</h2><blockquote><p>返回的结果时Cursor，和处理SQLiteDatabase获取的结果一致，同样新增和修改也是使用的ContentValues对象。</p></blockquote><h3 id="query"><a href="#query" class="headerlink" title="query()"></a>query()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> getContentResolver.query(<br>uri,<span class="hljs-comment">//FROM table_name</span><br>projection,<span class="hljs-comment">//SELECT column1, column2</span><br>selection,<span class="hljs-comment">//WHERE column = value</span><br>selectionArgs,<br>sortOrder<span class="hljs-comment">//ORDER BY column1, column2</span><br>);<br></code></pre></td></tr></table></figure><h3 id="insert-、update-、delete"><a href="#insert-、update-、delete" class="headerlink" title="insert()、update()、delete()"></a>insert()、update()、delete()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//增</span><br><span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>values.put(<span class="hljs-string">&quot;column1&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>);<br>values.put(<span class="hljs-string">&quot;column2&quot;</span>, <span class="hljs-number">1</span>);<br>getContentResolver().insert(uri, values);<br><span class="hljs-comment">//改</span><br><span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>values.put(<span class="hljs-string">&quot;column1&quot;</span>, <span class="hljs-string">&quot;text updated&quot;</span>);<br>getContentResolver().update(uri, values, <span class="hljs-string">&quot;column1 = ? and column2 = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>&#125;);<br><span class="hljs-comment">//删</span><br>getContentResolver().delete(uri, <span class="hljs-string">&quot;column2 = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;1&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><h1 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h1><h2 id="一、创建内容提供器"><a href="#一、创建内容提供器" class="headerlink" title="一、创建内容提供器"></a>一、创建内容提供器</h2><blockquote><p>自定义内容提供器需要继承ContentProvider，并重写其6个方法</p></blockquote><h3 id="六个需要重写的方法"><a href="#六个需要重写的方法" class="headerlink" title="六个需要重写的方法"></a>六个需要重写的方法</h3><ul><li><p>boolean onCreate()</p><blockquote><p>初始化内容跟提供器的时候调用。通常在这里完成对数据库的创建和升级等操作，返回一个boolean值用以表示初始化是否成功。</p></blockquote></li><li><p>query()、insert()、update()、delete()</p><blockquote><p>前面使用ContentResolver已经详细介绍过这几个方法了</p></blockquote></li><li><p>String getType(Uri uri)</p><blockquote><p>根据传入内容URI来返回相应的MIME类型</p></blockquote></li></ul><h3 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h3><blockquote><p>内容提供器中重写的方法几乎都有一个uri参数，UriMatcher可以根据传入的uri解析出希望访问的表和数据。</p></blockquote><p>内容URI的主要格式有两种：</p><ul><li><p>以路径结尾：表示希望访问该表中所有数据</p><blockquote><p>content:&#x2F;&#x2F;com.xy.app.provider&#x2F;table1</p></blockquote></li><li><p>以id结尾：表示期望访问该表中对应id的数据</p><blockquote><p>content:&#x2F;&#x2F;com.xy.app.provider&#x2F;table1&#x2F;1</p></blockquote></li></ul><p>我们可以使用通配符来匹配内容URI：</p><ul><li><p><code>*</code>：表示匹配任意长度的的任意字符</p><blockquote><p><code>content://com.xy.app.provider/*</code>表示匹配任意表</p></blockquote></li><li><p><code>#</code>：表示匹配任意长度的数字</p><blockquote><p><code>content://com.xy.app.provider/table1/#</code>表示匹配table1表中任意一行</p></blockquote></li></ul><p>使用UriMatch类来实现匹配内容URI的功能：</p><ul><li>addURI()方法：接收3个参数，分别是authority、path、自定义代码</li><li>match()方法：接收一个Uri对象，返回能匹配这个Uri对象的自定义代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ContentProvider</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOOK_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOOK_ITEM</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CATEGORY_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CATEGORY_ITEM</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">AUTHORITY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.xy.databasetest.provider&quot;</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UriMatcher uriMatcher;<br>    <br>    <span class="hljs-keyword">private</span> MyDatabaseHelper dbHelper;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        uriMatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UriMatcher</span>(UriMatcher.NO_MATCH);<br>        uriMatcher.addURI(AUTHORITY, <span class="hljs-string">&quot;book&quot;</span>, BOOK_DIR);<br>        uriMatcher.addURI(AUTHORITY, <span class="hljs-string">&quot;book/#&quot;</span>, BOOK_ITEM);<br>        uriMatcher.addURI(AUTHORITY, <span class="hljs-string">&quot;category&quot;</span>, CATEGORY_DIR);<br>        uriMatcher.addURI((AUTHORITY, <span class="hljs-string">&quot;category/#&quot;</span>, CATEGORY_ITEM));<br>    &#125;<br>    <br>    ...<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Cursor <span class="hljs-title function_">query</span><span class="hljs-params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> &#123;<br>        <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbHelper.getReadableDatabase();<br>        <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (uriMatcher.match(uri)) &#123;<br>            <span class="hljs-keyword">case</span> BOOK_DIR:<br>                <span class="hljs-comment">//TODO</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> BOOK_ITEM:<br>                <span class="hljs-comment">//TODO</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CATEGORY_DIR:<br>                <span class="hljs-comment">//TODO</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CATEGORY_ITEM:<br>                <span class="hljs-comment">//TODO</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cursor;<br>    &#125;<br>    <br>    ...<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h3><p>getType()方法用于返回传入Uri对象对应的MIME字符串。</p><p>MIME字符串由3部分组成：</p><ul><li>由vnd开头</li><li>根据内容URI不同结尾后接不同部分<ul><li>以路径结尾，则后接android.cursor.dir&#x2F;</li><li>以id结尾，则后接android.cursor.item&#x2F;</li></ul></li><li>最后接上vnd.&lt;authority&gt;.&lt;path&gt;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ContentProvider</span> &#123;<br>    <br>    ...<br>    <br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Uri uri)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (uriMatcher.match(uri)) &#123;<br>            <span class="hljs-keyword">case</span> BOOK_DIR:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;</span>;<br>            ...<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    ...<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、注册内容提供器"><a href="#二、注册内容提供器" class="headerlink" title="二、注册内容提供器"></a>二、注册内容提供器</h2><p>使用Android Studio的快捷方式创建的内容提供器会在AndroidManifest.xml中自动注册。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.DatabaseProvider&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:authorties</span>=<span class="hljs-string">&quot;com.xy.databasetest.provider&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:enable</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-持久化技术</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>在程序中使用的变量都属于是临时数据，存储在内存中，程序重启后就会消失，所以对于一些关键数据就需要使用数据持久化技术。</p><p>数据持久化技术就是将内存中的临时数据保存到存储设备中，持久化技术提供了一种机制让数据在内存和硬盘之间传输。</p><p>Android提供了三种方式来实现数据的持久化：</p><ul><li>文件存储</li><li>SharedPreferences存储</li><li>数据库存储</li></ul><h1 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h1><blockquote><p>它不对存储内容进行任何的格式化处理，所有数据原封不动的存储到文件中。因此，它适合存储一些简单的文本数据或二进制数据。若要存储较复杂的文本数据，就需要自定义一套格式规范，用于将取出的数据重新解析。</p></blockquote><p>Context类提供了openFileOutput()、openFileInput()方法用于读写文件。</p><h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><blockquote><p>使用文件存储，文件都存储在&#x2F;data&#x2F;data&#x2F;&lt;package name&gt;&#x2F;files&#x2F;路径下</p></blockquote><p>openFileOutput() 方法的参数与返回值：</p><ul><li><p>参数一：文件名</p><blockquote><p>文件创建时使用的就是这个名字</p><p>名字不能包含路径，因为每个程序有默认的存储路径：</p></blockquote></li><li><p>参数二：文件操作模式</p><blockquote><p>MODE_PRIVATE：默认的操作模式，当文件存在时，所写入的内容会覆盖原文件内容</p><p>MODE_APPEND：若文件存在，则往文件中追加内容</p></blockquote></li><li><p>返回值：方法返回的是一个FileOutputStream对象</p></li></ul><p>一个使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">dataSaved</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Data to save&quot;</span>;<br><span class="hljs-type">FileOutPutStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> openFileOutput(<span class="hljs-string">&quot;dataSaved&quot;</span>, Context.MODE_PRIVATE);<br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(out));<br><span class="hljs-comment">//通过writer存储数据</span><br>writer.write(data);<br></code></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>一个使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> openFileInput(<span class="hljs-string">&quot;data&quot;</span>);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in));<br><span class="hljs-comment">//从reader中读取数据</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">dataReadBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>; line = reader.readLine() != <span class="hljs-literal">null</span>; ) &#123;<br>    dataRead.append(line);<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">dataRead</span> <span class="hljs-operator">=</span> dataReadBuilder.toString();<br></code></pre></td></tr></table></figure><h1 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h1><blockquote><p>不同于文件的存储方式，SheredPreferences使用的是键值对的方式来存储数据。</p></blockquote><p>当保存一条数据的时候，需要给这条数据提供一个String类型的键，这样在读取数据的时候就可以通过这个键把相应的值取出来。而且SharedPreferences支持多种类型的数据类型存储，存储的是什么类型，通过键取出来的就是什么类型。</p><h2 id="获取SharedPreferences对象"><a href="#获取SharedPreferences对象" class="headerlink" title="获取SharedPreferences对象"></a>获取SharedPreferences对象</h2><ul><li><p>Context类中的getSharedPreferences()方法</p><blockquote><p>方法接收两个参数：</p><ul><li>参数一：指定SharedPreferences文件的名称。</li><li>参数二：指定操作模式。只有MODE_PRIVATE一种模式可选，表示只有当前应用程序才能对该文件进行读写。</li></ul></blockquote></li><li><p>Activity类中的getPreferences()方法</p><blockquote><p>与Context类的getSharedPrederences()方法类似。但这个方法只需要一个参数：操作模式，会自动使用Activity的类名作为文件名。</p></blockquote></li><li><p>PreferenceManager类中的getDefaultSharedPreferences()方法</p><blockquote><p> 这是一个静态方法，接收要给Context参数。会自动使用当前应用的包名作为前缀来命名SharedPreferences文件。</p></blockquote></li></ul><h2 id="存储数据-1"><a href="#存储数据-1" class="headerlink" title="存储数据"></a>存储数据</h2><blockquote><p>SharedPreferences文件都是存放在&#x2F;data&#x2F;data&#x2F;&lt;package name&gt;&#x2F;shared_prefs&#x2F;路径下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 通过SharedPreferences对象获取editor对象</span><br>SharedPreferences.<span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> getSharedPreferences(<span class="hljs-string">&quot;dataSaved&quot;</span>, MODE_PRIVATE).edit();<br><span class="hljs-comment">// 2. 往editor对象中添加数据</span><br>editor.putString(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;XY&quot;</span>);<br>editor.putInt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">22</span>);<br>editor.putBoolean(<span class="hljs-string">&quot;married&quot;</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 3. 提交添加的数据</span><br>editor.apply();<br></code></pre></td></tr></table></figure><h2 id="读取数据-1"><a href="#读取数据-1" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取SharedPreferences对象</span><br><span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">pref</span> <span class="hljs-operator">=</span> getSharedPreferences(<span class="hljs-string">&quot;data&quot;</span>, MODE_PRIVATE);<br><span class="hljs-comment">// 从SharedPreferences对象中取数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> pref.getString(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//方法中的第二参数为若没有找到key为“name”时返回的默认值</span><br><span class="hljs-type">Int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> pref.getInt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">married</span> <span class="hljs-operator">=</span> pref.getBoolean(<span class="hljs-string">&quot;married&quot;</span>, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h1 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h1><h2 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h2><blockquote><p>Android系统内置数据库，支持标准SQL语法，遵循数据库的ACID事务。</p></blockquote><h3 id="数据库的创建与升级"><a href="#数据库的创建与升级" class="headerlink" title="数据库的创建与升级"></a>数据库的创建与升级</h3><blockquote><p>Android提供了一个SQLiteOpenHelper帮助类，借助这个类可以非常简单的对数据库进行创建和升级。</p></blockquote><p>SQLiteOpenHelper是一个抽象类，若我们要使用它，就需要创建一个自己的帮助类去继承它。</p><ul><li><p>SQLiteOpenHelper中有两个抽象方法：onCreate()、onUpgrade()，我们必须在自己的帮助类中重写这两个方法，在这两个方法中去实现创建、升级数据库的逻辑。</p><ul><li><p>数据库的创建：onCreate()方法中会传入一个参数：SQLiteDatabase</p><blockquote><p>在onCreate方法方法中通过SQLiteDatabase对象执行SQL的建表语句</p><p>该方法只会在数据库创建的时候执行一次</p></blockquote></li><li><p>数据库的升级：onUpgrade()方法中传入三个参数：SQLiteDatabase对象、旧版本号、新版本号</p><blockquote><p>若数据库已经存在，再次执行数据库的构造函数，指定比之前大的版本号，在构造数据库的时候就会执行onUpgrade()方法而不是onCreate()方法。</p></blockquote></li></ul></li><li><p>SQLiteOpenHelper中有两个构造方法可供重写，一般使用参数少的哪个。该构造方法共接收4个参数：</p><ol><li><p>Context</p></li><li><p>数据库名</p></li><li><p>自定义Cursor：该参数允许我们在查询数据的时候返回一个自定义的Cursor，一般传入null</p></li><li><p>数据版本号：使用版本号可对数据库进行升级操作</p><blockquote><p>若是第一次构造，则会根据该版本号，执行onCreate()方法创建数据库</p><p>若不是第一次构造，则当传入版本号大于之前的版本号时，执行onUpgrade ()方法更新数据库</p></blockquote></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDatabaseHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SQLiteOpenHelper</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CREATE_BOOK</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;建表SQL语句&quot;</span>;<br>    <br>    <span class="hljs-comment">//用来保存创建MyDatabaseHelper的Context</span><br>    Context mContext;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyDatabaseHelper</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Context context, <span class="hljs-meta">@Nullable</span> String name, <span class="hljs-meta">@Nullable</span> SQLiteDatabase.CursorFactory factory, <span class="hljs-type">int</span> version)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, name, factory, version);<br>        mContext = context;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> &#123;<br>        db.execSQL(CREATE_BOOK);<br>        Toast.makeText(mContext, <span class="hljs-string">&quot;Create succeeded&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-type">int</span> oldVersion, <span class="hljs-type">int</span> newVersion)</span> &#123;<br>        db.execSQL(<span class="hljs-string">&quot;drop table if exists Book&quot;</span>);<br>        onCreate(db);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h3><blockquote><p>通过调用SQLiteOpenHelper中的getReadableDatabase()、getWriteDatabase()这两个方法，都打开一个数据库（若不存在则新建），并返回一个SQLiteDatabase对象。不同点在于，当数据库不可写入时（如磁盘已满），getReadableDatabase()方法返回的对象将以只读方式打开数据库，而getWriteableDatabase()方法则会出现异常。</p></blockquote><h4 id="添加（Create）"><a href="#添加（Create）" class="headerlink" title="添加（Create）"></a>添加（Create）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建数据库</span><br><span class="hljs-type">MyDatabaseHelper</span> <span class="hljs-variable">dbHelper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDatabaseHelper</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;BookStore.db&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//获取数据库对象</span><br><span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbHelper.getWritableDatabase();<br><span class="hljs-comment">//创建数据</span><br><span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>values.put(<span class="hljs-string">&quot;列名1&quot;</span>, 数据<span class="hljs-number">1</span>);<br>values.put(<span class="hljs-string">&quot;列名2&quot;</span>, 数据<span class="hljs-number">2</span>);<br>values.put(<span class="hljs-string">&quot;列名3&quot;</span>, 数据<span class="hljs-number">3</span>);<br><span class="hljs-comment">//插入数据到数据库</span><br>db.insert(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-literal">null</span>, values);<br></code></pre></td></tr></table></figure><p>insert方法的三个参数：</p><ul><li>参数一：指定表名</li><li>参数二：用于在未指定添加数据的情况下可为某些为空的列自动赋NULL，一般用不到该功能，传入null即可</li><li>参数三：ContentValues对象，提供一系列put方法，用于将表中对应列名以及相应的数据传入</li></ul><h4 id="更新（Update）"><a href="#更新（Update）" class="headerlink" title="更新（Update）"></a>更新（Update）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">db.update(<span class="hljs-string">&quot;Book&quot;</span>, values, <span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;The Da Vinci Code&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><p>update()的四个参数：</p><ul><li>参数一：指定表名</li><li>参数二：指定ContentValues对象，对象中放入要更新的列值</li><li>参数三：对应SQL语句中的where部分，<code>？</code>为占位符号</li><li>参数四：提供字符串数组用于匹配参数三中的占位符</li></ul><h4 id="删除（Delete）"><a href="#删除（Delete）" class="headerlink" title="删除（Delete）"></a>删除（Delete）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">db.delete(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-string">&quot;pages &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;500&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="查询（Retrieve）"><a href="#查询（Retrieve）" class="headerlink" title="查询（Retrieve）"></a>查询（Retrieve）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> db.query(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">if</span>(cursor.moveToFirst()) &#123;<br>    <span class="hljs-comment">//遍历每一列</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//取出列中数据</span><br>        <span class="hljs-comment">//getColumnIndex()方法可以获取某列在表中对应位置的索引</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;name&quot;</span>));<br>        ...<br>    &#125; <span class="hljs-keyword">while</span> (cursor.moveToNext());<br>&#125;<br>cursor.close();<br></code></pre></td></tr></table></figure><p>query()最短的重载方法也需要七个参数，分别对应SQL语句不同部分：</p><ul><li><p>table：FROM table_name</p></li><li><p>columns：SELECT column1, column2</p></li><li><p>selection：WHERE column &#x3D; value</p></li><li><p>slectionArgs</p></li><li><p>groupBy：GROUP BY column</p></li><li><p>having：HAVING column &#x3D; value</p></li><li><p>orderBy：ORDER BY column1, column2</p></li></ul><h4 id="使用SQL操作数据库"><a href="#使用SQL操作数据库" class="headerlink" title="使用SQL操作数据库"></a>使用SQL操作数据库</h4><p>使用SQLiteDatabase的execSQL()方法，传入SQL操作语句，来执行SQL。</p><h2 id="使用LitePal操作数据库"><a href="#使用LitePal操作数据库" class="headerlink" title="使用LitePal操作数据库"></a>使用LitePal操作数据库</h2><blockquote><p>LitePal是一款开源的Android数据库框架，它采用对象关系映射（ORM）的模式，将我们平时常用的数据库功能进行封装，使得我们不需要编写SQL语句也可以完成各种建表和CRUD操作。</p></blockquote><h3 id="配置LitePay"><a href="#配置LitePay" class="headerlink" title="配置LitePay"></a>配置LitePay</h3><ol><li><p>添加LitePal的依赖</p><blockquote><p>在app&#x2F;build.gradle文件中添加依赖</p></blockquote></li><li><p>编写配置文件</p><blockquote><p>新建配置文件：app&#x2F;src&#x2F;mian&#x2F;assets&#x2F;litepal.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">litepal</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dbname</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BookStore&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dbname</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">litepal</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>dbname：用于指定数据库名</li><li>version：用于指定数据库版本</li><li>list：用于指定所有的映射模型</li></ul></blockquote></li><li><p>修改AndroidManifest.xml文件</p><blockquote><p>修改其中&lt;application&gt;标签的android:name属性为org.litepal.LitePalApplication</p></blockquote></li></ol><h3 id="创建和升级数据库"><a href="#创建和升级数据库" class="headerlink" title="创建和升级数据库"></a>创建和升级数据库</h3><h4 id="映射模型类"><a href="#映射模型类" class="headerlink" title="映射模型类"></a>映射模型类</h4><ol><li><p>编写一个Java bean</p><blockquote><p>这个Java bean就对应着一张表，其属性一一对应数据库表中的列</p></blockquote></li><li><p>配置litepal.xml</p><blockquote><p>在其中的&lt;list&gt;标签中添加&lt;mapping&gt;标签，并设置属性class，为其指定映射的Java bean的完整类名</p></blockquote></li></ol><h4 id="创建和升级数据库-1"><a href="#创建和升级数据库-1" class="headerlink" title="创建和升级数据库"></a>创建和升级数据库</h4><blockquote><p>在使用原生的SQLite的时候，需要自己编写一个SQLiteHelper，重写其onCreate()，onUpdate()方法来实现创建和升级数据库，并且在升级数据库时，需要先将之前的表drop掉，再重新创建，原有数据丢失。而LitePay在映射了模型类后，我们创建和升级数据库就简单很多。</p></blockquote><ul><li><p>创建数据库</p><blockquote><p>直接调用LitePal.getDatabase()即可完成建表</p></blockquote></li><li><p>升级数据库</p><blockquote><ol><li>修改模型类（相当于修改表结构）或增加模型类（相当于新建表）</li><li>在litepal.xml文件中将版本号+1（若有新增表还需要配置新增模型类映射）</li><li>调用LitePal.getDatabase()即可完成表更新（LitePal会自动保留表中原有数据）</li></ol></blockquote></li></ul><h3 id="CRUD操作-1"><a href="#CRUD操作-1" class="headerlink" title="CRUD操作"></a>CRUD操作</h3><blockquote><p>首先需要让模型类继承DataSupport，让其拥有增删改查的功能</p></blockquote><h4 id="添加（Create）-1"><a href="#添加（Create）-1" class="headerlink" title="添加（Create）"></a>添加（Create）</h4><blockquote><p>使用SQLite添加数据：构建ContentValues对象 -&gt; 将数据put到ContentValues对象中 -&gt; 调用SQLiteDatabase的insert()方法将数据添加到数据库表中 </p></blockquote><p>LitePal添加数据：</p><ol><li>新建一个Book对象（前面映射的模型类）</li><li>然后设置其属性添加数据</li><li>调用模型类从DataSupport继承来的save()方法将数据添加到数据库</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建Book对象</span><br><span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br><span class="hljs-comment">// 设置数据</span><br>book.setName(<span class="hljs-string">&quot;The Da Vinci Code&quot;</span>);<br>...<br><span class="hljs-comment">// 将数据添加到数据库中</span><br>book.save();<br>    <br></code></pre></td></tr></table></figure><h4 id="更新（Update）-1"><a href="#更新（Update）-1" class="headerlink" title="更新（Update）"></a>更新（Update）</h4><h5 id="更新单条数据"><a href="#更新单条数据" class="headerlink" title="更新单条数据"></a>更新单条数据</h5><p>同样是使用save()方法，但是在调用save方法时会调用对象的isSaved()方法的结构来判断对象是否已经保存。若对象已经保存了则save()方法执行的时更新操作。</p><p>model对象被认为是已存储对象的两种情况：</p><ol><li>已经调用model.save()方法去将对象添加到表中</li><li>该model对象是通过LitePay提供的查询API查询获取的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加数据到数据库</span><br><span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>book.setName(<span class="hljs-string">&quot;The Da Vinci Code&quot;</span>);<br>...<br>book.save();<br><span class="hljs-comment">//更新数据</span><br>book.setName(<span class="hljs-string">&quot;Head first Java&quot;</span>);<br>book.save();<span class="hljs-comment">//由于这个book对象已经调用过save保存到数据库中了，所以这里的save是更新数据</span><br></code></pre></td></tr></table></figure><h5 id="更具条件更新n条数据"><a href="#更具条件更新n条数据" class="headerlink" title="更具条件更新n条数据"></a>更具条件更新n条数据</h5><p>使用模型类的updateAll()方法，第一个参数是条件语句，后面的额参数一一对应条件语句中额占位符，若没有参数表示更新表中所有行。</p><p>若在更新数据时需要将一些字段设置为默认值，则在更新前调用模型类的setToDefault(“列名”)，指定某列设置为默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更新指定行</span><br><span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>book.setPrice(<span class="hljs-number">14.95</span>);<br>book.updateAll(<span class="hljs-string">&quot;name = ? and author = ?&quot;</span>, <span class="hljs-string">&quot;The lost Symbol&quot;</span>, <span class="hljs-string">&quot;Dan Brown&quot;</span>);<br><br><span class="hljs-comment">//更新所有行的某列为默认值</span><br><span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>book.setToDefault(<span class="hljs-string">&quot;pages&quot;</span>);<br>book.updateAll();<br></code></pre></td></tr></table></figure><h4 id="删除（Delete）-1"><a href="#删除（Delete）-1" class="headerlink" title="删除（Delete）"></a>删除（Delete）</h4><p>使用LitePal有两种方法删除数据：</p><ul><li><p>方法一：直接调用已存储对象的delete()方法</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//保存数据</span><br><span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>book.set...;<br>...<br>book.save();<br><span class="hljs-comment">//通过已存储对象删除数据</span><br>book.delete();<br></code></pre></td></tr></table></figure></blockquote></li><li><p>方法二：使用DataSupport类的静态方法deleteAll，指定表和条件语句删除数据</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">DataSupport.deleteAll(Book.class, <span class="hljs-string">&quot;price &lt; ?&quot;</span>, <span class="hljs-string">&quot;15&quot;</span>);<br></code></pre></td></tr></table></figure><p>参数一：指定模型类来对应要删除数据的表</p><p>剩余参数：条件语句、占位符对应的参数</p></blockquote></li></ul><h4 id="查询（Retrieve）-1"><a href="#查询（Retrieve）-1" class="headerlink" title="查询（Retrieve）"></a>查询（Retrieve）</h4><blockquote><p>SQLite中查询数据需要使用SQLiteDatabase对象的query()方法来获取Cursor对象。有两个缺点：1. 参数多，2. 取数据麻烦</p></blockquote><p>使用LitePal查询数据调用DataSupport中的查询API即可。</p><h5 id="封装查询"><a href="#封装查询" class="headerlink" title="封装查询"></a>封装查询</h5><blockquote><p>返回的结果是List列表，取出的结果就直接是model对象</p></blockquote><ul><li><p>固定查询功能</p><ul><li>findAll：查询全部数据</li><li>findFirst：查询第一条数据</li><li>findLast：查询第二条数据</li></ul></li><li><p>定制查询功能</p><blockquote><p>使用下面五个方法自由组合，并在最后加上find(model.class)来指定查询的表</p></blockquote><ul><li>select()：指定查询列</li><li>where()：指定查询约束条件</li><li>order()：指定结果排序方式</li><li>limit()：指定查询结果数量</li><li>offset()：指定查询的偏移量（配合limit来实现分页查询）</li></ul></li></ul><h5 id="原生查询"><a href="#原生查询" class="headerlink" title="原生查询"></a>原生查询</h5><blockquote><p>返回的结果是Cursor对象，取结果会比较麻烦</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cursor</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> DataSupport.findBySQL(<span class="hljs-string">&quot;SQL查询语句&quot;</span>)；<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-四大组件-Broadcast</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Broadcast/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Broadcast/</url>
    
    <content type="html"><![CDATA[<h1 id="广播机制简介"><a href="#广播机制简介" class="headerlink" title="广播机制简介"></a>广播机制简介</h1><p>Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会接收到自己感兴趣的广播内容。这些广播内容可能来自于系统，也可能来自于其他应用程序。</p><p>Android提供了一套完整的API允许应用程序自由的发送和接收广播：</p><ul><li>发送广播借助于Intent</li><li>接收广播借助于广播接收器（Broadcast Receiver）</li></ul><p>广播的分类：</p><ul><li><p>标准广播（Normal broadcasts）</p><blockquote><p>标准广播是一种完全异步执行的广播。广播在发出后，所有广播接收器会同时接收到这一条广播。这样广播的效率高，但是也意味着无法被截断。</p></blockquote></li><li><p>有序广播（Ordered broadcasts）</p><blockquote><p>有序广播是一种同步执行的广播。在广播发出后，同一时刻之后有一个广播接收器收到这条广播，当这个广播接收器的逻辑执行完毕后，广播才会继续传递。根据广播接收器的优先级来决定先后顺序，前面的广播接收器还可以截断正在传播的额广播，这样后面的广播接收器就无法收到广播消息了。</p></blockquote></li></ul><h1 id="接收广播"><a href="#接收广播" class="headerlink" title="接收广播"></a>接收广播</h1><blockquote><p>广播接收器可以对自己感兴趣的广播进行注册，这样当有相应的广播发出时，广播接收器就能收到该广播，并在内部执行相应逻辑。</p></blockquote><h2 id="广播接收器的编写"><a href="#广播接收器的编写" class="headerlink" title="广播接收器的编写"></a>广播接收器的编写</h2><p>新建一个类，继承自Broadcast并重写其onReceive()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkChangeReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceiver</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//注意：在onReceive方法的主要作用是收到广播后打开程序其他组件，比如创建状态栏通知、启动一个服务等。</span><br>    <span class="hljs-comment">//在广播接收器中不允许开启线程，也不能添加过多耗时的操作。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>        <span class="hljs-comment">//do something when received a broadcast</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广播接收器的注册"><a href="#广播接收器的注册" class="headerlink" title="广播接收器的注册"></a>广播接收器的注册</h2><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 获取IntentFilter对象，用于过滤监听的广播 </span><br><span class="hljs-type">IntentFilter</span> <span class="hljs-variable">intentFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>();<br>intentFilter.addAction(<span class="hljs-string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span>);<span class="hljs-comment">//这个action是系统网络状态发生变化时发出的广播</span><br><span class="hljs-comment">// 2. 获取Receiver对象</span><br><span class="hljs-type">NetWorkChangeReceiver</span> <span class="hljs-variable">networkChangeReceiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetworkReceiver</span>();<br><span class="hljs-comment">// 3. 注册Receiver</span><br>rigisterReceiver(networkChangeReceiver, intentFilter);<br></code></pre></td></tr></table></figure><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><blockquote><p>在AndroidManifest.xml中进行Receriver的动态注册</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.NetworkChangeReceiver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>&lt;receiver&gt;的android:name属性用于指定注册的Receiver类</li><li>&lt;action&gt;的android:name属性则用来指定过滤的action</li></ul><h1 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.xy.broadcasttest.MY_BROADCAST&quot;</span>);<br><span class="hljs-comment">//发送标准广播</span><br>sendBroadcast(intent);<br><span class="hljs-comment">//发送有序广播</span><br>sendOrderedBroadcast(intent, <span class="hljs-literal">null</span>); <span class="hljs-comment">//第二个参数是权限相关的</span><br></code></pre></td></tr></table></figure><p>有序广播的接收：</p><ul><li><p>接收优先级设置</p><blockquote><p>在广播接收器进行注册的时候，为&lt;intent-filter&gt;设置android:priority属性。</p></blockquote></li><li><p>截断广播</p><blockquote><p> 在广播接收器的onReceive方法中调用abortBroadcast()方法。</p></blockquote></li></ul><h1 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h1><p>前面的广播发送与接收都属于系统全局广播。广播可被任意程序接收，这样容易引发安全问题，比如我们发送的携带关键数据的广播可能被其他程序截获，其他程序也可能不断发送垃圾广播。</p><p>Android引入了一套本地广播机制，使用该机制发出的广播只能在应用程序内传递，广播接收器也只接受本程序发出的广播。</p><p>实现本地广播的方法：使用LocalBroadcast来进行广播的发送与广播接收器的注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalBroadcastManager</span> <span class="hljs-variable">localBroadcastManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalBroadcastManager</span>.getInstance(<span class="hljs-built_in">this</span>);<br><br><span class="hljs-comment">//发送本地广播</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.xy.broadcasttest.LOACL_BROADCAST&quot;</span>);<br>localBroadcastManager.sendBroadcasttest(intent);<br><br><span class="hljs-comment">//注册本地广播接收器</span><br><span class="hljs-type">IntentFilter</span> <span class="hljs-variable">intentFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>();<br>intentFilter.addAction(<span class="hljs-string">&quot;com.xy.broadcasttest.LOACL_BROADCAST&quot;</span>);<br><span class="hljs-type">localReceiver</span> <span class="hljs-variable">localReceiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoacalReceiver</span>();<br>localBroadcastManager.sendBroadcast(localReceiver, intentFilter);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-Fragment</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-Fragment/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-Fragment/</url>
    
    <content type="html"><![CDATA[<h1 id="碎片是什么"><a href="#碎片是什么" class="headerlink" title="碎片是什么"></a>碎片是什么</h1><blockquote><p>碎片（Fragment）是一种可以嵌入在活动当中的UI片段。碎片和活动非常相似，可以理解为一个迷你型得活动。</p></blockquote><p>碎片的出现就是为了适配平板。手机由于和平板之间的尺寸差别，在手机上合适的UI在平板上会被拉升，导致界面中出现大量空白，屏幕空间浪费。</p><p>一个例子：</p><p>例如在手机中将新闻标题列表放在一个活动中，点击新闻标题进入新闻详情，则进入另一个活动中，这个活动包括标题和内容。如果在平板上也使用和手机一样的设计，则标题会被拉伸至充满整个平板屏幕，而新闻标题一般很短，则会导致界面出现大量的空白区域。</p><p>可以使用Fragment来解决这个问题：将新闻标题列表界面和新闻详情界面放在两个碎片中，手机使用两个活动分别引用这两个碎片，平板则在同一个活动中引用这两个碎片，这样平板的空间就充分的利用起来了。</p><h1 id="碎片的使用方式"><a href="#碎片的使用方式" class="headerlink" title="碎片的使用方式"></a>碎片的使用方式</h1><h2 id="碎片的简单用法"><a href="#碎片的简单用法" class="headerlink" title="碎片的简单用法"></a>碎片的简单用法</h2><ol><li><p>为碎片建立一个xml布局（my_fragment.xml）</p></li><li><p>新建一个MyFragment继承自Fragment，并重写MyFragment中的onCreateView方法，在该方法中动态加载Fragment的布局文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> infater.inflate(R.layout.my_fragment, container, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在布局文件中引用fragment</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/my_fragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.xy.fragmenttest.MyFragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">...</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>需要使用android：name来指定这个fragment组件对应的Fragment类。</p></li></ol><h2 id="在活动中动态添加碎片"><a href="#在活动中动态添加碎片" class="headerlink" title="在活动中动态添加碎片"></a>在活动中动态添加碎片</h2><h3 id="实现动态添加碎片"><a href="#实现动态添加碎片" class="headerlink" title="实现动态添加碎片"></a>实现动态添加碎片</h3><p>首先预定在Activity对应的布局文件中，共两个元素，一个&lt;fragment&gt;，id为left_fragment；另一个&lt;FramLayout&gt;，id为right_layout。</p><p>我们在Activity中编写一个可以实现动态添加碎片的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 获取需要用来替换的碎片实例</span><br><br>privat <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceFragment</span><span class="hljs-params">(Fragment fragment)</span> &#123;<br>    <span class="hljs-comment">// 2. 获取FragmentManager</span><br>    <span class="hljs-type">FragmentManager</span> <span class="hljs-variable">fragmentManager</span> <span class="hljs-operator">=</span> getSupportFragmentManager();<br>    <span class="hljs-comment">// 3. 开启一个事务</span><br>    <span class="hljs-type">FragmentTransaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> fragmentManager.beginTransaction();<br>    <span class="hljs-comment">// 4. 向容器中添加或替换碎片，两个参数：容器id和待添加的碎片实例</span><br>    trasaction.replace(R.id.right_layout, fragment);<br>    <span class="hljs-comment">// 实现按下Back键返回上一个碎片的功能（可选）</span><br>    transaction.addToBackStack(<span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 5. 提交事务</span><br>    trasaction.commit();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在碎片中模拟返回栈"><a href="#在碎片中模拟返回栈" class="headerlink" title="在碎片中模拟返回栈"></a>在碎片中模拟返回栈</h3><p>若在上面的代码中去除<code>transaction.addTobackStack()</code>这一段，则在按下Back后，会直接退出程序。添加了这一段后，按下Back键会返回上一个Fragment界面。这个方法有点类似与记录一个回滚点的意思。</p><h3 id="碎片和活动之间的通信"><a href="#碎片和活动之间的通信" class="headerlink" title="碎片和活动之间的通信"></a>碎片和活动之间的通信</h3><p>虽然碎片是嵌入在活动中显示的，但是二者之间的关系并没有很亲密。活动和碎片各自存在于一个单独得类中，它们之间并没有显示得方式进行通信。</p><ul><li><p>活动中获取碎片实例</p><blockquote><p>FragmentManager提供了一个类似于findViewById()得方法，专门用于从布局文件中获取碎片实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyFragment</span> <span class="hljs-variable">myFragment</span> <span class="hljs-operator">=</span> getSupportFragmentManager().findFragmentById(R.id.my_fragment);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>碎片中获取活动实例</p><blockquote><p>在碎片中可以通过调用getActivity()方法来获取和当前碎片所关联的活动实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MainActivity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> getActivity();<br></code></pre></td></tr></table></figure><p>当在碎片中需要使用Context对象的时候，也可以使用getActivity()方法，因为Activity本身就是一个Context对象。</p></blockquote></li><li><p>碎片中获取碎片实例</p><blockquote><p>通过碎片获取活动实例，然后再通过活动实例再获取其他碎片实例，这样就实现了碎片之间的通信。</p></blockquote></li></ul><h1 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h1><h2 id="碎片的状态"><a href="#碎片的状态" class="headerlink" title="碎片的状态"></a>碎片的状态</h2><blockquote><p>碎片依附于活动存在</p></blockquote><p>碎片的状态以及对应进入该状态的条件：</p><ul><li><p>运行状态</p><blockquote><p>碎片是可见的，且它所关联的活动处于运行状态</p></blockquote></li><li><p>暂停状态</p><blockquote><p>碎片关联的活动进入暂停状态（活动被另一个活动不完全覆盖）</p></blockquote></li><li><p>停止状态</p><blockquote><ul><li>碎片关联的活动进入停止状态</li><li>或调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但是在提交前调用了addToBackStack() 方法</li></ul></blockquote></li><li><p>销毁状态</p><blockquote><ul><li>碎片关联的活动被销毁</li><li>或调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，在提交前没有调用addToBackStack() 方法</li></ul></blockquote></li></ul><h2 id="碎片的生命周期和回调方法"><a href="#碎片的生命周期和回调方法" class="headerlink" title="碎片的生命周期和回调方法"></a>碎片的生命周期和回调方法</h2><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-Fragment/webp.webp" alt="img" style="zoom:80%;"><p>几个重点的回调方法：</p><ul><li>onAttach()：当碎片和活动建立关联时调用</li><li>onCreateView：为碎片创建视图（加载碎片的布局）时调用</li><li>onActivityCreated()：当与碎片关联的活动创建完毕的时候调用</li><li>onDestroyView()：当与碎片关联的视图被移除时调用</li><li>onDetach()：当碎片和活动解除关联的时候调用</li></ul><h1 id="根据不同设备选择不同的布局"><a href="#根据不同设备选择不同的布局" class="headerlink" title="根据不同设备选择不同的布局"></a>根据不同设备选择不同的布局</h1><blockquote><p>在res中新建<code>layout-限定符</code>文件夹文件夹，程序运行在不同设备会根据限定符选择不同的layout文件夹中的资源。</p></blockquote><p>例如在layout中保存的是手机的布局文件，只显示一页，然后新建一个layout-larger文件，在其中保存和layout中一样文件名的布局文件，但是修改这些布局让其适配平板，例如显示两页。应用程序在运行是，会根据设备屏幕大小选择使用layout还是layout-larger中的布局文件。</p><p>常见的一些限定符：</p><ul><li>屏幕大小：<ul><li>small</li><li>normal</li><li>large</li><li>xlarge</li></ul></li><li>屏幕分辨率：<ul><li>ldpi</li><li>mdpi</li><li>hdpi</li><li>xhdpi</li><li>xxhdpi</li></ul></li><li>屏幕方向：<ul><li>land</li><li>port</li></ul></li></ul><p>最小限定符：</p><ul><li>例如<code>layout-sw600dp</code>，在大于等于600dp的设备上会使用这个文件夹中的布局文件。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-UI</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-UI/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-UI/</url>
    
    <content type="html"><![CDATA[<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>布局是一种可以用来放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写精美的界面。同时布局也可以嵌套布局。</p><p>布局和控件之间的关系：</p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-UI/viewgroup_2x.png" alt="img" style="zoom: 50%;"><ul><li><p>线性布局（LinearLayout）</p><blockquote><p>线性布局中的控件线性排列。</p><ul><li>通过<code>android:orientation=&quot;vertical/horizontal&quot;</code>来控制水平垂直&#x2F;水平排列。</li><li>通过<code>android:layout_weight</code>来控制控件所占屏幕比例</li></ul></blockquote></li><li><p>相对布局（RelativeLayout）</p><blockquote><p>相对布局中可以设置控件之间的相对位置关系。</p></blockquote></li><li><p>帧布局（FrameLayout）</p><blockquote><p>新加入的控件永远在前一个控件之上，都放在左上角。</p></blockquote></li><li><p><del>绝对布局（AbsoluteLayout）</del></p><blockquote><p>通过坐标来控制控件的位置，左上角为（0，0），已废弃。</p></blockquote></li><li><p>表格布局（TableLayout）</p><blockquote><p>将子元素拍成行和列，由多个TableRow对象组成，每个TableRow代表一行。</p><p>TableLayout的子节点不能设置layout_width属性，宽度总是MATCH_PARENT。</p></blockquote></li><li><p>-约束布局（ConstraintLayout）</p><blockquote><p>每个控件有水平和垂直两个方向上的约束，共四个约束。（有点像机械制图中的约束）</p><p>ConstraintLayout中的控件不建议使用MATCH_PARENT，建议使用MATCH_CONSTRAINT（0dp）和水平约束来设置。</p></blockquote></li><li><p>FlexboxLayout</p><blockquote><p>对应于CSS中的CSS Flexible Box Layout Module。</p></blockquote></li></ul><h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><ul><li>TextView</li><li>Button</li><li>EditText</li><li>ImageView</li><li>ProgressBar</li><li>AlertDialog</li><li>ProgressDialog</li></ul><h2 id="滚动控件"><a href="#滚动控件" class="headerlink" title="滚动控件"></a>滚动控件</h2><p>当程序中有大量同类型的数据需要展示的时候，就需要使用滚动组件，当手指滑动屏幕时，原有数据滚出屏幕，同时新的数据滚入屏幕。</p><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h4 id="ListView的使用"><a href="#ListView的使用" class="headerlink" title="ListView的使用"></a>ListView的使用</h4><ol><li><p>在Activit的布局中引入ListView，并为其指定一个id</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ListView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/list_view&quot;</span> <span class="hljs-attr">...</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写自定义ListView子项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/fruit_image&quot;</span> <span class="hljs-attr">...</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/fruit_name&quot;</span> <span class="hljs-attr">...</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写Adapter</p><ul><li><p>先定义一个实体类用于包装ListView子项中需要的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> imageId;<br>    <span class="hljs-comment">//TODO</span><br>    <span class="hljs-comment">//构造方法以及getter和setter</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建一个自定义适配器，继承自ArrayAdapter，并将泛型指定为Fruit类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ArrayAdapter</span>&lt;Fruit&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> resoutceId;<br>    <br>    <span class="hljs-comment">//三个构造参数：一、上下文；二、ListView子项布局；三、List&lt;&gt;数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FruitAdapter</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> textViewResourceId, List&lt;Fruit&gt; objects)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, textViewResourceId, objects);<br>        resourceId = textViewResourceId;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">getView</span><span class="hljs-params">(<span class="hljs-type">int</span> position, View convertView, ViewGroup parent)</span> &#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> getItem(position);<br>        <span class="hljs-comment">//填充ListView子项</span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> LayoutInflater.from(getContext()).inflate(resourceId, parent, <span class="hljs-literal">false</span>);<br>        <span class="hljs-type">ImageView</span> <span class="hljs-variable">fruitImage</span> <span class="hljs-operator">=</span> view.findViewById(R.id.fruit_image);<br>        <span class="hljs-type">TextView</span> <span class="hljs-variable">fruitName</span> <span class="hljs-operator">=</span> view.findViewById(R.id.fruit_name);<br>        fruitImage.setImageResource(fruit.getImageId());<br>        fruitName.setText(fruit.getName());<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的inflate方法有三个参数：</p><ol><li>ListView子项布局的id</li><li>指定的父布局</li><li>false表示：让我们在父布局中声明的layout属性有效，但不会为这个View添加父布局。因为一旦View有了父布局后，它就不能添加到ListView中了。</li></ol></li></ul></li><li><p>在Activity中为listView注入Adapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在Activity的onCreate方法中进行注入</span><br><span class="hljs-type">FruitAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FruitAdapter</span>(<span class="hljs-built_in">this</span>, R.layout.fruit_item, fruitList);<span class="hljs-comment">//fruitList是一个List&lt;Fruit&gt;类型的数据</span><br><span class="hljs-type">ListView</span> <span class="hljs-variable">listView</span> <span class="hljs-operator">=</span> findViewById(R.id.list_view);<br>listView.setAdapter(adapter);<br></code></pre></td></tr></table></figure></li></ol><h4 id="ListView的优化"><a href="#ListView的优化" class="headerlink" title="ListView的优化"></a>ListView的优化</h4><blockquote><p>在FruitAdapter的getView()方法中，每次都将布局重新加载一遍，当ListView快速滚动时，就会成为性能瓶颈。</p></blockquote><p>优化有两个方面：</p><ol><li>通过getView方法中的convertView参数来缓存View</li><li>使用ViewHolder来缓存View中的控件实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ArrayAdapter</span>&lt;Fruit&gt; &#123;<br>    <br>    ...<br>        <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">getView</span><span class="hljs-params">(<span class="hljs-type">int</span> position, View convertView, ViewGroup parent)</span> &#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> getItem(position);<br>        View view;<br>        ViewHolder viewHolder;<br>        <br>        <span class="hljs-keyword">if</span>(convertView == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//若没有view缓存,新建view和viewHolder</span><br>            <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> LayoutInflater.from(getContext()).inflate(resourceId, parent, <span class="hljs-literal">false</span>);<br>            viewHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewHolder</span>();<br>            viewHolder.fruitImage = view.findViewById(R.id.fruit_image);<br>            viewHolder.fruitName = view.findViewById(R.id.fruit_name);<br>            view.setTag(viewHolder);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//若这个view已经缓存，直接获取缓存</span><br>            view = convertView;<br>            viewHolder = view.getTag();<br>        &#125;<br>        <span class="hljs-comment">//填充ListView子项</span><br>        viewHolder.fruitImage.setImageResource(fruit.getImageId());<br>        viewHolder.fruitName.setText(fruit.getName());<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ListView的点击事件"><a href="#ListView的点击事件" class="headerlink" title="ListView的点击事件"></a>ListView的点击事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在Activity的onCreat方法中为ListView注册监听器</span><br>listView.setOnItemClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AdapterView</span>.OnItemClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onItemClick</span><span class="hljs-params">(AdapterView&lt;?&gt; parent, View view, <span class="hljs-type">int</span> position, <span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-comment">//position是点击的子项的位置，通过position可以知道点击的是哪个子项。</span><br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> fruitList.get(position);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><p>listView有两个方面的缺点：</p><ul><li>需要使用一些技巧来提升其运行效率，否则其性能很差</li><li>扩展性不足，例如不支持横向滚动</li></ul><p>RecyclerView可以说是一个增强的ListView，不经可以实现和ListView相同的效果，还优化ListView存在的各种不足之处。</p><h4 id="RecyclerView的基本用法"><a href="#RecyclerView的基本用法" class="headerlink" title="RecyclerView的基本用法"></a>RecyclerView的基本用法</h4><ol><li><p>添加RecycleView的依赖</p><blockquote><p>在app&#x2F;build.gredle文件中，在dependencies闭包中添加依赖。</p></blockquote></li><li><p>在布局中添加RecycleView的控件，为其指定id。</p></li><li><p>跟使用ListView一样，新建Fruit类和fruit_item.xml子布局。</p></li><li><p>为RecycleView准备一个适配器类Adapter，其中ViewHolder是适配器中定义的一个内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123;<br>    <span class="hljs-comment">//使用List存储数据</span><br>    <span class="hljs-keyword">private</span> List&lt;Fruit&gt; mFruitList;<br><br>    <span class="hljs-comment">//通过构造函数传入数据源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FruitAdapter</span><span class="hljs-params">(List&lt;Fruit&gt; fruitList)</span> &#123;<br>        mFruitList = fruitList;<br>    &#125;<br><br>    <span class="hljs-comment">//ViewHolder用于缓存子项中的组件实例</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.ViewHolder &#123;<br>        View fruitView;<br>        Button fruitButton;<br>        TextView fruitName;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ViewHolder</span><span class="hljs-params">(View view)</span> &#123;<br>            <span class="hljs-built_in">super</span>(view);<br>            fruitView = view;<br>            fruitButton = view.findViewById(R.id.fruit_button);<br>            fruitName = view.findViewById(R.id.fruit_name);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//该方法用于构建ViewHolder实例</span><br>    <span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@androidx</span>.annotation.NonNull ViewGroup viewGroup, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-comment">//加载fruit_item布局</span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.fruit_item, viewGroup, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//将加载出来的子项布局传入ViewHolder，创建viewHolder实例</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewHolder</span>(view);<br>        <span class="hljs-comment">//返回该viewHolder实例</span><br>        <span class="hljs-keyword">return</span> holder;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//该方法用于对子项的数据进行赋值，当每个子项被滚动到屏幕内时执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@androidx</span>.annotation.NonNull ViewHolder viewHolder, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-comment">//获取子项数据</span><br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> mFruitList.get(i);<br>        <span class="hljs-comment">//对子项进行赋值</span><br>        viewHolder.fruitName.setText(fruit.getName());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//该方法用于获取子项的个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getItemCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mFruitList.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在Activity中为RecycleView注入LayoutManager和Adapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RecyclerView</span> <span class="hljs-variable">recyclerView</span> <span class="hljs-operator">=</span> (RecyclerView) findViewById(R.id.recycle_view);<br><span class="hljs-comment">// 1. 取并注入LayoutManager</span><br><span class="hljs-comment">// LayoutManager用于指定子项的排布方式</span><br><span class="hljs-type">LinearLayoutManager</span> <span class="hljs-variable">layoutManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearLayoutManager</span>(<span class="hljs-built_in">this</span>);<br>recyclerView.setLayoutManager(layoutManager);<br><span class="hljs-comment">// 2. 获取并注入Adapter</span><br><span class="hljs-comment">// Adapter则是为RecycleView指定数据源，以及数据与子项的适配</span><br><span class="hljs-type">FruitAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FruitAdapter</span>(fruitList);<br>recyclerView.setAdapter(adapter);<br></code></pre></td></tr></table></figure></li></ol><h4 id="横向滚动和瀑布流布局"><a href="#横向滚动和瀑布流布局" class="headerlink" title="横向滚动和瀑布流布局"></a>横向滚动和瀑布流布局</h4><blockquote><p>RecyclerView的布局由设置的LayoutManager控制。</p></blockquote><h5 id="横向滚动"><a href="#横向滚动" class="headerlink" title="横向滚动"></a>横向滚动</h5><ol><li><p>在子项布局中，将子项内部元素的排列方式改为垂直</p><blockquote><p>修改子项布局主要是为了适配横向滚动</p></blockquote></li><li><p>在Activity中对LayoutManager进行设置，设置为水平</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);<br></code></pre></td></tr></table></figure></li></ol><h5 id="瀑布流布局"><a href="#瀑布流布局" class="headerlink" title="瀑布流布局"></a>瀑布流布局</h5><blockquote><p>除了上面使用的LinearLayoutManger之外，RecyclerView还提供了GridLayoutManager（网格布局）、StaggeredGridLayoutManager（瀑布流布局）。</p></blockquote><ol><li><p>修改子项布局</p><blockquote><p>layout_margin：改为match_parent，因为瀑布流布局宽度由布局的列数决定自动适配</p><p>layout_margin：为每项之间留点间距</p></blockquote></li><li><p>在Activity中使用StaggeredGridLayoutManager来控制RecyclerView的布局</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StaggeredGridLayoutManager</span> <span class="hljs-variable">layoutManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaggeredGridLayoutManager</span>(<span class="hljs-number">3</span>, StaggeredGridLayoutManager.VERTICAL);<br></code></pre></td></tr></table></figure><blockquote><p>参数一：指定列数</p><p>参数二：指定布局排列方向</p></blockquote></li></ol><h4 id="RecyclerView的点击事件"><a href="#RecyclerView的点击事件" class="headerlink" title="RecyclerView的点击事件"></a>RecyclerView的点击事件</h4><blockquote><p>不同于ListView，RecyclerView并没有提供类似于setOnItemClickListener()这样的注册监听器方法，而是需要我们自己给子项的View注册点击事件。</p></blockquote><p>RecyclerView这样设计的原因：</p><ul><li>ListView中的setOnItemClickListener()注册的是子项的点击事件，如果我们想点击子项中具体的某个按钮，那么ListView实现起来就很麻烦。</li><li>因此RecyclerView就直接抛弃了子项点击事件的监听器，所有的点击事件由具体的View去注册。</li></ul><p>修改Adapter，在Adapter的onCreatViewHolder中通过ViewHolder为子项中的元素注册监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123;<br>    <br>    <span class="hljs-comment">//省略部分见上面的Adapter</span><br>    ...<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@androidx</span>.annotation.NonNull ViewGroup viewGroup, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.fruit_item, viewGroup, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewHolder</span>(view);<br>        <br>        <span class="hljs-comment">//为整个子项注册监听器</span><br>        holder.fruitView.setOnClickListener(New View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                <span class="hljs-comment">//do something</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//为子项中的图片注册监听器</span><br>        holder.fruitImage.setOnClickListener(New View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                <span class="hljs-comment">//do something</span><br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">return</span> holder;<br>    &#125;<br>    <br>    ...<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><h3 id="View继承结构"><a href="#View继承结构" class="headerlink" title="View继承结构"></a>View继承结构</h3><p>控件和布局的继承结构：</p><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-UI/webp.webp" alt="img"></p><p>由上可见，所有的控件和布局都是直接或间接地继承自View的。View是Android中最基本的一个UI组件，它可以在屏幕上绘制一块矩形区域，并响应这块区域中的各事件。</p><ul><li>我们使用的各种控件其实就是在View的基础之上添加了各自特有的功能。</li><li>而ViewGroup则是一种特殊的View，它是一个用于放置控件和布局的容器，它可以包含多个子View和子ViewGroup。</li></ul><h3 id="自定义控件的方法"><a href="#自定义控件的方法" class="headerlink" title="自定义控件的方法"></a>自定义控件的方法</h3><p>自定控件主要有两种方法：</p><ul><li>方法一：先编写XML的自定义布局，在其他界面中引用该XML布局</li><li>方法二：创建一个控件类，在类中动态加载自定义的布局，并且同时还可以为自定义布局绑定逻辑，然后在其他界面引用这个控件类。</li></ul><p>下面以创建一个模仿iPhone的标题栏为例介绍如何自定义控件。</p><h4 id="方法一、引入布局"><a href="#方法一、引入布局" class="headerlink" title="方法一、引入布局"></a>方法一、引入布局</h4><blockquote><p>通过编写自定义的界面，然后在其他界面中引用该自定义界面，避免重复界面的编写。</p></blockquote><p>iPhone的标题栏左右各一个按钮，中间是标题，大致结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 其中两个按钮需要分别绑定back和edit的逻辑 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/title_back&quot;</span> <span class="hljs-attr">...</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">...</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/title_edit&quot;</span> <span class="hljs-attr">...</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果要在其他界面中引入上面编写的title界面，只需要使用<code>&lt;include layout=&quot;@layout/title&quot; /&gt;</code>即可。</p><p>如果要使用自定义的标题栏替换系统自带的标题栏，则还需要在Activity类中将系统自带的标题栏隐藏掉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ActionBar</span> <span class="hljs-variable">actionBar</span> <span class="hljs-operator">=</span> getSupportActionBar();<br><span class="hljs-keyword">if</span>(actionBar != <span class="hljs-literal">null</span>) &#123;<br>    actionBar.hide();<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-UI/image-20221203111511993.png" alt="image-20221203111511993"></p><h4 id="方法二、引入自定义控件"><a href="#方法二、引入自定义控件" class="headerlink" title="方法二、引入自定义控件"></a>方法二、引入自定义控件</h4><blockquote><p>自定的标题栏通过引入布局的方法解决了重复编写布局代码的问题。但是如果需要布局中的一些控件能响应事件，那么还需要在每个活动中为这些控件单独编写一次事件注册的代码。通过自定义控件可以为我们控件绑定逻辑，比如说我们编写的title控件，back按钮和edit按钮在不同活动中的功能是相同的，在自定义控件中为其绑定逻辑后，在其他界面直接引用这个控件，就不需要再单独为其绑定逻辑。</p></blockquote><p>自定义控件代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TitleLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinearLayout</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TitleLayout</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>.(context, attrs);<br>        <span class="hljs-comment">// 1. 动态加载自定义布局</span><br>        <span class="hljs-comment">//from方法构建一个LayoutInflater对象</span><br>        <span class="hljs-comment">//inflate方法，参数一：要加载的布局文件；参数二：为加载好的布局文件指定父布局。</span><br>        LayoutInflater.from(context).inflate(R.layout.title, <span class="hljs-built_in">this</span>);<br>        <br>        <span class="hljs-comment">// 2. 为两个按钮绑定逻辑</span><br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在其他布局文件中添加自定义控件和添加普通控件一样，只是添加自定义控件需要指定完整的类名（包名不可省略）。类似于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">com.xy.uicustomviews.TitleLayout</span> <span class="hljs-attr">...</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样引入的自定义控件后，自定义控件内的点击事件就已经注册好了，省去了很多重复代码的编写。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-四大组件-Activity</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/</url>
    
    <content type="html"><![CDATA[<h1 id="活动简介"><a href="#活动简介" class="headerlink" title="活动简介"></a>活动简介</h1><p>活动（Activity）是一种可以包含用户界面的组件，主要用于与用户进行交互。一个应用程序可以包含零个或多个活动，不包含活动就是一个没有用户界面的应用。</p><h1 id="活动创建步骤"><a href="#活动创建步骤" class="headerlink" title="活动创建步骤"></a>活动创建步骤</h1><h2 id="1、编写布局（first-layout-xml）"><a href="#1、编写布局（first-layout-xml）" class="headerlink" title="1、编写布局（first_layout.xml）"></a>1、编写布局（first_layout.xml）</h2><p>Android 程序的设计讲究逻辑与视图分离，最好每一个活动都能对应一个布局。布局是用来显示界面内容的。</p><p>在 app&#x2F;src&#x2F;main&#x2F;res&#x2F;layout 中 右键-&gt;New-&gt;Layout resource file 即可创建一个布局。</p><p>具体布局的编写会在后面的 UI 介绍中详细说明。</p><h2 id="2、创建活动（FirstActivity-java）"><a href="#2、创建活动（FirstActivity-java）" class="headerlink" title="2、创建活动（FirstActivity.java）"></a>2、创建活动（FirstActivity.java）</h2><p>在 java 文件夹下的应用程序包中 New-&gt;Activity-&gt;Empty Activity 即可新建一个空的活动。</p><p>在新建的时候会有两个可选的选项：</p><ul><li>Generate Layout File：自动生成对应的 layout 布局文件</li><li>Launcher Activity：将新建的活动设置为主活动</li></ul><p>新建后的Activity文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        <span class="hljs-comment">//设置对应的布局文件。</span><br>        setContentView(R.layout.first_layout);<span class="hljs-comment">//R.layout.first_layout为前文所述的res文件引用的方法。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、注册活动（AndroidManifest-xml）"><a href="#3、注册活动（AndroidManifest-xml）" class="headerlink" title="3、注册活动（AndroidManifest.xml）"></a>3、注册活动（AndroidManifest.xml）</h2><p>在新建Activity的时候，Android Studio 会自动在 AndroidManifest文件中注册我们新建的活动。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 指定需要注册的activity类 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.FirstActivity&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 设置该活动为主活动 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在&lt;application&gt;标签中使用&lt;activity&gt;标签注册活动</li><li>&lt;activity&gt;标签中使用 android:name 属性来指定具体注册的活动</li><li>在 &lt;activity&gt;标签中使用&lt;intent-filter&gt;标签指定action和category可以指定该活动为主活动</li></ul><h1 id="活动中的一些操作"><a href="#活动中的一些操作" class="headerlink" title="活动中的一些操作"></a>活动中的一些操作</h1><h2 id="为布局元素绑定点击逻辑"><a href="#为布局元素绑定点击逻辑" class="headerlink" title="为布局元素绑定点击逻辑"></a>为布局元素绑定点击逻辑</h2><h3 id="1-获取元素对象"><a href="#1-获取元素对象" class="headerlink" title="1. 获取元素对象"></a>1. 获取元素对象</h3><blockquote><p>通过findViewById方法获取元素对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> findViewById(R.id.button);<br></code></pre></td></tr></table></figure><p>关于 R.id.button：</p><ul><li><p>方法中传入的id是在布局文件中为元素绑定的id值：<Button android:id="@+id/button"></Button></p></li><li><p>Button元素的<code>android:id</code>属性为当前元素定义一个唯一标识符。</p></li><li><p>在XML文件中使用<code>@id/button</code>是引用资源的语法，使用<code>@+id/button</code>则是定义一个id。</p></li></ul><h3 id="2-绑定点击逻辑"><a href="#2-绑定点击逻辑" class="headerlink" title="2. 绑定点击逻辑"></a>2. 绑定点击逻辑</h3><blockquote><p>为元素对象设置onClickListener对象，绑定点击逻辑</p></blockquote><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        ...<br><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> findViewById(R.id.button);<br>button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                <span class="hljs-comment">//button点击时执行的逻辑操作</span><br>            &#125;<br>    &#125;);<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        ...<br><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> findViewById(R.id.button);<br>button.setOnclickListener(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br><span class="hljs-keyword">switch</span>(v.getId()) &#123;<br>            <span class="hljs-keyword">case</span> R.id.button:<br>                <span class="hljs-comment">//button点击时执行的逻辑操作</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h2><blockquote><p>Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的消息通知给用户，这些消息会在一段时间后显示，并且不会占用任何屏幕空间。</p></blockquote><p>通过Toast.makeText().show();来显示一条Toast通知。</p><p>makeText()方法需要三个参数：</p><ol><li><p>Context（上下文对象）</p><blockquote><p>活动本身就是一个Context对象，所以在活动中调用Toast可以直接传入this</p></blockquote></li><li><p>Charsequence（文本内容）</p></li><li><p>int（显示时长）</p><blockquote><p>可以使用Toast自带的常量：</p><ul><li>Toast.LENGTH_SHORT</li><li>Toast.LENGTH_LONG</li></ul></blockquote></li></ol><h2 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h2><h3 id="1、编写Menu布局"><a href="#1、编写Menu布局" class="headerlink" title="1、编写Menu布局"></a>1、编写Menu布局</h3><p>在res&#x2F;menu中右键选择新建一个Menu resource file，命名为main：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">menu</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/add_item&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:title</span>=<span class="hljs-string">&quot;Add&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/Remove_item&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:title</span>=<span class="hljs-string">&quot;Remove&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">menu</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/image-20221202195523482.png" alt="image-20221202195523482"></p><h3 id="2、在Activity中显示Menu"><a href="#2、在Activity中显示Menu" class="headerlink" title="2、在Activity中显示Menu"></a>2、在Activity中显示Menu</h3><p>在Activity中重写onCreateOptionMenu()方法：（使用Ctrl + O可以快速重写方法。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onCreateOptionsMenu</span><span class="hljs-params">(Menu menu)</span> &#123;<br>    getMenuInflater().inflate(R.menu.main, menu);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>getMenuInflater()方法获取MenuInflater对象</li><li>调用MenuInflater的inflate()方法创建菜单，有两个参数<ul><li>参数一：指定通过哪个资源文件创建菜单</li><li>参数二：指定我们的菜单项要添加到哪一个Menu对象中</li></ul></li><li>返回值<ul><li>返回true：表示允许创建的菜单显示出来</li><li>返回false：表示不允许显示</li></ul></li></ul><h3 id="3、为Menu绑定逻辑"><a href="#3、为Menu绑定逻辑" class="headerlink" title="3、为Menu绑定逻辑"></a>3、为Menu绑定逻辑</h3><p>在Activity中重写onOptionsItemsSelected()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onOptionsItemSelected</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MenuItem item)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (item.getItemId()) &#123;<br>        <span class="hljs-keyword">case</span> R.id.add_item:<br>            <span class="hljs-comment">//add菜单需要绑定的逻辑</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> R.id.remove_item:<br>            <span class="hljs-comment">//remove菜单项需要绑定的逻辑</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><blockquote><p>通过Intent可以在活动之间跳转。</p></blockquote><p>Intent大致可以分为两种：显示Intent和隐式Intent。</p><h3 id="显示Intent"><a href="#显示Intent" class="headerlink" title="显示Intent"></a>显示Intent</h3><p>使用Intent（Context packageContext, Class&lt;?&gt; cls）即可创建一个显示Intent。</p><ul><li>参数一：Context要求提供一个启动活动的上下文</li><li>参数二：Class指定想要启动的目标活动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, targetActivity.class);<br>startActivity(intent);<br></code></pre></td></tr></table></figure><h3 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h3><p>隐式Intent并不明确指定想要启动哪一个活动，而是指定一系列action和category等信息，然后由系统分析该Intent，匹配合适的活动启动。</p><h4 id="指定Activity响应的action和category"><a href="#指定Activity响应的action和category" class="headerlink" title="指定Activity响应的action和category"></a>指定Activity响应的action和category</h4><p>Activity在AndroidManifest.xml中注册的时候，可以指定当前活动可以响应的action和category。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.targetActivity&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.xy.test.TARGETACTIVITY_START&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- category可以指定多个，上面的是默认的category --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="启动隐式的Intent"><a href="#启动隐式的Intent" class="headerlink" title="启动隐式的Intent"></a>启动隐式的Intent</h4><p>使用intent(String action)来创建一个隐式Intent，然后可以使用addCategoty(String category)指定category。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.xy.test.TARGETACTIVITY_START&quot;</span>);<br>intent.addCategory(<span class="hljs-string">&quot;com.xy.test.MY_CATEGORY&quot;</span>);<br>startActivity(Intent);<br></code></pre></td></tr></table></figure><ul><li>隐式Intent只能指定一个action，但是可以指定多个category</li><li>“android.intent.category.DEFAULT”是intent创建时的默认category</li><li>只有action和category与intent全部匹配的activity才会被启动</li></ul><h4 id="使用隐式Intent启动其他程序活动"><a href="#使用隐式Intent启动其他程序活动" class="headerlink" title="使用隐式Intent启动其他程序活动"></a>使用隐式Intent启动其他程序活动</h4><p>例如启动系统浏览器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW);<br>intent.setData(Uri.parse(<span class="hljs-string">&quot;http://www.google.com&quot;</span>));<br>startActivity(intent);<br></code></pre></td></tr></table></figure><ul><li>Intent.ACTION_VIEW 是 Android系统内置的动作，其常量值为android.intent.action.VIEW</li><li>在通过Uri.parse()方法将网站地址解析为一个Uri对象</li><li>在调用Intent的setData()方法将Uri对象设置到intent中</li><li>最后启动，即可打开系统浏览器</li></ul><h4 id="让自己的Activity响应其他程序发出的隐式Intent"><a href="#让自己的Activity响应其他程序发出的隐式Intent" class="headerlink" title="让自己的Activity响应其他程序发出的隐式Intent"></a>让自己的Activity响应其他程序发出的隐式Intent</h4><p>在Activity注册的时候，在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精准地指定当前活动能够响应什么类型地数据。</p><p>&lt;data&gt;标签中可以配置的属性：</p><ul><li>android:scheme。指定数据地协议。如http、geo、tel。</li><li>android:host。指定数据的主机名。如<a href="http://www.google.com./">www.google.com。</a></li><li>android:port。指定数据的端口，一般紧随在主机名后。</li><li>android:path。指定主机名和端口后的部分，如一段网址中跟在域名后的部分。</li><li>android:mimeType：指定可以处理的数据类型。</li></ul><h3 id="使用Intent在活动之间传递数据"><a href="#使用Intent在活动之间传递数据" class="headerlink" title="使用Intent在活动之间传递数据"></a>使用Intent在活动之间传递数据</h3><h4 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h4><blockquote><p>可以现在活动中将数据存在Intent中，然后再目标活动中通过Intent获取数据。</p></blockquote><p>在FirstActivity将数据存在Intent中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello SecondActivity&quot;</span>;<br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, SecondActivity.class);<br>intent.putExtra(<span class="hljs-string">&quot;dataFromFristActivity&quot;</span>, data);<br>startActivity(intent);<br></code></pre></td></tr></table></figure><p>在SecondActivity中将Intent中的数据取出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在Activity中调用getIntent()方法可以获取到用于启动该Activity的Intent</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> getIntent();<br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> intent.getStringExtra(<span class="hljs-string">&quot;dataFromFristActivity&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="返回数据给上一个活动"><a href="#返回数据给上一个活动" class="headerlink" title="返回数据给上一个活动"></a>返回数据给上一个活动</h4><blockquote><p>返回上一个活动只需要按以下Back键，这样并没有一个用于启动活动的Intent用来传递数据。</p><p>Activity中有一个startActivityForResult()方法用于启动活动，并可以获取所启动活动的返回值。</p></blockquote><p>在FirstActivity中通过startActivityForResult()方法启动活动，并重写处理返回结果的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, SecondActivity.class);<br><span class="hljs-comment">//第二个参数是请求码，请求码只要是一个唯一值就可以</span><br>startActivityForResult(intent, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-comment">//参数一：启动活动是传入的请求码；参数二：返回数据时传入的结果码；参数三：返回数据时传入的带有数据的intent</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode, <span class="hljs-type">int</span> resultCode,  Intent data)</span> &#123;<br>    <span class="hljs-comment">//不同请求码对应不同的处理逻辑</span><br>    <span class="hljs-keyword">switch</span> (requestCode) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-comment">//不同结果码对应不同的处理逻辑</span><br>            <span class="hljs-keyword">if</span> (requestCode == RESULT_OK) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">dataFromSecondActivity</span> <span class="hljs-operator">=</span> data.getStringExtra(<span class="hljs-string">&quot;data_FromSecondActivity&quot;</span>);<br>                <span class="hljs-comment">//do something else</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在SecondActivity中新建一个Intent用于存储返回的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处的Intent只是用来存储数据，没有指定意图</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>intent.putExtra(<span class="hljs-string">&quot;dataFromSecondActivity&quot;</span>, <span class="hljs-string">&quot;Hello FirstActivity&quot;</span>);<br><span class="hljs-comment">//该方法用于向上一个活动返回数据。参数一：处理结果，一般使用RESULT_OK或RESULT_CANCELED;参数二：带有数据的Intent对象</span><br>setResult(RESULT_OK, intent);<br></code></pre></td></tr></table></figure><h1 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h1><h2 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h2><blockquote><p>Android使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合，这个栈也被称为返回栈（Back Stack）。</p></blockquote><p>栈是一种后进先出的数据结构，当启动一个新的活动时，它被压入栈中位于栈顶，当我们按下Back键或调用finish方法去销毁一个活动，处于栈顶的活动会出栈，这时前一个入栈的活动就会位于栈顶。系统总是会显示处于栈顶的活动给用户。</p><p>图示：</p><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/diagram_backstack.png" alt="img"></p><h2 id="活动的状态"><a href="#活动的状态" class="headerlink" title="活动的状态"></a>活动的状态</h2><ol><li><p>运行状态</p><blockquote><p>当活动位于返回栈的栈顶时，该活动处于运行状态。</p></blockquote></li><li><p>暂停状态</p><blockquote><p>当活动不处于栈顶，但仍然可见时，该活动处于暂停状态。</p></blockquote></li><li><p>停止状态</p><blockquote><p>当活动不处于栈顶，并完全不可见时，该活动处于停止状态。</p></blockquote></li><li><p>销毁状态</p><blockquote><p>当活动从返回栈中移除后，该活动处于销毁状态。</p></blockquote></li></ol><p>系统会根据活动状态选择优先回收的活动。</p><h2 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h2><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/520426-20220901224242136-1475887995.png" alt="img"></p><p>Activity类中定义的7个回调方法，一一对应活动生命周期的每一个环节：</p><ol><li><p>onCreate()：活动第一次被创建时调用。</p></li><li><p>onStart()：活动由不可见变为可见时调用。</p></li><li><p>onResume()：方法准备好和用户进行交互时调用。</p><blockquote><p>此时活动一定处于栈顶，并处于运行状态</p></blockquote></li><li><p>onPause()：当系统要启动或恢复另一个活动时调用。</p><blockquote><p>一般在此方法中释放资源，保存关键数据，不要在该方法中进行耗时操作，会影响新栈顶活动的调用</p></blockquote></li><li><p>onStop()：当活动完全不可见时调用。</p><blockquote><p>它和onPause()方法的主要区别在于，若启动的新活动是一个对话框式的活动，那么onPause()会被执行。</p><p>（在Activity注册时，为Activity设置属性<code>android:theme=&quot;@style/Theme.AppCompat.Dialog&quot;</code>即可将Activity设置为对话框式的活动）</p></blockquote></li><li><p>onRestart()：在方法由停止状态变为运行状态之前调用。</p></li><li><p>onDestoty()：在活动被销毁之前调用。</p></li></ol><p>根据活动的生命周期，又可以将活动分为三种生存期：</p><ul><li><p>完整生存期：onCreat()和onDestory()方法之间所经历的。</p><blockquote><p>一般来说，在onCreate()中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。</p></blockquote></li><li><p>可见生存期：onStart()和onStop()方法之间所经历的。</p><blockquote><p>在可见生存期间内，互动对用户总是可见的，即使可能无法与用户进行交互。我们可以通过这两个方法管理对用户可见的资源。</p><p>例如，在onStart()方法中对资源进行加载，在onStop()方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。</p></blockquote></li><li><p>前台生存期： onResum()和onPause()之间经历的。</p><blockquote><p>在前台生存期，活动总是处于运行状态，并可以和用户进行交互，我们平时看到和接触到最多的就是这个状态下的活动。</p></blockquote></li></ul><h2 id="活动被回收之前的数据保存"><a href="#活动被回收之前的数据保存" class="headerlink" title="活动被回收之前的数据保存"></a>活动被回收之前的数据保存</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>当一个活动进入停止状态后，可能会被系统回收，而此时可能活动中还有一些需要使用的临时数据，例如文本框中输入的文字。当活动被回收后，返回该活动会执行onCreate()方法而不是onRestart()，这样的话刚才文本框中输入的文字就会被都没了，因为活动被重建了，严重影响用户体验。</p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><h4 id="1-被回收前保存数据"><a href="#1-被回收前保存数据" class="headerlink" title="1. 被回收前保存数据"></a>1. 被回收前保存数据</h4><p>重写Activity的onSaveInstanceState()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSaveInstanceState</span><span class="hljs-params">(Bundle outState)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onSaveInstanceState(outState);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tempData</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Something you just typed&quot;</span>;<br>    outState.putString(<span class="hljs-string">&quot;data_key&quot;</span>, tempData);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法保证活动被回收之前一定会被调用，因此我们可以通过该方法在活动被回收前保存需要的数据。</p><h4 id="2-重建后恢复数据"><a href="#2-重建后恢复数据" class="headerlink" title="2. 重建后恢复数据"></a>2. 重建后恢复数据</h4><p>在Activity的onCreate()方法中有一个Bundle参数，该参数保存了活动被系统回收前保存的全部数据。在onCreate方法中通过Bundle获取之前保存的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_main);<br><span class="hljs-keyword">if</span>(savedInstanceState != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tempData</span> <span class="hljs-operator">=</span> savedInstanceState.getString(<span class="hljs-string">&quot;data_key&quot;</span>);<br>        <span class="hljs-comment">//do something to resume activity</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h1><blockquote><p>活动共有四种启动模式，通过给&lt;activity&gt;标签指定<code>android:launchMode</code> 属性来选择启动模式。</p></blockquote><h2 id="standard（默认）"><a href="#standard（默认）" class="headerlink" title="standard（默认）"></a>standard（默认）</h2><blockquote><p>每次启动一个Standart活动，都会创建一个该活动的一个新的实例压入返回栈中。</p></blockquote><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/webp.webp" alt="img"></p><h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><blockquote><p>在启动一个singleTop活动的时候，若该活动已经处于栈顶，则会直接使用它，不会再创建一个新的活动实例压入栈顶。若栈顶不是该活动，则会新建一个活动入栈。</p></blockquote><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/webp-16699916444119.webp" alt="img"></p><h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><blockquote><p>在启动一个singleTask活动的时候，若栈中已经存在该活动，则会将该活动上的所有其他活动全部出栈，使该活动处于栈顶。若栈中没有改活动，则会新建一个活动入栈。</p></blockquote><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/webp-166999179717012.webp" alt="img"></p><h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><blockquote><p>在启动一个singleInstance活动时，会启用一个新的返回栈来管理这个活动。</p><p>这样做的意义：若我们程序中的一个活动允许其他程序调用，使用singleInstance模式启动活动可以共享这个活动的实例。因为每个程序都有自己的返回栈，若使用其他三种启动模式，同一个活动在不同的返回栈中入栈必然是创建了一个新的实例，就无法是实现实例共享。而singleInstance模式下会为该活动创建一个单独的返回栈，这样不管哪个应用访问该活动那个，都公用的是用一个返回栈，也就解决了活动实例的共享问题。</p></blockquote><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/webp-166999234506015.webp" alt="img"></p><h1 id="活动使用技巧"><a href="#活动使用技巧" class="headerlink" title="活动使用技巧"></a>活动使用技巧</h1><h2 id="根据界面判断活动"><a href="#根据界面判断活动" class="headerlink" title="根据界面判断活动"></a>根据界面判断活动</h2><blockquote><p>自己写的代码可能清楚界面对应的活动，而在企业中可能接手的是别人写的代码，当需要在某界面上修改一些对应Activity代码是，可能半天找不到对应的活动是哪一个。</p></blockquote><p>写一个BaseActivity，并让所有的Activity都继承自BaseActivity。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br><span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br><span class="hljs-type">Log</span>.d(<span class="hljs-string">&quot;BaseActivity&quot;</span>, getClass().getSimpleName());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样当进入到一个界面的时候，该活动的类名就会被打印出来。</p><h2 id="随时随地退出程序"><a href="#随时随地退出程序" class="headerlink" title="随时随地退出程序"></a>随时随地退出程序</h2><blockquote><p>假设我们正处于栈顶的Activity中，下面还有两个活动，那么若要退出程序，则需要连按3次Back键，按Home键只是回到桌面，程序并没有结束。所以若我们的程序需要一个注销或者退出的功能该怎么办？</p></blockquote><p>解决的办法就是使用一个专门的集合类对所有的活动进行同一管理。</p><ol><li><p>新建一个ActivityCollector用于存储所有活动：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityCollector</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Activity&gt; activities = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addActivity</span><span class="hljs-params">(Activity activity)</span> &#123;<br>        activities.add(activity);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeActivity</span><span class="hljs-params">(Activity activity)</span> &#123;<br>        activities.remove(activity);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(Activity activity : activities) &#123;<br>            <span class="hljs-keyword">if</span> (!activity.isFinishing()) &#123;<br>                activity.finish();<br>            &#125;<br>        &#125;<br>        activities.clear();<br>        <span class="hljs-comment">//杀死当前进程</span><br>        android.os.Process.killProcess(android.os.Process.myPid());<span class="hljs-comment">//KillProcess不能用于杀死其他进程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>在BaseActivity中通过重写onCreate()方法和onDestory()方法，让每个活动都继承它，让每个活动在创建时加入ActivityCollector中，销毁时移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br><span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>Log.d(<span class="hljs-string">&quot;BaseActivity&quot;</span>, getClass().getSimpleName());<br>        <span class="hljs-comment">//将当前活动加入ActivityCollector</span><br>        ActivityCollector.addActivity(<span class="hljs-built_in">this</span>);<br>&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestory();<br>        <span class="hljs-comment">//将当前活动移出ActivityCollector</span><br>        ActivityCollector.removeActivity(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>若要退出程序，额可以直接调用ActivityCollector的finishAll()方法即可。</p></li></ol><h2 id="启动活动的最佳写法"><a href="#启动活动的最佳写法" class="headerlink" title="启动活动的最佳写法"></a>启动活动的最佳写法</h2><blockquote><p>启动一个活动的方法：1. 构建Intent 2.若有参数则将参数存入Intent中 3. 使用startActivity()方法启动活动。</p><p>这种启动活动的方法的问题：若我们要启动一个不是由自己开发的活动，或者开发的活动要提供给别人使用。这个时候，使用者不知道Activity所需要的参数。要么阅读Activity的源码或者和编写者沟通。</p></blockquote><p>通过在Activity中编写一个静态的启动方法，使用该启动方法启动该线程就可以解决上面的问题。</p><p>被调用活动的启动方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseActivity</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionStart</span><span class="hljs-params">(Context context, String data1,String data2)</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(context, SecondActivity.class);<br>        intent.putExtra(<span class="hljs-string">&quot;param1&quot;</span>，data1);<br>        intent.putExtra(<span class="hljs-string">&quot;param2&quot;</span>, data2);<br>        context.startActivity(intent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用者的调用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SecondActivity.actionStart(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;first data&quot;</span>, <span class="hljs-string">&quot;second data&quot;</span>);<br></code></pre></td></tr></table></figure><p>原来Intent的是由调用者构建，这样将Intent构建的任务交给被调用者。调用者通过actionStart方法即可知道启动活动需要的参数。同时还简化了启动活动的代码。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发-总体简介</title>
    <link href="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%80%BB%E4%BD%93%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%80%BB%E4%BD%93%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓系统架构"><a href="#安卓系统架构" class="headerlink" title="安卓系统架构"></a><a href="https://cloud.tencent.com/developer/article/1415759">安卓系统架构</a></h1><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%80%BB%E4%BD%93%E7%AE%80%E4%BB%8B/android-stack_2x.png" alt="Android 软件堆栈"></p><h2 id="1、Linux-内核层"><a href="#1、Linux-内核层" class="headerlink" title="1、Linux 内核层"></a>1、Linux 内核层</h2><blockquote><p>安卓平台的基础是Linux内核。</p></blockquote><ul><li>ART依靠linux内核执行底层功能。例如线程和内存管理。</li><li>硬件制造商在该层为硬件开发底层驱动。</li></ul><h2 id="2、硬件抽象层"><a href="#2、硬件抽象层" class="headerlink" title="2、硬件抽象层"></a>2、硬件抽象层</h2><blockquote><p>硬件抽象层（HAL）提供标准界面，向更高级别的Java API框架显式设备硬件功能。</p></blockquote><p>HAL包含多个库模块，其中每个模块都为特定硬件组件实现一个界面，例如相机、蓝牙模块。当框架API要求访问硬件设备时，系统将为该硬件组件加载库模块。</p><h2 id="3、系统运行时库层"><a href="#3、系统运行时库层" class="headerlink" title="3、系统运行时库层"></a>3、系统运行时库层</h2><blockquote><p>该层包含很多C&#x2F;C++编写的原生库还有Android Runtime。</p></blockquote><h3 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h3><p>每个应用都在其自己的进程中运行，都单独拥有一个ART实例。</p><p>ART编写为通过执行DEX文件来运行多个虚拟机。DEX文件是专为Android设计的字节码格式，经过优化，使用内存很少。编译工具链（如Jack）可以将Java源码编译为DEX字节码，使其在Android平台运行。</p><p>ART的主要功能：</p><ul><li>预先编译（AOT）和即时编译（JIT）</li><li>垃圾回收（GC）</li><li>DEX字节码转化为机器码</li><li>更好的调试支持</li></ul><p>安卓还包含一套核心运行时库，可提供给 Java API 框架 Java 编程语言的大部分功能。</p><h3 id="原生C-x2F-C-库"><a href="#原生C-x2F-C-库" class="headerlink" title="原生C&#x2F;C++库"></a>原生C&#x2F;C++库</h3><p>许多核心Android系统组件和服务（例如ART、HAL）构建自原生代码。Android 平台提供 Java API框架以向应用层提供部分原生库的功能。</p><p>例如，可以通过 Android 框架的 Java OpenGL API 访问 OpenGL ES， 以支持在应用中绘制和操作 2D 和 3D 图形。如果开发的是需要 C&#x2F;C++ 代码的应用，可以使用 Android NDK 直接从原生代码访问某些原生平台库。</p><h2 id="4、API框架层"><a href="#4、API框架层" class="headerlink" title="4、API框架层"></a>4、API框架层</h2><blockquote><p>应用可以调用通过 Java 语言编写的 API 从而使用 Android OS的整个功能集。</p></blockquote><p>这些 API 形成创建 Android 应用所需的构建块，它们可以简化核心模块化系统组件和服务重复使用。</p><p>包含的组件和服务：</p><ul><li><p>视图系统</p><blockquote><p>用于构件应用的UI，包括列表、网格、文本框、按钮以及可嵌入的网络浏览器。</p></blockquote></li><li><p>资源管理器</p><blockquote><p>用于访问非代码资源，例如本地化的字符串、图形和布局文件。</p></blockquote></li><li><p>通知管理器</p><blockquote><p>可让所有应用在状态栏中显式自定义提醒。</p></blockquote></li><li><p>活动管理器</p><blockquote><p>用于管理应用的生命周期，提供常见的导航返回栈。</p></blockquote></li><li><p>内容提供程序</p><blockquote><p>可让应用访问其他应用中的数据，或共享本应用的数据。</p></blockquote></li></ul><h2 id="5、应用层"><a href="#5、应用层" class="headerlink" title="5、应用层"></a>5、应用层</h2><blockquote><p>Android系统自带很多核心应用，例如邮件、短信、日历、浏览器、联系人等。</p></blockquote><p>系统自带应用和第三方应用一样，没有特殊状态。因此可使用一些第三方应用替换系统自带应用，系统应用可作为用户的应用，以及提供开发者访问，例如若第三方软件需要发送短信，可以直接调用系统的短信应用，而无需自己构建该功能。</p><h1 id="安卓应用开发的特色"><a href="#安卓应用开发的特色" class="headerlink" title="安卓应用开发的特色"></a>安卓应用开发的特色</h1><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><ul><li><p>活动（Activity）</p><blockquote><p>活动是安卓应用的门面，在应用中看得见的都放在活动中。</p></blockquote></li><li><p>服务（Service）</p><blockquote><p>服务在后台运行，无法看到，应用退出后仍可以运行。</p></blockquote></li><li><p>广播接收器（Broadcast Receiver）</p><blockquote><p>广播接收器允许应用接收来自各处的广播，例如电话、短信等。同时应用也可以对外发送广播消息。</p></blockquote></li><li><p>内容提供器（Content Provider）</p><blockquote><p>内容提供器为跨应用分享数据提供可能，例如读取系统电话簿应用中的联系人信息。</p></blockquote></li></ul><h2 id="系统控件"><a href="#系统控件" class="headerlink" title="系统控件"></a>系统控件</h2><p>系统提供了丰富的系统控件用于编写界面。同时也可以定制自己的控件使用。</p><h2 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h2><p>安卓系统自带了SQLite数据库。</p><p>其特点：</p><ul><li>轻量化、速度快、嵌入式、关系型数据库</li><li>支持标准SQL语法</li><li>Android封装了API用于操作该数据库</li></ul><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%80%BB%E4%BD%93%E7%AE%80%E4%BB%8B/image-20221202151503735.png" alt="image-20221202151503735"></p><h2 id="基本无需修改文件"><a href="#基本无需修改文件" class="headerlink" title="基本无需修改文件"></a>基本无需修改文件</h2><ul><li><p>.gradle 和 .idea文件夹</p><blockquote><p>由 Android Studio自动生成，无需关心，无需编辑。</p></blockquote></li><li><p>gradle文件夹</p><blockquote><p>包含了 gradle wrapper 的配置文件。Android会根据本地的缓存情况自动决定是否下载 gradle wrapper。默认没有启用 gralde wrapper。</p></blockquote></li><li><p>.gitignore</p><blockquote><p>用于将指定目录或文件排除在版本控制之外。</p></blockquote></li><li><p>build.gradle</p><blockquote><p>项目全局的gredle构建脚本。通常不需要修改。</p></blockquote></li><li><p>gradle.properties</p><blockquote><p>全局的gradle配置文件，这里配置的属性会影响到项目中所有的gradle编译脚本。</p></blockquote></li><li><p>gradlew和gradlew.bat</p><blockquote><p>用于在命令行界面执行gradle命令。</p></blockquote></li><li><p>local.properties</p><blockquote><p>用于指定本机中 Android SDK 路径，通常自动生成，不需要修改。</p></blockquote></li><li><p>settings.gradle</p><blockquote><p>用于指定项目中所有引用的模块。通常情况下模块应用都是自动完成的，需要手动修改的场景较少。</p></blockquote></li></ul><h2 id="app文件夹"><a href="#app文件夹" class="headerlink" title="app文件夹"></a>app文件夹</h2><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%80%BB%E4%BD%93%E7%AE%80%E4%BB%8B/image-20221202153942362.png" alt="image-20221202153942362"></p><h3 id="基本无需修改文件-1"><a href="#基本无需修改文件-1" class="headerlink" title="基本无需修改文件"></a>基本无需修改文件</h3><ul><li><p>build文件夹</p><blockquote><p>类似于外层builde目录，包含一些编译时自动生成的文件。</p></blockquote></li><li><p>libs文件夹</p><blockquote><p>项目中使用到的第三方jar包放在该目录下。在该目录中的jar包会被自动添加到构建路径中。</p></blockquote></li><li><p>.gitignore</p><blockquote><p>同外层.gitignore文件一样，该文件用于将app模块中指定的目录或文件排除在版本控制之外。</p></blockquote></li><li><p>proguard-rules.pro</p><blockquote><p>用于指定项目代码混淆规则，防止代码被破解。</p></blockquote></li></ul><h3 id="src文件夹"><a href="#src文件夹" class="headerlink" title="src文件夹"></a>src文件夹</h3><p><img src="/2022/12/02/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%80%BB%E4%BD%93%E7%AE%80%E4%BB%8B/image-20221202154757132.png" alt="image-20221202154757132"></p><h4 id="androidTest-和test-文件夹"><a href="#androidTest-和test-文件夹" class="headerlink" title="androidTest 和test 文件夹"></a>androidTest 和test 文件夹</h4><blockquote><p>这两个目录用于存放编写的测试用例，一个是Android test测试用例，一个是Unit test测试用例。</p></blockquote><h4 id="main-文件夹"><a href="#main-文件夹" class="headerlink" title="main 文件夹"></a>main 文件夹</h4><blockquote><p>该文件夹中存放的就是我们真正编写的安卓应用代码。</p></blockquote><h5 id="1-java"><a href="#1-java" class="headerlink" title="1. java"></a>1. java</h5><blockquote><p>此处就是用于存放我们所有的Java代码。</p></blockquote><h5 id="2-res"><a href="#2-res" class="headerlink" title="2. res"></a>2. res</h5><blockquote><p>此处用于存放项目中使用到的资源。</p></blockquote><p>包含的文件夹内容：</p><ul><li>layout：布局文件</li><li>values：字符串、样式、主题等配置</li><li>drawable：图片</li><li>mipmap：应用图标</li><li>dpi后缀文件夹：设备适配（一般使用xxhdpi）</li></ul><p>res中的的文件基本都是xml文件，例如res&#x2F;values&#x2F;string.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引用res中资源的方式：</p><ul><li>在Java代码中引用：通过<code>R.string.app_name</code>可获取上面字符串的引用。</li><li>在XML文件中引用：通过<code>@string/app_name</code>可获取上面字符串的引用。</li></ul><p>其中的string可以替换为drawable、mipmap、layout用于引用图片、图标、布局。</p><h5 id="3-AndroidManifest-xml"><a href="#3-AndroidManifest-xml" class="headerlink" title="3. AndroidManifest.xml"></a>3. AndroidManifest.xml</h5><blockquote><p>Android项目的配置文件。</p></blockquote><ul><li>在项目中定义的四大组件需要在该文件中注册</li><li>应用的所需权限在该文件中声明</li></ul><h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><blockquote><p>Android Studio 使用 Gradle 来构建项目。Gradle是一种给长先进的项目构建工具，基于Groovy的领域特定语言来声明项目设置，摒弃了传统基于XML（如Maven）的各种繁琐配置。</p></blockquote><p>外层的build.gradle:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 应用插件</span><br>plugins &#123;<br>    id <span class="hljs-string">&#x27;com.android.application&#x27;</span> version <span class="hljs-string">&#x27;7.3.1&#x27;</span> apply <span class="hljs-literal">false</span><span class="hljs-comment">// 应用程序模块，可直接运行</span><br>    id <span class="hljs-string">&#x27;com.android.library&#x27;</span> version <span class="hljs-string">&#x27;7.3.1&#x27;</span> apply <span class="hljs-literal">false</span><span class="hljs-comment">//库模块，依附于应用程序模块与逆行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内层的build.gradle:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 配置项目构建的各个属性</span><br>android &#123;<br>    namespace <span class="hljs-string">&#x27;com.xy.materialdesign&#x27;</span><br>    compileSdk <span class="hljs-number">32</span><span class="hljs-comment">// 用于编译的SDK版本</span><br><br>    <span class="hljs-comment">// 项目细节配置</span><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&quot;com.xy.materialdesign&quot;</span><span class="hljs-comment">// 项目包名</span><br>        minSdk <span class="hljs-number">21</span><span class="hljs-comment">// 最低兼容安卓版本</span><br>        targetSdk <span class="hljs-number">32</span><span class="hljs-comment">// 目标兼容安卓版本（高于该版本的功能和特性不会开启）</span><br>        versionCode <span class="hljs-number">1</span><span class="hljs-comment">// 版本号</span><br>        versionName <span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-comment">// 版本名称</span><br><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 指定生成安装文件的配置</span><br>    buildTypes &#123;<br>        <span class="hljs-comment">// 除了release还可以有一个debug闭包，用于指定测试版安装文件配置</span><br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><span class="hljs-comment">// 是否开启代码混淆</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span> <span class="hljs-comment">// 混淆时使用的规则文件</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 编译配置</span><br>    compileOptions &#123;<br>        sourceCompatibility JavaVersion.VERSION_1_8<br>        targetCompatibility JavaVersion.VERSION_1_8<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 指定项目的依赖关系，有三种依赖方式：远程依赖、本地依赖、库依赖</span><br>dependencies &#123;<br>    <span class="hljs-comment">// 远程依赖格式 &#x27;域名:组名:版本号&#x27;</span><br>    implementation <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.4.1&#x27;</span><br>    <span class="hljs-comment">// 本地依赖格式 fileTree(dit: &#x27;目录&#x27;, include: [&#x27;过滤格式&#x27;])</span><br>    implementation fileTree(<span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br>    <span class="hljs-comment">// 库依赖格式 project(&#x27;:库名称&#x27;)</span><br>    implementation project(<span class="hljs-string">&#x27;:mylibrary&#x27;</span>)<br>    <br>    <span class="hljs-comment">// 测试依赖</span><br>    testImplementation <span class="hljs-string">&#x27;junit:junit:4.13.2&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h1><blockquote><p>安卓提供的日志工具时Log（android.util.Log）。</p></blockquote><p>Log提供了五种方法用于打印日志，分别对应不同的日志级别：</p><ul><li><p>Log.v()</p><blockquote><p>verbose：用于打印最为琐碎、意义最小的日志信息。</p></blockquote></li><li><p>Log.d()</p><blockquote><p>debug：用于打印一些对调试程序和分析问题有用的调试信息。</p></blockquote></li><li><p>Log.i()</p><blockquote><p>important：用于打印一些比较重要的数据。这些数据应该是你想要看到的、可以帮助你分析用户行为的数据。</p></blockquote></li><li><p>Log.w()</p><blockquote><p>用于打印一些警告信息。提示程序潜在的风险，最好去修复出现警告的地方。</p></blockquote></li><li><p>Log.e()</p><blockquote><p>用于打印程序中的错误信息。当出现错误信息时（例如进入catch块），一般代表程序出现严重问题，必须尽快修复。</p></blockquote></li></ul><p>方法所需的参数：</p><ul><li>String tag：一般传入当前类名即可，主要用于对打印信息进行过滤。</li><li>String msg：传入想要打印的具体内容。</li></ul><p>Log的快捷使用：</p><ul><li>在java类中输入logt，再按下Tab键，就会以当前类名生成一个TAG常量。</li><li>输入logd，再按下Tab键，会自动补全一条log语句，tag参数默认是TAG常量。</li></ul><p>为什么不使用 System.out.println 打印日志?</p><p>因为除了方便之外，全是缺点：</p><ul><li>日志打印不可控</li><li>打印时间无法确定</li><li>不能添加过滤器</li><li>日志没有级别区分</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络模型</title>
    <link href="/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络模型简介"><a href="#网络模型简介" class="headerlink" title="网络模型简介"></a>网络模型简介</h1><p>当前存在三种划分网络模型的方式：</p><ul><li>OSI七层模型</li><li>TCP&#x2F;IP四层模型</li><li>五层模型</li></ul><p><img src="/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/webp.webp" alt="img"></p><p>互联网在层次化后，只要将各层之间的接口规划好，每个层内部的设计就能够自由改动。在网络开发中经常遇到各种协议，不同的协议在不同的层次当中，在一个层次中子需要关心在该层中的设计。</p><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><blockquote><p>OSI模型由国际化标准组织在1984年提出，试图使各种计算机在世界范围内互联为网络的标准框架。</p></blockquote><p>OSI模型是一个七层体系架构，每层有特定功能。七层协同工作，将数据从一个设备传输到另一个设备。</p><p><img src="/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/webp-16697207049467.webp" alt="img"></p><h2 id="第七层：应用层（Application-Layer）"><a href="#第七层：应用层（Application-Layer）" class="headerlink" title="第七层：应用层（Application Layer）"></a>第七层：应用层（Application Layer）</h2><blockquote><p>OSI模型的最顶层，应用层是app访问网络、向用户显示接收到信息的窗口。</p></blockquote><p>应用层功能如下：</p><ul><li>网络虚拟终端</li><li>FTAM-File传输的访问与管理</li><li>邮件服务</li><li>目录服务</li></ul><h2 id="第六层：表示层（Presentation-Layer）"><a href="#第六层：表示层（Presentation-Layer）" class="headerlink" title="第六层：表示层（Presentation Layer）"></a>第六层：表示层（Presentation Layer）</h2><blockquote><p>表示层也成为转换层（translation layer）。在表示层提取应用层的数据，并根据需要转换格式，以便通过网络传输。</p></blockquote><p>表示层功能如下：</p><ul><li>转换</li><li>加密、解密</li><li>压缩</li></ul><h2 id="第五层：会话层（Session-Layer）"><a href="#第五层：会话层（Session-Layer）" class="headerlink" title="第五层：会话层（Session Layer）"></a>第五层：会话层（Session Layer）</h2><blockquote><p>会话层负责建立连接，维护会话、认证，并确保安全。</p><p>会话层中的数据称为message（消息）。</p></blockquote><p>会话层的功能如下：</p><ul><li>建立、维护、终止会话</li><li>同步：会话层允许进程向数据中添加同步点，用于定位错误，避免数据丢失</li><li>对话控制：会话层允许两个系统以半双工或全双共方式互相通信</li></ul><h2 id="第四层：传输层（Transport-Layer）"><a href="#第四层：传输层（Transport-Layer）" class="headerlink" title="第四层：传输层（Transport Layer）"></a>第四层：传输层（Transport Layer）</h2><blockquote><p>传输层从网络层获取服务，并向应用层提供服务。传输层提供端到端的消息传递服务，发送成功后返回确认、数据出错后重发的功能。</p><p>传输层由操作系统管理，是OSI模型的核心。传输层中的数据称为segments（段）。</p></blockquote><p>传输层的两个不同性质的协议：</p><ul><li>TCP（Transmission Control Protocol，传输控制协议）：面向链接，是byte stream<ul><li>数据按顺序到达</li><li>数据最小错误</li><li>重复数据丢弃</li><li>缺失数据重发</li><li>流量拥塞控制</li></ul></li><li>UDP（User Data Protocol，用户数据报协议）：无连接，不可靠<ul><li>使用弱校验和算法检查错误</li><li>适用于对实时性要求高，可靠性要求低的流媒体（音视频），或者建立可靠连接消耗太大的简单查询，如DNS解析。</li></ul></li></ul><p>传输层的功能如下：</p><ul><li><p>分段和重组（segmentation and reassembly）</p><blockquote><p>在发送端：传输层从session layer接收message，将message分割为segment，每个segment都关联一个header。</p><p>在目标端：传输层根据segment的header重组message。</p></blockquote></li><li><p>服务点寻址（service point addressing）</p><blockquote><p>为了将消息传递给正确的进程，header中包含service point addressing或 port address。</p></blockquote></li></ul><h2 id="第三层：网络层（Network-Layer）"><a href="#第三层：网络层（Network-Layer）" class="headerlink" title="第三层：网络层（Network Layer）"></a>第三层：网络层（Network Layer）</h2><blockquote><p>网络层用于将数据从一台主机传输到位于不同网络中的另一台主机。</p><p>网络层中的数据称为packet（包）。</p></blockquote><p>网络层的功能如下：</p><ul><li><p>路由（routing）</p><blockquote><p>网络层协议决定从源地址到目的地址选取那条线路</p></blockquote></li><li><p>逻辑寻址（logical addressing）</p><blockquote><p>为唯一地标识互联网上的设备，网络层定义了一种寻址方式：IP协议。发送者和接收者的IP地址由网络层放置到header中</p></blockquote></li></ul><h2 id="第二层：链路层（Data-Link-layer）"><a href="#第二层：链路层（Data-Link-layer）" class="headerlink" title="第二层：链路层（Data Link layer）"></a>第二层：链路层（Data Link layer）</h2><blockquote><p>数据链路层负责节点到节点的消息传递，该层的主要功能是确保在物理层上的一个节点到另一个节点正确传输数据。当数据包到达时，DDL使用MAC地址传输给目标主机。</p><p>链路层中的数据成为frame（帧）。</p></blockquote><p>数据链路层被划分为两个子层：</p><ul><li><p>逻辑链路控制 LLC（Logical Link Control）</p><blockquote><p>从网络层接收的数据包（packet）根据网卡的帧大小进一步分割为数据帧（frame）。DLL在发送方、接收方的header中封装了MAC地址。</p></blockquote></li><li><p>媒体访问控制 MAC（Media Access Control）</p><blockquote><p>通过地址解析协议 ARP（Address Resolution Protocol），可以获取拥有指定IP地址目标主机的MAC地址。</p></blockquote></li></ul><p>链路层的功能如下：</p><ul><li><p>封装帧（framing）</p><blockquote><p>它为发送方提供了一种对接收方有意义的一组比特，其通过将特殊的位模式附加到帧的开头和结尾来实现。</p></blockquote></li><li><p>物理寻址（physical addressing）</p><blockquote><p>创建帧后，链路层为每一帧添加发送方、接收方的MAC地址</p></blockquote></li><li><p>错误控制（error control）</p><blockquote><p>链路层的错误控制机制会检测、重发丢失或损坏的帧</p></blockquote></li><li><p>流控制（flow control）</p><blockquote><p>双方的速率必须保持恒定，否则数据可能会被损坏。Flow control协调在收到确认之前可发送的数据量。</p></blockquote></li><li><p>访问控制（access control）</p><blockquote><p>多个设备共享一个通信通道时，MAC子层用于确定时间哪个设备可以控制给通道</p></blockquote></li></ul><h2 id="第一层：物理层（Physical-Layer）"><a href="#第一层：物理层（Physical-Layer）" class="headerlink" title="第一层：物理层（Physical Layer）"></a>第一层：物理层（Physical Layer）</h2><blockquote><p>OSI参考模型的最底层是物理层。物理层负责在设备和设备传输介质之间传输、接收非结构化数据，它将数字bits转换为点、无线电、光等信号。规范定义了电压、电压变化时间、物理速率、最大传输距离等。</p><p>物理层中的数据是bit（比特）</p></blockquote><p>物理层负责将单个bits从一个节点传输到下一个节点。当接收数据时，物理层将接收信号（电、光等）并将其转换为0和1，并发送给链路层。</p><p><img src="/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/webp-166972449048610.webp" alt="img"></p><p>物理层的功能如下：</p><ul><li><p>比特同步（bit synchronization）</p><blockquote><p>物理层通过提供原子钟，实现发送、接收比特同步</p></blockquote></li><li><p>比特率控制（bit rate control）</p><blockquote><p>物理层定义了传输控制，决定每秒发送数据量</p></blockquote></li><li><p>物理拓扑（phyical topologies）</p><blockquote><p>物理层指定在网络中排列不同设备、节点的方式，如总线、星型或网状拓扑。</p></blockquote></li><li><p>传输模式（transmission mode）</p><blockquote><p>物理层还定义了两个连接设备间数据传输方式，如：</p><ul><li>单工（simplex）：数据单向传输</li><li>半双工（half-duplex）：数据双向传输，但不能同时传输</li><li>全双工（duplex）：数据双向传输，且能同时传输</li></ul></blockquote></li></ul><h1 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h1><blockquote><p>OSI模型是一个参考&#x2F;逻辑模型，它旨在通过将通信过程分为更小、更简单的组件来描述通信系统的功能。TCP&#x2F;IC是Transmission Control Protocol&#x2F;Internet Protocol协议的缩写。</p></blockquote><p>TCP&#x2F;IP四层模型包含以下四层：</p><ul><li>应用层（Application Layer）</li><li>传输层（Transport Layer&#x2F;Host-to-Host）</li><li>网络层（Internet Layer）</li><li>网络接口层（Network Interface）</li></ul><p><img src="/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/webp-166972868064413.webp" alt="img"></p><h2 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h2><blockquote><p>TCP&#x2F;IP模型中的应用层OSI模型中application layer、presentation layer、session layer三层。负责节点到节点的通信，并控制用户界面。</p></blockquote><p>应用层的主要协议：</p><ul><li>HTTP&#x2F;HTTPS：Hypertext Transfer Protocol（超文本传输协议）</li><li>FTP&#x2F;TFTP：File Transfer Protocol（文件传输协议）</li><li>Telnet：Teletype Network（虚拟终端）</li><li>SSH：Secure Shell Protocol（加密网络传输协议）</li><li>SMTP：Simple Mail Transfer Protocol（简单邮件传输协议）</li><li>SNMP：Simple Network Management Protocol（简单网络管理协议）</li><li>DNS：Domain Name System（域名系统）</li></ul><h2 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h2><blockquote><p>TCP&#x2F;IP模型中的应用层对应OS模型中的transport layer。负责端到端数据传输和错误控制。</p></blockquote><p>传输层的主要协议：</p><ul><li>TCP：Transport Control Protocol（传输控制协议）</li><li>UDP：User Datagram Protocol（用户数据报协议）</li></ul><h2 id="网络层（Internet-Layer）"><a href="#网络层（Internet-Layer）" class="headerlink" title="网络层（Internet Layer）"></a>网络层（Internet Layer）</h2><blockquote><p>TCP&#x2F;IP模型中的网络层与OSI模型中的网络层对应。定义了数据逻辑传输的协议。</p></blockquote><p>网络层的主要协议：</p><ul><li>IP：Internet Protocol（计算机网络地址）</li><li>ICMP：Internet Control Message Protocol（互联网控制消息协议）</li><li>ARP：Address Resolution Protocol（地址解析协议）</li></ul><h2 id="网络接口层（Network-Interface）"><a href="#网络接口层（Network-Interface）" class="headerlink" title="网络接口层（Network Interface）"></a>网络接口层（Network Interface）</h2><blockquote><p>TCP&#x2F;IP模型中的network interface对应OSI model中的data link和physical。网络接口层进行硬件寻址、物理传输数据。</p></blockquote><h1 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h1><blockquote><p>虽然OSI模型由国际标准组织制定，但其实现过于复杂，制定周期过长，在其整套标准推出之前，TCP&#x2F;IP模型已经在全球范围内被广泛使用，因此，TCP&#x2F;IP模型才是事实上的标准。</p></blockquote><p>TCP&#x2F;IP模型定义了应用层、传输层、网际层、网络接口层层，但并没有给出接口层的具体实现。因此，通常将网络接口层替换为OSI七层模型中的数据链路层和物理层，这就是五层网络模型：</p><p><img src="/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/webp.webp" alt="img"></p><h1 id="网络传输中的数据处理"><a href="#网络传输中的数据处理" class="headerlink" title="网络传输中的数据处理"></a>网络传输中的数据处理</h1><blockquote><p>在分层系统中，层之间使用不同格式交换数据，被称为协议数据单元（Protocol data unit，缩写为PDU）。</p></blockquote><p>不同层之间PDU：</p><p><img src="/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/webp-166973218102618.webp" alt="img"></p><p>当用户请求访问网站时，服务器把请求的数据传递给application layer。此时，从上层至下层根据约定执行相应操作，数据通过物理层传递给接收者。接收者收到数据后，从底层向上传输，每层执行相应功能，直到发送给对应app。</p><p><img src="/2022/11/29/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/webp-166973248795821.webp" alt="img"></p><p>从上层向下层传输过程中，每层会为PDU添加header、footer，用以指导、标记packet，这个过程称为封装。Header、footer和data共同构成下一层的PDU。整个过程持续到底层，即physical layer或network access layer，数据从这一层传输给接收者。接收者处理过程相反，每层根据header、footer解封数据，直到所有数据接收、处理完毕。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池的创建</title>
    <link href="/2022/11/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <url>/2022/11/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h1><blockquote><p>线程池（ThreadPool）是一种基于池化思想管理和使用线程的机制。它是将多个线程预先存储在一个“池子”内，当有任务出现时可以避免重新创建和销毁线程所带来性能开销，只需要从“池子”内取出相应的线程执行对应的任务即可。</p></blockquote><p>池化思想的应用：</p><ul><li>内存池：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ul><p>线程池的优势：</p><ul><li><p>降低资源消耗</p><blockquote><p>通过池化技术重复利用已创建的线程，降低线程创建和销毁所造成的损耗。</p></blockquote></li><li><p>提高响应速度</p><blockquote><p>任务到达时，无需等待线程创建即可立即执行。</p></blockquote></li><li><p>提高线程的可管理性</p><blockquote><p>线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</p></blockquote></li><li><p>提供更多扩展功能</p><blockquote><p>线程池具备可扩展性，允许开发人员向其中增加更多的功能。比如延时定时线程池，允许任务延期执行或定期执行。</p></blockquote></li></ul><p>《java开发手册》中强制规定：线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><p>说明：线程池的好处在于减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。若不使用线程池，有可能造成系统创建大量同类线程而导致内存消耗完或者”过度切换“的问题。</p><h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><p>线程池的创建主要分为两类：</p><ol><li><p>通过ThreadPoolExecutor创建的线程池</p><blockquote><p>最原始的创建线程池的方式，它包含7个参数可供设置。</p></blockquote></li><li><p>通过Executors创建的线程池</p><blockquote><p>通过该工具类的静态方法获取线程池，它通过ThreadPoolExecutor，预设不同的参数创建不同的线程池。</p></blockquote></li></ol><h1 id="各线程池的详细介绍"><a href="#各线程池的详细介绍" class="headerlink" title="各线程池的详细介绍"></a>各线程池的详细介绍</h1><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h3><p>其构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>七个参数的含义：</p><ol><li><p>corePoolSize（核心线程数）</p><blockquote><p>线程池中始终存活的线程数。</p></blockquote></li><li><p>maximumPoolSize（最大线程数）</p><blockquote><p>线程池中允许的最大线程数，当线程池的任务队列满了之后可以创建的最大线程数。</p></blockquote></li><li><p>keepAliveTime（最大线程数可存活时间）</p><blockquote><p>当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。</p></blockquote></li><li><p>unit（存活时间单位）</p><blockquote><p>配合keepAliveTime使用，二者一起用于设定线程存活时间。</p><p>可选的7种参数：</p><ul><li>TimeUnit.DAYS：天</li><li>TimeUnit.HOURS：小时</li><li>TimeUnit.MINUTES：分</li><li>TimeUnit.SECONDS：秒</li><li>TimeUnit.MILLISECONDS：毫秒</li><li>TimeUnit.MICROSECONDS：微秒</li><li>TimeUnit.NANOSECONDS：纳秒</li></ul></blockquote></li><li><p>workQueue（阻塞队列）</p><blockquote><p>用来存储线程池等待执行的任务，均为线程安全的阻塞队列。线程池的排队策略与所选择的BlockingQueue有关。</p><p>可选的7种类型：</p><ul><li>ArrayBlockingQueue：数组结构、有界阻塞队列</li><li><strong>LinkedBlockingQueue</strong>：链表结构、有界阻塞队列</li><li><strong>SynchronousQueue</strong>：不存储元素</li><li>PriorityBlockingQueue：支持优先级、无界阻塞队列</li><li>DelayQueue：使用优先级队列实现、延迟期满后才能获取元素、无界阻塞队列</li><li>LinkedTransferQueue：链表结构、无界阻塞队列、与SynchronousQueue类似、含有非阻塞方法</li><li>LinkedBlockingDequeue：链表结构、双向阻塞队列</li></ul></blockquote></li><li><p>threadFactory（线程工厂）</p><blockquote><p>用于创建线程。默认为正常优先级、非守护线程。</p></blockquote></li><li><p>hander（拒绝则略）</p><blockquote><p>拒绝处理任务时的策略。</p><p>可选的4种策略：</p><ul><li><strong>AbortPolicy</strong>：拒绝并抛出异常</li><li>DiscardPolicy：忽略并抛弃当前任务</li><li>CallerRunsRolicy：使用当前调用的线程来执行此任务</li><li>DiscardOldestPolicy：抛弃队列头部（最老）的一个任务，并执行当前任务</li></ul></blockquote></li></ol><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>几个关键节点：</p><ul><li>当线程数小于核心线程数：创建线程</li><li>当线程数大于等于核心线程数，且任务队列未满：将任务放入任务队列</li><li>当线程数大于等于核心线程数，且任务队列已满：<ul><li>若线程数小于最大线程数：创建线程</li><li>若线程数大于最大线程数：执行拒绝策略</li></ul></li></ul><p>![image.png](线程池的创建&#x2F;1608131630859-4e5632bf-3c2f-4856-8ee1-6ed2b7ef0f0b.png#align&#x3D;left&amp;display&#x3D;inline&amp;height&#x3D;543&amp;margin&#x3D;[object Object]&amp;name&#x3D;image.png)</p><h3 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h3><p>使用new即可创建一个RejectedExecutionHandler，然后重写其rejectedExecution方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,TimeUnit.SECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>                           <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionHandler</span>() &#123;<br>                               <span class="hljs-meta">@Override</span><br>                               <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r,ThreadPoolExecutor executor)</span> &#123;<br>                                   <span class="hljs-comment">// 执行自定义拒绝策略的相关操作</span><br>                                   System.out.println(<span class="hljs-string">&quot;我是自定义拒绝策略~&quot;</span>);<br>                               &#125;<br>                           &#125;);<br></code></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><h3 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1. FixedThreadPool"></a>1. FixedThreadPool</h3><blockquote><p>创建一个固定大小的线程池。可控制并发的线程数，超出的线程会在队列中等待。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数：nThreads</li><li>最大线程数：nThreads</li><li>存活时间：0秒</li><li>阻塞队列：LinkedBlockingQueue</li></ul><h3 id="2-CachedThreadPool"><a href="#2-CachedThreadPool" class="headerlink" title="2. CachedThreadPool"></a>2. CachedThreadPool</h3><blockquote><p>创建一个可缓存的线程池，若线程超过处理所需，缓存一段时间后回收，若线程不够，则新建线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                      threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数：0</li><li>最大线程数：无限制</li><li>存活时间：60秒</li><li>阻塞队列：SynchronousQueue</li></ul><h3 id="3-SingleThreadExecutor"><a href="#3-SingleThreadExecutor" class="headerlink" title="3. SingleThreadExecutor"></a>3. SingleThreadExecutor</h3><blockquote><p>创建单个线程池，它可以保证先进先出的执行顺序。</p><p>单线程池的意义：提供了工作队列，生命周期管理，工作线程维护等功能</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                    threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数：1</li><li>最大线程数：1</li><li>存活时间：0秒</li><li>阻塞队列：LinkedBlockingQueue</li></ul><h3 id="4-ScheduledThreadPool"><a href="#4-ScheduledThreadPool" class="headerlink" title="4. ScheduledThreadPool"></a>4. ScheduledThreadPool</h3><blockquote><p>创建一个可以执行延迟任务的线程池</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-SingleThreadScheduledExecutor"><a href="#5-SingleThreadScheduledExecutor" class="headerlink" title="5. SingleThreadScheduledExecutor"></a>5. SingleThreadScheduledExecutor</h3><blockquote><p>创建一个单线程的可以执行延迟任务的线程池</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newSingleThreadScheduledExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatedScheduledExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newSingleThreadScheduledExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatedScheduledExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-newWorkStealingPool"><a href="#6-newWorkStealingPool" class="headerlink" title="6. newWorkStealingPool"></a>6. newWorkStealingPool</h3><blockquote><p>创建一个抢占式执行的线程池（任务执行顺序不确定）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span><br>            (parallelism,<br>             ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>             <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span><br>            (Runtime.getRuntime().availableProcessors(),<br>             ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>             <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池的选择"><a href="#线程池的选择" class="headerlink" title="线程池的选择"></a>线程池的选择</h2><p>《Java开发手册》中强制要求：不允许使用Executors创建线程池，而是通过ThreadPoolExecutor的方式。</p><ul><li>使用ThreadPoolExecutor来创建线程池，让创建线程池的时候更加明确线程池的运行规则，避免资源耗尽的风险。</li></ul><p>使用Executors返回的线程池对象的弊端：</p><ul><li><p>FixedThreadPool和SingleThreadPool</p><blockquote><p>允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</p></blockquote></li><li><p>CachedThreadPool</p><blockquote><p>允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM</p></blockquote></li></ul><p>综上：推荐使用ThreadPoolExecutor的方式创建线程池。因为使用这种方式创建的线程池更可控，线程池的运行规则更明确，可以规避一些未知风险。</p><p><strong>参考</strong>：<a href="https://www.cnblogs.com/vipstone/p/14149065.html">https://www.cnblogs.com/vipstone/p/14149065.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-垃圾回收</title>
    <link href="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Java垃圾回收基础知识"><a href="#Java垃圾回收基础知识" class="headerlink" title="Java垃圾回收基础知识"></a>Java垃圾回收基础知识</h1><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="判断对象是否可回收的算法"><a href="#判断对象是否可回收的算法" class="headerlink" title="判断对象是否可回收的算法"></a>判断对象是否可回收的算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><blockquote><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1，引用计数器为0时对象可被回收。</p></blockquote><p>存在的问题：当两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。</p><p>因为循环引用的问题，因此Java虚拟机不使用引用计数算法。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote><p>通过GC Root作为起始点进行搜索，能够达到的对象都是存活的，不可达到的对象都是可被回收的。</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/0635cbe8.png" alt="image"></p><p>Java虚拟机使用该算法来判断对象是否可被回收。</p><p>在Java中GC Roots一般包含以下内容：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><blockquote><p>无论是通过引用计数算法判断引用对象的数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p></blockquote><p>Java有四种不同强度的引用类型：</p><ul><li><p>强引用：不会被回收</p><blockquote><p>被强引用关联的对象不会被回收。</p><p>使用new一个新对象的方式来建立强引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure></blockquote></li><li><p>软引用：内存不足时被回收</p><blockquote><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用SoftReference类来创建软引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 使对象只被软引用关联</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>弱引用：在下一次垃圾回收时被回收</p><blockquote><p>被弱引用关联的对象一定会被回收，也就是它只能存活到下一次垃圾回收发生之前。</p><p>使用WeakReference 类来实现弱引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>WeakReference&lt;Object&gt; wf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>虚引用：在被回收时收到一个系统通知</p><blockquote><p>虚引用又被称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用PhantomReference来实现虚引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>PhantomReference&lt;Object&gt; pf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><blockquote><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区进行回收性价比不高。方法区的回收主要是对常量池的回收和对类的卸载。</p></blockquote><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p><p>可以通过<code>-Xnoclassgc</code> 参数来控制是否对类进行卸载。</p><p>类卸载的条件比较苛刻，必须满足的三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><blockquote><p>finalize()用来做关闭外部资源等工作，但try-finally等方式可以做的更好，而且finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p></blockquote><p>当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了finalize()方法自救，后面回收时不会再调用finalize()方法。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记-清除"></a>1. 标记-清除</h3><blockquote><p>将存活的对象进行标记，然后清理掉未被标记的对象。</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="image"></p><p>不足：</p><ul><li>标记和清除的过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存</li></ul><h3 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记-整理"></a>2. 标记-整理</h3><blockquote><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" alt="image"></p><h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3. 复制算法"></a>3. 复制算法</h3><blockquote><p>将内存划分为大小相等的两块，每次只使用其中一块，当这块内存用完后就将其中还存活的对象复制到另一块上面，然后再将使用过的内存空间进行一次清理。</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" alt="image"></p><p>不足：只使用了内存的一半。</p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><blockquote><p>现在的商业虚拟机都采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p></blockquote><p>一般将堆分为新生代和老年代：</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记-清除&#x2F;标记整理</li></ul><p>新生代使用的复制算法不是简单的将新生代划分为两个大小相等的两块，而是分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中一块Survivor。在回收时，将Eden和Survivor中还存活着的对象一次性复制到另一块Survivor空间上，最后清理Eden和使用过的那块Survivor。</p><p>HotSpot虚拟机的Eden和Survivor的大小比例默认为8：1，保证内存的利用率达到90%。如果回收存活的对象占用内存大于10%，那么Survivor空间就存不下这些对象，此时就需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>下面是HotSpot虚拟机中的7个垃圾收集器，连线表示二者可以配合使用：</p><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="image"></p><p>两个关于垃圾收集器的基本概念</p><ul><li><p>单线程与多线程</p><blockquote><p>单线程指的是垃圾收集器只能使用一个线程进行收集，而多线程使用多个线程。</p></blockquote></li><li><p>串行与并行</p><blockquote><p>串行指的是垃圾收集器与用户程序交替执行，着意味着在执行垃圾收集的时候需要暂停用户程序。并行指的是垃圾收集器和用户程序同时执行。</p><p>除了CMS和G1外，其他垃圾收集器都是以串行的方式执行。</p></blockquote></li></ul><h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><blockquote><p>串行、单线程</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="image"></p><p>它的优点是简单高效，对于单CPU环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是Client模式下的默认新生代收集器。因为在用户的桌面场景下，分配个虚拟机管理的内存很小，Serial收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在100多毫秒以内，只要不是很频繁，这点停顿是可以接受的。</p><h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h3><blockquote><p>是Serial收集器的多线程版本</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="image"></p><p>是Server模式下的的默认新生代收集器。除了性能原因外，主要是因为除了Serial收集器，只有它能与CMS收集器配合工作。</p><p>默认开启的线程数量和CPU数量相同，可以使用<code>-XX:ParallelGCThreads</code>参数来设置线程数。</p><h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h3><blockquote><p>与ParNew一样是多线程收集器，它的目标是达到一个可控制的吞吐量。</p></blockquote><p>其他收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标时达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指的时CPU用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间换来的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开GC自适应的调节策略。这样就不需要手动指定新生代大小、Eden和Survivor区的比例、晋升老年代对象年龄等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h3><blockquote><p>Serial收集器的老年代版本</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="image"></p><p>Client模式下默认的老年代收集器。</p><p>若是在Server模式下使用，它有两大功能：</p><ul><li>在JDK1.5及之前版本（Parallel Old诞生以前），与Parallel Scavenge收集器搭配使用</li><li>作为CMS收集器的后背预案，在并发收集发生Concurrent Mode Failure时使用</li></ul><h3 id="5-Paralled-Old-收集器"><a href="#5-Paralled-Old-收集器" class="headerlink" title="5. Paralled Old 收集器"></a>5. Paralled Old 收集器</h3><blockquote><p>是Paralled Scavenge收集器的老年代版本。</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="image"></p><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge + Paralled Old的组合。</p><h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h3><blockquote><p>CMS（Concurrent Mark Sweep），多线程、标记-清除算法。</p></blockquote><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="image"></p><p>CMS垃圾收集分为以下四个流程：</p><ol><li><p>初始标记（停顿）</p><blockquote><p>仅仅只是标记一下 GC Roots 能直接关联到的对象，速度快很，需要停顿。</p></blockquote></li><li><p>并发标记</p><blockquote><p>进行 GC Roots Tracing 的过程，它在整个回收中耗时最长，但是不需要停顿。</p></blockquote></li><li><p>重新标记（停顿）</p><blockquote><p>为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要停顿。</p></blockquote></li><li><p>并发清除</p><blockquote><p>清除被标记为垃圾的对象，不需要停顿。</p></blockquote></li></ol><p>CMS垃圾收集器的缺点：</p><ul><li><p>吞吐量低</p><blockquote><p>低停顿是以牺牲吞吐量为代价的，导致CPU利用率不够高。</p></blockquote></li><li><p>无法出现浮动垃圾，可能出现Concurrent Mode Failure。</p><blockquote><p>浮动垃圾指的是在并发清除阶段由于用户线程继续运行而产生的垃圾。而这部分垃圾只能到下一次GC时才能回收，所以CMS需要留部分内存用于存放浮动垃圾，如果预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将临时启用Serial Old来替代CMS。</p></blockquote></li><li><p>标记-清除算法导致空间碎片</p><blockquote><p> CMS采用的是标记-清除算法，由于该算法会导致产生空间碎片，所以往往会出现老年代空间充足，但却无法找到足够大的连续内存来分配对象，这样就不得不提前触发一次Full GC。</p></blockquote></li></ul><h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><blockquote><p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。HotSpot开发团队赋予它的使命是未来替换掉CMS收集器。</p></blockquote><p>堆被分为新生代和老年代，其他收集器都是单独对整个新生代或整个老年代进行垃圾收集，而G1直接对新生代和老年代一起回收。</p><ul><li>传统的新生代和老年代划分：</li></ul><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="image"></p><ul><li>G1将堆划分为多个大小相等大独立区域（Region），新生代和老年代不再物理隔离：</li></ul><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="image"></p><p>通过引入Region的概念，将堆划分为多个小空间，使得每个小空间可以单独进行垃圾回收。这种划分方式带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收所获得的空间，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>每一个Region都有一个Remembered Set，用于记录该Region中的对象的引用对象所在的Region。通过使用Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>G1收集器的运作（不计算维护Remember Set的操作）：</p><p><img src="/2022/11/14/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="image"></p><ol><li><p>初始标记（停顿）</p></li><li><p>并发标记</p></li><li><p>最终标记（停顿）</p><blockquote><p>为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs中，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中。这阶段需要停顿线程，但是可并行执行。</p></blockquote></li><li><p>筛选回收（停顿）</p><blockquote><p>首先对各个Region中的回收价值和成本进行维护，根据用户所期望的GC停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p></blockquote></li></ol><p>具体如下特点：</p><ul><li><p>空间整合</p><blockquote><p>整体来看是基于“标记-整体”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</p></blockquote></li><li><p>可预测的停顿</p><blockquote><p>能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒。</p></blockquote></li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><p>JVM在进行GC时，并非每次都对堆内存（新生代和老年代、方法区）区域一起回收的，大部分时候回收的都是新生代。</p><p>针对HotSpot VM的实现，GC按照回收区域分为：</p><ul><li><p>部分收集（Partial GC）</p><ul><li><p>新生代收集（Minor GC）</p><blockquote><p>只收集新生代的垃圾</p></blockquote></li><li><p>老年代收集（Major GC）</p><blockquote><p>目前，只有CMS GC有单独收集老年代垃圾的行为。很多时候Major GC与Full GC混合使用。</p></blockquote></li><li><p>混合收集（Mixed GC）</p><blockquote><p>目前只有G1 GC有这种行为，收集整个新生代以及部分老年代的垃圾。</p></blockquote></li></ul></li><li><p>整堆收集（Full GC）</p><blockquote><p>收集整个Java堆和方法区的垃圾。</p></blockquote></li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ol><li><p>对象优先在Eden区分配</p><blockquote><p>大多数情况下，对象在新生代Eden区分配，当Eden区空间不够时，发起Minor GC。</p></blockquote></li><li><p>大对象直接进入老年代</p><blockquote><p>大对象指的是需要连续内存空间的对象，例如长字符串和数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p><code>-XX:PretenureSizeThreshold</code> ，大于此值的对象直接在老年代分配内存，避免在Eden区和Survivor区之间大量的内存复制。</p></blockquote></li><li><p>长期存活对象进入老年代</p><blockquote><p>为对象定义年龄计数器，对象在Eden区出生，经过一轮Minor GC后仍存活，移动动到Survivor中，年龄增加一岁，增加到一定年龄则移动到老年代中。</p><p><code>-XX:MaxTenuringThreshold</code>用来定义年龄阈值。</p></blockquote></li><li><p>动态对象年龄判定</p><blockquote><p>虚拟机并不是永远要求对象的年龄必须达到阈值才能进入老年代。如果在Survivor中相同年龄的所有对象大小的总和大于Survivor空间的一半，则年龄大雨或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</p></blockquote></li><li><p>空间分配担保</p><blockquote><p>在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。</p><ul><li><p>如果条件成立的话，那么Minor GC可以确认是安全的。</p></li><li><p>如果不成立的话，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</p><ul><li>如果允许。那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC。如果Minor GC后空间还不够，会触发Full GC。</li><li>如果不允许担保失败，或小于。那么就进行一次Full GC。</li></ul></li></ul></blockquote></li></ol><h3 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h3><blockquote><p>Minor GC的触发条件很简单，当Eden区满后就触发。而Full GC耗时较长，所以触发条件也相对复杂。</p></blockquote><ul><li><p>调用System.gc()</p><blockquote><p>调用System.gc()只是建议虚拟机执行Full GC，但虚拟机不一定真的执行。不建议使用这种方式，而是让虚拟机管理内存。</p></blockquote></li><li><p>老年代空间不足</p><blockquote><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活对象进入老年代等。</p><p>为了避免以上原因引起Full GC，可以采取如下措施：</p><ul><li>应当尽量不要创建过大的对象以及数组。</li><li>通过<code>-Xmn</code>虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。</li><li>通过<code>-XX:MaxTenuringThreshold</code>调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</li></ul></blockquote></li><li><p>空间分配担保失败</p><blockquote><p>使用复制算法的Minor GC需要老年代的内存空间做担保，如果担保失败会执行一次Full GC。</p></blockquote></li><li><p>JDK1.7及以前的永久代空间不足</p><blockquote><p>在JDK1.7及以前，HotSpot虚拟机中的方法区使用永久代实现的，永久代中存放的是一些Class的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满。在未配置为采用CMS GC的情况下也会执行Full GC，如果经过Full GC后仍回收不了，那么虚拟机就会抛出OOM异常。</p><p>为了避免上述原因引起的Full GC，可以通过增大永久代空间或转为使用CMS GC。</p></blockquote></li><li><p>Concurrent Mode Failure</p><blockquote><p>执行CMS GC的过程中，在回收老年代垃圾时会产生浮动垃圾，浮动垃圾过多可能导致老年代空间不足，便会报Concurrent Mode Failur错误，并触发Full GC。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-内存模型</title>
    <link href="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JMM简介"><a href="#JMM简介" class="headerlink" title="JMM简介"></a>JMM简介</h1><h2 id="JMM的引入"><a href="#JMM的引入" class="headerlink" title="JMM的引入"></a>JMM的引入</h2><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><blockquote><p>JVM内部使用的Java内存模型在线程栈和堆之间划分内存。</p></blockquote><p>下图从逻辑角度说明Java内存模型：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-memory-model-1.png" alt="img"></p><h3 id="堆和栈中分别存放的是什么"><a href="#堆和栈中分别存放的是什么" class="headerlink" title="堆和栈中分别存放的是什么"></a>堆和栈中分别存放的是什么</h3><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-memory-model-2.png" alt="img"></p><p>线程栈中包含正在执行的每个方法的所有局部变量。线程只能访问它自己的线程栈，由线程创建的局部变量对于其他线程是不可见的。即使两个线程正在执行同样的代码，两个线程仍将在每个自己的线程栈中创建该代码的局部变量，一次每个线程都有自己的每个局部变量的版本。</p><p>基本类型的所有局部变量完全存储在线程栈中，因此对其他线程不可见。一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身。</p><p>所有线程创建的对象都保存在堆中。这包括基本类型的包装类。创建对象后，无论是将其分配给局部变量还是分配给另一个对象的成员变量，该对象本身仍存储在堆上，局部变量和成员变量中存储的是对象的引用，而非对象本身。</p><p>静态类变量也与类定义一起存储在堆上。</p><h3 id="线程栈如何访问堆上对象"><a href="#线程栈如何访问堆上对象" class="headerlink" title="线程栈如何访问堆上对象"></a>线程栈如何访问堆上对象</h3><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-memory-model-3.png" alt="img"></p><p>所有具有对象引用的线程都可以访问堆上的对象。当一个线程有权访问一个对象时，它也可以访问该对象的成员变量，若该成员变量是其他对象的引用，通过该对象可以访问其他对象。</p><h2 id="JMM和硬件内存结构的关系"><a href="#JMM和硬件内存结构的关系" class="headerlink" title="JMM和硬件内存结构的关系"></a>JMM和硬件内存结构的关系</h2><h3 id="硬件内存结构简介"><a href="#硬件内存结构简介" class="headerlink" title="硬件内存结构简介"></a>硬件内存结构简介</h3><p>现代硬件内存结构与内部Java内存模型略有不同。了解硬件内存架构以了解Java内存模型。</p><p>现代计算机硬件架构简化图：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-memory-model-4.png" alt="img"></p><ul><li><p>多核心</p><blockquote><p>现代计算机CPU通常有多个内核。所以若Java应用是多线程的，那么线程可能在不同核心并行运行。</p></blockquote></li><li><p>CPU寄存器</p><blockquote><p>每个CPU核心都包含一组在CPU内存中的寄存器。CPU可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。</p></blockquote></li><li><p>CPU高速缓存</p><blockquote><p>每个CPU核心还具有CPU高速缓存存储器层。CPU访问高速缓存存储器的速度介于主存和寄存器之间。</p></blockquote></li><li><p>主存（RAM）</p><blockquote><p>所有CPU核心都可以访问主存。主存比高速缓存容量大，但是同时访问速度也较慢。</p></blockquote></li></ul><p>当CPU访问主存是，会从主存读取数据到CPU高速缓存，再部分缓存读到内部寄存器，然后再对其执行操作。当CPU需要将结果写回主存时，它会将值从内部寄存器刷新到高速缓存，并在某些时候将值刷新回主存。</p><h3 id="JMM与硬件内存连接——引入"><a href="#JMM与硬件内存连接——引入" class="headerlink" title="JMM与硬件内存连接——引入"></a>JMM与硬件内存连接——引入</h3><p>Java内存模型和硬件内存架构是不同的。硬件内部架构不区分线程栈和堆，在硬件上二者都位于主存中，并且二者的一部分有时可能存在于CPU高速缓存和CPU内部寄存器中。如图所示：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-memory-model-5.png" alt="img"></p><p>当对象和变量可以存储在计算机的不同区域中时，可能会导致某些问题。两个主要问题：</p><ul><li>Visibility of thread updates (writes) to shared variables.（可见性）</li><li>Race conditions when reading, checking and writing shared variables.（竞态）</li></ul><h3 id="JMM与硬件内存连接——对象共享后的可见性"><a href="#JMM与硬件内存连接——对象共享后的可见性" class="headerlink" title="JMM与硬件内存连接——对象共享后的可见性"></a>JMM与硬件内存连接——对象共享后的可见性</h3><blockquote><p>如果多个线程共享一个对象，但是没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。</p></blockquote><p>共享对象最初存储在主存中，然后CPU上运行的线程将共享对象读入其CPU缓存中，然后在缓存中对共享对象进行秀给，只要CPU缓存未刷新到主存，那么这个共享对象的更改对于在其他CPU上运行的线程是不可见的。这样每个线程最终可能都拥有一个自己的共享对象副本，每个副本位于不同的CPU缓存中。</p><p>如下图所示，左CPU上运行的一个线程读取共享变量到CPU缓存中，然后将count变量改为2，但还未刷新到主存中。右CPU读取该对象的count变量仍为旧值，也就是说左CPU所做的修改对右CPU上的线程不可见。</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-memory-model-6.png" alt="img"></p><p>要解决共享对象的可见性问题，可以使用Java的volatile关键字。volatile关键字可以确保直接从主存中读取给定变量，并在更新后立即写回主存。</p><h3 id="JMM与硬件内存连接——竞态条件"><a href="#JMM与硬件内存连接——竞态条件" class="headerlink" title="JMM与硬件内存连接——竞态条件"></a>JMM与硬件内存连接——竞态条件</h3><blockquote><p>如果多个线程共享一个对象，并且多个线程同时更新该共享对象的变量，则可能出现竞态。</p></blockquote><p>例如有两个线程对共享变量的count执行+1操作。正确的执行逻辑是对一个线程对count执行+1操作后，另一个线程再对count执行+1操作，结果就是count +&#x3D; 2。</p><p>但是在多线程的情况下，可能出现竞态条件问题。例如线程A将共享对象的count读入其CPU缓存，线程B执行相同操作，此时共享对象的count被读入两个不同的CPU缓存，此时线程A和线程B都对count执行+1操作，并刷新到主存中。此时执行的结果是count +&#x3D;1。</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-memory-model-7.png" alt="img"></p><p>要解决此问题，可以使用Java的synchronized关键字。synchronized保证同步块内的代码在同一时间内只有一个线程在执行，同时还保证在同步块内访问的所有变量都是从主存中读取的，当退出同步块时，所有的变量更新都会被刷新回主存（无论变量是否被声明未volatile）</p><h2 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h2><p>在并发编程中，我们需要处理两个关键问题：</p><ul><li>线程之间如何通信</li><li>线程之间如何同步</li></ul><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：</p><ul><li><p>共享内存</p><blockquote><p>在共享内存的并发模型中，线程之间共享程序的公开状态，线程之间通过读写内存中的公共状态来隐式进行通信。</p></blockquote></li><li><p>消息传递</p><blockquote><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p></blockquote></li></ul><p>Java的并发采用的是共享内存模型，Java线程之间通信总是隐式进行的，整个通信过程对程序员完全透明。如果不了解线程之间通信的工作机制，在编写多线程程序时，很可能会遇到各种奇怪的内存可见性问题。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>同步是指程序用于线程之间操作发生相对顺序的机制。</p><ul><li>在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</li><li>在消息传递的并发模型里，由于消息的发送必须在消息接收之前，因此同步是隐式进行的。</li></ul><h2 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h2><ul><li><p>共享变量</p><blockquote><p>在Java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。所以说使用“共享变量”来指代实例域、静态域和数组元素。</p></blockquote></li><li><p>局部变量</p><blockquote><p>局部变量（Local variables）、方法定义参数（formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会存在可见性问题，也不受内存模型的影响。</p></blockquote></li></ul><p>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。</p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他硬件和编译器优化。</p><p>Java内存模型的抽象示意图：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-1.png" alt="img"></p><p>从上图来看，线程A与线程B之间要通信的话，要经历这两个步骤：</p><ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去</li><li>然后，线程B到主内存中读取线程A之前更新过的共享变量</li></ol><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-2.png" alt="img"></p><p>从整体上来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>从Java源代码到最终实际执行的指令序列，会经历下面三种重排序：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-3.png" alt="img"></p><ul><li><p>编译器优化的重排序</p><blockquote><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p></blockquote></li><li><p>指令级并行的重排序</p><blockquote><p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</p></blockquote></li><li><p>内存系统的重排序</p><blockquote><p>由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是乱序执行的</p></blockquote></li></ul><p>这些重排序可能会导致多线程程序出现内存可见性问题。JMM属于语言级别的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的重排序，为程序员提供一致的内存可见性保证。JMM的重排序规则：</p><ul><li><p>对于编译器重排序</p><blockquote><p>JMM的编译器重排序规则会禁止特定类型的编译器重排序</p></blockquote></li><li><p>对于处理器重排序</p><blockquote><p>JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers）指令，来禁止特定类型的处理器重排序</p></blockquote></li></ul><h2 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h2><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。</p><ul><li><p>写缓冲区的作用</p><blockquote><p>写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待内存写入数据而产生的延迟。同时，通过以批处理的方式刷写缓冲区，以及合并缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。</p></blockquote></li><li><p>写缓冲区带来的问题</p><blockquote><p>由于写缓冲区只对它所在的处理器可见。这个特定会对内存操作的执行顺序产生较为重要的影响：处理器对内存的读&#x2F;写操作的执行顺序，不一定与内存实际发生的读&#x2F;写操作顺序一致。</p></blockquote></li></ul><p>常见处理器允许的重排序类型：</p><table><thead><tr><th></th><th>Load-Load</th><th>Load-Store</th><th>Store-Store</th><th>Store-Load</th><th>数据依赖</th></tr></thead><tbody><tr><td>sparc-TSO&#x2F;x86</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>ia64&#x2F;PowerPC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr></tbody></table><p>可见常见的处理器都允许Store-Load重排序，且都不允许对存在数据依赖的操作做重排序。</p><p>为了保证内存可见性，java编译器在生成的指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。内存屏障指令可分为四类：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>StoreLoad Barriers</td><td>Store1;<br>StoreLoad;<br>Load2;</td><td>确保Store1数据刷新到内存，之前于Load2及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td>Store1;<br>StoreStore;<br>Store;</td><td>确保Store1数据刷新到内存，之前于Store2及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td>Load1;<br>LoadStore;<br>Store;</td><td>确保Load1数据的装载，之前于Store2及所有后续的存储指令刷新到内存。</td></tr><tr><td>LoadLoad Barriers</td><td>Load1;<br>LoadLoad;<br>Load2;</td><td>确保Load1数据的装载，之前与Load2及所有后续装载指令的装载。</td></tr></tbody></table><p>StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。该屏障是一个“全能型”屏障，它同时具有其他三个屏障的效果，现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓存区中的数据全部刷新到内存中（buffer fully flush）。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>从JDK开始，java使用新的JSR-133内存模型。JSR-133提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里所说的两个操作即可以是同一线程之内，也可以是在不同线程之间。</p><p>happens-before规则：</p><ul><li><p>程序顺序规则</p><blockquote><p>as-if-serial规则，一个线程中的每个操作，happens-before于该线程中的任意后续操作</p></blockquote></li><li><p>监视器规则</p><blockquote><p>对一个监视器的解锁，happens-before于随后对这个监视器的加锁</p></blockquote></li><li><p>volatile变量规则</p><blockquote><p>对一个volatile域的写，happens-before于任意后续对这个volatile域的读</p></blockquote></li><li><p>传递性</p><blockquote><p>如果A happens-before B，且B happens-before C，那么A happens-before C</p></blockquote></li></ul><p>两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行。happens-before仅仅要求前一个操作（执行结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p><p>happens-before于JMM的关系如图所示：<br><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-5.png" alt="img"></p><p>一个happens-before规则通常对应着多个编译器重排序规则和处理器重排序规则。对于java程序员来说，只需要根据happens-before规则即可编写正确同步的多线程应用，它屏蔽了复杂的重排序规则以及这些规则的具体实现。JMM通过happens-before规则对程序员提供内存可见性保证。</p><h1 id="重排序-1"><a href="#重排序-1" class="headerlink" title="重排序"></a>重排序</h1><h2 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h2><blockquote><p> 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，那么这两个操作之间就存在数据依赖性。</p></blockquote><p>数据依赖有如下三种：</p><ul><li><p>写后读</p><blockquote><p>a &#x3D; 1; b &#x3D; a; </p><p>写一个变量后，再读这个位置。</p></blockquote></li><li><p>写后写</p><blockquote><p>a &#x3D; 1; a &#x3D; 2; </p><p>写一个变量之后，再写这个变量。</p></blockquote></li><li><p>读后写</p><blockquote><p>a &#x3D; b; b &#x3D; 1; </p><p>读一个变量后，再写这个变量。</p></blockquote></li></ul><p>上述三种情况，只要重排序这两个操作的执行顺序，程序的执行结果将会被改变。</p><p>JMM会禁止编译器和处理器的对存在数据依赖关系的两个操作重排序。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作。</p><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><blockquote><p>as-if-serial语义指的是：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p></blockquote><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</p><p>以计算圆面积的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">pi</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;    <span class="hljs-comment">//A</span><br><span class="hljs-type">double</span> <span class="hljs-variable">r</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;     <span class="hljs-comment">//B</span><br><span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> pi * r * r; <span class="hljs-comment">//C</span><br></code></pre></td></tr></table></figure><p>上面三个操作的数据依赖关系：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-6.png" alt="img"></p><p>如上所示，AC之间存在数据依赖，BC之间也存在数据依赖，因此A和B都不能重排序到C操作之后。而AB之间没有数据依赖关系，所以AB之间可以重排序。下图是该程序可能的两种执行顺序：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-7.png" alt="img"></p><p>as-if-serial语义把单线程程序保护了起来。遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建一个幻觉：单线程程序是按程序的顺序来执行的。</p><p>as-if-serial语义使得编写单线程程序时无需担心重排序，也无需担心内存可见性问题。</p><h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>根据happens-before的程序顺序规则，上面计算圆面积的示例代码存在三个happens-before关系：</p><ul><li>A happens-before B</li><li>B happens-before C</li><li>A happens-before C</li></ul><p>这里的A happens-before C关系，是根据happens-before的传递性推导出来的。</p><p>这里的A happens-before B，但实际执行的B可以排在A之前执行。若A happens-before B，并不代表A一定要再B之前执行，JMM仅仅要求A操作（执行结果）对B操作可见，且A操作按顺序排在B操作之前。在这儿操作A和操作B之间没有数据依赖关系，操作A的结果不需要对B可见，且重排序后的执行结果不变，这种情况下，JMM认为这种重排序合法，会允许这种重排序。</p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的提高并行度。</p><p>编译器和处理器遵循这一目标，从happens-before的定义我们也可以看出，JMM同样遵循这一目标。</p><h2 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h2><p>根据下面示例代码来观察重排序对多线程应用的影响：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReorderExample</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>;                   <span class="hljs-comment">//1</span><br>        <span class="hljs-comment">//flag变量是个标记，用来标识变量a是否被写入</span><br>        flag = <span class="hljs-literal">true</span>;             <span class="hljs-comment">//2</span><br>    &#125;<br><br>    Public <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;               <span class="hljs-comment">//3</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>  a * a;       <span class="hljs-comment">//4</span><br>            ……<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里假设线程A执行writer()方法，随后线程B执行reader()方法。观察线程B在执行操作4时，能否看到线程A在操作1中对共享变量的写入？答案是：不一定。</p><p>由于操作1和操作2没有数据依赖关系，操作3和操作4没有数据依赖关系，编译器和处理器可以分别对这两个操作重排序。</p><p>若操作1和操作2重排序，可能的程序执行时序图：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-8.png" alt="img"></p><p>线程A还未写入变量a，就先标记变量flag，随后线程B通过flag判断变量a已经被写入（但实际还没写入），然后读取变量a。在这里多线程程序的语义被重排序破坏了。</p><p>若操作3和操作4重排序，可能的执行时序图：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-9.png" alt="img"></p><p>控制依赖关系：操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度，为此编译器和处理器采用猜测执行来克服控制相关性对并行度的影响。以处理器猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后将计算结果临时保存到一个名为重排序缓冲的硬件缓存中共，当操作3的条件判断为真时，在将计算结果写入变量i中。</p><p>在单线程程序中，对存在控制依  赖的操作重排序（猜测执行），不会改变执行结果；单在多线程程序中，该重排序会破坏多线程程序语义。</p><h1 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h1><h2 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h2><p>数据竞争：</p><p>当程序未正确同步时，就会存在数据竞争。java内存模型规范对数据竞争的定义：在一个线程写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序。</p><p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p><p>顺序一致性保证：</p><p>JMM保证正确同步的多线程程序具有顺序一致性（seuentially consistent）——即程序的执行结果域该程序在顺序一致性内存模型中的执行结果相同。这里指的同步是广义上的同步，包括对常用同步原语（lock、volatile和final）的正确使用。</p><h2 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h2><blockquote><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。</p></blockquote><h3 id="特定"><a href="#特定" class="headerlink" title="特定"></a>特定</h3><p>顺序一致性内存模型的两大特点：</p><ol><li>一个线程中的所有操作必须按照程序的顺序来执行</li><li>所有线程都只能看到一个单一的操作执行顺序（不论程序是否正确同步）</li></ol><p>要实现上述的两个特点，在顺序一致性内存模型中，每个操作都必须原子执行且立即对所有线程可见。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>顺序一致性内存模型为程序员提供的视图如下：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-10.png" alt="img"></p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，这个内存在同一时刻只能有一个线程能进行读&#x2F;写，在多个线程并发执行时，就能把所有线程的所有内存读&#x2F;写操作串行化。</p><h3 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h3><p>假设有两个线程A和B并发执行。其中线程A有三个操作，它们在程序中的顺序是：A1 -&gt; A2 -&gt; A3，B线程也有三个操作，它们在程序中的顺序是：B1 -&gt; B2 -&gt; B3。</p><ul><li>若这两个线程使用监视器来正确同步：A线程的三个操作执行后释放监视器，随后B线程获取同一监视器。那么程序在顺序一致性模型中的执行示意图如下所示：</li></ul><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-11.png" alt="img"></p><ul><li>若这两个线程没有做同步，那么这个未同步程序在顺序一致性模型中的执行示意图如下所示：</li></ul><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-12.png" alt="img"></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程A和线程B看到的执行顺序都是：B1 -&gt; A1 -&gt; A2 -&gt; B2 -&gt; A3 -&gt; B3。只所以能得到这个保证是因为顺序一致性内存模型中的每一个操作必须立即对所有线程可见。</p><p>但是，在JMM中就没有上述的保证，未同步的程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。因为在JMM内存模型中每个线程有自己的本地内存，线程会把写过的数据缓存在本地内存中，在还没有将修改刷新到主内存之前，这个写操作仅对当前线程可见，从其他线程的角度来看，会认为这个写操作还未被执行。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。</p><h2 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h2><blockquote><p>使用前面的例子，通过synchronized关键字（监视器）同步，来观察正确同步的程序如何具有顺序一致性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedExample</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>;<br>        flag = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a;<br>            ……<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例代码中，假设线程A执行了writer()方法后，线程B执行reader()方法。</p><p>这是一个正确同步的多线程程序，根据JMM规范，该程序的执行结果与该程序在顺序一致性模型中的执行结果一致。该程序在两个内存模型中的执行时序对比图：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-13.png" alt="img"></p><ul><li><p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。</p></li><li><p>而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出和进入监视器时做一些特别处理，使得线程在这两个时间点具有和顺序一致性模型相同的内存视图。</p></li></ul><p>虽然线程A在临界区内做了重排序，但由于监视器的互斥执行的特性，这里线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。由此，我们可以看到JMM在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能为编译器和处理器留下重排序的优化空间。</p><h2 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h2><blockquote><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false等），JMM保证线程读取到的值不会无中生有的冒出来。</p></blockquote><p>为了实现最小安全性，JVM在堆上分配对象时，首先会清空内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在已清零的内存空间分配对象时，域的默认值已经完成了。</p><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未正确同步的程序在顺序一致性模型中执行时，整体也是无序的，其结果无法预知，保证未同步程序在这两个模型中的执行结果一致毫无意义。但未正确同步的程序在顺序一致性模型中执行会提供一些JMM没有的保证：</p><ul><li>保证单线程内的操作是按程序的顺序执行</li><li>保证所有线程只能看到一致的操作执行顺序</li><li>保证对所有内存读&#x2F;写都具有原子性（64位的long型和double型变量）</li></ul><p>第三个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。</p><p>每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称为<strong>总线事务（bus transaction）</strong>。总线事务包括读事务和写事务，读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读&#x2F;写内存中一个或多个物理上连续的字。这里的关键是，总线会同步尝试并发使用总线的事务，在一个处理器执行总线事务期间，总线会禁止其他所有的处理器和I&#x2F;O设备执行内存的读&#x2F;写。</p><p>通过下面示意图来说明总线的工作机制：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-14.png" alt="img"></p><p>如上所示，假设吃处理器A、B和C同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争做出裁决，这里我们假设总线在仲裁后判定处理器A在竞争中获胜，那么处理器A会继续它的总线事务，而其他两个处理器则要等待A的总线事务完成后才能访问内存。假设在A执行总线期间（不管这个总线事务时读事务还是写事务），处理器D向总线发起总线事务，此时处理器D的这个请求会被总线禁止。</p><p>总线的这个工作机制可以把所有处理器对内存的访问以串行化的方式来执行，在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读&#x2F;写操作具有原子性。</p><p>在一些32位的处理器上，如果要求对64位数据的读&#x2F;写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java语言规范鼓励但不求JVM对64位的long型变量和double型变量的读&#x2F;写具有原子性。当JVM在这种处理器上运行时，会把一个64位long&#x2F;double型变量的读&#x2F;写操作拆分为32位的读&#x2F;写操作来执行。这两个32位的读&#x2F;写操作可能会被分配到不同的总线事务中执行，此时对这些64位变量的读&#x2F;写将不具有原子性。</p><p>当单个内存操作不具有原子性，将可能会产生意想不到的后果。示意图如下：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-15.png" alt="img"></p><p>如上图所示，假设处理器A写一个long型变量，同时处理器B要读这个long型变量。处理器A中64位的写操作被拆分为两个32位的写操作，且这两个32位的写操作被分配到不同的写事务中执行。同时处理器B中64位的读操作被拆分位两个32位的读操作，且这两个32位的读操作被分配到同一个的读事务中执行。当处理器A和B按上图的时序来执行时，处理器B将看到仅仅被处理器A“写了一半”的无效值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="处理器内存模型"><a href="#处理器内存模型" class="headerlink" title="处理器内存模型"></a>处理器内存模型</h2><blockquote><p>顺序一致性内存模型时一个理论参考模型，JMM和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对性能将会有很大影响。</p></blockquote><p>根据对不同类型读&#x2F;写操作组合的执行顺序放松，可以把常见的处理器内存模型划分为下面几种类型：</p><ul><li><p>TSO</p><blockquote><p>放松程序中写-读操作的顺序，由此产生total store ordering内存模型</p></blockquote></li><li><p>PSO</p><blockquote><p>在TSO的基础上，继续放松程序中写-写操作的顺序，由此产生parial store order内存模型</p></blockquote></li><li><p>RMO</p><blockquote><p>在PSO的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了relaxed memory order内存模型和PowerPC内存模型</p></blockquote></li></ul><p>注意，这里处理器对读&#x2F;写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p><p>下面的表格展示了常见处理器内存模型的细节特征：</p><table><thead><tr><th>内存模型名称</th><th>对应的处理器</th><th>Store-Load重排序</th><th>Store-Store重排序</th><th>Load-Load和Load-Store重排序</th><th>可以更早取到其他处理器的写</th><th>可以更早读到当前处理器的写</th></tr></thead><tbody><tr><td>TSO</td><td>sparc-TSO X64</td><td>Y</td><td></td><td></td><td></td><td>Y</td></tr><tr><td>PSO</td><td>sparc-PSO</td><td>Y</td><td>Y</td><td></td><td></td><td>Y</td></tr><tr><td>RMO</td><td>ia64</td><td>Y</td><td>Y</td><td>Y</td><td></td><td>Y</td></tr><tr><td>PowerPC</td><td>PowerPC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><p>因为写缓冲区使得处理器模型具有的共同点：</p><ul><li>都允许写-读重排序，因为它们都使用写缓存区，写缓存区可能导致写-读操作重排序。</li><li>都允许更早读到当前处理器的写，原因同样是因为写缓冲区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</li></ul><p>上面表格中的各种处理器模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的越弱，因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p><p>由于常见的处理器内存模型比JMM要弱，java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同过的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入不同种类和数量的内存屏障。下图展示了JMM在不同处理器内存模型中需要插入的内存屏障的示意图：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-x01.png" alt="img"></p><p>如图所示，JMM屏蔽了不同处理器内存模型的差异，它在不同处理器平台之上为java程序员呈现了一个一致的内存模型。</p><h2 id="JMM、处理器内存模型、顺序一致性内存模型三者之间的关系"><a href="#JMM、处理器内存模型、顺序一致性内存模型三者之间的关系" class="headerlink" title="JMM、处理器内存模型、顺序一致性内存模型三者之间的关系"></a>JMM、处理器内存模型、顺序一致性内存模型三者之间的关系</h2><blockquote><p>JMM是一个语言级的内存模型</p><p>处理器内存模型是硬件级别的内存模型</p><p>顺序一致性内存模型是一个理论参考模型</p></blockquote><p>下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-x02.png" alt="img"></p><p>由上图可以看出：处理器内存模型比语言内存模型要弱，语言内存模型又要比顺序一致性内存模型要弱。</p><h2 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h2><p>从JMM设计者的角度来说，在设计JMM时，需要考虑两个关键因素：</p><ul><li><p>程序员对内存模型的使用</p><blockquote><p>程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</p></blockquote></li><li><p>编译器和处理器对内存模型的实现</p><blockquote><p>编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</p></blockquote></li></ul><p>由于这两个关键因素是互相矛盾的，所以设计JMM的核心目标是要找个一个好的平衡。</p><p>JMM的设计如下：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-x03.png" alt="img"></p><ul><li><p>JMM向程序员提供happens-before规则保证内存可见性</p><blockquote><p>JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证。</p></blockquote></li><li><p>JMM对编译器和处理器尽可能减少约束</p><blockquote><p>JMM遵循一个基本原则：只要不改变程序的执行结果（程序指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。</p><p>比如：如果编译器分析认定一个锁只会被单线程访问，那么这个锁就可以被消除。如果编译器分析认定volatile变量仅会被单个线程访问，那么编译器就可以把这个volatile变量当作普通变量处理。</p><p>这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</p></blockquote></li></ul><h2 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h2><p>JMM的内存可见性保证按照程序类型可以分为下面三类：</p><ul><li><p>对于单线程程序</p><blockquote><p>单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同</p></blockquote></li><li><p>对于正确同步的多线程程序</p><blockquote><p>正确同步的多线程程序的执行将具有顺序一致性。JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p></blockquote></li><li><p>未同步&#x2F;未正确同步的多线程程序</p><blockquote><p>JMM为它们提供最小的安全型保证：线程执行时读取到的值，要么是之前某线程写入的值，要么是默认的零值。</p></blockquote></li></ul><p>如图是这三类程序在JMM中和顺序一致性内存模型中的执行结果的异同：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java-jmm-x04.png" alt="img"></p><p>只要多线程是正确同步的，JMM保证该程序在任意处理器平台上与该程序在顺序一致性模型中的执行结果一致。</p><h2 id="JSR-133对旧内存模型的修补"><a href="#JSR-133对旧内存模型的修补" class="headerlink" title="JSR-133对旧内存模型的修补"></a>JSR-133对旧内存模型的修补</h2><ul><li><p>增强volatile的内存语义</p><blockquote><p>旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义，使得volatile相当于一个轻量级锁。</p></blockquote></li><li><p>增强final的内存语义</p><blockquote><p>在旧内存模型中，多次读取同一个final变量的值可能不同。JSR-133为final增加了两个重排序规则，使得final具有了初始化安全性。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-内存结构</title>
    <link href="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/007S8ZIlly1gg9kuge8ovj32150tt7cd.jpg" alt="img"></p><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分和管理存在部分差异。</p><p>下图是JVM整体架构，中间部分就是Java虚拟机定义的运行时数据区：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt="jvm-framework"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另一些则是于线程一一对应的，这些与线程一一对应的数据区域会随着线程的开始和结束而创建和销毁。</p><ul><li>线程私有：程序计数器、虚拟机栈、本地方法栈</li><li>线程共享：堆、方法区、堆外内存（Java7的永久代或Java8的元空间、代码缓存）</li></ul><h1 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h1><p>程序计数寄存器（Program Counter Register），Register的命名源自于CPU的寄存器，寄存器存储指令相关的线程信息，CPU只有把数据装载到寄存器才能运行。</p><p>这里并非是广义上所指的物理寄存器，叫程序计数器会更贴切。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。程序计数器是一块较小的内存空间，<strong>可以看作是当前线程所执行的字节码的行号指示器</strong>。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p></blockquote><p>通过<code>javap -v xx.class</code> 命令反编译（或通过IDEA插件Jclasslib直接查看），可以看到当前类对应的Code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。如图：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc5kmznm1sj31m50u0wph.jpg" alt="jvm-pc-counter"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过两个关于PC寄存器的问题了解PC寄存器：</p><ul><li><p>使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址？</p><blockquote><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就需要知道接着从哪儿开始继续执行。JVM得字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p></blockquote></li><li><p>PC寄存器为什么会被设定为线程私有的？</p><blockquote><p>多线程在一个特定的时间段内只会执行其中某一个线程，CPU会不停的做任务切换，这样必然会导致经常中断和恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p></blockquote></li></ul><p>关于PC寄存器的一些总结：</p><ul><li><p>占用空间小，运行速度最快</p><blockquote><p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</p></blockquote></li><li><p>线程私有，生命周期同线程一致</p><blockquote><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致。</p></blockquote></li><li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。</p><blockquote><p>如果当前线程正在执行的是Java方法，程序计数器记录的是JVM字节码指令地址，如果是执行native方法，则是未指定值（undefined）</p></blockquote></li><li><p>它是程序控制流的指示器</p><blockquote><p>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖于计数器完成</p></blockquote></li><li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p></li><li><p>它时唯一一个在JVM规范中没有规定任何<code>OutOfMemeoryError</code>情况的区域</p></li></ul><h1 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h1><blockquote><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次Java方法调用，是线程私有的，生命周期和线程一致。</p></blockquote><p>作用：</p><ul><li>主管java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li></ul><p>特点：</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM直接对虚拟机栈的操作只有两个：方法执行，入栈；方法执行结束，出栈</li><li>栈不存在垃圾回收问题</li></ul><p>栈中可能出现的异常：</p><ul><li><p><code>StackOverflowError</code>异常</p><blockquote><p>如果虚拟机采用固定大小的虚拟机栈，那每个线程的Java虚拟机栈容量可以在线程创建时独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常</p></blockquote></li><li><p><code>OutOfMemoryError</code>异常</p><blockquote><p>如果虚拟机采用可动态扩展的虚拟机栈，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机会抛出OutOfMemoryError异常</p></blockquote></li></ul><p>栈大小设置：</p><ul><li>可以通过参数<code>-Xss</code> 来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</li></ul><h2 id="栈的运行原理"><a href="#栈的运行原理" class="headerlink" title="栈的运行原理"></a>栈的运行原理</h2><ul><li>JVM对Java栈的操作只有两个，对栈帧的压栈和出栈。</li><li>在一个活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧对应的方法是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧。</li><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧成为当前栈帧。</li><li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用的是return指令，另一种是抛出异常。不管是哪种方式退出函数，都会导致栈帧被弹出。</li></ul><p>IDEA在debug的时候，可以在debug窗口看到Frames中各种方法的压栈和出栈情况：</p><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc9s12g5wlj31li0owdm9.jpg" alt="img"></p><h2 id="栈的存储单位（栈帧）"><a href="#栈的存储单位（栈帧）" class="headerlink" title="栈的存储单位（栈帧）"></a>栈的存储单位（栈帧）</h2><h3 id="栈帧简介"><a href="#栈帧简介" class="headerlink" title="栈帧简介"></a>栈帧简介</h3><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每一个方法都各自对应一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）</li><li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li><li>一些附加信息</li></ul><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" alt="jvm-stack-frame"></p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><blockquote><p>局部变量表也被称为局部变量数组或者本地变量表。是一组变量值存储空间，主要存储方法参数和定义在方法体内的局部变量。</p></blockquote><h5 id="关于局部变量表的一些："><a href="#关于局部变量表的一些：" class="headerlink" title="关于局部变量表的一些："></a>关于局部变量表的一些：</h5><ul><li>由于局部变量表是建立在线程的栈上，是线程私有数据，因此不存在数据安全问题。</li><li>局部变量表所需的容量大小是在编译器确定下来的，并保存在方法的Code属性的<code>maximum localvariables</code>数据项中。在方法运行期间局部变量表的大小不会改变。</li><li>方法嵌套的最大次数由栈的和栈帧决定。一般来说，栈越大，方法嵌套次数越多。对一个函数而言，它的参数和局部变量越多，局部变量表越大，它的栈帧越大，会导致其嵌套调用次数减少。</li><li>局部变量表中的变量只有在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li><li>参数值的存放总是在局部变量数组的index0开始的，到数组长度-1的索引结束。</li><li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量直接或间接引用的对象都不会被回收。</li></ul><h5 id="局部变量表的最基本存储单位：Slot（变量槽）"><a href="#局部变量表的最基本存储单位：Slot（变量槽）" class="headerlink" title="局部变量表的最基本存储单位：Slot（变量槽）"></a>局部变量表的最基本存储单位：Slot（变量槽）</h5><ul><li><p>在局部变量表中，32位以内的类型只占用一个Slot，64位的占用两个连续的Slot。</p><blockquote><ul><li>byte、shor、char、boolean在存储前被转换为int，占用一个Slot</li><li>returnAddress类型也占用一个Slot</li><li>long和double则占据两个Slot</li></ul></blockquote></li><li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上。</p></li><li><p>如果访问一个64位占用两个Slot的局部变量，只需要使用其前一个索引即可。</p></li><li><p>如果当前栈帧是由构造方法或实例方法创建的，那么该对象引用this将会被存放在index为0的Slot处，其余参数按照参数表顺序继续排列。这也是静态方法中不可以引用this的原因，因为静态方法的局部变量表中不存在this变量。</p></li><li><p>栈帧中的局部变量表的槽位是可以重用的。如果一个局部变量过了其作用域，那么在其作用域后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p></li></ul><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><blockquote><p>操作数栈，也可以称为表达式栈（Expression Stack）。主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。</p></blockquote><ul><li>操作数栈，在方法执行过程中，根据字节码指令往操作数栈中写入或提取数据，即入栈和出栈。</li><li>某些字节码指令将值压入操作数栈。其余的字节码指令将操作数取出栈，使用后再将结果压入栈。例如执行复制、交换、求和等操作。</li></ul><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><ul><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，此时这个方法的操作数栈是空的。</li><li>每个操作数栈会拥有一个明确的栈深度用于存储数值，其中所需的最大深度再编译器就定义好了，保存在方法的Code属性的<code>max_stack</code>数据项中。</li><li>栈中的元素可以是任意的Java数据类型，一个栈单位深度可以保存32位数据。</li><li>操作数栈只能通过入栈和出栈操作来完成数据访问，不能使用索引访问数据。</li><li>如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</li><li>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，这里的栈指的就是操作数栈。</li></ul><h5 id="栈顶缓存（Top-of-stack-Cashing）"><a href="#栈顶缓存（Top-of-stack-Cashing）" class="headerlink" title="栈顶缓存（Top-of-stack-Cashing）"></a>栈顶缓存（Top-of-stack-Cashing）</h5><p>HotSpot的执行引擎采用的并非是基于寄存器的架构，但这并不代表HotSpot VM的实现没有间接利用到寄存器。</p><p>寄存器是物理CPU中的组成部分之一，它同时也是CPU中非常重要的高速存储资源。一般来说寄存器的读写速度是内粗的几十倍不止，不过寄存器资源十分有限，不同平台下的CPU寄存器数量不同。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读写次数。由于操作数是存储在内存中的，因此频繁的执行内存读写操作必然影响执行速度。</p><p>为了解决这个问题，HotSpot VM的设计者们提出了栈顶缓存计数，将栈顶元素全部缓存到物理CPU的寄存器中，以此降低对内粗的读写次数，提升执行引擎的执行效率</p><h4 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h4><h5 id="动态链接简介"><a href="#动态链接简介" class="headerlink" title="动态链接简介"></a>动态链接简介</h5><ul><li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都所谓符号引用（Symbolic Reference）保存到Class文件的常量池中。描述一个方法调用了其他的方法时，就是通过常量池中指向方法的符号引用来表示的，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</li></ul><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/0082zybply1gca4k4gndgj31d20o2td0.jpg" alt="jvm-dynamic-linking"></p><h5 id="JVM时如何执行方法调用的"><a href="#JVM时如何执行方法调用的" class="headerlink" title="JVM时如何执行方法调用的"></a>JVM时如何执行方法调用的</h5><p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</p><p>Class文件的编译过程不包括传统编译器中的链接步骤，一切方法调用在Class文件里面存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用）。也就是在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关（绑定是一个字段、方法或类在符号引用被替换为直接引用的过程，这仅发生一次）。</p><p>JVM中的绑定机制：</p><ul><li><p>早期绑定（静态链接）</p><blockquote><p>早期绑定就是指被调用的目标方法如果在编译器可知，且运行期保持不变，即可将这个方法与所属的类型进行绑定。这样一来，由于明确了被调用的目标方法究竟是哪一个，因此就可以使用静态链接的方式将符号引用转换为直接引用。</p></blockquote></li><li><p>晚期绑定（动态链接）</p><blockquote><p>如果被调用的方法在编译期无法被确定下来，只能在程序运行期根据实际的类型绑定相关的方法，这种绑定方式被称为晚期绑定。</p></blockquote></li></ul><p>虚方法和非虚方法：</p><ul><li><p>非虚方法</p><blockquote><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</p></blockquote></li><li><p>虚方法</p><blockquote><p>其他的方法称为虚方法。</p><p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标，有可能会影响到执行效率。</p><p>为了提高性能，JVM采用在类的方法区建立一个 虚方法表（virtual method table），使用索引表来代替查找。每个类中都有一个虚方法表，表中存放着各个方法的实际入口。虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方法表也初始化完毕。</p></blockquote></li></ul><h4 id="方法返回地址（return-address）"><a href="#方法返回地址（return-address）" class="headerlink" title="方法返回地址（return address）"></a>方法返回地址（return address）</h4><blockquote><p>用来存放调用该方法的PC寄存器的值。</p></blockquote><p>方法的结束有两种方式：</p><ul><li><p>正常执行完成</p><blockquote><p>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称正常完成出口。</p></blockquote></li><li><p>出现异常退出</p><blockquote><p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p><p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便再发生异常的时候找到异常处理的代码。</p></blockquote></li></ul><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表和操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>两种方法结束方式的区别在于：通过异常完成出口退出方法不会给它的上层调用者产生任何返回值。</p><h4 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息还取决于具体的虚拟机实现。</p><h1 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h1><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><blockquote><p>一个Native Method就是一个Java调用非Java代码的接口。例如Unsafe类就有很多本地方法。</p></blockquote><p>为什么需要使用本地方法？</p><p>有些层次的任务使用Java不好实现，或者说效率不高，例如：</p><ul><li><p>与Java环境外交互</p><blockquote><p>有时Java应用需要与Java外面的环境交互，这就是本地方法存在的原因。</p></blockquote></li><li><p>与操作系统交互</p><blockquote><p>JVM支持Java语言本身和运行时库，但是有时需要依赖一些底层系统的支持。通过本地方法，我们可以实现用Java与实现了jre的底层系统交互，JVM的一部分就是C语言写的。</p></blockquote></li><li><p>Sun‘s Java</p><blockquote><p>Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用Java实现的，它也通过一些本地方法与外界交互。比如，类<code>java.lang.Thread</code> 的<code>setPriority</code> 的方法是用Java实现的，但它的实现是调用该类的本地方法<code>setPriority()</code>，该方法是C实现的，并被植入JVM内部。</p></blockquote></li></ul><h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><blockquote><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p></blockquote><ul><li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。跟Java虚拟机栈一样是线程私有的，且同样可以固定栈大小或可动态扩展栈大小（取决于虚拟机实现）。</li><li>本地方法使用C语言实现</li><li>它的具体做法是：本地方法栈中等级native方法，在执行引擎执行时加载本地方法库。当某线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限。</li><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存。</li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li></ul><h1 id="四、堆内存"><a href="#四、堆内存" class="headerlink" title="四、堆内存"></a>四、堆内存</h1><blockquote><p>栈是运行时的单位。解决程序的运行问题，即程序如何执行，或者说如何处理数据。</p><p>堆是存储的单位。解决的是数据存储的问题，即数据怎么放、放在哪儿。</p></blockquote><h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><blockquote><p>分代的唯一理由就是优化GC性能。</p></blockquote><p>对于大多数应用，Java堆是Java虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分为三块区域：</p><ul><li>新生代：新对象和没达到一定年龄的对象都在新生代。</li><li>老年代：被长时间使用的对象在老年代，老年代的内存空间比新生代更大。</li><li>元空间：存放一些方法中的临时操作对象等。（JDK1.8之前叫永久代，占用JVM内存，JDK1.8之后直接使用物理内存）</li></ul><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg" alt="JDK7"></p><p>Java虚拟机规定，Java堆可以是物理上不连续的内存空间，只要逻辑上是连续的即可，像磁盘空间一样。JVM实现时既可以时固定大小的，也可以时扩展的，主流虚拟机都是可扩展的（通过<code>-Xmx</code>和<code>-Xms</code>参数控制）。如果堆中共没有完成实例分配，且堆无法再扩展时，就会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h3><p>新生代是新对象创建的地方。当新生代满后，执行垃圾回收，这种垃圾回收称为Minor GC。</p><p>新生代被分为三部分：伊甸区（Eden Memory）和两个幸存区（Surviver Memory），默认比例8：1：1</p><ul><li>大多数新建对象都位于Eden内存空间</li><li>两个幸存区标记为From&#x2F;To区，To区总是空的。</li><li>当Eden空间满后，执行Minor GC，将Eden和From区中所有幸存者移动到To区，然后反转两个幸存区的From&#x2F;To标记。</li><li>经过多轮GC后存活下来的对象会被移动到老年代。通常是通过设置新生代对象的年龄阈值实现。</li></ul><h3 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h3><p>老年代的对象主要是两类：</p><ul><li><p>一类是经过多轮GC后仍然存活的新生代对象。</p></li><li><p>还有一类是大对象。</p><blockquote><p>大对象是指需要大量连续内存空间的对象。直接将大对象放入老年代是为了避免在Minor GC的时候频繁的将大对象在Eden区和两个Survivor区之间移动，从而避免大量的内存拷贝。</p></blockquote></li></ul><p>在老年代满后，会发生Major GC，Major GC通常会比Minor GC花费更多时间。</p><h3 id="元空间（Meta-Space）"><a href="#元空间（Meta-Space）" class="headerlink" title="元空间（Meta Space）"></a>元空间（Meta Space）</h3><p><img src="/2022/11/14/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg" alt="img"></p><p>不管是JDK8之前的永久代，还是JDK8及以后的元空间，都可以看作是Java虚拟机规范中方法区的实现。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名Non-Heap，应该与Java堆区分开。 </p><h2 id="对象在堆中的内存分配与生命周期"><a href="#对象在堆中的内存分配与生命周期" class="headerlink" title="对象在堆中的内存分配与生命周期"></a>对象在堆中的内存分配与生命周期</h2><ol><li>new的对象先放到Eden区，若是大对象则直接放到Old区</li><li>当Eden区空间不足，又需要新建对象时，JVM会对Eden区进行Minor GC，将Eden区中存活的对象移动到Surviver To区，并将对象年龄+1</li><li>To区接收了存活对象后和From区交换身份，变为From区。在下一轮的Minor GC中回收Eden区和From区，将存活对象移动到To区如此反复</li><li>当新生代中的对象年龄大于15（默认回收标记），就会被放到老年代</li><li>当老年代的内存不足后，会触发Major GC，进行老年代内存的回收</li><li>若老年代执行了Major GC后，剩余空间仍无法保存对象，就会产生OOM异常</li></ol><h2 id="GC垃圾回收简介"><a href="#GC垃圾回收简介" class="headerlink" title="GC垃圾回收简介"></a>GC垃圾回收简介</h2><p>针对HotSpot VM的实现，GC按照回收区域主要分为两大类：</p><ul><li><p>部分收集：</p><ul><li><p>Minor GC：只是新生代的垃圾收集</p></li><li><p>Major GC：只是老年代的垃圾收集</p><blockquote><p>只有CMS GC会又单独收集老年代的行为。很多时候Major GC会和Full GC混合使用。</p></blockquote></li><li><p>Mixed GC：收集整个新生代以及部分老年代的垃圾</p></li></ul></li><li><p>整堆收集：</p><ul><li>Full GC：收集整个Java堆和方法区的垃圾</li></ul></li></ul><h2 id="JVM针对堆区的一些优化"><a href="#JVM针对堆区的一些优化" class="headerlink" title="JVM针对堆区的一些优化"></a>JVM针对堆区的一些优化</h2><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><h4 id="什么是TLAB（Thread-Local-Allocation-Buffer）？"><a href="#什么是TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="什么是TLAB（Thread Local Allocation Buffer）？"></a>什么是TLAB（Thread Local Allocation Buffer）？</h4><ul><li>从内存模型而不是垃圾回收的角度，对Eden区域进行继续划分，为每个线程分配了一个私有的缓存区域，它包含在Eden空间中</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li><li>OpenJDK衍生出来的JVM大都提供TLAB设计</li></ul><h4 id="为什么要使用TLAB？"><a href="#为什么要使用TLAB？" class="headerlink" title="为什么要使用TLAB？"></a>为什么要使用TLAB？</h4><blockquote><p>避免为对象实例分配地址时加锁，提高分配速度。</p></blockquote><p>堆区时线程共享的，任何线程都可以访问到堆区的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中共划分内存空间是不安全的。为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><p>TLAB的设计为每个线程分配一个私有的缓存区域，线程创建对象时默认在该缓存区域创建，这样就不存在多线程冲突，也就不需要加锁。一旦对象在TLAB空间分配内存失败，JVM则会尝试通过加锁机制在Eden空间中直接为对象分配内存保证操作的原子性。</p><p>控制参数：</p><ul><li><code>-XX:UseTLAB</code>：设置是否开启TLAB空间</li><li><code>-XX:TLABWasteTargetPercent</code>：设置TLAB空间所占Eden空间的百分比（默认1%）</li></ul><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析的基本行为就是分析对象动态所用域：当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。若它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方，称为方法逃逸。</p><p>使用逃逸分析，编译器可以对代码做优化：</p><ul><li><p>栈上分配</p><blockquote><p>若一个对象在方法中被分配，且指向该对象的指针不会逃逸，对象可能会直接在栈中分配内存。这样该对象所占空间随着栈帧出栈而销毁，就减轻了GC压力。</p></blockquote></li><li><p>同步省略（锁消除）</p><blockquote><p>若一个对象只能被一个线程访问到，那么对于这个对象的一些同步操作可以消除。</p></blockquote></li><li><p>标量替换</p><blockquote><p>标量（Scalar）指一个无法再分解的数据，例如Java中的基本数据类型就是标量。哪些还可以被分解的就叫做聚合量（Aggregate），例如Java对象。</p><p>若一个对象不会被方法方法外部访问，那么JVM不会创建该对象，而是将该对象分解成若干被这个方法使用的成员变量替代。这些替代的成员变量再栈帧或寄存器上分配空间。这个过程就是标量替换。</p></blockquote></li></ul><h1 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h1><h2 id="关于方法区"><a href="#关于方法区" class="headerlink" title="关于方法区"></a>关于方法区</h2><h3 id="方法区简介"><a href="#方法区简介" class="headerlink" title="方法区简介"></a>方法区简介</h3><ul><li><p>方法区（Method Area）与java堆一样，是所有线程共享的内存区域。</p></li><li><p>方法区的大小和堆空间一样，可以选择固定大小，也可以选择可扩展。方法区的大小决定了系统可以放多少个类，如果系统中类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误。</p></li><li><p>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫Non-Heap，目的是将其与Java堆区分开</p></li><li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本&#x2F;字段&#x2F;方法&#x2F;接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能会有新的常量放入池中，这种特性被开发者利用的比较多的时String.intern()方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出OOM异常。</p></li></ul><h3 id="方法区、永久代和元数据区之间的关系"><a href="#方法区、永久代和元数据区之间的关系" class="headerlink" title="方法区、永久代和元数据区之间的关系"></a>方法区、永久代和元数据区之间的关系</h3><ul><li><p>方法区</p><blockquote><p>方法区只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据。并没有规定如何实现方法区，不同厂商有不同的实现。永久代和元空间都可以理解为方法区的具体实现。</p></blockquote></li><li><p>永久代（PermGen）</p><blockquote><p>永久代是Hotspot虚拟机特有的概念。永久代物理上是堆的一部分，和新生代、老年代地址是连续的（受垃圾回收期管理）。永久代存储类的元信息、静态变量和常量池等数据。</p></blockquote></li><li><p>元空间（Metaspace）</p><blockquote><p>在JDK8之后移除了永久代，替换为元空间。元空间物理上是属于本地内存（堆外内存，不受垃圾回收器管理）。元空间只存储类的元信息，而静态变量和常量池则并入堆中。</p></blockquote></li></ul><h3 id="设置方法区的大小"><a href="#设置方法区的大小" class="headerlink" title="设置方法区的大小"></a>设置方法区的大小</h3><p>在JDK8后方法区的实现是元空间，元空间有两个大小设定参数：</p><ul><li><p><code>-XX:MetaspaceSize</code></p><blockquote><p>默认21M。<code>-XX:MetaspaceSize</code>是初始的高水位线，一旦触及该水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线会被重置。新的高水位线的值取决于GC后释放的元空间内存大小，如果释放的空间不足，则会适当提高，如果释放的空间过多，则会适当降低。</p></blockquote></li><li><p><code>-XX:MaxMetaspaceSize</code></p><blockquote><p>默认-1，即没有限制。所以若不指定大小，虚拟机可能会耗尽所有的系统可用内存。如果元空间发生溢出，虚拟机同样会抛出异常<code>OutOfMemoryError:Metaspace</code>。</p></blockquote></li></ul><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><blockquote><p> 方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p></blockquote><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><h4 id="类型信息-1"><a href="#类型信息-1" class="headerlink" title="类型信息"></a>类型信息</h4><p>对于每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ul><li>该类型的完整有效名称（全名 &#x3D; 包名.类名）</li><li>该类型直接父类的有效名（interface和Object没有父类）</li><li>该类型的修饰符（public，abstrac，final的某个子集）</li><li>该类型直接接口的一个有序列表</li></ul><h4 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h4><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序，域的相关信息包括：</p><ul><li>域名称</li><li>域类型</li><li>域修饰符（public、private、protected、static、final、volatile、transient的某个子集）</li></ul><h4 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4><p>JVM必须保存所有的方法，方法的相关信息包括：</p><ul><li>方法名称</li><li>方法的返回类型</li><li>方法的参数数量和类型</li><li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstrace的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstrac和native方法除外）</li><li>异常表（每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量索引）</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。要理解运行时常量池需要先了解字节码文件中的常量池。</p></blockquote><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>一个有效额字节码文件中除了包含类的版本信息、字段、方法、以及接口等描述信息外，还包含一项重要的信息：常量池表（Constant Pool Table）。常量池表包含各种字面量和对类型、域、方法的符号引用。</p><p>一个Java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接保存到字节码中，而是存入常量池，字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池，常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型数据。</p><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表是Class文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li><li>JVM为每个已加载的类型（类或接口）单独维护一个常量池，池中的数据项像数组项一样，是通过索引访问的</li><li>运行时常量池中包含各种不同的常量。包括编译器就已经明确的数值字面量，也包括运行期解析后才能获得的方法或字段引用（此时不再是常量池中的符号地址，而是已经转换为真实地址）。 </li><li>运行时常量池，相对于Class文件常量池的另一个重要特征时：动态性。Java语言并不要求常量一定只有编译器间才能产生，运行期间也可以将新的常量放入池中，String类的<code>intern()</code>方法就是这样的</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，则JVM会抛出OOM异常。</li></ul><h2 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h2><ul><li><p>JDK1.6及之前</p><blockquote><p>有永久代，静态变量存放在永久代上</p></blockquote></li><li><p>JDK1.7</p><blockquote><p>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移动到堆中</p></blockquote></li><li><p>JDK1.8及之后</p><blockquote><p>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</p></blockquote></li></ul><p>移除永久代的原因：</p><ul><li><p>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。</p><blockquote><p>如果某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，可能会经常出现OOM。而元空间和永久代最大的区别在于元空间不在虚拟机中，而是使用本地内存，所以在默认情况下，元空间的大小仅受本地内存限制。</p></blockquote></li><li><p>对永久代进行调优较困难</p></li></ul><h2 id="方法区的内存回收"><a href="#方法区的内存回收" class="headerlink" title="方法区的内存回收"></a>方法区的内存回收</h2><p>方法区的垃圾回收的主要两部分内容：</p><ul><li>常量池中废弃的常量</li><li>不再使用的类型</li></ul><h3 id="常量池中废弃常量的回收"><a href="#常量池中废弃常量的回收" class="headerlink" title="常量池中废弃常量的回收"></a>常量池中废弃常量的回收</h3><p>方法区内常量池中主要存放的两大类常量：</p><ul><li><p>字面量</p><blockquote><p>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值</p></blockquote></li><li><p>符号引用</p><blockquote><p>而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></blockquote></li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中常量没有被任何地方引用，就可以被回收。</p><h3 id="不再使用的类型的回收"><a href="#不再使用的类型的回收" class="headerlink" title="不再使用的类型的回收"></a>不再使用的类型的回收</h3><p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：</p><ol><li><p>该类所有实例都已经被回收。</p><blockquote><p>也就是Java堆中不存在该类及其任何派生子类的实例。</p></blockquote></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用。</p><blockquote><p>这样就无法在任何地方通过反射访问该类的方法。</p></blockquote></li><li><p>加载该类的类加载器已经被回收。</p><blockquote><p>这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常很难达成。</p></blockquote></li></ol><p>Java虚拟机被允许堆满足上述三个条件的无用类进行回收。这里说的是“被允许”，而不是和对象一样，不使用了就必然会回收，是否对类回收通过<code>-Xnoclassgc</code>参数控制。还可以使用<code>-verbose:class</code>、<code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。</p><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-类加载</title>
    <link href="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM全局知识体系图示"><a href="#JVM全局知识体系图示" class="headerlink" title="JVM全局知识体系图示"></a>JVM全局知识体系图示</h1><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-jvm-overview.png" alt="img"></p><h1 id="类字节码"><a href="#类字节码" class="headerlink" title="类字节码"></a>类字节码</h1><p>计算机是不能运行java代码，必须先运行java虚拟机，再由java虚拟机运行编译后的java代码。这个编译后的java代码，就是java字节码。</p><p>为什么jvm不能直接运行java代码？因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的，所有java代码必须要先编译成字节码文件，JVM才能正确识别代码转换后的指令并运行。</p><ul><li>Java代码间接翻译成字节码，存储字节码的文件再交由不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li><li>JVM也不再只支持Java，由此衍生出许多基于JVM的编程语言，如Groovy、Scala、Koltin等等。</li></ul><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-jvm-class-1.png" alt="img"></p><h2 id="字节码文件"><a href="#字节码文件" class="headerlink" title="字节码文件"></a>字节码文件</h2><p>class文件本质上是一个以8字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列再class文件中。JVM根据其特定的规则解析该二进制数据，从而得到相关信息。</p><p>Class文件采用一个伪结构来存储，它有两种类型：无符号数和表。这里暂不详细的讲。</p><h3 id="Class文件的结构属性"><a href="#Class文件的结构属性" class="headerlink" title="Class文件的结构属性"></a>Class文件的结构属性</h3><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-jvm-class-2.png" alt="img"></p><h3 id="一个简单的Class的字节码"><a href="#一个简单的Class的字节码" class="headerlink" title="一个简单的Class的字节码"></a>一个简单的Class的字节码</h3><p>一个简单的Main.java文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> m;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> m + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>javac Main.java</code>编译生成Main.class文件，以文本形式打开生成的class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">cafe babe <span class="hljs-number">0000</span> <span class="hljs-number">0034</span> <span class="hljs-number">0013</span> 0a00 <span class="hljs-number">0400</span> 0f09<br><span class="hljs-number">0003</span> <span class="hljs-number">0010</span> <span class="hljs-number">0700</span> <span class="hljs-number">1107</span> <span class="hljs-number">0012</span> <span class="hljs-number">0100</span> <span class="hljs-number">016d</span> <span class="hljs-number">0100</span><br>0149 <span class="hljs-number">0100</span> 063c 696e <span class="hljs-number">6974</span> <span class="hljs-number">3e01</span> <span class="hljs-number">0003</span> <span class="hljs-number">2829</span><br><span class="hljs-number">5601</span> <span class="hljs-number">0004</span> <span class="hljs-number">436f</span> <span class="hljs-number">6465</span> <span class="hljs-number">0100</span> 0f4c 696e 654e<br><span class="hljs-number">756d</span> <span class="hljs-number">6265</span> <span class="hljs-number">7254</span> <span class="hljs-number">6162</span> 6c65 <span class="hljs-number">0100</span> 0369 <span class="hljs-number">6e63</span><br><span class="hljs-number">0100</span> 0328 <span class="hljs-number">2949</span> <span class="hljs-number">0100</span> 0a53 6f75 <span class="hljs-number">7263</span> <span class="hljs-number">6546</span><br>696c <span class="hljs-number">6501</span> 0009 4d61 696e 2e6a <span class="hljs-number">6176</span> 610c<br><span class="hljs-number">0007</span> 0008 0c00 <span class="hljs-number">0500</span> <span class="hljs-number">0601</span> <span class="hljs-number">0010</span> <span class="hljs-number">636f</span> 6d2f<br><span class="hljs-number">7268</span> <span class="hljs-number">7974</span> <span class="hljs-number">686d</span> <span class="hljs-number">372f</span> 4d61 696e <span class="hljs-number">0100</span> 106a<br><span class="hljs-number">6176</span> <span class="hljs-number">612f</span> 6c61 <span class="hljs-number">6e67</span> 2f4f 626a <span class="hljs-number">6563</span> <span class="hljs-number">7400</span><br><span class="hljs-number">2100</span> <span class="hljs-number">0300</span> <span class="hljs-number">0400</span> <span class="hljs-number">0000</span> <span class="hljs-number">0100</span> <span class="hljs-number">0200</span> <span class="hljs-number">0500</span> <span class="hljs-number">0600</span><br><span class="hljs-number">0000</span> <span class="hljs-number">0200</span> <span class="hljs-number">0100</span> <span class="hljs-number">0700</span> 0800 <span class="hljs-number">0100</span> 0900 <span class="hljs-number">0000</span><br>1d00 <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0000</span> 052a b700 01b1 <span class="hljs-number">0000</span><br><span class="hljs-number">0001</span> 000a <span class="hljs-number">0000</span> <span class="hljs-number">0006</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0001</span><br>000b 000c <span class="hljs-number">0001</span> 0009 <span class="hljs-number">0000</span> <span class="hljs-number">001f</span> <span class="hljs-number">0002</span> <span class="hljs-number">0001</span><br><span class="hljs-number">0000</span> <span class="hljs-number">0007</span> 2ab4 <span class="hljs-number">0002</span> <span class="hljs-number">0460</span> ac00 <span class="hljs-number">0000</span> <span class="hljs-number">0100</span><br>0a00 <span class="hljs-number">0000</span> <span class="hljs-number">0600</span> <span class="hljs-number">0100</span> <span class="hljs-number">0000</span> 0800 <span class="hljs-number">0100</span> 0d00<br><span class="hljs-number">0000</span> <span class="hljs-number">0200</span> 0e<br></code></pre></td></tr></table></figure><ul><li>文件开头四个字节<code>cafe babe</code>称之为<code>魔数</code>，唯有以“cafe babe”开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。</li><li><code>0000</code>是编译器JDK版本的次版本号为0，<code>0034</code>转化为十进制52，是主版本号。java的版本号从45开始，除了1.0和1.1都是使用45.x外，后每升一个大版本，版本号就加一。也就是说，编译该class文件的jdk版本为1.8.0 。</li><li>后续的文件内容为常量池，通过反编译来分析…</li></ul><h3 id="反编译上述Class的字节码"><a href="#反编译上述Class的字节码" class="headerlink" title="反编译上述Class的字节码"></a>反编译上述Class的字节码</h3><blockquote><p>java内置的一个反编译工具javap可以反编译字节码文件。</p></blockquote><p>javap的用法为：<code>javap &lt;options&gt; &lt;classes&gt;</code>。其中<options>选项包括的内容:</options></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">-help  --help  -?        输出此用法消息<br>-version                 版本信息<br>-v  -verbose             输出附加信息<br>-l                       输出行号和本地变量表<br>-public                  仅显示公共类和成员<br>-protected               显示受保护的/公共类和成员<br>-package                 显示程序包/受保护的/公共类和成员 (默认)<br>-p  -private             显示所有类和成员<br>-c                       对代码进行反汇编<br>-s                       输出内部类型签名<br>-sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)<br>-constants               显示最终常量<br>-classpath &lt;path&gt;        指定查找用户类文件的位置<br>-cp &lt;path&gt;               指定查找用户类文件的位置<br>-bootclasspath &lt;path&gt;    覆盖引导类文件的位置<br></code></pre></td></tr></table></figure><p>输入命令<code>javap -v -p Main.class</code>的输出内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字节码文件信息</span><br>Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2018</span>-<span class="hljs-number">4</span>-<span class="hljs-number">7</span>; size <span class="hljs-number">362</span> bytes<br>  MD5 checksum 4aed8540b098992663b7ba08c65312de<br>  Compiled from <span class="hljs-string">&quot;Main.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.rhythm7.Main<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>      <br><span class="hljs-comment">//常量池</span><br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">18</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">3.</span>#<span class="hljs-number">19</span>         <span class="hljs-comment">// com/rhythm7/Main.m:I</span><br>   #<span class="hljs-number">3</span> = Class              #<span class="hljs-number">20</span>            <span class="hljs-comment">// com/rhythm7/Main</span><br>   #<span class="hljs-number">4</span> = Class              #<span class="hljs-number">21</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">5</span> = Utf8               m<br>   #<span class="hljs-number">6</span> = Utf8               I<br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">12</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">13</span> = Utf8               Lcom/rhythm7/Main;<br>  #<span class="hljs-number">14</span> = Utf8               inc<br>  #<span class="hljs-number">15</span> = Utf8               ()I<br>  #<span class="hljs-number">16</span> = Utf8               SourceFile<br>  #<span class="hljs-number">17</span> = Utf8               Main.java<br>  #<span class="hljs-number">18</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">19</span> = NameAndType        #<span class="hljs-number">5</span>:#<span class="hljs-number">6</span>          <span class="hljs-comment">// m:I</span><br>  #<span class="hljs-number">20</span> = Utf8               com/rhythm7/Main<br>  #<span class="hljs-number">21</span> = Utf8               java/lang/Object<br>      <br><span class="hljs-comment">//方法表合集</span><br>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> m;<br>    descriptor: I<br>    flags: ACC_PRIVATE<br><br>  <span class="hljs-keyword">public</span> com.rhythm7.Main();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">3</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/rhythm7/Main;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inc</span><span class="hljs-params">()</span>;<br>    descriptor: ()I<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field m:I</span><br>         <span class="hljs-number">4</span>: iconst_1<br>         <span class="hljs-number">5</span>: iadd<br>         <span class="hljs-number">6</span>: ireturn<br>      LineNumberTable:<br>        line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">7</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/rhythm7/Main;<br>&#125;<br><br><span class="hljs-comment">//类名</span><br>SourceFile: <span class="hljs-string">&quot;Main.java&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Part-1-字节码文件信息"><a href="#Part-1-字节码文件信息" class="headerlink" title="Part 1 字节码文件信息"></a>Part 1 字节码文件信息</h3><p>开头七行得信息：</p><ul><li>class文件当前所在位置</li><li>最后修改时间</li><li>文件大小</li><li>MD5值</li><li>编译自哪个文件</li><li>类得全限定名</li><li>jdk次版本号、主版本号</li></ul><p>再接着是该类得访问标志，访问标志含义如下：</p><ul><li>ACC_PUBLIC：是否为Public类型</li><li>ACC_FINAL：是否被声明为final，只有类可以设置</li><li>ACC_INTERFACE：标志这是一个接口</li><li>ACC_ABSTRACT：是否为abstract类型，对于接口或抽象类来说，此标志为真，其他类型为假</li><li>ACC_ANNOTATION：标志这是一个注解</li><li>ACC_ENUM：标志这是一个枚举</li><li>ACC_SUPER：是否允许使用invokespecial字节码指令得新语义</li><li>ACC_SYNTHETIC：标志这个类并非由用户代码生成</li></ul><h3 id="Part-2-常量池"><a href="#Part-2-常量池" class="headerlink" title="Part 2 常量池"></a>Part 2 常量池</h3><p>常量池可以理解成Class文件中的资源仓库。</p><p>主要存放的是两大类常量：</p><ul><li><p>字面量（Literal）</p><blockquote><p>字面量类似于java中的常量概念，如文本字符串，final常量等。</p></blockquote></li><li><p>符号引用（Symbolic References）</p><blockquote><p>符号引用类似于编译原理方面的概念，包括以下三种：</p><ul><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符号（Descriptor）</li><li>方法的名称和描述符</li></ul><p>不同于C&#x2F;C++，JVM是再加载Class文件的时候才进行动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获取对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。</p></blockquote></li></ul><p>通过反编译的文件来查看字节码内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">#<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">18</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>#<span class="hljs-number">4</span> = Class              #<span class="hljs-number">21</span>            <span class="hljs-comment">// java/lang/Object</span><br>#<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>#<span class="hljs-number">8</span> = Utf8               ()V<br>#<span class="hljs-number">18</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>#<span class="hljs-number">21</span> = Utf8               java/lang/Object<br></code></pre></td></tr></table></figure><p>第一个常量是一个方法定义，指向了第4和第8个常量，以此类推，最后可以拼接成第一个常量右侧注释内容：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java/lang/Object.<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>:()V<br></code></pre></td></tr></table></figure><p>该段可以理解为该类的实例构造器的声明，由于Main类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了Main类的直接父类是Object，该方法默认返回V，也就是void，无返回值。</p><p>关于字节码的类型对应如下：</p><ul><li>B：byte</li><li>C：char</li><li>D：double</li><li>F：float</li><li>I：int</li><li>S：short</li><li>Z：boolean</li><li>V：void</li><li>L：对象类型，以分号结尾。如Ljava&#x2F;lang&#x2F;Object;</li><li>[：数组类型，每一维使用一个前置的<code>[</code>字符来描述。例如定义一个java.lang.String[][]类型的二维数组，将被记录为 [[Ljava&#x2F;lang&#x2F;String;</li></ul><h3 id="Part-3-方法表集合"><a href="#Part-3-方法表集合" class="headerlink" title="Part 3 方法表集合"></a>Part 3 方法表集合</h3><p>在常量池之后是对类内部的方法描述，在字节码中以表的集合形式表现。</p><p>反编译后的方法表中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里声明了一个私有变量m，类型为int，返回值为int。</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> m;<br>  descriptor: I<br>  flags: ACC_PRIVATE<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是构造方法：Main()，返回值为void，公开方法。</span><br><span class="hljs-keyword">public</span> com.rhythm7.Main();<br>   descriptor: ()V<br>   flags: ACC_PUBLIC<br>   <span class="hljs-comment">//方法体信息</span><br>   Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: aload_0<br>        <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>     LineNumberTable:<br>       line <span class="hljs-number">3</span>: <span class="hljs-number">0</span><br>     LocalVariableTable:<br>       Start  Length  Slot  Name   Signature<br>           <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/rhythm7/Main;<br></code></pre></td></tr></table></figure><p>code内的主要属性：</p><ul><li><p>stack（最大操作数栈）</p><blockquote><p>JVM运行时会根据这个值来分配栈帧（Frame） 中的操作栈深度，此处为1。</p></blockquote></li><li><p>locals（局部变量所需的存储空间）</p><blockquote><p>单位为slot，slot时虚拟机为局部变量分配内存时所使用的最小单位，为四字节大小。方法参数（包括隐藏的参数this）、显示异常处理器的参数（try catch中的catch块中所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot可以重用。</p></blockquote></li><li><p>arg_size（方法参数的个数）</p><blockquote><p>这里是1，因为每个实例方法都会有一个隐藏参数this。</p></blockquote></li><li><p>attribute_info（方法体内容）</p><blockquote><p>0，1，4为字节码“行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量（java&#x2F;lang&#x2F;Object.””:()V），然后执行返回语句，结束方法。</p></blockquote></li><li><p>LineNumberTable（字节码偏移量）</p><blockquote><p>该属性的作用是描述源码行号于字节码行号之间的关系。可以使用-g:none或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时午饭获取到发生异常的源码行号，也就无法按照源码的行数来调试程序。</p></blockquote></li><li><p>LocalVariableTable</p><blockquote><p>该属性的作用时描述栈帧中局部变量与源码中定义的变量之间的关系。可以使用-g:none或-g:vars来取消或生成该项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0，arg1这样的占位符。</p><ul><li>start：表示该局部变量在哪一行开始可见</li><li>length：表示可见行数</li><li>Slot：代表所在栈帧位置</li><li>Name：变量名称</li><li>Signature：类型签名</li></ul></blockquote></li></ul><h3 id="Part-4-类名"><a href="#Part-4-类名" class="headerlink" title="Part 4 类名"></a>Part 4 类名</h3><p>最后就是源码文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SourceFile: <span class="hljs-string">&quot;Main.java&quot;</span><br></code></pre></td></tr></table></figure><h2 id="字节码的增强技术"><a href="#字节码的增强技术" class="headerlink" title="字节码的增强技术"></a>字节码的增强技术</h2><blockquote><p>字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。</p></blockquote><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-class-enhancer-1.png" alt="img"></p><h3 id="字节码增强技术"><a href="#字节码增强技术" class="headerlink" title="字节码增强技术"></a>字节码增强技术</h3><h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><p>对于需要手工操纵字节码的需求，可以使用ASM，它可以直接生产.class字节码文件，也可以在被类加载入JVM之前动态修改类行为：</p><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-class-enhancer-2.png" alt="img"></p><p>ASM的应用场景由有AOP（CGLIB就是基于ASM）、热部署、修改其他jar包中的类等。这些操作都涉及比较底层的步骤，实现起来比较麻烦。后面通过介绍ASM的两种API，并使用ASM来实现一个比较粗糙的AOP，然后更快地理解ASM的处理流程。</p><h5 id="ASM-API"><a href="#ASM-API" class="headerlink" title="ASM API"></a>ASM API</h5><h6 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h6><blockquote><p>ASM Core API可以类比解析XML文件的SAX方式，不需要把整个类的结构读取进来，就可以使用流式的方式来处理字节码文件。</p></blockquote><p>好处是非常节约内存，但是编程难度大。然而出于性能考虑，一般情况下编程都使用Core API。其中的几个关键类：</p><ul><li><p>ClassReader</p><blockquote><p>用于读取已经编译好的.class文件</p></blockquote></li><li><p>ClassWriter</p><blockquote><p> 用于重新构建编译后的类。如修改类名、属性以及方法，也可以生成新的类的字节码文件。</p></blockquote></li><li><p>各种Visitor类</p><blockquote><p>如上所述，Core API根据字节码从上到下依次处理，对于字节码文件中不同区域有不同的Visitor：</p><ul><li>MethodeVisitor：用于访问方法（实现AOP主要使用该Visitor）</li><li>FieldVisitor：用于访问类变量</li><li>AnnotationVisitor：用于访问注释</li></ul></blockquote></li></ul><h6 id="树形API"><a href="#树形API" class="headerlink" title="树形API"></a>树形API</h6><blockquote><p>ASM Tree API可以类比解析XML文件的DOM方式，把整个类的结构读入内存，生成属性结构。</p></blockquote><p>缺点是消耗内存多，但是编程比较简单。Tree API不同于Core API，Tree API通过各种Node类来映射字节码的各个区域。类比DOM节点，就可以很好的理解这种编程方式。</p><h5 id="直接使用ASM实现AOP"><a href="#直接使用ASM实现AOP" class="headerlink" title="直接使用ASM实现AOP"></a>直接使用ASM实现AOP</h5><blockquote><p>利用ASM的Core API来增强类。实现在方法调用前、后增加逻辑。</p></blockquote><p>首先定义一个Base类：其中只包含一个process()方法，方法中输出一行“process”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;process&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>增强后，我们期望在方法执行前输出“start”，执行后输出“end”。</p><p>使用ASM实现AOP需要定义的两个类：</p><ul><li><p>MyClassVisitor</p><blockquote><p>用于visit字节码以及修改字节码</p></blockquote></li><li><p>Generator</p><blockquote><p>在该类中定义ClassReader和ClassWriter。</p></blockquote></li></ul><p>其中的逻辑是ClassReader读取字节码，然后交给MyClassVisitor类处理，处理完后由ClassWriter写字节码并将旧的字节码替换掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.objectweb.asm.ClassReader;<br><span class="hljs-keyword">import</span> org.objectweb.asm.ClassVisitor;<br><span class="hljs-keyword">import</span> org.objectweb.asm.ClassWriter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//读取</span><br>        <span class="hljs-type">ClassReader</span> <span class="hljs-variable">classReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(<span class="hljs-string">&quot;meituan/bytecode/asm/Base&quot;</span>);<br>        <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);<br>        <span class="hljs-comment">//处理</span><br>        <span class="hljs-type">ClassVisitor</span> <span class="hljs-variable">classVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassVisitor</span>(classWriter);<br>        classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);<br>        <span class="hljs-type">byte</span>[] data = classWriter.toByteArray();<br>        <span class="hljs-comment">//输出</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;operation-server/target/classes/meituan/bytecode/asm/Base.class&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(f);<br>        fout.write(data);<br>        fout.close();<br>        System.out.println(<span class="hljs-string">&quot;now generator cc success!!!!!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.objectweb.asm.ClassVisitor;<br><span class="hljs-keyword">import</span> org.objectweb.asm.MethodVisitor;<br><span class="hljs-keyword">import</span> org.objectweb.asm.Opcodes;<br><br><span class="hljs-comment">//继承自ClassVisitor，用于对字节码的观察</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Opcodes</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassVisitor</span><span class="hljs-params">(ClassVisitor cv)</span> &#123;<br>        <span class="hljs-built_in">super</span>(ASM5, cv);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> version, <span class="hljs-type">int</span> access, String name, String signature,</span><br><span class="hljs-params">                      String superName, String[] interfaces)</span> &#123;<br>        cv.visit(version, access, name, signature, superName, interfaces);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;<br>        <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> cv.visitMethod(access, name, desc, signature,<br>                exceptions);<br>        <span class="hljs-comment">//Base类中有两个方法：无参构造以及process方法，这里不增强构造方法</span><br>        <span class="hljs-keyword">if</span> (!name.equals(<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>) &amp;&amp; mv != <span class="hljs-literal">null</span>) &#123;<br>            mv = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMethodVisitor</span>(mv);<br>        &#125;<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>    <br>    <span class="hljs-comment">//内部类，继承自MethodVisitor用于对类内方法的观察</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMethodVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Opcodes</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyMethodVisitor</span><span class="hljs-params">(MethodVisitor mv)</span> &#123;<br>            <span class="hljs-built_in">super</span>(Opcodes.ASM5, mv);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.visitCode();<br>            <span class="hljs-comment">//方法进入后，打印&quot;start&quot;</span><br>            mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);<br>            mv.visitLdcInsn(<span class="hljs-string">&quot;start&quot;</span>);<br>            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode)</span> &#123;<br>            <span class="hljs-keyword">if</span> ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)<br>                    || opcode == Opcodes.ATHROW) &#123;<br>                <span class="hljs-comment">//方法在返回之前，打印&quot;end&quot;</span><br>                mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);<br>                mv.visitLdcInsn(<span class="hljs-string">&quot;end&quot;</span>);<br>                mv.visitMethodInsn(INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-literal">false</span>);<br>            &#125;<br>            mv.visitInsn(opcode);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对字节码做修改的步骤：</p><ol><li>通过MyClassVisitor类中的visitMethod方法，判断当前字节码读到哪个方法了。跳过构造方法<code>&lt;init&gt;</code>后，将需要被增强的方法交给内部类MyMethodVisiter来进行处理。</li><li>接下来，进入内部类MyMethodVisitor中的visitCode方法，它会在ASM开始访问某一个方法的Code区时被调用，重写visitCode方法，将AOP中的前置逻辑就放在这里。MyMethodVisitor继续读取字节码指令，每当ASM访问到无参数指令时，都会调用MyMethodVisitor中的visitInsn方法。我们判断了当前指令给是否为无参数的“return”指令，如果是就在它的前面添加一些指令，也就是将AOP的后置逻辑放在该方法中。</li><li>综上，重写MyMethodeVisitor中的两个方法，就可以实现AOP了，而重写方法时就需要用ASM的写法，手动写入或修改字节码。通过调用methodVisitor的visitXXXXInsn()方法就可以实现字节码的插入，XXXX对应相应的操作码助记符类型，例如mv.visitLdcInsn(“end”)对应的操作码就是Ldc“end”即将字符串“end”压入栈。</li><li>完成这两个类后，运行Generator中的main方法完成对Base类的字节码增强，增强后的结果可以在编译后的target文件夹中找到Base.class文件进行查看，可以看到反编译后的代码已经改变。</li></ol><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-class-enhancer-3.png" alt="img"></p><h5 id="ASM工具"><a href="#ASM工具" class="headerlink" title="ASM工具"></a>ASM工具</h5><p>利用ASM手写字节码时，需要利用一系列visitXXXXInsn()方法来写对应的助记符，所以需要先将每一行源码转化为一个个的助记符，然后通过ASM的语法转换为visitXXXXInsn()这种写法。第一步将源码转化为助记符就已经够麻烦了不熟悉字节码操作集合的话，需要我们将代码编译后再反编译才能得到源代码对应的助记符。第二步利用ASM写字节码时，如何传参也很令人头疼。</p><p>ASM社区为了解决上面的问题，提供了IDEA插件工具ASM byte Outline：</p><p>安装后，右键选择“Show Bytecode Outline”，在新标签页中选择“ASMified”这个tab，如图所示：</p><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-class-enhancer-4.png" alt="img"></p><p>在图中就可以看到这个类中的代码对应ASM写法了。图中上下两个红框分别对应AOP中前置逻辑与后置逻辑，将这两块直接复制到visitor中的visitMethod()以及visitInsn()方法中，就可以了。</p><h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><blockquote><p>ASM是在指令层面上操作字节码的，操作比较晦涩。另外一类框架Javassist：强调源代码层次操作字节码。</p></blockquote><p>利用Javassist实现字节码增强时，可以无需关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是ClassPool、CtClass、CtMethod、CtField这四个类：</p><ul><li><p>CtClass（compile-time class）</p><blockquote><p>编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。</p></blockquote></li><li><p>ClassPool</p><blockquote><p>从开发视角来看，ClassPool是一张保存CtClass信息的HashTable，key为类名，value为类名对应的CtClass对象。当我们需要对某个类进行修改时，就是通过pool.getCtClass(“className”)方法从pool中获取到对应的CtClass。</p></blockquote></li><li><p>CtMethod、CtField</p><blockquote><p>对应类的方法和属性。</p></blockquote></li></ul><p>使用上述四个类，写一个小Demo来展示Javassist的简单、快速的特点。同样是对Vas的process()方法进行增强，在方法调用前后输出“start”和“end”。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.meituan.mtrace.agent.javassist.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavassistTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException, IOException &#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-comment">//从ClassPool中获取到相应的CtClass对象</span><br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.get(<span class="hljs-string">&quot;meituan.bytecode.javassist.Base&quot;</span>);<br>        <span class="hljs-comment">//获取CtClass对象中的方法</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> cc.getDeclaredMethod(<span class="hljs-string">&quot;process&quot;</span>);<br>        <span class="hljs-comment">//在方法执行前后插入需要增强的java代码</span><br>        m.insertBefore(<span class="hljs-string">&quot;&#123; System.out.println(\&quot;start\&quot;); &#125;&quot;</span>);<br>        m.insertAfter(<span class="hljs-string">&quot;&#123; System.out.println(\&quot;end\&quot;); &#125;&quot;</span>);<br>        <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cc.toClass();<br>        cc.writeFile(<span class="hljs-string">&quot;/Users/zen/projects&quot;</span>);<br>        <span class="hljs-type">Base</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (Base)c.newInstance();<br>        h.process();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行时类的重载"><a href="#运行时类的重载" class="headerlink" title="运行时类的重载"></a>运行时类的重载</h3><h4 id="问题的引入"><a href="#问题的引入" class="headerlink" title="问题的引入"></a>问题的引入</h4><p>上面介绍了两种不同类型的字节码增强框架，且都利用它们实现了较为粗糙的AOP。在上面的AOP实现中都不涉及重加载类，都是先对编译好的class文件进行修改，修改后再通过new新建对象并调用。</p><p>但是，如果我们在一个JVM中，先加载一个类，再对其进行字节码增强并重新加载就会报错，因为JVM不允许再运行时动态重载一个类。</p><p>显然，如果只能再类加载前对类进行强化，那么字节码增强技术的使用场景就很窄了。我们期望的效果是：在一个持续运行并已经加载了所有类的JVM中，还能利用字节码增强技术对其中的类行为做替换并重新加载。</p><p>为了模拟这这种情况，我们将Base类做改写，在其中编写main方法，每五秒调用一次process()方法，在process()方法中输出一行“process”。我们的目的是在JVM运行中的时候，将process()方法做替换，也就是在运行中时，每五秒打印的内容由”process”变为打印”start process end”。改写的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> ManagementFactory.getRuntimeMXBean().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> name.split(<span class="hljs-string">&quot;@&quot;</span>)[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//打印当前Pid</span><br>        System.out.println(<span class="hljs-string">&quot;pid:&quot;</span>+s);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">5000L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            process();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;process&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面介绍JVM运行时重加载类信息的一些Java类库。</p><h4 id="Instrument"><a href="#Instrument" class="headerlink" title="Instrument"></a>Instrument</h4><blockquote><p>instrument是JVM提供的一个可以修改已加载类的类库，专门为Java语言编写的插桩服务提供支持。需要依赖JVMTI的Attach API机制实现。</p></blockquote><p> 要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransfromer接口，定义一个类文件转换器。接口中的transform()方法会在类文件被加载时调用，而在transform方法里，我们可以利用上文中的ASM或Javassist对传入的字节码进行改写或替换，生成新的字节码数组后返回。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.instrument.ClassFileTransformer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestTransformer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassFileTransformer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="hljs-type">byte</span>[] classfileBuffer) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Transforming &quot;</span> + className);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.get(<span class="hljs-string">&quot;meituan.bytecode.jvmti.Base&quot;</span>);<br>            <span class="hljs-type">CtMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> cc.getDeclaredMethod(<span class="hljs-string">&quot;process&quot;</span>);<br>            m.insertBefore(<span class="hljs-string">&quot;&#123; System.out.println(\&quot;start\&quot;); &#125;&quot;</span>);<br>            m.insertAfter(<span class="hljs-string">&quot;&#123; System.out.println(\&quot;end\&quot;); &#125;&quot;</span>);<br>            <span class="hljs-keyword">return</span> cc.toBytecode();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有了Transformer，还需要将其注入到运行的JVM中。</p><p>定义一个Agent，借助Agent的能力将Instrument注入到JVM中。Agent中的一个类Instrumentation可以做启动后的Instrument、本地代码的Instrument，以及动态改变Classpath等等。我们可以向Instrumentation中添加上文中定义的Transformer，并指定要被重加载的类，这样当Agent被Attach到一个JVM中时，就会执行类字节码替换并重载入JVM的操作。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.instrument.Instrumentation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAgent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">agentmain</span><span class="hljs-params">(String args, Instrumentation inst)</span> &#123;<br>        <span class="hljs-comment">//指定我们自己定义的Transformer，在其中利用Javassist做字节码替换</span><br>        inst.addTransformer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestTransformer</span>(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//重定义类并载入新的字节码</span><br>            inst.retransformClasses(Base.class);<br>            System.out.println(<span class="hljs-string">&quot;Agent Load Done.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;agent load failed!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JVMTI-amp-Agent-amp-Attach-API"><a href="#JVMTI-amp-Agent-amp-Attach-API" class="headerlink" title="JVMTI &amp; Agent &amp; Attach API"></a>JVMTI &amp; Agent &amp; Attach API</h4><p>首先需要介绍JPDA（Java Platform Debugger Architecture）。如果JVM启动时开启了JPDA，那么类是允许被重新加载的。在这种情况下，已经被加载的就版本类信息可以被卸载，然后重新加载新版本的类。正如JPDA名称中的Debugger，JDPA其实是一套用于调试Java程序的标准，任何JDK都必须实现该标准。</p><p>JPDA定义了一套完整的体系，它将调试体系分为三部分，并规定了三者之间的通信接口。三部分由低到高分别是：JVMTI（Java虚拟机工具接口）、JDWP（Java调试协议）、JDI（Java调试接口）。三者关系如下：</p><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-class-enhancer-6.png" alt="img"></p><p><strong>JVMTI：</strong></p><p>借助JVMTI的一部分能力，帮助动态重载类信息。JVMTI是JVM提供的一套对JVM进行操作的工具接口。通过JVMTI，可以实现对JVM的多种操作，它通过接口注册各种事件钩子，在JVM事件触发时，同时触发预定义的钩子，实现对各个 JVM事件的相应，事件包括文件加载、异常的产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC开始和结束、方法调用进入和退出、临界区竞争与等待、VM启动与退出等等。</p><p><strong>Agent：</strong></p><p>而Agent就是JVMTI的一种实现，Agent有两种启动方式，一是随Java进程启动而启动，经常见到的java -agentlib就是这种方式；二是运行时载入，通过Attach API，将模块（jar包）动态地Attach到指定进程id的Java进程中。</p><p><strong>Attach API：</strong></p><p>Attach API的作用时提供JVM进程间通信的能力，比如我们为了让另外一个JVM进程把线上服务的线程Dump出来，会运行jstack或jmap的进程，并传递pid的参数，告诉它要对哪个线程进行线程Dump，这就是Attach API做的事情。</p><p>下面我们通过Attach API的loadAgent()方法，将打包好的Agent jar包动态Attach到目标JVM上。具体实现如下：</p><ol><li><p>定义Agent，并在其中实现AgentMain方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.instrument.Instrumentation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAgent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">agentmain</span><span class="hljs-params">(String args, Instrumentation inst)</span> &#123;<br>        <span class="hljs-comment">//指定我们自己定义的Transformer，在其中利用Javassist做字节码替换</span><br>        inst.addTransformer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestTransformer</span>(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//重定义类并载入新的字节码</span><br>            inst.retransformClasses(Base.class);<br>            System.out.println(<span class="hljs-string">&quot;Agent Load Done.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;agent load failed!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后将TestAgent类打包成一个含有MANIFEST.MF的jar包，其中MANIFEST.MF文件中将Agent-Class属性指定为TestAgent的全限定名，如下图所示：</p><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-class-enhancer-7.png" alt="img"></p></li><li><p>最后利用Attach API，将我们打包好的jar包Attach到JVM pid上，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Attacher</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException &#123;<br>        <span class="hljs-comment">// 传入目标 JVM pid</span><br>        <span class="hljs-type">VirtualMachine</span> <span class="hljs-variable">vm</span> <span class="hljs-operator">=</span> VirtualMachine.attach(<span class="hljs-string">&quot;39333&quot;</span>);<br>        vm.loadAgent(<span class="hljs-string">&quot;/Users/zen/operation_server_jar/operation-server.jar&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>由于在MANIFEST.MF中指定了Agent-Class，所以在Attach后，目标JVM在运行时会走到TestAgent类中定义的agentmain()方法，而在这个方法中，我们利用Instrumentation，将指定的类的字节码通过定义的类转化器TestTransformer做了Base类的字节码替换（通过javassist），并完成了类的重新加载。由此，我们完成了“在JVM运行时，改变类的字节码并重新载入类信息”的目的。</p></li></ol><p>以下为运行时重新载入类的效果：</p><ul><li>先运行Base中的main方法，启动一个JVM</li><li>可以看到控制台每五秒输出一次“process”</li><li>接着执行Attacher中的main()方法，启动一个新的JVM，并将上一个JVM的pid传入。</li><li>此时回到上一个mian()方法的控制台，可以看到控制台每五秒输出“process”前后分别输出“start”和“end”。也就是说完成了运行时的字节码增强，并重新载入了这个类。</li><li><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java-class-enhancer-8.png" alt="img"></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><p>热部署</p><blockquote><p>不部署服务而对线上服务做修改，可以做打点、增加日志等操作。</p></blockquote></li><li><p>Mock</p><blockquote><p>测试的时候对某些服务做Mock。</p></blockquote></li><li><p>性能诊断工具</p><blockquote><p>比如bTrace就是利用Instrument，实现无侵入地跟踪一个正在运行地JVM，监控到类和方法级别地状态信息。</p></blockquote></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>字节码增强技术相当于是一把打开运行时JVM的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态。此为，我们平时使用的动态代理、AOP也与字节码增强密切相关，它们本质上还是利用各种手段生成符合规范的字节码文件。</p><p>综上所述，掌握字节码增强后可以高效地定位并快速修复一些棘手地问题（如线上性能问题、方法出现不可控地出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。</p><h1 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>如图所示：</p><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java_jvm_classload_2.png" alt="img"></p><p>其中加载、验证、准备、初始化这四个阶段是按顺序开始的，而不是按顺序进行或完成，因为这些阶段通常都是相互交叉地混合进行地，通常在一个阶段执行地过程中调用或激活另一个阶段。</p><p>而解析阶段地开始时间不一定，它在某些情况下可以在初始化阶段后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p><h3 id="加载（查找并加载类的二进制数据）"><a href="#加载（查找并加载类的二进制数据）" class="headerlink" title="加载（查找并加载类的二进制数据）"></a>加载（查找并加载类的二进制数据）</h3><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java_jvm_classload_1.png" alt="img"></p><p>相对于类加载的其他阶段而言，加载阶段（准确地来说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员即可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被“首次组东使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误），如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p>加载.class文件有多种方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip、jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译.class文件</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证（确保被加载的类的正确性）"><a href="#验证（确保被加载的类的正确性）" class="headerlink" title="验证（确保被加载的类的正确性）"></a>验证（确保被加载的类的正确性）</h4><blockquote><p>验证时连接阶段的第一步，这一阶段的目的时为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟类加载的时间。</p><p>验证阶段大致会完成4个阶段的检验动作：</p><ul><li><p>文件格式验证</p><blockquote><p>验证字节流是否符合Class文件格式的规范。例如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有被支持的类型。</p></blockquote></li><li><p>元数据验证</p><blockquote><p>对字节码描述的信息进行语义分析（注意：对比<code>javac</code>编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求。例如：这个类是否有父类，除了<code>java.lang.Object</code>之外。</p></blockquote></li><li><p>字节码验证</p><blockquote><p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></blockquote></li><li><p>符号引用验证</p><blockquote><p>确保解析动作能正确执行。</p></blockquote></li></ul><h4 id="准备（为类的静态变量分配内存、并将其初始化为默认值）"><a href="#准备（为类的静态变量分配内存、并将其初始化为默认值）" class="headerlink" title="准备（为类的静态变量分配内存、并将其初始化为默认值）"></a>准备（为类的静态变量分配内存、并将其初始化为默认值）</h4><blockquote><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p></blockquote><p>需要重点关注的两点：</p><ul><li><p>准备阶段进行内存分配的仅是类变量。不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p></li><li><p>这里所设置的初始值是数据类型默认的零值，而不是在Java代码中被显式赋予的值。</p><blockquote><p>假设一个类变量定义为：<code>public static int value = 3</code>。那么变量value在准备阶段后的值为0，而不是3，因为这个时候尚未开始执行任何Java方法。把value赋值为3的<code>put static</code>指令在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法中，所以把value赋值为3的动作将在初始化阶段才会被执行。</p></blockquote></li></ul><p>其余需要注意的几点：</p><ul><li><p>对基本数据类型来说。类变量和全局变量，如果不显式赋值，系统会赋予默认零值；局部变量必须在使用前显式赋值，否则不能通过编译。</p></li><li><p>对于引用数据类型来说。如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值<code>null</code>。</p></li><li><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认零值。</p></li><li><p>同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明时为其显式地赋值，否则编译不通过。而只被<code>final</code>修饰地常量则既可以在声明时显式地赋值，也可以在类初始化时显式地为其赋值，总之，系统不会为其赋予默认零值，需要在使用前显式地赋值。</p></li><li><p>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段，变量value就会被初始化为ConstValue属性所指定的值。</p><blockquote><p>假设上面的类变量定义为：<code>public static final int value = 3</code>。编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中。</p></blockquote></li></ul><h4 id="解析（把类中的符号引用转换为直接引用）"><a href="#解析（把类中的符号引用转换为直接引用）" class="headerlink" title="解析（把类中的符号引用转换为直接引用）"></a>解析（把类中的符号引用转换为直接引用）</h4><blockquote><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p></blockquote><p>符号引用就是一组符号用来描述目标，可以是任何字面量。主要有如下七类：</p><ul><li>类或接口</li><li>字段</li><li>类方法</li><li>接口方法</li><li>方法类型</li><li>方法句柄</li><li>调用点</li></ul><p>直接引用就是直接指向目标的指针、相对偏移量或一个简介定位到目标的句柄。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>JVM负责对类进行初始化，主要是对类的静态变量进行初始化。</p><p>Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量时指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤：</p><ol><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ol><p>类初始化时机：只有对类的主动使用的时候才会导致类的初始化。类的主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new一个对象。</li><li>访问某个类或接口的静态变量，或对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如Class.forName(“com.pdai.jvm.Test”)）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类，直接使用java.exe命令来与运行某个主类</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类访问方法区中数据结构的接口，对象时Heap区的数据</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>Java虚拟机将结束生命周期的几种情况：</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载器的层次"><a href="#类加载器的层次" class="headerlink" title="类加载器的层次"></a>类加载器的层次</h3><p><img src="/2022/11/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD/java_jvm_classload_3.png" alt="img"></p><p>注意：这里父类加载器并不是通过继承关系类实现的，而是采用组合实现的。</p><p>站在Java虚拟机的角度来说，只存在两种不同的类加载器：</p><ul><li><p>启动类加载器</p><blockquote><p>它使用C++实现（仅限Hotspot，其他虚拟机有使用java实现的），它是虚拟机自身的一部分。</p></blockquote></li><li><p>其他类加载器</p><blockquote><p>这些类加载器都是由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中后才能去加载其他的类。</p></blockquote></li></ul><p>站在Java开发人员的角度，类加载器可以大致分为三类：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）</p><blockquote><p>负责加载存放在 JDK&#x2F;jre&#x2F;lib 下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类）。启动类加载器是无法被Java程序直接引用的。</p></blockquote></li><li><p>扩展类加载器（Extension ClassLoader）</p><blockquote><p>该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p></blockquote></li><li><p>应用程序类加载器（Application ClassLoader）</p><blockquote><p>该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></blockquote></li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>应用程序都是由上述三种类加载器互相配合进行加载的。如果有必要，我们还可以加入自定义的类加载器，因为JVM自带的ClassLoader只懂得从本地文件系统加载标准的Java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li>在执行非置信代码前，自动验证数字签名</li><li>动态地创建符合用户特定需要地定制化构建类</li><li>从特定地场所取得java class，例如从数据库和网络中</li></ul><p>自定义类加载器一般继承自ClassLoader类，只需要重写其中的findClass方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pdai.jvm.classloader;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String root;<br><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">byte</span>[] classData = loadClassData(name);<br>        <span class="hljs-keyword">if</span> (classData == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> defineClass(name, classData, <span class="hljs-number">0</span>, classData.length);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadClassData(String className) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> root + File.separatorChar<br>                + className.replace(<span class="hljs-string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="hljs-string">&quot;.class&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bufferSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>;<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[bufferSize];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> ((length = ins.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                baos.write(buffer, <span class="hljs-number">0</span>, length);<br>            &#125;<br>            <span class="hljs-keyword">return</span> baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRoot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(String root)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br><br>        <span class="hljs-type">MyClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>();<br>        classLoader.setRoot(<span class="hljs-string">&quot;D:\\temp&quot;</span>);<br><br>        Class&lt;?&gt; testClass = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            testClass = classLoader.loadClass(<span class="hljs-string">&quot;com.pdai.jvm.classloader.Test2&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> testClass.newInstance();<br>            System.out.println(object.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在自定义类加载器中进行解密。</p><p>需要注意的几点：</p><ul><li>这里传递的文件名需要时类的全限定名。即<code>com.pdai.jvm.classloader.Test2</code>格式的，因为defineClass方法是按这种格式进行处理。</li><li>最好不要重写loadClass文件。因为这样容易破坏双亲委派模式。</li><li>这类Test类本身可以被AppClassLoader类加载，因此我们不能将com&#x2F;pdai&#x2F;jvm&#x2F;classloader&#x2F;Test2.class放在类路径下，否则由于双亲委派机制的存在，会导致该类被AppClassLoader直接加载，而不会通过我们自定义类加载器加载。</li></ul><h3 id="寻找类加载器"><a href="#寻找类加载器" class="headerlink" title="寻找类加载器"></a>寻找类加载器</h3><p>寻找类加载器的一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pdai.jvm.classloader;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>        System.out.println(loader);<br>        System.out.println(loader.getParent());<br>        System.out.println(loader.getParent().getParent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">sun.misc.Launcher$AppClassLoader@64fef26a<br>sun.misc.Launcher$ExtClassLoader@1ddd40f3<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code> 的父Loader。原因是<code>BootstrapLoader</code>是用c语言实现的，找不到一个确定返回父Loader的方式，于是就返回<code>null</code>。</p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类加载有三种方式：</p><ul><li>命令行启动应用时由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul><p>Class.forName()和ClassLoader.loadClass()的区别：</p><ul><li>ClassLoader.loadClass()只做一件事，就是将.class文件加载到JVM中，不会执行static中的内容，只有在newInstance才会执行static块。</li><li>Class.forName()除了将.class文件加载到JVM中，还会对类进行解析，执行类中的static块。</li><li>Class.forName(name, initialize, loader)带参函数也可以控制是否加载static块。并且只有调用了newInstance()方法才会调用构造函数，创建类的对象。</li></ul><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><ul><li><p>全盘负责</p><blockquote><p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另一个类加载器来载入</p></blockquote></li><li><p>父类委托</p><blockquote><p>先让父类加载器尝试加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></blockquote></li><li><p>缓存机制</p><blockquote><p>缓存机制将会保存所有加载过的Class都会被缓存。当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换为Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</p></blockquote></li><li><p>双亲委派机制</p><blockquote><p>如果一个类加载器收到类加载请求，它首先不会自己去尝试加载这个类，而时把请求委托给父加载器去完成，依次向上，因此所有的类加载器请求最终都会被传递到顶层的启动类加载器，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></blockquote></li></ul><p>双亲委派机制过程：</p><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME&#x2F;jre&#x2F;lib里未查找到该class），会使用ExtClassLoader来尝试加载。</li><li>如ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li></ol><p>双亲委派机制的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 首先判断该类型是否已经被加载</span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> findLoadedClass(name);<br>    <span class="hljs-comment">// 如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//如果存在父类加载器，就委派给父类加载器加载</span><br>                c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果不存在父类加载器，就由启动类加载器加载</span><br>                c = findBootstrapClass0(name);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            <span class="hljs-comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span><br>            c = findClass(name);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>        resolveClass(c);<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>双亲委派机制的优势：</p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的七大原则</title>
    <link href="/2022/11/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2022/11/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式四个基本要素与七大原则"><a href="#设计模式四个基本要素与七大原则" class="headerlink" title="设计模式四个基本要素与七大原则"></a>设计模式四个基本要素与七大原则</h1><h2 id="四个基本要素"><a href="#四个基本要素" class="headerlink" title="四个基本要素"></a>四个基本要素</h2><ul><li><p>模式名称（pattern name）</p><blockquote><p>一个注记名，它用一两个词来描述设计模式的问题、解决方案和效果。</p></blockquote></li><li><p>问题（problem）</p><blockquote><p>描述了应该在何时使用模式。</p></blockquote></li><li><p>解决方案（solution）</p><blockquote><p>描述了设计的组成成分，它们之间的相关关系以及各自的职责和协作方案。</p></blockquote></li><li><p>效果（consequences）</p><blockquote><p>描述了模式应用的效果以及使用模式应该权衡的问题。</p></blockquote></li></ul><p>设计模式的创始人很明确地指出了设计模式地基本要素。但是由于现实中浮躁、偏向过度设计等因素地干扰，开发者很多时候会过度关注设计模式和模式的实现（1、3要素），忽略设计模式的场景和目标（2、4要素），导致设计出来的编码逻辑可能过于复杂或者达不到预期的效果。</p><h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><ul><li><p>单一职责原则（Single Responsibility Principle，SRP）</p><blockquote><p>一个类只负责一个功能领域中的相应职责</p></blockquote></li><li><p>开闭原则（Open Closed Principle，OCP）</p><blockquote><p>对扩展开放，对修改关闭</p></blockquote></li><li><p>里氏代换原则（Liskov Substitution Principle，LSP）</p><blockquote><p>所有引用基类的地方必须能透明地使用其子类</p></blockquote></li><li><p>接口隔离原则（Interface Segregation Principle，ISP）</p><blockquote><p>类之间地依赖关系应该建立在最小的接口上</p></blockquote></li><li><p>依赖倒转原则（Dependency Inversion Principle，DIP）</p><blockquote><p>依赖于抽象，不能依赖于具体实现</p></blockquote></li><li><p>最少知识原则（Least Knowledge Principle，LKP）</p><blockquote><p>迪米特法则（Law of Demeter，LOD）</p><p>一个软件实体应当尽可能少的于其他实体发生相互作用</p></blockquote></li><li><p>合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）</p><blockquote><p>尽量使用合成&#x2F;聚合，而不是通过继承来达到复用的目的</p></blockquote></li></ul><p>前五个为常用的SOLID原则。</p><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><blockquote><p>指一个类或模块应该有且仅有一个改变的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受意想不到的破环。如果想要避免这种现象的发生，就要尽可能地遵守单一职责原则。</p><p>此原则的核心就是解耦和增强内聚性。</p></blockquote><h2 id="单一职责原则的意义"><a href="#单一职责原则的意义" class="headerlink" title="单一职责原则的意义"></a>单一职责原则的意义</h2><p>单一职责原则告诉我们：一个类不能做太多的东西。</p><p>在软件系统中，一个类（模块或方法）承担的职责越多，那么其被复用的可能性越低。一个典型的例子就是万能类。其实可以说一句大实话：任何一个常规的MVC项目，在极端情况下，可以用一个类（甚至一个方法）完成所有的功能。但是这样做就会严重耦合，甚至牵一发动全身。一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责分离，将不同职责封装到不同的类中，即将不同的变化原因封装在同一个类中。</p><h2 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h2><h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><p>在一个项目系统代码编写的时候，由于历史原因和认为的不规范导致项目没有分层，一个service类的伪代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span> &#123;<br><br><span class="hljs-keyword">public</span> UserDTO <span class="hljs-title function_">findUser</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">// 获取数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> getConnection();<br>        <span class="hljs-comment">// 执行SQL语句</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM t_user WHERE name = ?&quot;</span>);<br>preparedStatement.setObject(<span class="hljs-number">1</span>, name);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-comment">// 处理结果</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>        <span class="hljs-comment">//entity值拷贝到dto</span><br>        <span class="hljs-keyword">return</span> dto;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Service中做了太多东西，包括数据库连接的管理和SQL的执行这些业务层不应该接触到的逻辑。而且由于这些数据库相关的代码耦合在Service层，如果说数据库更换成Oracle，那么这个业务层的代码也需要大改。</p><h3 id="遵循单一原则的代码"><a href="#遵循单一原则的代码" class="headerlink" title="遵循单一原则的代码"></a>遵循单一原则的代码</h3><ul><li>拆分出一个新的DateBaseUtils类用于专门管理数据库资源</li><li>Dao类用于专门执行查询和查询结果封装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Dao dao;<br><br><span class="hljs-keyword">public</span> UserDTO <span class="hljs-title function_">findUser</span><span class="hljs-params">(String name)</span>&#123;<br>       <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span>  dao.findUserByName(name);<br>       <span class="hljs-type">UserDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>();<br>       <span class="hljs-comment">//entity值拷贝到dto</span><br>       <span class="hljs-keyword">return</span> dto;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dao</span>&#123;<br><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserByName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//获取数据库连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DataBaseUtils.getConnnection();<br>        <span class="hljs-comment">//执行SQL语句</span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM t_user WHERE name = ?&quot;</span>);<br>preparedStatement.setObject(<span class="hljs-number">1</span>, name);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-comment">//处理结果</span><br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，如果有查询封装的变动只需要修改Dao类，数据库相关的变动只需要修改DataBaseUtils类，每个类的职责分明。</p><p>这个时候，如果我们要把底层的存储结构换成Redis或者MongoDB，那么就需要重建整个Dao类，像这种情况下，需要进行接口隔离，后面分析接口隔离原则时详细分析。</p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改已有代码的情况下进行扩展。</p><h2 id="开闭原则的意义"><a href="#开闭原则的意义" class="headerlink" title="开闭原则的意义"></a>开闭原则的意义</h2><p>在软件的生命周期内，因为变化、升级和维护等原因需要对原软件进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要对原有代码经过重新测试。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><h2 id="如何实现对扩展开放，对修改关闭"><a href="#如何实现对扩展开放，对修改关闭" class="headerlink" title="如何实现对扩展开放，对修改关闭"></a>如何实现对扩展开放，对修改关闭</h2><p>要实现对扩展开放，对修改关闭，即遵守开闭原则，需要对系统进行抽象化设计，抽象可以基于抽象类或者接口。一般来说需要做到如下几点（下面接口指的是接口或抽象类）：</p><ul><li><p>通过接口约束扩展。</p><blockquote><p>对扩展进行边界限定，不允许出现在接口中不存在的public方法，也就是扩展必须添加具体实现而不是改变具体的方法。</p></blockquote></li><li><p>参数类型、引用对象尽量使用接口。</p><blockquote><p>使用接口和抽象类而不是实现类，这样就能尽量保证抽象层时稳定的。</p></blockquote></li><li><p>不允许修改接口定义。</p></li></ul><h2 id="例子说明-1"><a href="#例子说明-1" class="headerlink" title="例子说明"></a>例子说明</h2><p>某后台需要检测业务数据，然后展示图表，如柱状图、折线图等，在未来需要支持图标的着色操作。</p><h3 id="原始代码-1"><a href="#原始代码-1" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BarChart</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw bar chart...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LineChart</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw line chart...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawChart</span><span class="hljs-params">(String type)</span>&#123;<br><span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;line&quot;</span>))&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">LineChart</span>().draw();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;bar&quot;</span>))&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">BarChart</span>().draw();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做在初期能满足业务需要，开发效率也高，但是当后面需要新增一个饼状图的时候，即新增一个饼状图的类，原来的客户端App类的drawChart()方法也要新增一个elseif分支，这样做就是修改了原有客户端类库的方法，很不合理。如果在这个时候，在图中加入一个颜色属性，复杂度也大大提高。</p><h3 id="遵循开闭原则的代码"><a href="#遵循开闭原则的代码" class="headerlink" title="遵循开闭原则的代码"></a>遵循开闭原则的代码</h3><p>基于上面的问题，引入一个抽象Chart类AbstractChart，App类在画图的时候总是把相关的操作委托到具体的AbstractChart的派生类实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractChart</span> &#123;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BarChart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractChart</span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Draw bar chart...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LineChart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractChart</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Draw line chart...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawChart</span><span class="hljs-params">(AbstractChart chart)</span>&#123;<br>chart.draw();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，如果新增一种图，只需要新增一个AbstractChart的子类即可，客户端类App不需要改变原来的逻辑。修改后的设计符合开闭原则，因为整个系统在扩展时，原有的代码没有做任何修改。</p><h1 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h1><p>所有引用基类的地方必须能透明地使用其子类对象，也可以简单理解为任何基类可以出现的地方，子类一定可以出现。</p><h2 id="里氏代换原则的意义"><a href="#里氏代换原则的意义" class="headerlink" title="里氏代换原则的意义"></a>里氏代换原则的意义</h2><p>只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。<strong>里氏代换原则是对开闭原则的补充</strong>。实现开闭原则的关键步骤就是抽象化，而基类于子类的继承关系就是抽象化的具体表现，所以里氏替换是对实现抽象化的具体步骤的规范。</p><h2 id="子类为什么可以替换基类的位置"><a href="#子类为什么可以替换基类的位置" class="headerlink" title="子类为什么可以替换基类的位置"></a>子类为什么可以替换基类的位置</h2><p>原因很简单，只要存在继承关系，基类所有的非私有属性和方法，子类都可以通过继承获得（白箱复用），反过来不成立，因为子类很有可能扩充自身的非私有属性或方法，这个时候不能用基类获取子类新增的这些属性和方法。</p><p>里氏代换原则是实现开闭原则的基础，它告诉我们在设计程序的时候尽可能使用基类进行对象的定义和引用，在运行时再决定基类的具体的子类型。</p><p>举个简单的例子说明，假设父类为会呼吸的动物，子类猪和鸟有各自不同的呼吸方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breathe</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breathe</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Bird breathes...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breathe</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Pig breathes...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">Animal</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>bird.breathe();<br><span class="hljs-type">Animal</span> <span class="hljs-variable">pig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>();<br>pig.breathe();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口，不要建立臃肿庞大的接口，也就是接口尽量细化，同时接口中的方法尽量少。</p><h2 id="接口隔离原则和单一职责原则"><a href="#接口隔离原则和单一职责原则" class="headerlink" title="接口隔离原则和单一职责原则"></a>接口隔离原则和单一职责原则</h2><ul><li><p>单一职责原则注重的是类和接口的职责单一，这里的职责是从业务逻辑上划分的。</p></li><li><p>但当接口隔离原则要求当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需要知道与之相关的方法即可。</p></li></ul><p>也就是说，我们在设计接口的时候有可能满足单一职责原则但是不满足接口隔离原则。</p><h2 id="接口隔离原则的规范"><a href="#接口隔离原则的规范" class="headerlink" title="接口隔离原则的规范"></a>接口隔离原则的规范</h2><ul><li>使用接口隔离原则前首先需要满足单一职责原则。</li><li>接口需要高内聚。也就是提高接口、类、模块的处理能力，少对外发布public的方法。</li><li>只提供访问者需要的方法。</li><li>接口设计时有限度的，接口的设计粒度越小，系统越灵活，但是也不能过小。</li></ul><h2 id="例子说明-2"><a href="#例子说明-2" class="headerlink" title="例子说明"></a>例子说明</h2><p>在spring-data-redis中，RedisTemplate中持有一些列的基类。分别是ValueOperations（处理K-V）、ListOprations（处理Hash）、SetOperations（处理集合）等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ValueOperations</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(K key, V value)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(K key, V value, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h1><p>程序要依赖于抽象接口，不要依赖于具体实现。简单来说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><h2 id="依赖倒转原则的意义"><a href="#依赖倒转原则的意义" class="headerlink" title="依赖倒转原则的意义"></a>依赖倒转原则的意义</h2><p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类。即，使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p><p>为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><h2 id="依赖倒转的注意事项"><a href="#依赖倒转的注意事项" class="headerlink" title="依赖倒转的注意事项"></a>依赖倒转的注意事项</h2><ul><li>高层给模块不应该依赖低层模块，高层模块和低层模块都应该依赖于抽象。</li><li>抽象不应该依赖于具体，具体应该依赖于抽象。</li></ul><p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入（DI）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种：构造注入、Setter注入、接口注入。Spring的IOC是此实现的典范。</p><p>从Java的角度看依赖倒转原则的本质就是：面向接口（抽象）编程</p><ul><li>每个具体的类都应该有其接口或基类，或二者都具备</li><li>类中的引用对象应该是接口或基类</li><li>任何具体类都不应该派生出子类</li><li>尽量不要覆写基类中的方法</li><li>结合里氏代换原则使用</li></ul><h2 id="例子说明-3"><a href="#例子说明-3" class="headerlink" title="例子说明"></a>例子说明</h2><p>司机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//司机接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Driver</span> &#123;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//setter注入</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setCar</span><span class="hljs-params">(Car car)</span>;<br>&#125;<br><span class="hljs-comment">//Car接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Car</span> &#123;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//司机实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Driver</span> &#123;<br><br><span class="hljs-keyword">private</span> Car car;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>car.run();<br>&#125;<br><br>    <span class="hljs-comment">//通过sette注入其Car依赖</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCar</span><span class="hljs-params">(Car car)</span> &#123;<br><span class="hljs-built_in">this</span>.car = car;<br>&#125;<br>&#125;<br><span class="hljs-comment">//Car实现类Bmw</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bmw</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Car</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Bmw runs...&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//Car实现类Benz</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Benz</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Car</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Benz runs...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//针对接口编程，使用接口声明变量Drive和Car</span><br><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultDriver</span>();<br><span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br>        <br>        <span class="hljs-comment">//使用setter注入不同的Car（Benz）</span><br>driver.setCar(car);<br>driver.drive();<br>        <br>car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bmw</span>();<br>        <span class="hljs-comment">//使用Setter注入不同的Car（Bmw）</span><br>driver.setCar(car);<br>driver.drive();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h1><p>一个软件实体应该尽可能少地与其他实体发生相互作用。每一个软件单位对其他地单位都只有最少的知识，而且局限于哪些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块独立，相互之间不存在（或很少）依赖关系。迪米塔法则不希望类之间建立直接的联系，如果真的有需要建立联系，也希望通过它的中间类来转达。</p><h2 id="迪米特法则的规则"><a href="#迪米特法则的规则" class="headerlink" title="迪米特法则的规则"></a>迪米特法则的规则</h2><ul><li><p>Only talk to your immediate friends（只与直接的朋友交流）</p><blockquote><p>一个对象的”朋友“包括他本身（this）、它持有的成员对象、入参对象、它所创建的对象。</p></blockquote></li><li><p>尽量少发布public的变量和方法</p><blockquote><p>一旦公开的属性和方法越多，修改的时候影响的范围越大。</p></blockquote></li><li><p>”是自己的就是自己的“</p><blockquote><p>如果一个方法放在本类中共，既不产生新的类间依赖，也不造成负面的影响，那么此方法就应该放在本类中。</p></blockquote></li></ul><h2 id="迪米特法则的意义"><a href="#迪米特法则的意义" class="headerlink" title="迪米特法则的意义"></a>迪米特法则的意义</h2><p>迪米特法则和核心观念就是类间的解耦，所谓的降级类间的耦合，实际上就是尽量减少对象之间的交互。如果两个对象之间不必直接通信，那么这两个对象就不应当发生任何直接的相互作用，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某个方法的话，可以通过第三者转发这个调用，简而言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。但是这样会引发一个问题，有可能产生大量的中间类，导致系统的复杂度提到，可维护性降低。</p><h2 id="例子说明-4"><a href="#例子说明-4" class="headerlink" title="例子说明"></a>例子说明</h2><p>体育老师要知道班里面女生的人数，他委托体育课代表清点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupLeader</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Girl&gt; girls;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupLeader</span><span class="hljs-params">(List&lt;Girl&gt; girls)</span> &#123;<br><span class="hljs-built_in">this</span>.girls = girls;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countGirls</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;The sum of girls is &quot;</span> + girls.size());<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">command</span><span class="hljs-params">(GroupLeader leader)</span>&#123;<br>leader.countGirls();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br><span class="hljs-type">GroupLeader</span> <span class="hljs-variable">groupLeader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupLeader</span>(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Girl</span>()));<br>teacher.command(groupLeader);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，体育课代表就是中间类，体育课代表对于体育老师来说就是”直接的朋友“，如果去掉体育课代表这个中间类，体育老师必须亲自清点女生人数，这样做就违反了迪米特法则。</p><h1 id="合成-x2F-聚合复用原则"><a href="#合成-x2F-聚合复用原则" class="headerlink" title="合成&#x2F;聚合复用原则"></a>合成&#x2F;聚合复用原则</h1><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新的对象通过向内部持有的这些对象的委派达到复用已有功能的目的，而不是通过继承来获得已有的功能。</p><h2 id="聚合（Aggregate）的概念"><a href="#聚合（Aggregate）的概念" class="headerlink" title="聚合（Aggregate）的概念"></a>聚合（Aggregate）的概念</h2><p>聚合表示一种弱的”拥有“关系，一般表现为松散的整体和部分的关系，其实，所谓整体和部分也可以是完全不相关的。例如A对象持有B对象，B对象并不是A对象的一部分，也就是B对象的生命周期是B对象自身管理，和A对象不相关。</p><h2 id="合成（Composite）的概念"><a href="#合成（Composite）的概念" class="headerlink" title="合成（Composite）的概念"></a>合成（Composite）的概念</h2><p>合成表示一种强的”拥有“的关系，一般表现为严格的整体和部分的关系，整体和部分的生命周期是一样的。</p><h2 id="聚合和合成的关系"><a href="#聚合和合成的关系" class="headerlink" title="聚合和合成的关系"></a>聚合和合成的关系</h2><p><img src="/2022/11/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/yb7o5cffsd.jpg" alt="img"></p><h2 id="为什么要使用合成-x2F-聚合来替代继承达到复用的目的"><a href="#为什么要使用合成-x2F-聚合来替代继承达到复用的目的" class="headerlink" title="为什么要使用合成&#x2F;聚合来替代继承达到复用的目的"></a>为什么要使用合成&#x2F;聚合来替代继承达到复用的目的</h2><p>继承复用破坏包装，因为继承将基类的实现细节暴露给派生类，基类的内部细节通常对子类来说是可见的，这种复用也称为”<strong>白箱复用</strong>“。这里有一个 明显的问题是：派生类继承自基类，如果基类的实现发生改变，将会影响到所有派生类的实现。从基类继承而来的实现是静态的，不可能在运行时发生改变，不够灵活。</p><p>合成或聚合关系可以将已有的对象（一般称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象得内部实现细节对于新对象不可见，所以这种复用又称为”<strong>黑箱复用</strong>“。相对于继承关系而言，其耦合度相对较低，成员对象得变化对新对象得影响不大，可以在新对象中根据实际需要有选择地调用成员对象地操作。合成&#x2F;聚合复用可以在运行时动态进行，新对象可以动态地引用与成员类型相同地其他对象。</p><h2 id="慎用继承"><a href="#慎用继承" class="headerlink" title="慎用继承"></a>慎用继承</h2><p>一般情况下，只有明确知道派生类和基类满足IS A的时候才选用继承，当满足HAS A或者不能判断的情况下应该选用合成&#x2F;聚合。</p><p>下面通过一个极端例子说明非IS A的情况下使用继承会出现什么情况：</p><p>定义一个抽象手，手有一个摇摆的方法，然后定义左右手继承抽象手，实现摇摆方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHand</span> &#123;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swing</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeftHand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHand</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swing</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Left hand swings...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RightHand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHand</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swing</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Right hand swings...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面手的继承没有任何问题。现在要实现人（Person）这个类，具备摇左右手的功能。</p><p>如果不考虑IS A的关系，很可能会这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSwingHand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHand</span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swing</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot; hand swings...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSwingHand</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swingLeftHand</span><span class="hljs-params">()</span>&#123;<br>System.out.print(<span class="hljs-string">&quot;Left &quot;</span>);<br><span class="hljs-built_in">super</span>.swing();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swingRightHand</span><span class="hljs-params">()</span>&#123;<br>System.out.print(<span class="hljs-string">&quot;Right &quot;</span>);<br><span class="hljs-built_in">super</span>.swing();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的Person实现了功能，但是逻辑不正确，因为Person不是Hand。</p><p>Hand和Person是严格的部分和整体的关系，或者说Person和Hand是HAS A的关系，并且Hand和Person的生命周期相同，所以使用合成，这样的逻辑就十分清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>  &#123;<br><br><span class="hljs-keyword">private</span> AbstractHand leftHand;<br><span class="hljs-keyword">private</span> AbstractHand rightHand;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>leftHand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeftHand</span>();<br>rightHand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RightHand</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swingLeftHand</span><span class="hljs-params">()</span>&#123;<br>leftHand.swing();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swingRightHand</span><span class="hljs-params">()</span>&#123;<br>rightHand.swing();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-MVC</title>
    <link href="/2022/11/11/Spring-MVC/"/>
    <url>/2022/11/11/Spring-MVC/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Spring-MVC"><a href="#什么是Spring-MVC" class="headerlink" title="什么是Spring MVC"></a>什么是Spring MVC</h1><h2 id="Spring-MVC的引入"><a href="#Spring-MVC的引入" class="headerlink" title="Spring MVC的引入"></a>Spring MVC的引入</h2><p>Spring框架中最后最重要的概念是IOC和AOP，这是Spring的核心。我们要怎样在此基础上构建上层的应用呢？</p><p><img src="/2022/11/11/Spring-MVC/spring-springframework-mvc-1.png" alt="img"></p><p>针对上层的Web应用，Spring MVC诞生了，它是Spring技术栈中最为重要的一个框架。</p><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><blockquote><p>MVC 是 Model（模型）- View（视图）-Controller（控制器）的缩写，一种软件设计规范。本质上也是一种解耦。</p></blockquote><p>用一种业务逻辑、数据、界面显式分离的方法，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p><p><img src="/2022/11/11/Spring-MVC/spring-springframework-mvc-4.png" alt="img"></p><ul><li><p>Model（模型）</p><blockquote><p>是应用程序中用于处理程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。</p></blockquote></li><li><p>View（视图）</p><blockquote><p>是应用程序中处理数据显示的部分。通常视图时依赖模型数据创建的。</p></blockquote></li><li><p>Controller（控制器）</p><blockquote><p>时应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p></blockquote></li></ul><h2 id="什么是Spring-MVC-1"><a href="#什么是Spring-MVC-1" class="headerlink" title="什么是Spring MVC"></a>什么是Spring MVC</h2><blockquote><p>简单来说，Spring MVC是Spring在Spring Container Core和AOP等技术的基础上，遵顼web MVC规范推出的web开发框架，目的是为了简化Java栈的web开发。</p></blockquote><p>Spring MVC的相关特性：</p><ul><li><p>天生与Spring框架集成（如IoC容器、AOP等）</p></li><li><p>更加简洁的Web层开发</p></li><li><p>提供的强大的约定大于配置的契约式编程支持</p></li><li><p>能简单的进行Web层的单元测试</p></li><li><p>支持灵活的URL到页面控制器的映射</p></li><li><p>非常容易与其他视图技术集成。</p><blockquote><p>因为模型数据不放在特定的API中，而是在一个Model中（Map数据结构实现，因此很容易被其他框架复用）</p></blockquote></li><li><p>非常灵活的数据验证、格式化和数据绑定机制，能使用任何对象进行数据绑定，不必实现的顶框架的API</p></li><li><p>提供一套强大的JSP标签库，简化JSP开发</p></li><li><p>支持灵活的本地化、主题等解析</p></li><li><p>更加简单的异常处理</p></li><li><p>对静态资源的支持</p></li><li><p>支持Restful风格</p></li></ul><h1 id="Spring-MVC的请求流程"><a href="#Spring-MVC的请求流程" class="headerlink" title="Spring MVC的请求流程"></a>Spring MVC的请求流程</h1><blockquote><p>Spring Web MVC 框架是一个基于请求驱动的Web框架，使用了前端控制器模式来进行设计，再根据请求映射规则分发给相应的页面控制器进行处理。</p></blockquote><p><img src="/2022/11/11/Spring-MVC/spring-springframework-mvc-5.png" alt="img"></p><ol><li><p>用户发送请求（DispatcherServlet）</p><blockquote><p>前端控制器作为统一访问点，将收到的请求委托给其他解析器进行处理。</p></blockquote></li><li><p>映射处理器（HandlerMapping）</p><blockquote><p>HandlerMapping将请求映射为HandlerExcutionChain对象（包含一个Handler页面控制器和多个HandlerInterceptior拦截器）。通过这种策略模式，很容易添加新的映射策略。</p></blockquote></li><li><p>处理器适配（HandlerAdepter）</p><blockquote><p>HanlderAdapter将处理器包装为适配器，从而支持多种类型的处理器。即适配器设计模式的应用，从而很容易支持很多类型的处理器。</p></blockquote></li><li><p>调用处理器的功能处理方法（Handler）</p><blockquote><p>HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）。</p></blockquote></li><li><p>视图解析（ViewResolver）</p><blockquote><p>ViewResolver将逻辑视图名解析为具体的View。通过这种策略模式，很容易更换其他视图技术。</p></blockquote></li><li><p>模型渲染（View）</p><blockquote><p>View会根据传入的Model模型数据进行渲染，此处的Model实际上是一个Map数据结构。因此很容易支持其他视图技术</p></blockquote></li><li><p>返回响应（DispatcherServlet）</p><blockquote><p>返回响应给用户，到此流程结束</p></blockquote></li></ol><h1 id="Spring-MVC案例"><a href="#Spring-MVC案例" class="headerlink" title="Spring MVC案例"></a>Spring MVC案例</h1><p>项目结构：</p><p><img src="/2022/11/11/Spring-MVC/image-20221112213533579.png" alt="image-20221112213533579"></p><h2 id="Maven包引入"><a href="#Maven包引入" class="headerlink" title="Maven包引入"></a>Maven包引入</h2><ul><li>spring-webmvc包（其中已包含Spring Core Container相关的包）</li><li>javax.servlet-api包</li><li>jstl包（JSP中使用jstl）</li></ul><h2 id="业务代码编写"><a href="#业务代码编写" class="headerlink" title="业务代码编写"></a>业务代码编写</h2><p>User实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;pdai&quot;</span>, <span class="hljs-number">18</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>service:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserServiceImpl userService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">list</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>        modelAndView.addObject(<span class="hljs-string">&quot;dateTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        modelAndView.addObject(<span class="hljs-string">&quot;userList&quot;</span>, userService.findUserList());<br>        modelAndView.setViewName(<span class="hljs-string">&quot;userList&quot;</span>); <span class="hljs-comment">// views目录下userList.jsp</span><br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.1&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>SpringFramework - SpringMVC Demo @pdai<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 1.配置DispatcherServlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc-demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc-demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 2.配置编码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="springmvc-xml"><a href="#springmvc-xml" class="headerlink" title="springmvc.xml"></a>springmvc.xml</h2><blockquote><p>在web.xml中我们配置初始化参数contextConfigLocation，路径是classpath:springmvc.xml。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所以springmvc.xml文件在resources目录下创建。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:jpa</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 扫描注解 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;tech.pdai.springframework.springmvc&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 静态资源处理 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 开启注解 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jspViewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JSP视图"><a href="#JSP视图" class="headerlink" title="JSP视图"></a>JSP视图</h2><p>userList.jsp：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>User List<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">c:if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$&#123;!empty userList&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table table-bordered table-striped&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$&#123;userList&#125;&quot;</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">c:if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h2><ol><li><p>下载tomcat，并给tomcat&#x2F;bin中的执行文件赋权</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> apache-tomcat-9.0.62<br><span class="hljs-built_in">cd</span> bin<br><span class="hljs-built_in">chmod</span> 777 *.sh<br></code></pre></td></tr></table></figure></li><li><p>配置IDEA中的Run Configuration</p><p><img src="/2022/11/11/Spring-MVC/image-20221112221846232.png" alt="image-20221112221846232"></p></li><li><p>添加tomcat-local</p><img src="/2022/11/11/Spring-MVC/image-20221112221949335.png" alt="image-20221112221949335" style="zoom:50%;"></li><li><p>将下载的tomcat跟tomcat-local关联</p><p><img src="/2022/11/11/Spring-MVC/image-20221112222111926.png" alt="image-20221112222111926"></p></li><li><p>在Deployment中添加我们的项目</p><p><img src="/2022/11/11/Spring-MVC/image-20221112222235091.png" alt="image-20221112222235091"></p></li><li><p>运行tomcat，并使用浏览器访问（注意访问路径）</p></li></ol><h1 id="Spring-MVC-实现原理"><a href="#Spring-MVC-实现原理" class="headerlink" title="Spring MVC 实现原理"></a>Spring MVC 实现原理</h1><h2 id="DispatcherServlet的初始化过程"><a href="#DispatcherServlet的初始化过程" class="headerlink" title="DispatcherServlet的初始化过程"></a>DispatcherServlet的初始化过程</h2><h3 id="DispatcherServlet和ApplicationContext之间的关系"><a href="#DispatcherServlet和ApplicationContext之间的关系" class="headerlink" title="DispatcherServlet和ApplicationContext之间的关系"></a>DispatcherServlet和ApplicationContext之间的关系</h3><h3 id="DispatcherServlet的初始化流程"><a href="#DispatcherServlet的初始化流程" class="headerlink" title="DispatcherServlet的初始化流程"></a>DispatcherServlet的初始化流程</h3><h2 id="DispatcherServlet处理请求的过程"><a href="#DispatcherServlet处理请求的过程" class="headerlink" title="DispatcherServlet处理请求的过程"></a>DispatcherServlet处理请求的过程</h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-AOP</title>
    <link href="/2022/11/11/Spring-AOP/"/>
    <url>/2022/11/11/Spring-AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="如何理解AOP"><a href="#如何理解AOP" class="headerlink" title="如何理解AOP"></a>如何理解AOP</h1><blockquote><p>AOP 是 Aspect Oriented Programming的缩写，即面向切面编程。AOP的本质也是为了解耦，它是一种设计思想。</p></blockquote><h2 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h2><blockquote><p>AOP最早是AOP联盟的组织提出的，指定一套规范。Spring将AOP的思想引入框架之中，通过预编译方式和运行期间动态代理实现程序的统一维护的一种技术。</p></blockquote><p>通过一个例子，如何给如下UserServiceImpl中所有方法添加进入方法的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//进入方法的日志</span><br>        System.out.println(<span class="hljs-string">&quot;execute method： findUserList&quot;</span>);<br>        <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;pdai&quot;</span>, <span class="hljs-number">18</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//进入方法的日志</span><br>        System.out.println(<span class="hljs-string">&quot;execute method： addUser&quot;</span>);<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将记录日志功能解耦为日志切面，它的目标是解耦。进而引入AOP的理念：就是将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中。</p><p><img src="/2022/11/11/Spring-AOP/spring-framework-aop-4.png" alt="img"></p><p>OOP和AOP：</p><ul><li>OOP面向对象，针对业务处理过程的实体及其属性和行为进行抽象封装，以便获得更加清晰高效的逻辑单元划分。</li><li>AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，以获得逻辑过程中的各部分之间低耦合的隔离效果。</li></ul><p>这两种设计思想在目标上有着本质的差异：</p><p><img src="/2022/11/11/Spring-AOP/spring-framework-aop-2.png" alt="img"></p><h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><p>一些AOP概念和术语（非Spring特有）：</p><ul><li><p>连接点（Jointpoint）：在哪里干</p><blockquote><p>表示需要在程序中插入横切关注点的拓展点。连接点可能是类初始化、方法执行、方法调用、字段调用或异常处理等等。Spring只支持方法执行连接点。在AOP中表示为在哪里干。</p></blockquote></li><li><p>切入点（Pointcut）：哪里干的集合</p><blockquote><p>选择一组相关连接点的模式，即可以认为是连接点的集合。Spring支持perl5正则表达式和AspectJ切入点模式，Spirng默认使用AspectJ语法。在AOP中表示在哪里干的集合。</p></blockquote></li><li><p>通知（Advice）：干什么</p><blockquote><p>在连接点上执行的行为。通知提供了在AOP中需要在切入点所选择的连接点处进行拓展现有行为的手段。包括前置通知、后置通知、环绕通知，在Spring中通过代理模式实现AOP，并通过拦截器模式以及环绕连接点的拦截器链织入通知。在AOP中表示为干什么。</p></blockquote></li><li><p>切面（Aspect）：在哪儿干和干什么集合</p><blockquote><p>横切关注点的模块化。比如上面提到的日志组件，可以认为是通知、引入和切入点的组合。在Spring中可以使用Schema和@AspectJ方式进行组织实现。在AOP中表示为在哪儿干和干什么集合。</p></blockquote></li><li><p>引入（inter-type declaration）：引入什么</p><blockquote><p>也成为内部类型声明，为已有的类添加额外新的字段或方法。Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象），在AOP中表示为干什么（引入什么）</p></blockquote></li><li><p>目标对象（Target Object）：对谁干</p><blockquote><p>需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可被称为被通知对象。由于Spring AOP通过代理模式实现，从而这个对象永远是被代理对象。在AOP中表示为对谁干。</p></blockquote></li><li><p>织入（Weaving）：怎么实现</p><blockquote><p>把切面连接到其它的应用程序类型或者对象上，并创建一个被通知对象。这些可以在编译时、类加载时或运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。在AOP中表示为怎么实现的。</p></blockquote></li><li><p>AOP代理（AOP Proxy）：怎么实现的一种典型方式</p><blockquote><p>AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型请用切面。在AOP中表示为怎么实现的一中典型方式。</p></blockquote></li></ul><p>通知类型：</p><ul><li><p>前置通知（Before advice）</p><blockquote><p>在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）</p></blockquote></li><li><p>后置通知（After returning advice）</p><blockquote><p>在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回</p></blockquote></li><li><p>异常通知（After throwing advice）</p><blockquote><p>在方法抛出异常退出时执行的通知</p></blockquote></li><li><p>最终通知（After （finally）advice）</p><blockquote><p>当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）</p></blockquote></li><li><p>环绕通知（Around Advice）</p><blockquote><p>包围一个连接点的通知，如方法调用。这时最强大的一种通知类型，环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p></blockquote></li></ul><p>环绕通知是最常用的通知类型。和AspectJ一样，Spring提供所有通知类型的通知，推荐使用尽可能简单的通知类型来实现需要的功能。例如，如果你只是需要一个方法的返回值来更新缓存，最好使用后置通知而不是环绕通知，尽管环绕通知也能完成，用合适的类型通知可以让编程模型变得简单，并且能避免很多潜在错误。</p><p><img src="/2022/11/11/Spring-AOP/spring-framework-aop-3.png" alt="img"></p><h2 id="Spring-AOP和AspectJ是什么关系"><a href="#Spring-AOP和AspectJ是什么关系" class="headerlink" title="Spring AOP和AspectJ是什么关系"></a>Spring AOP和AspectJ是什么关系</h2><p>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译器进行），让java代码具有AspectJ的AOP功能。</p><p>可以说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，并且AspectJ与Java程序完全兼容，几乎是无缝关联，因此对于有Java编程基础的工程师，上手和使用都很简单。</p><h3 id="为什么需要理清Spring-AOP和AspectJ的关系？"><a href="#为什么需要理清Spring-AOP和AspectJ的关系？" class="headerlink" title="为什么需要理清Spring AOP和AspectJ的关系？"></a>为什么需要理清Spring AOP和AspectJ的关系？</h3><p>@Aspect以及增强的几个注解，为什么不是Spring包，而是来源于AspectJ：</p><p><img src="/2022/11/11/Spring-AOP/spring-framework-aop-5.png" alt="img"></p><h3 id="Spring-AOP和AspectJ是什么关系？"><a href="#Spring-AOP和AspectJ是什么关系？" class="headerlink" title="Spring AOP和AspectJ是什么关系？"></a>Spring AOP和AspectJ是什么关系？</h3><ul><li><p>AspectJ是更强的AOP框架，是实际意义的AOP标准</p></li><li><p>Spring为何不写类似AspectJ的框架？</p><blockquote><p>Spring使用纯Java实现，它不需要专门的编译过程，它不需要专门的编译过程，它的一个重要原则是无侵入性（non-invasiveness）。Spring小组完全有能力写类似的框架，只是Spring AOP从来没有打算通过提供一种全面的AOP解决方案来与AspectJ竞争。Spring的开发小组相信无论是基于代理的框架如Spring AOP或是成熟的框架如AspectJ都是很有价值的，它们之间应该是互补而不是竞争的关系。</p></blockquote></li><li><p>Spring小组喜欢@AspectJ注解风格更胜于Spring XML配置。</p><blockquote><p>在Spring 2.0使用了和AspectJ 5一样的注释，并且使用AspectJ来切入点解析和匹配。但是，AOP在运行时仍是纯的Spring AOP，并不依赖于AspectJ的编译器或织入器（weaver）。</p></blockquote></li><li><p>Spring 2.5 对AspectJ的支持</p><blockquote><p>在一些环境下，增加了对AspectJ的装载时编织支持，同时提供了一个新的bean切入点</p></blockquote></li></ul><h3 id="更多关于AspectJ"><a href="#更多关于AspectJ" class="headerlink" title="更多关于AspectJ"></a>更多关于AspectJ</h3><p>AspectJ应用到Java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect（切面）应用到目标函数（类）的过程。</p><ul><li><p>动态织入</p><blockquote><p>动态织入的方式时在运行时动态将要增强的代码织入到目标类中。这往往时通过动态代理技术完成的，比如java JDK的动态代理（反射实现）或者CGLIB的动态代理（继承实现），SpringAOP采用的就是基于运行时增强的代理技术。</p></blockquote></li><li><p>静态织入</p><blockquote><p>AspectJ采用的就静态织入的方式。AspectJ主要采用的时编译期织入，在这个期间使用AspectJ的acj编译器（类似于javac）把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类</p></blockquote><p><img src="/2022/11/11/Spring-AOP/spring-framework-aop-6.png" alt="img"></p></li></ul><h1 id="如何使用AOP"><a href="#如何使用AOP" class="headerlink" title="如何使用AOP"></a>如何使用AOP</h1><h2 id="XML-Schema配置方式"><a href="#XML-Schema配置方式" class="headerlink" title="XML Schema配置方式"></a>XML Schema配置方式</h2><p>定义目标类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopDemoServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doMethod1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;AopDemoServiceImpl.doMethod1()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doMethod2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;AopDemoServiceImpl.doMethod2()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doMethod3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;AopDemoServiceImpl.doMethod3()&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;some exception&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>定义切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-comment">//环绕通知.</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;环绕通知: 进入方法&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        System.out.println(<span class="hljs-string">&quot;环绕通知: 退出方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><span class="hljs-comment">//前置通知</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBefore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;前置通知&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//后置通知.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterReturning</span><span class="hljs-params">(String result)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知, 返回值: &quot;</span> + result);<br>    &#125;<br><span class="hljs-comment">//异常通知.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterThrowing</span><span class="hljs-params">(Exception e)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;异常通知, 异常: &quot;</span> + e.getMessage());<br>    &#125;<br><span class="hljs-comment">//最终通知.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfter</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;最终通知&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>XML配置AOP：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">...</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;tech.pdai.springframework&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 目标类 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.service.AopDemoServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- configure properties of bean here as normal --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 切面 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.aspect.LogAspect&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- configure properties of aspect here as normal --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置切面 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logAspect&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 配置切入点 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* tech.pdai.springframework.service.*.*(..))&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 环绕通知 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAround&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 前置通知 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doBefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 后置通知；returning属性：用于设置后置通知的第二个参数的名称，类型是Object --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAfterReturning&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span> <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;result&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 异常通知：如果没有异常，将不会执行增强；throwing属性：用于设置通知第二个参数的的名称、类型--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAfterThrowing&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span> <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;e&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 最终通知 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAfter&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// create and configure beans</span><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;aspects.xml&quot;</span>);<br><br>    <span class="hljs-comment">// retrieve configured instance</span><br>    <span class="hljs-type">AopDemoServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;demoService&quot;</span>, AopDemoServiceImpl.class);<br><br>    <span class="hljs-comment">// use configured instance</span><br>    service.doMethod1();<br>    service.doMethod2();<br>    <span class="hljs-keyword">try</span> &#123;<br>        service.doMethod3();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// e.printStackTrace();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">-----------------------<br>环绕通知: 进入方法<br>前置通知<br>AopDemoServiceImpl.doMethod1()<br>环绕通知: 退出方法<br>最终通知<br>-----------------------<br>环绕通知: 进入方法<br>前置通知<br>AopDemoServiceImpl.doMethod2()<br>环绕通知: 退出方法<br>最终通知<br>后置通知, 返回值: hello world<br>-----------------------<br>环绕通知: 进入方法<br>前置通知<br>AopDemoServiceImpl.doMethod3()<br>最终通知<br>异常通知, 异常: some exception<br></code></pre></td></tr></table></figure><h2 id="AspectJ注解方式"><a href="#AspectJ注解方式" class="headerlink" title="AspectJ注解方式"></a>AspectJ注解方式</h2><p>基于XML的声明式AspectJ存在一些不足：需要再Spring配置文件中配置大量的代码信息。</p><p>为了解决这个问题，Spring使用了AspectJ框架为AOP的实现提供了一套注解：</p><ul><li><p>@Aspect：切面</p></li><li><p>@pointcut：切入点表达式</p><blockquote><p>在使用时还需要定义一个包含名字和任意参数的方法签名来表示切入点名称，这个方法签名就是一个返回值为void，且方法体为空的普通方法。</p></blockquote></li><li><p>@Before：前置通知</p><blockquote><p>相当于BeforeAdvice。在使用时可以指定pointcut&#x2F;value和returning属性。其中pointcut和value属性作用一样，都用于指定切入点表达式。</p></blockquote></li><li><p>@AfterReturnning：后置通知</p><blockquote><p>相当于AfterReturningAdvice。属性和@Before的属性一样。</p></blockquote></li><li><p>@Around：环绕通知</p><blockquote><p>相当于MethodInterceptor。在使用时需要指定一个value属性，该属性用于指定该通知被植入的切入点。</p></blockquote></li><li><p>@After-Throwing：异常通知</p><blockquote><p>用于定义异常通知来处理程序中未处理的异常，相当于ThrowAdvice。在使用时可指定point&#x2F;value和throwing属性。throwing属性用于指定一个形参名来表示Advice方法中可定义与此名相同的形参，该形参可用于访问目标方法抛出的异常。</p></blockquote></li><li><p>@After：最终通知</p><blockquote><p>不管是否异常，该通知都会执行。使用时需要指定一个value属性指定该通知被织入的切入点。</p></blockquote></li><li><p>@DeclareParents：引介通知</p><blockquote><p>相当于InroductionInterceptor。（不要求掌握）</p></blockquote></li></ul><p>Spring AOP的实现方式时动态织入，动态织入的方式是在运行是动态将要增强的代码织入到目标类中，这往往是通过动态代理技术实现的。Spring对应不同情况选择不同的代理方式。</p><ul><li>对于接口使用JDK动态代理（底层通过反射实现）</li><li>对于非接口使用CGLIB动态代理（底层通过继承实现）</li></ul><h2 id="AOP使用的一些问题"><a href="#AOP使用的一些问题" class="headerlink" title="AOP使用的一些问题"></a>AOP使用的一些问题</h2><h2 id="切入点的申明规则？"><a href="#切入点的申明规则？" class="headerlink" title="切入点的申明规则？"></a>切入点的申明规则？</h2><p>执行表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution（modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern（param-pattern） <span class="hljs-keyword">throws</span>-pattern?）<br></code></pre></td></tr></table></figure><ul><li><p>ret-type-pattern（必选）</p><blockquote><p>返回类型模式。决定了方法的返回类型必须依次匹配一个连接点。最频繁使用的返回模式类型是<code>*</code>，它匹配任意返回类型。</p></blockquote></li><li><p>declaring-type-pattern</p><blockquote><p>一个全限定的类型名将只会匹配返回给定类型的方法</p></blockquote></li><li><p>name-pattern（必选）</p><blockquote><p>名字模式匹配的是方法名。</p></blockquote></li><li><p>param-pattern（必选）</p><blockquote><p>参数模式。</p><ul><li>（）匹配了无参方法</li><li>（..）匹配接受任意数量参数的方法（匹配所有方法）</li><li>（.）匹配只接收一个任意参数类型的方法</li><li>（, String） 匹配一个接收两个参数的方法，第一个任意类型，第二个必须为String</li></ul></blockquote></li></ul><p>一些切入点表达式例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任意公共方法的执行：</span><br>execution（<span class="hljs-keyword">public</span> * *（..））<br><br><span class="hljs-comment">// 任何一个名字以“set”开始的方法的执行：</span><br>execution（* set*（..））<br><br><span class="hljs-comment">// AccountService接口定义的任意方法的执行：</span><br>execution（* com.xyz.service.AccountService.*（..））<br><br><span class="hljs-comment">// 在service包中定义的任意方法的执行：</span><br>execution（* com.xyz.service.*.*（..））<br><br><span class="hljs-comment">// 在service包或其子包中定义的任意方法的执行：</span><br>execution（* com.xyz.service..*.*（..））<br><br><span class="hljs-comment">// 在service包中的任意连接点（在Spring AOP中只是方法执行）：</span><br>within（com.xyz.service.*）<br><br><span class="hljs-comment">// 在service包或其子包中的任意连接点（在Spring AOP中只是方法执行）：</span><br>within（com.xyz.service..*）<br><br><span class="hljs-comment">// 实现了AccountService接口的代理对象的任意连接点 （在Spring AOP中只是方法执行）：</span><br><span class="hljs-built_in">this</span>（com.xyz.service.AccountService）<span class="hljs-comment">// &#x27;this&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 实现AccountService接口的目标对象的任意连接点 （在Spring AOP中只是方法执行）：</span><br>target（com.xyz.service.AccountService） <span class="hljs-comment">// &#x27;target&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点（在Spring AOP中只是方法执行）</span><br>args（java.io.Serializable） <span class="hljs-comment">// &#x27;args&#x27;在绑定表单中更加常用; 请注意在例子中给出的切入点不同于 execution(* *(java.io.Serializable))： args版本只有在动态运行时候传入参数是Serializable时才匹配，而execution版本在方法签名中声明只有一个 Serializable类型的参数时候匹配。</span><br><br><span class="hljs-comment">// 目标对象中有一个 @Transactional 注解的任意连接点 （在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@target</span>（org.springframework.transaction.annotation.Transactional）<span class="hljs-comment">// &#x27;@target&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个目标对象声明的类型有一个 @Transactional 注解的连接点 （在Spring AOP中只是方法执行）：</span><br><span class="hljs-meta">@within</span>（org.springframework.transaction.annotation.Transactional） <span class="hljs-comment">// &#x27;@within&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个执行的方法有一个 @Transactional 注解的连接点 （在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@annotation</span>（org.springframework.transaction.annotation.Transactional） <span class="hljs-comment">// &#x27;@annotation&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个只接受一个参数，并且运行时所传入的参数类型具有@Classified 注解的连接点（在Spring AOP中只是方法执行）</span><br><span class="hljs-meta">@args</span>（com.xyz.security.Classified） <span class="hljs-comment">// &#x27;@args&#x27;在绑定表单中更加常用</span><br><br><span class="hljs-comment">// 任何一个在名为&#x27;tradeService&#x27;的Spring bean之上的连接点 （在Spring AOP中只是方法执行）</span><br>bean（tradeService）<br><br><span class="hljs-comment">// 任何一个在名字匹配通配符表达式&#x27;*Service&#x27;的Spring bean之上的连接点 （在Spring AOP中只是方法执行）</span><br>bean（*Service）<br><br></code></pre></td></tr></table></figure><p> 此外切入点表达式支持逻辑运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;&amp; 要求连接点同时匹配两个切入点表达式<br>|| 要求连接点匹配任意个切入点表达式<br>!: 要求连接点不匹配指定的切入点表达式<br></code></pre></td></tr></table></figure><h2 id="多种增强通知的顺序？"><a href="#多种增强通知的顺序？" class="headerlink" title="多种增强通知的顺序？"></a>多种增强通知的顺序？</h2><p>当多个通知想要在统一连接点运行时，Spring AOP遵循和AspectJ一样的优先规则来确定通知执行的顺序。</p><ul><li><p>当定义在不同切面的两个通知在同一连接点运行</p><blockquote><p>需要指定优先级。通过在切面类中实现org.springframwork.core.Ordered接口，或者用@Order注释来定义优先级。在两个切面中，Ordered.getValue()方法返回值（或注解值）小的优先级更高。</p></blockquote></li><li><p>当定义在同一切面的两个通知在同一连接点运行</p><blockquote><p>执行的顺序未知，且不能声明顺序。所以可以通过将这些在同一连接点运行的通知压缩到同一个通知方法，或者说重构通知到不同的切面类中，当它们在不同切面类时，即可声明它们的顺序。</p></blockquote></li></ul><h2 id="Spring-AOP-和-AspectJ之间的关键区别？"><a href="#Spring-AOP-和-AspectJ之间的关键区别？" class="headerlink" title="Spring AOP 和 AspectJ之间的关键区别？"></a>Spring AOP 和 AspectJ之间的关键区别？</h2><blockquote><p>AspectJ可以做Spring AOP干不了的事情，它是AOP编程的完全解决方案。Spring AOP则是致力于解决企业级开发中最普遍的AOP（方法织入）。</p></blockquote><table><thead><tr><th align="left">Spring AOP</th><th>AspectJ</th></tr></thead><tbody><tr><td align="left">在纯Java中实现</td><td>使用Java编程语言的扩展实现</td></tr><tr><td align="left">不需要单独的编译过程</td><td>除非设置LTW，否则需要AspectJ编译器（ajc）</td></tr><tr><td align="left">只能使用运行时织入</td><td>不能运行时织入。支持编译时、编译后和加载时织入</td></tr><tr><td align="left">仅仅支持方法级编制</td><td>支持编制字段、方法、构造函数、静态初始值设定项、最终类&#x2F;方法等</td></tr><tr><td align="left">只能由Spring容器管理的bean上实现</td><td>可以在所有域对象上实现</td></tr><tr><td align="left">仅支持方法执行切入点</td><td>支持所有切入点</td></tr><tr><td align="left">代理由目标对象创建，并且切面应用在这些代理上</td><td>在执行应用程序之前，各切面直接在代码中共进行织入</td></tr><tr><td align="left">性能差</td><td>性能好</td></tr><tr><td align="left">简单</td><td>复杂</td></tr></tbody></table><h2 id="Spring-AOP-还是完全用AspectJ？"><a href="#Spring-AOP-还是完全用AspectJ？" class="headerlink" title="Spring AOP 还是完全用AspectJ？"></a>Spring AOP 还是完全用AspectJ？</h2><blockquote><p>Spring AOP更易用，AspectJ更强大</p></blockquote><ul><li><p>Spring AOP比完全使用AspectJ更加简单，因为它不需要引入AspectJ的编译器&#x2F;织入器到开发和构建的过程中。如果只需要在Spring bean上通知执行操作，Spring AOP更合适。</p></li><li><p>如果需要通知没有在Spring容器中的对象，或者通知其他非方法执行的连接点，那么就需要使用AspectJ。</p><blockquote><p>在使用AspectJ的时候，可以使用AspectJ代码风格或@AspectJ注解风格：</p><ul><li>若切面在设计中扮演重要角色，且能在IDE中使用AspectJ Development Tools（AJDT），那么首选AspectJ语言。因为该语言专门被设计用于编写切面，更清晰、简单。</li><li>若没有IDE，或切面并非重要角色，那么可以考虑使用@AspectJ风格，并在构建脚本中增加切面织入的段落。</li></ul></blockquote></li></ul><h1 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h1><h2 id="AOP切面的实现"><a href="#AOP切面的实现" class="headerlink" title="AOP切面的实现"></a>AOP切面的实现</h2><h2 id="AOP代理的创建"><a href="#AOP代理的创建" class="headerlink" title="AOP代理的创建"></a>AOP代理的创建</h2><h2 id="CGLIB代理实现"><a href="#CGLIB代理实现" class="headerlink" title="CGLIB代理实现"></a>CGLIB代理实现</h2><h2 id="JDK代理实现"><a href="#JDK代理实现" class="headerlink" title="JDK代理实现"></a>JDK代理实现</h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-IOC</title>
    <link href="/2022/11/11/Spring-IOC/"/>
    <url>/2022/11/11/Spring-IOC/</url>
    
    <content type="html"><![CDATA[<h1 id="如何理解IoC"><a href="#如何理解IoC" class="headerlink" title="如何理解IoC"></a>如何理解IoC</h1><h2 id="Spring-Bean是什么"><a href="#Spring-Bean是什么" class="headerlink" title="Spring Bean是什么"></a>Spring Bean是什么</h2><blockquote><p>Ioc Container 管理的是Spring Bean，那么Spring Bean是什么呢？</p></blockquote><p>Spring里面的bean就类似于定义的一个组件。而这个组件的作用就是实现某个功能，这里所定义的bean就相当于提供了一个更为简便的方法来调用这个组件去实现需要完成的功能。</p><h2 id="IoC是什么"><a href="#IoC是什么" class="headerlink" title="IoC是什么"></a>IoC是什么</h2><blockquote><p>IoC是一种设计思想。在Java开发中，IoC意味着将设计好的对象交给容器控制，而不是传统的在对象内部直接控制。</p></blockquote><h3 id="谁控制谁，控制什么？"><a href="#谁控制谁，控制什么？" class="headerlink" title="谁控制谁，控制什么？"></a>谁控制谁，控制什么？</h3><p>对象的创建：</p><ul><li>在传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象。</li><li>在IoC中专门有一个容器来创建这些对象，即由IoC容器来控制对象的创建。</li></ul><p>谁控制谁：IoC容器控制了对象</p><p>控制什么：主要控制外部资源获取（不只是对象，包括其他资源比如文件等）</p><h3 id="为何叫反转，反转了什么？"><a href="#为何叫反转，反转了什么？" class="headerlink" title="为何叫反转，反转了什么？"></a>为何叫反转，反转了什么？</h3><p>有反转就对应有正转：</p><ul><li>正转就是传统程序中由我们自己在对象中主动控制去直接获取依赖对象</li><li>反转则是由容器来创建即注入依赖对象</li></ul><p>为什么叫反转：因为由容器帮我们查找并注入依赖对象，对象只是被动地接收依赖对象。</p><p>反转了什么：依赖对象的获取被反转</p><h3 id="图例说明："><a href="#图例说明：" class="headerlink" title="图例说明："></a>图例说明：</h3><p>传统的对象创建及组合：（主动去创建对象然后再组合起来）</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-1.png" alt="img"></p><p>有了IoC&#x2F;DI容器后：（客户端不再主动去创建这些对象）</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-2.png" alt="img"></p><h2 id="Ioc能做什么"><a href="#Ioc能做什么" class="headerlink" title="Ioc能做什么"></a>Ioc能做什么</h2><blockquote><p>Ioc不是一种技术，只是一种思想，一个重要的面向对象编程的法则。它能指导我们如何设计出松耦合、更优良的程序。</p></blockquote><p>传统应用程序都是由我们在类内部主动创建对象，从而导致类与类之间高耦合，难于测试。有了IoC容器后，把创建和查找依赖对象的控制全交给容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也便于测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序本来占据主导，要获取什么资源都是主动获取，但是在IoC&#x2F;DI思想中，应用程序就变成被动了，被动的等待IoC容器来创建并注入它所需要的资源了。</p><p>IoC很好的体现了面向对象设计法则之一——好莱坞法则：“别找我们，我们找你”。即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去获取。</p><h2 id="IoC和DI的关系"><a href="#IoC和DI的关系" class="headerlink" title="IoC和DI的关系"></a>IoC和DI的关系</h2><blockquote><p>控制反转是通过依赖注入实现的，其实它们是统一概念的不同角度描述。</p><p>IoC是设计思想，DI是实现方式。</p></blockquote><p>DI-Dependency Injection，即依赖注入。组件之间依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是提升组件的重用的频率，并为系统搭建一个灵活、可拓展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可以制定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><ul><li><p>谁依赖谁</p><blockquote><p>应用程序依赖于IoC容器</p></blockquote></li><li><p>为什么需要依赖</p><blockquote><p>应用程序需要IoC容器来提供对象需要的外部资源</p></blockquote></li><li><p>谁注入谁</p><blockquote><p>IoC容器注入应用程序某个对象，应用程序依赖的对象</p></blockquote></li><li><p>注入了什么</p><blockquote><p>注入某个对象所需要的外部资源（包括对象、资源、常量数据）</p></blockquote></li><li><p>Ioc和DI的关系</p><blockquote><p>由于控制反转概念比较含糊（可能只是理解容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以Martin Fowler又给出一个新的名字“依赖注入”。相对于IoC而言，“依赖注入”明确描述了“被注入对象依赖与IoC容器配置依赖对象”。通俗来讲，IoC是设计思想，DI是实现方式。</p></blockquote></li></ul><h1 id="如何使用IoC"><a href="#如何使用IoC" class="headerlink" title="如何使用IoC"></a>如何使用IoC</h1><h2 id="IoC的配置的三种方式"><a href="#IoC的配置的三种方式" class="headerlink" title="IoC的配置的三种方式"></a>IoC的配置的三种方式</h2><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>将bean的信息配置放在.xml文件中，通过Spring加载xml配置文件为我们创建bean。</p><p>这种方式出现在很多早期SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是第三方类不支持Spring注解。</p><ul><li>优点：适用于任何场景，结构清晰，通俗易懂</li><li>缺点：配置繁琐，不易维护，扩展性差</li></ul><p>举例：</p><ol><li>配置xx.xml</li><li>声明命名空间和配置bean</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- services --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for services go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="java配置"><a href="#java配置" class="headerlink" title="java配置"></a>java配置</h3><p>将类的创建交给我们的配置类JavaConfig完成，Spring只负责维护和管理，采用纯Java创建方式。其本质就是把在XML上的配置声明转移到Java配置类中。</p><ul><li>优点：适用于任何场景；配置方便；扩展性高</li><li>缺点：可读性比较差</li></ul><p>举例：</p><ol><li>创建一个配置类，添加@Configuration注解声明为配置类</li><li>创建方法，方法加上@bean注解，该方法用于创建并返回实例，该实例创建后交由Spring管理。方法名建议与实例名相同（首字母小写）。（实例类不需要加任何注解）</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">public</span> UserDaoImpl <span class="hljs-title function_">userDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;userService&quot;)</span><br>    <span class="hljs-keyword">public</span> UserServiceImpl <span class="hljs-title function_">userService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.setUserDao(userDao());<br>        <span class="hljs-keyword">return</span> userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>通过在类上加注解的方式，来声明这个类交给Spring管理，Spring会自动扫描带@Component、@Controller、@Service、@Repository这四个注解的类，然后帮我们创建并管理，前提是先配置Spring的注解扫描器。</p><ul><li>优点：开发便捷，通俗易懂，方便维护</li><li>缺点：对于一些第三方资源无法通过添加注解来配置，只能采用XML或JavaConfig类配置</li></ul><p>举例：</p><ol><li>对类添加@Component等相关注解</li><li>配置Spring注解扫描，有三种方法：<ul><li>在XML中配置<code>context:component-scan base-package= &#39;包名&#39;</code></li><li>在JavaConfig类添加<code>@ComponentScan(&quot;包名&quot;)</code>注解</li><li>在App中通过<code>new AnnotationConfigApplicationContext(&#39;包名&#39;)</code>指定扫描的basePackage</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="依赖注入的三种方式"><a href="#依赖注入的三种方式" class="headerlink" title="依赖注入的三种方式"></a>依赖注入的三种方式</h2><h3 id="setter方式"><a href="#setter方式" class="headerlink" title="setter方式"></a>setter方式</h3><blockquote><p>setter方法注入的本质包含两步：</p><ol><li>需要new UserServiceImple()创建对象，所以需要默认构造函数</li><li>调用setUserDao()函数注入userDao的值，所以需要setUserDao()函数</li></ol></blockquote><p>xml配置方式中，<code>&lt;property&gt;</code>都是setter注入，对应的xml文件和service类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userDao.findUserList();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDaoImpl userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注释配置方式就只需要在对应setter方法上添加@Autowired注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userDao.findUserList();<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDaoImpl userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法注入（Construct注入）"><a href="#构造方法注入（Construct注入）" class="headerlink" title="构造方法注入（Construct注入）"></a>构造方法注入（Construct注入）</h3><blockquote><p>构造方法注入的本质是通过new UserServiceImpl(userDao)创建对象，在创建对象的时候通过构造方法注入所依赖的对象。</p></blockquote><p>XML配置方式中，<code>&lt;constructor-arg&gt;</code>是通过构造函数参数注入的，对应的xml文件和UserServiceImpl：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(UserDaoImpl userDaoImpl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDaoImpl;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userDao.findUserList();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解配置方式要在构造方法上添加@Autowired注解（也可省略）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDaoImpl userDao;<br><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 这里@Autowired也可以省略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserDaoImpl userDaoImpl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDaoImpl;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userDao.findUserList();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="field注入"><a href="#field注入" class="headerlink" title="field注入"></a>field注入</h3><p>以@Autowired注解注入（自动注入）为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。</p><ul><li>constructor：通过构造方法进行自动注入，spring会匹配和构造方法参数类型一致的bean进行注入，如果有有多个构造方法，Spring会优先注入多参数的构造方法。</li><li>byName：被注入bean的id名必须与set方法后半截匹配，并且id名称首字母必须小写，这一点与手动set注入不同</li><li>byType：查找所有的set方法，将符合参数类型的bean注入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Ioc和DI使用的一些问题"><a href="#Ioc和DI使用的一些问题" class="headerlink" title="Ioc和DI使用的一些问题"></a>Ioc和DI使用的一些问题</h2><h3 id="为什么推荐构造器注入？"><a href="#为什么推荐构造器注入？" class="headerlink" title="为什么推荐构造器注入？"></a>为什么推荐构造器注入？</h3><blockquote><p>构造器注入能够保证注入的组件不可变，并且确保需要的依赖不为空。此外注入的依赖总是能在返回客户端（组件）代码的时候保证完全初始化。</p></blockquote><ul><li>依赖不可变：构造器的方法参数被final修饰</li><li>依赖不为空（省去了我们对其检查）：通过构造器注入，在实例化UserServiceImpl的时候，由Spring容器传入所需参数，如果没有所需参数，则会报错。</li><li>完全初始化的状态：跟依赖不为空结合起来。向构造器传参前，要确保注入内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。</li></ul><p>所以通常是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserDaoImpl userDaoImpl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDaoImpl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="setter注入的问题："><a href="#setter注入的问题：" class="headerlink" title="setter注入的问题："></a>setter注入的问题：</h4><p>对于IoC容器意外的环境，除了使用反射来提供它所需的依赖之外，无法复用该实现类。而且将一直是个潜在的隐患，因为你不调用将一直无法发现NPE的存在。</p><h4 id="field注入（注解注入）的问题："><a href="#field注入（注解注入）的问题：" class="headerlink" title="field注入（注解注入）的问题："></a>field注入（注解注入）的问题：</h4><p>可能会导致循环依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用构造器注入，在spring项目启动的时候，就会抛出：</p><p>BeanCurrentlyInCreationException：Requested bean is currently in creation: Is there an unresolvable circular reference？从而提醒你避免循环依赖，如果是field注入的话，启动不会报错，使用那个bean的时候才会报错。</p><h3 id="使用构造器注入时，注入太多类导致Bad-Smell怎么办？"><a href="#使用构造器注入时，注入太多类导致Bad-Smell怎么办？" class="headerlink" title="使用构造器注入时，注入太多类导致Bad Smell怎么办？"></a>使用构造器注入时，注入太多类导致Bad Smell怎么办？</h3><p>当一个Controller中注入了太多的Service类，Sonar会提示警告：</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-3.png" alt="img"></p><p>对于这个问题，说明类的设计有问题。要考虑是否违反了单一性职责原则，从而导致需要注入这么多依赖。</p><h3 id="Autowired、-Resourec和-Inject等注解注入的区别？"><a href="#Autowired、-Resourec和-Inject等注解注入的区别？" class="headerlink" title="@Autowired、@Resourec和@Inject等注解注入的区别？"></a>@Autowired、@Resourec和@Inject等注解注入的区别？</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul><li>@Autowired是Spring自带的注解</li><li>可以作用在：CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE</li><li>默认根据类型进行自动装配</li><li>若有某类型有多个Bean候选，需要使用配合@Qualifier指定名称匹配，或者使用@Primary在Bean的定义中指定首选的组件</li><li>可以设置属性required &#x3D; false，如果找不到bean则不会报错</li></ul><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul><li>@Resource是JSR250规范的实现，在javax.annotation包下</li><li>可以作用在：TYPE、FIELD、METHOD上</li><li>默认根据属性名称进行装配</li><li>若某属性名称对应多个Bean，则可以通过name属性指定进行注入</li></ul><h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><ul><li>@Inject是JSR330（Dependency Injection for java）中的规范，需要导入Javax.inject.inject jar包，才能实现注入</li><li>可以作用在：CONSTRUCTOR、METHOD、FIELD</li><li>默认根据类型自动装配</li><li>若需要按名称进行装配，则需要配合@Named</li></ul><h1 id="IOC的实现原理"><a href="#IOC的实现原理" class="headerlink" title="IOC的实现原理"></a>IOC的实现原理</h1><h2 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h2><p>IOC容器的整体功能：</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-7.png" alt="img"></p><p>IOC容器有三个设计要点：</p><ul><li>BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册</li><li>BeanDefinition：各种Bean对象及其相互关系</li><li>ApplicationContext：IOC接口的设计和实现</li></ul><h3 id="BeanFactory和BeanRegistry"><a href="#BeanFactory和BeanRegistry" class="headerlink" title="BeanFactory和BeanRegistry"></a>BeanFactory和BeanRegistry</h3><blockquote><p>Spring Bean的创建是典型的工厂模式。这一系列的Bean工厂（也即IOC容器）为开发者管理对象间的依赖关系提供了很多便利和基础服务。在Spring中有许多的IOC容器的实现供用户选择和使用，这是IOC容器的基础。</p><p>在顶层的结构设计主要围绕着BeanFactory和xxxRegistry进行：</p><ul><li>BeanFactory：工厂模式定义了IOC容器的基本功能规范</li><li>BeanRegistry：向IOC容器手工注册BeanDefinition对象的方法</li></ul></blockquote><p>相互关系如下：</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-2.png" alt="img"></p><h4 id="BeanFactory定义了IOC容器基本功能规范？"><a href="#BeanFactory定义了IOC容器基本功能规范？" class="headerlink" title="BeanFactory定义了IOC容器基本功能规范？"></a>BeanFactory定义了IOC容器基本功能规范？</h4><blockquote><p>BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范。它有三个子类：ListableBeanFactory、HierarchicalBeanfactory和AutowireCapableBeanFactory。</p></blockquote><p>BeanFactory接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> &#123;    <br>      <br>    <span class="hljs-comment">//用于取消引用实例并将其与FactoryBean创建的bean区分开来。例如，如果命名的bean是FactoryBean，则获取将返回Factory，而不是Factory返回的实例。</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">FACTORY_BEAN_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&amp;&quot;</span>; <br>        <br>    <span class="hljs-comment">//根据bean的名字和Class类型等来得到bean实例    </span><br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException;    <br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Class requiredType)</span> <span class="hljs-keyword">throws</span> BeansException;    <br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException;<br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException;<br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//返回指定bean的Provider</span><br>    &lt;T&gt; ObjectProvider&lt;T&gt; <span class="hljs-title function_">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span>;<br>    &lt;T&gt; ObjectProvider&lt;T&gt; <span class="hljs-title function_">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span>;<br><br>    <span class="hljs-comment">//检查工厂中是否包含给定name的bean，或者外部注册的bean</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBean</span><span class="hljs-params">(String name)</span>;<br><br>    <span class="hljs-comment">//检查所给定name的bean是否为单例/原型</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-comment">//判断所给name的类型与type是否匹配</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-comment">//获取给定name的bean的类型</span><br>    <span class="hljs-meta">@Nullable</span><br>    Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-comment">//返回给定name的bean的别名</span><br>    String[] getAliases(String name);<br>     <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BeanFactoty为何要定义这么多层次的接口？"><a href="#BeanFactoty为何要定义这么多层次的接口？" class="headerlink" title="BeanFactoty为何要定义这么多层次的接口？"></a>BeanFactoty为何要定义这么多层次的接口？</h4><blockquote><p>主要是为了区分在Spring内部在操作过程中对象的传递和转化过程中，对对象的数据访问所所得限制。</p></blockquote><p>接口有哪些：</p><ul><li><p>HierarchicalBeanFactory</p><blockquote><p>父子级联IOC容器的接口，子容器可以通过接口方法访问父容器。通过HierarchicalBeanFactory接口，Spring的IOC容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的Bean，但父容器不能访问子容器的Bean。Spring中使用父子容器实现了很多功能，例如Spring MVC中，业务层和持久层和Bean位于父容器，展现层Bean位于子容器中，这样展现层可以引用业务层和持久层的Bean，但业务层和持久层看不到展现层的Bean。</p></blockquote></li><li><p>AutowireCapableBeanfactory</p><blockquote><p>定义了将容器中的bean按某种规则进行自动装配的方法。</p></blockquote></li><li><p>ListableBeanFactory</p><blockquote><p>该接口定义了访问容器的Bean基本信息的若干方法。如查看Bean的个数、获取某一类型Bean的配置名、查看容器是否包含某一Bean等方法。</p></blockquote></li><li><p>ConfigurableBeanFactory</p><blockquote><p>这是一个重要的接口，增强了IOC容器的可定制性。它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法。</p></blockquote></li><li><p>ConfigurableListableBeanFactory</p><blockquote><p>ConfigurableBeanFactory和ListableBeanFactory的结合。</p></blockquote></li></ul><p>如何将Bean注册到Beanfactory？</p><blockquote><p>Spring 配置文件中每一个<code>&lt;bean&gt;</code>节点元素在Spring容器中都通过一个BeanDefinition对象表示，它描述了Bean的配置信息。而BeanDefinitionRegistry接口提供了向容器手工注册BeanDefinition对象的方法。</p></blockquote><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><blockquote><p>Bean对象存在依赖嵌套等关系，所以设计者设计了BeanDefinition，它用来对Bean对象及关系定义。</p><p>三个理解的要点：</p><ul><li>BeanDefinition：定义了各种Bean对象及其相互关系</li><li>BeanDefinitionReader：这是BeanDefinition的解析器</li><li>BeanDefinitionHolder：这是BeanDefinition的包装类。用来存储BeanDefinition，name和aliases等</li></ul></blockquote><h4 id="BeanDefinition-1"><a href="#BeanDefinition-1" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的，其继承体系如下：</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-3.png" alt="img"></p><h4 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h4><p>Bean的解析过程非常复杂，功能被分得很细，因为着里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过下图中的类完成：</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-5.png" alt="img"></p><h4 id="BeanDefinitionHolder"><a href="#BeanDefinitionHolder" class="headerlink" title="BeanDefinitionHolder"></a>BeanDefinitionHolder</h4><p>BeanDefinitionHolder这是beanDefination的包装类，用于存储BeanDefinition、name和aliases等。</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-4.png" alt="img"></p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><blockquote><p>IOC容器的接口是ApplicationContext，很显然它必须继承BeanFactory对Bean规范（最基本的IOC）进行定义。而ApplicationContext表示的是应用的上下文，除了对Bean的管理外，还包含：</p><ul><li>访问资源：对不同方式的Bena配置（即资源）进行加载。（实现ResourcePatternResolver接口）</li><li>国际化：支持信息源，可以实现国际化。（实现MessageSource接口）</li><li>应用事件：支持应用事件。（实现ApplicationEventPublisher接口）</li></ul></blockquote><h4 id="ApplicationContext接口的设计"><a href="#ApplicationContext接口的设计" class="headerlink" title="ApplicationContext接口的设计"></a>ApplicationContext接口的设计</h4><p>ApplicationContext整体结构：</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-51.png" alt="img"></p><ul><li><p>HierarchicalBeanFactory和ListableBeanFactory</p><blockquote><p>ApplicationContext继承这两个接口，在此基础上，还通过多个其他接口扩展了BeanFactory的功能。</p></blockquote></li><li><p>ApplicationEventPublisher</p><blockquote><p>让容器拥有发布应用上下文事件的功能，包括启动事件、关闭事件等。</p><p>实现了ApplicationListener事件监听接口的Bean可以接收到容器事件，并对事件进行响应处理。在ApplicationContext抽象实现类AbstractApplicationContext中，我们可以发现存在一个ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。</p></blockquote></li><li><p>MessageSource</p><blockquote><p>为应用提供i18n国际化消息访问的功能。</p></blockquote></li><li><p>ResourcePatternResolver</p><blockquote><p>所有ApplicationContext实现类都实现了类似于PathMatchResourcePatternResolver的功能，可以通过带前缀的Ant风格的资源文件路径装载Spring的配置文件</p></blockquote></li><li><p>LifeCycle</p><blockquote><p>该接口时Spring 2.0 加入的，该接口提供了start()和stop()两个方法，主要用于控制异步处理过程。</p><p>在具体使用时，该接口会同时被ApplicationContext和具体Bean实现，ApplicationContext会将stert&#x2F;stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。</p></blockquote></li></ul><h4 id="ApplicationContext接口的实现"><a href="#ApplicationContext接口的实现" class="headerlink" title="ApplicationContext接口的实现"></a>ApplicationContext接口的实现</h4><blockquote><p>不同的Bean的配置方式（XML、groovy、annotation等）有着不同的资源加载方式，这便衍生出了众多ApplicationContext的实现类。</p></blockquote><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-61.png" alt="img"></p><p>从类结构设计上看，根据是否需要Refresh容器衍生出两个抽象类：</p><ul><li><p>GenericApplicaionContext</p><blockquote><p>初始化的时候创建容器，往后的每次refresh都不会更改</p></blockquote></li><li><p>AbstractRefreshableApplicationContext</p><blockquote><p>每次refresh都是先清楚已有的容器，然后再重新创建。</p><p>AbstractRefreshableApplicationContext及其子类无法做到GenericApplicationContext混合搭配从不同源头获取Bean的定义信息</p></blockquote></li></ul><p>从加载的源来看，衍生出众多类型的ApplicationContext，例如：</p><ul><li><p>FileSystemXmlApplicationContext</p><blockquote><p>从系统盘符中加载xml配置文件</p></blockquote></li><li><p>ClassPathXmlApplicationContext</p><blockquote><p>从类路径下加载xml配置文件</p></blockquote></li><li><p>AnnotationConfigApplicationContext</p><blockquote><p>从一个或多个基于java的配置类中加载上下文定义，适用于java注解方式配置</p></blockquote></li><li><p>ConfigurableApplicationContext</p><blockquote><p>拓展于ApplicationContext，它新增两个主要方法：refresh()和close()，让ApplicationContext具有启动、刷新和关闭应用上下文的能力。</p><p>调用close()即可关闭应用上下文，在应用上下文关闭的情况下调用refresh()即可启动应用上下文，在已启动的状态下，调用refresh()则清除缓存并重新装载配置信息。这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。</p></blockquote></li></ul><p>进一步的理解：</p><ul><li><p>AnnotaionConfigApplicationContext为什么继承GenericApplicationContext？</p><blockquote><p>因为基于注解的配置，是不太会被运行时修改的，这意味着不需要进行动态bean配置和刷新容器，所以只需要GenericApplicationContext</p></blockquote></li><li><p>为什么AnnotationWebConfigApplicationContext却是继承了AbstractRefreshableApplicationContext？</p><blockquote><p>因为用户可以通过ApplicationContextInitializer来设置contextInitializerClasses（context-param&#x2F;init-param），在这种情况下用户倾向于刷新Bean。</p></blockquote></li><li><p>基于xml配置的类的继承关系？</p><blockquote><p>XML相关的配置必然继承AbstractRefreshApplicationContext，因为XML这种配置文件易修改，所以需要动态性刷新Bean的支持。</p><p>且由于存在多种XML的加载方式，所以需要AbstractXmlApplicationContext，其中包含了将XML配置解析成BeanDefination的过程。</p></blockquote></li></ul><h3 id="设计结构和设计要点结合"><a href="#设计结构和设计要点结合" class="headerlink" title="设计结构和设计要点结合"></a>设计结构和设计要点结合</h3><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-71.png" alt="img"></p><h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><blockquote><p>初始化流程：Spring将资源配置（以xml配置为例）通过加载和解析，生成BeanDefination并注册到IOC容器中。</p></blockquote><p>初始化流程为圈出来的部分：</p><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-73.png" alt="img"></p><h3 id="初始化的入口"><a href="#初始化的入口" class="headerlink" title="初始化的入口"></a>初始化的入口</h3><p>对于xml配置的Spring应用，在main()方法中实例化ClasspathXmlApplicationContext即可创建IoC容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;aspects.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>, <span class="hljs-string">&quot;services.xml&quot;</span>);<br></code></pre></td></tr></table></figure><p>ClasspathXmlApplicationContxt的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String... configLocations)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-built_in">this</span>(configLocations, <span class="hljs-literal">true</span>, (ApplicationContext)<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String[] configLocations, <span class="hljs-type">boolean</span> refresh, <span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">// 1. 设置Bean资源加载器</span><br>    <span class="hljs-built_in">super</span>(parent);<br><br>    <span class="hljs-comment">// 2. 设置配置路径</span><br>    <span class="hljs-built_in">this</span>.setConfigLocations(configLocations);<br><br>    <span class="hljs-comment">// 3. 初始化容器</span><br>    <span class="hljs-keyword">if</span> (refresh) &#123;<br>        <span class="hljs-built_in">this</span>.refresh();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-设置资源解析器和环境"><a href="#1-设置资源解析器和环境" class="headerlink" title="1. 设置资源解析器和环境"></a>1. 设置资源解析器和环境</h3><p>ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的构造方法（super(parent)）为容器设置好Bean资源加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractApplicationContext</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span> &#123;<br>    <span class="hljs-comment">// 默认构造函数初始化容器id, name, 状态 以及 资源解析器</span><br>    <span class="hljs-built_in">this</span>();<br><br>    <span class="hljs-comment">// 将父容器的Environment合并到当前容器</span><br>    <span class="hljs-built_in">this</span>.setParent(parent);<br>&#125;<br><span class="hljs-comment">// 1.1 默认构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.logger = LogFactory.getLog(<span class="hljs-built_in">this</span>.getClass());<br>    <span class="hljs-built_in">this</span>.id = ObjectUtils.identityToString(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.displayName = ObjectUtils.identityToString(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.beanFactoryPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <span class="hljs-built_in">this</span>.active = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>();<br>    <span class="hljs-built_in">this</span>.closed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>();<br>    <span class="hljs-built_in">this</span>.startupShutdownMonitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-built_in">this</span>.applicationStartup = ApplicationStartup.DEFAULT;<br>    <span class="hljs-built_in">this</span>.applicationListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>();<br>    <span class="hljs-comment">//资源解析器</span><br>    <span class="hljs-built_in">this</span>.resourcePatternResolver = <span class="hljs-built_in">this</span>.getResourcePatternResolver();<br>&#125;<br><br><span class="hljs-comment">// Spring资源加载器</span><br><span class="hljs-keyword">protected</span> ResourcePatternResolver <span class="hljs-title function_">getResourcePatternResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMatchingResourcePatternResolver</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br><span class="hljs-comment">// 1.2 合并父容器环境</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span> &#123;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Environment</span> <span class="hljs-variable">parentEnvironment</span> <span class="hljs-operator">=</span> parent.getEnvironment();<br>        <span class="hljs-keyword">if</span> (parentEnvironment <span class="hljs-keyword">instanceof</span> ConfigurableEnvironment) &#123;<br>            <span class="hljs-built_in">this</span>.getEnvironment().merge((ConfigurableEnvironment)parentEnvironment);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-设置配置路径"><a href="#2-设置配置路径" class="headerlink" title="2. 设置配置路径"></a>2. 设置配置路径</h3><p>在设置容器的资源加载器之后，接下来ClasspathXmlApplicationContext执行setConfigLocations方法，该方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean定义资源文件的定位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfigLocations</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String... locations)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locations != <span class="hljs-literal">null</span>) &#123;<br>        Assert.noNullElements(locations, <span class="hljs-string">&quot;Config locations must not be null&quot;</span>);<br>        <span class="hljs-built_in">this</span>.configLocations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[locations.length];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; locations.length; ++i) &#123;<br>            <span class="hljs-comment">// 解析配置路径</span><br>            <span class="hljs-built_in">this</span>.configLocations[i] = <span class="hljs-built_in">this</span>.resolvePath(locations[i]).trim();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.configLocations = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">resolvePath</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-comment">// 从上一步Environment中解析</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getEnvironment().resolveRequiredPlaceholders(path);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-初始化容器的主体流程"><a href="#3-初始化容器的主体流程" class="headerlink" title="3. 初始化容器的主体流程"></a>3. 初始化容器的主体流程</h3><p>Spring IoC容器对Bean定义资源的载入是从refresh()函数开始的。</p><p>refresh()是一个<strong>模板方法</strong>，refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似与会IoC容器的重启，在新建好的容器中对容器进行初始化，对bean定义资源进行载入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">contextRefresh</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.refresh&quot;</span>);<br><br>        <span class="hljs-comment">// Prepare this context for refreshing.</span><br>        prepareRefresh();<br><br>        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>        <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>        prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>            postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanPostProcess</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.beans.post-process&quot;</span>);<br>            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>            invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>            registerBeanPostProcessors(beanFactory);<br>            beanPostProcess.end();<br><br>            <span class="hljs-comment">// Initialize message source for this context.</span><br>            initMessageSource();<br><br>            <span class="hljs-comment">// Initialize event multicaster for this context.</span><br>            initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>            onRefresh();<br><br>            <span class="hljs-comment">// Check for listener beans and register them.</span><br>            registerListeners();<br><br>            <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>            finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// Last step: publish corresponding event.</span><br>            finishRefresh();<br>        &#125;<br><br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                        <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>            &#125;<br><br>            <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>            destroyBeans();<br><br>            <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>            cancelRefresh(ex);<br><br>            <span class="hljs-comment">// Propagate exception to caller.</span><br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br><br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br>            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>            resetCommonCaches();<br>            contextRefresh.end();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>refresh()的设计是一个非常典型的<strong>资源类加载处理型</strong>的思路。其顶层思路如下：</p><ul><li>模板方法设计模式，模板方法中使用典型的钩子方法</li><li>将具体的初始化加载方法插入钩子方法之 间</li><li>将初始化的阶段封装，用来记录当前初始化到什么阶段。常见的设计是xxxPhase&#x2F;xxxStage。</li><li>资源加载初始化有失败等处理，所以必然有try&#x2F;catch&#x2F;finally</li></ul><p><img src="/2022/11/11/Spring-IOC/spring-framework-ioc-source-8.png" alt="img"></p><h4 id="初始化BeanFactory"><a href="#初始化BeanFactory" class="headerlink" title="初始化BeanFactory"></a>初始化BeanFactory</h4><h4 id="读取Bean定义资源（AbstractBeanDefinitionReader）"><a href="#读取Bean定义资源（AbstractBeanDefinitionReader）" class="headerlink" title="读取Bean定义资源（AbstractBeanDefinitionReader）"></a>读取Bean定义资源（AbstractBeanDefinitionReader）</h4><h4 id="加载Bean定义资源（XmlBeanDefinitionReader）"><a href="#加载Bean定义资源（XmlBeanDefinitionReader）" class="headerlink" title="加载Bean定义资源（XmlBeanDefinitionReader）"></a>加载Bean定义资源（XmlBeanDefinitionReader）</h4><h4 id="将Bean定义资源转换为Document对象（DocumentLoader）"><a href="#将Bean定义资源转换为Document对象（DocumentLoader）" class="headerlink" title="将Bean定义资源转换为Document对象（DocumentLoader）"></a>将Bean定义资源转换为Document对象（DocumentLoader）</h4><h4 id="解析载入Bean定义资源文件（XmlBeanDefinitionReader）"><a href="#解析载入Bean定义资源文件（XmlBeanDefinitionReader）" class="headerlink" title="解析载入Bean定义资源文件（XmlBeanDefinitionReader）"></a>解析载入Bean定义资源文件（XmlBeanDefinitionReader）</h4><h4 id="对Bean定义的Document对象解析（DefaultDefinitionDocumentReader）"><a href="#对Bean定义的Document对象解析（DefaultDefinitionDocumentReader）" class="headerlink" title="对Bean定义的Document对象解析（DefaultDefinitionDocumentReader）"></a>对Bean定义的Document对象解析（DefaultDefinitionDocumentReader）</h4><h4 id="解析Bean定义资源文件生成的BeanDefinition（BeanDefinitionParserDelegate）"><a href="#解析Bean定义资源文件生成的BeanDefinition（BeanDefinitionParserDelegate）" class="headerlink" title="解析Bean定义资源文件生成的BeanDefinition（BeanDefinitionParserDelegate）"></a>解析Bean定义资源文件生成的BeanDefinition（BeanDefinitionParserDelegate）</h4><h4 id="在IOC容器注册解析后的BeanDefinition"><a href="#在IOC容器注册解析后的BeanDefinition" class="headerlink" title="在IOC容器注册解析后的BeanDefinition"></a>在IOC容器注册解析后的BeanDefinition</h4><h2 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h2><h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h3><h3 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h3><blockquote><p>Spring只解决了单例模式下属性依赖的循环问题。Spring为了解决单例的循环依赖问题，使用了三级缓存。</p></blockquote><h4 id="Spring单例模式下的属性依赖"><a href="#Spring单例模式下的属性依赖" class="headerlink" title="Spring单例模式下的属性依赖"></a>Spring单例模式下的属性依赖</h4><h4 id="Spring为何不能解决非单例属性之外的循环依赖"><a href="#Spring为何不能解决非单例属性之外的循环依赖" class="headerlink" title="Spring为何不能解决非单例属性之外的循环依赖"></a>Spring为何不能解决非单例属性之外的循环依赖</h4><h4 id="其他循环依赖如何解决"><a href="#其他循环依赖如何解决" class="headerlink" title="其他循环依赖如何解决"></a>其他循环依赖如何解决</h4><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-框架介绍</title>
    <link href="/2022/11/11/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/11/11/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h1><h2 id="Spring的起源"><a href="#Spring的起源" class="headerlink" title="Spring的起源"></a>Spring的起源</h2><blockquote><p>J2EE –&gt; EJB –&gt; Spring</p></blockquote><p>J2EE的出现带来了诸如事务管理之类的核心中间层概念的标准化，但在实践中开发效率，开发难度和性能都不行。</p><p>EJB的学习和应用都很难，不容易理解。</p><ul><li>要严格地实现各种不同类型地接口</li><li>大量重复代码</li><li>配置复杂单调</li><li>使用JNDI进行对象查找也是单调枯燥</li><li>开发效率低，资源消耗高</li></ul><p>Spring的最大目的就是使JAVA EE开发更加容易。同时，Spring之所以与Struts、Hibernate等单层框架不同，是因为Spring致力与提供一个以统一的、高效的方式构造整个应用，并且可以将单层框架以最佳的组合柔和在一起建立一个连贯的体系。</p><p>可以说Spring是一个提供了更完善开发环境的一个框架，可以为POJO对象提供企业级服务。</p><h2 id="Spring的特性和优势"><a href="#Spring的特性和优势" class="headerlink" title="Spring的特性和优势"></a>Spring的特性和优势</h2><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ul><li><p>非侵入式</p><blockquote><p>基于Spring开发的应用中的对象可以不依赖于Spring的API</p></blockquote></li><li><p>IOC</p><blockquote><p> Inversion of Control，控制反转。指的是将对象的创建权交给Spring，没有使用Spring的时候，对象都是在我们自己的代码中new创建的，而使用Spring后，对象都是由框架创建的。</p></blockquote></li><li><p>DI</p><blockquote><p>Dependency Injection，依赖注入。指的是依赖的对象不需要手动调用setXX方法取设置，而是通过配置赋值。</p></blockquote></li><li><p>AOP</p><blockquote><p>Aspect Oriented Programming，面向切面编程。</p></blockquote></li><li><p>容器</p><blockquote><p>Spring是一个容器，因为它包含并且管理应用对象的生命周期。</p></blockquote></li><li><p>组件化</p><blockquote><p>Spring实现了使用简单的组件配置组合成一个复杂的应用。在Spring中可以使用XML和Java注解组合这些对象。</p></blockquote></li><li><p>一站式</p><blockquote><p>在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了表现层的SpringMVC和持久层的Spring JDBC）</p></blockquote></li></ul><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li><p>Spring可以使开发人员使用POJOs开发企业级的应用程序。</p><blockquote><p>只使用POJOs的好处是不需要EJB容器，比如应用程序服务器，但是可以选择一个健壮的servlet容器，比如Tomcat。</p></blockquote></li><li><p>Spring在一个单元模式中是有组织的。</p><blockquote><p>即使包和类的数量非常大，我们也只需要关心需要的，忽略其他的即可。</p></blockquote></li><li><p>Spring可以避免造轮子。</p><blockquote><p>它真正利用了一些现有的技术，像ORM框架、日志框架、JEE、Quartz和JDK计时器，其他视图技术。</p></blockquote></li><li><p>测试Spring编写的程序很容易。</p><blockquote><p>因为环境相关的代码被移动到这个框架中。此外，通过使用JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。</p></blockquote></li><li><p>Spring的web框架是一个设计良好的web MVC框架。</p><blockquote><p>它为比如Structs或者其他工程上的或者不怎么受欢迎的web框架提供了一个很好的供替代的选择。MVC模式导致应用程序的不同方面（输入逻辑、业务逻辑和UI逻辑）分离，同时提供这些元素之间的松散耦合。模型（Model）封装了应用程序数据，通常它们将由POJO类组成。视图（View）负责渲染模型数据，一般来说它生成客户端浏览器可以解释的HTML输出。控制器（Controller）负责处理用户请求并构造适当的模型，并将其传递给视图进行渲染。</p></blockquote></li><li><p>Spring封装了一些难用的API</p><blockquote><p>对于JavaEE开发中的一些难用的API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p></blockquote></li><li><p>轻量级</p><blockquote><p>Spring的IOC容器往往是轻量级的，特别是于EJB容器相比的时候。这有利于在内存和CPU资源有限的计算机上开发和部署应用程序。</p></blockquote></li><li><p>提供统一的事务管理接口</p><blockquote><p>可以向下扩展到本地事务并扩展到全局事务</p></blockquote></li></ul><h1 id="Spring的组成"><a href="#Spring的组成" class="headerlink" title="Spring的组成"></a>Spring的组成</h1><p><img src="/2022/11/11/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/spring-framework-introduce-8.png" alt="img"></p><h2 id="Core-Container（Spring的核心容器）"><a href="#Core-Container（Spring的核心容器）" class="headerlink" title="Core Container（Spring的核心容器）"></a>Core Container（Spring的核心容器）</h2><p>Spring的核心容器是其他模块建立的基础。</p><ul><li><p>Beans模块</p><blockquote><p>提供了个框架的基础部分，包括控制反转和依赖注入。</p></blockquote></li><li><p>Core核心模块</p><blockquote><p>封装了Spring框架的底层部分，包括资源访问、类型转换及一些常用工具类</p></blockquote></li><li><p>Context上下文模块</p><blockquote><p>建立在Core和Bean模块上。集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等。</p><p>ApplicationContext接口是上下文模块的焦点。</p></blockquote></li><li><p>SpEl模块</p><blockquote><p>提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</p></blockquote></li></ul><h2 id="Data-Access-x2F-Integration（数据访问-x2F-集成）"><a href="#Data-Access-x2F-Integration（数据访问-x2F-集成）" class="headerlink" title="Data Access&#x2F;Integration（数据访问&#x2F;集成）"></a>Data Access&#x2F;Integration（数据访问&#x2F;集成）</h2><ul><li><p>JDBC模块</p><blockquote><p>提供了一个JDBC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</p></blockquote></li><li><p>ORM模块(Object&#x2F;Relational Mapping)</p><blockquote><p>提供与流行的“对象-关系”映射框架无缝集成的API，包括JPA、JDO、Hibernate和MyBatis等。而且还可以使用Spring事务管理，无需额外控制事务。</p></blockquote></li><li><p>OXM模块(Object&#x2F;XML Mapping)</p><blockquote><p>提供了一个支持Object&#x2F;XML映射的抽象层实现，比如JAXB、Castor、XMLBeans、JiBX、和XStream。将Java对象映射为XML数据，或者将XML数据映射成Java对象。</p></blockquote></li><li><p>JMS模块</p><blockquote><p>指Java消息服务，提供一套“消息生产者、消息消费者”模板用于更加简介地使用JMS，JMS用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信</p></blockquote></li><li><p>Transaction事务模块</p><blockquote><p>支持编程和声明式事务管理</p></blockquote></li></ul><h2 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h2><ul><li><p>Web模块</p><blockquote><p>提供了基本地Web开发集成特性，例如多文件上传功能、使用Servlet监听器的IOC容器初始化以及Web应用上下文</p></blockquote></li><li><p>Servlet模块</p><blockquote><p>提供一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证和一套非常易用的JSP标签，完全无缝与Spring其他技术协作</p></blockquote></li><li><p>WebSocket模块</p><blockquote><p>提供简单的接口，用户只要实现响应的接口就可以快速的搭建WebSocket Server，从而实现双向通讯。</p></blockquote></li><li><p>Webfux模块</p><blockquote><p>Spring Web Flux 是 Spring Framework 5.x 中引入的新的响应式web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范。Spring Web Flux 用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。</p></blockquote></li></ul><h2 id="AOP、Aspects、Instumentation和Messaging"><a href="#AOP、Aspects、Instumentation和Messaging" class="headerlink" title="AOP、Aspects、Instumentation和Messaging"></a>AOP、Aspects、Instumentation和Messaging</h2><ul><li><p>AOP模块</p><blockquote><p>提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合</p></blockquote></li><li><p>Aspects模块</p><blockquote><p>提供AspectJ的集成，是一个功能强大且成熟的面向切面编程（AOP）的框架</p></blockquote></li><li><p>Instrumentation模块</p><blockquote><p>提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</p></blockquote></li><li><p>messaging模块</p><blockquote><p>Spring 4.0后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</p></blockquote></li><li><p>jcl模块</p><blockquote><p>Spring 5.x 中新增了日志框架集成的模块</p></blockquote></li></ul><h2 id="Test模块"><a href="#Test模块" class="headerlink" title="Test模块"></a>Test模块</h2><p>Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。</p><p>包括Mock Objects，TestContext Framework，Spring MVC Test，Web TestClient。</p><h1 id="Hello-Spring"><a href="#Hello-Spring" class="headerlink" title="Hello Spring"></a>Hello Spring</h1><p>Spring框架的常用场景图：</p><p><img src="/2022/11/11/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/spring-framework-helloworld-2.png" alt="img"></p><h2 id="设计一个Spring的Hello-World"><a href="#设计一个Spring的Hello-World" class="headerlink" title="设计一个Spring的Hello World"></a>设计一个Spring的Hello World</h2><p>结合上面的使用场景图，设计一个查询用户的案例的两个需求，看Spring框架为我们简化了什么开发工作。</p><p>需求如下：</p><ul><li>查询用户数据来看，DAO+POJO -&gt; Serveice 的初始化和装载</li><li>给所有的Service的查询方法记录日志</li></ul><p>项目步骤：</p><ol><li><p>创建一个Mavaen的java项目</p></li><li><p>引入Spring框架的POM依赖（pom.xml）</p><blockquote><p>（Project Object Model，项目对象模型）是Maven工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?pom.xml中需要关注的部分?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;aspectjweaver.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>spring-context</li><li>spring-core</li><li>spring-beans</li><li>aspectjweaver</li></ul></li><li><p>编写POJO - User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写DAO - UserDaoImpl，并增加daos.xml，用于获取POJO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserDaoImpl</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//init</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//mocked to find user list.</span><br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;pdai&quot;</span>, <span class="hljs-number">18</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.dao.UserDaoImpl&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写业务层UserServiceImpl，并增加services.xml，用于调用DAO层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//init</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * find user list</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userDao.findUserList();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * set userDao</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDaoImpl userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- services --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for services go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写Aspect，并增加aspects.xml，拦截所有Service中的方法，并输出记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * aspect for every methods under service package.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;execution(* tech.pdai.springframework.service.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">businessService</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// get attribute through annotation</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> ((MethodSignature) pjp.getSignature()).getMethod();<br>        System.out.println(<span class="hljs-string">&quot;execute method: &quot;</span> + method.getName());<br><br>        <span class="hljs-comment">// continue to process</span><br>        <span class="hljs-keyword">return</span> pjp.proceed();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;tech.pdai.springframework&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.aspect.LogAspect&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- configure properties of aspect here as normal --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>组装App（ClassPathXmlApplicationContext）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// create and configure beans</span><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;aspects.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>, <span class="hljs-string">&quot;services.xml&quot;</span>);<br><br>        <span class="hljs-comment">// retrieve configured instance</span><br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserServiceImpl.class);<br><br>        <span class="hljs-comment">// use configured instance</span><br>        List&lt;User&gt; userList = service.findUserList();<br><br>        <span class="hljs-comment">// print info from beans</span><br>        userList.forEach(a -&gt; System.out.println(a.getName() + <span class="hljs-string">&quot;,&quot;</span> + a.getAge()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>整体项目的文件结构</p><p><img src="/2022/11/11/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/image-20221111213702966.png" alt="image-20221111213702966"></p></li></ol><h2 id="Hello-World中Spring核心的体现"><a href="#Hello-World中Spring核心的体现" class="headerlink" title="Hello World中Spring核心的体现"></a>Hello World中Spring核心的体现</h2><h3 id="控制反转-IOC"><a href="#控制反转-IOC" class="headerlink" title="控制反转-IOC"></a>控制反转-IOC</h3><blockquote><p>第一个需求：查询用户，service通过调用dao查询pojo。</p><p>本质上就是如何创建User&#x2F;Dao&#x2F;Service的问题。</p></blockquote><p>如果没有Spring框架，我们需要自己创建User&#x2F;Dao&#x2F;Service等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserDaoImpl</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br><span class="hljs-type">UserSericeImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>userService.setUserDao(userDao);<br>List&lt;User&gt; userList = userService.findUserList();<br></code></pre></td></tr></table></figure><p>有了Spring框架，将原有的Bean的创建工作转给框架，需要时从Bean的容器中获取即可（Bean的创建和使用分离）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// create and configure beans</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;aspects.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>, <span class="hljs-string">&quot;services.xml&quot;</span>);<br><br><span class="hljs-comment">// retrieve configured instance</span><br><span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserServiceImpl.class);<br><br><span class="hljs-comment">// use configured instance</span><br>List&lt;User&gt; userList = service.findUserList();<br><br></code></pre></td></tr></table></figure><p>Spring接管Bean创建工作的示意图：</p><p><img src="/2022/11/11/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/spring-framework-helloworld-6.png" alt="img"></p><p>更进一步，便更能理解为何有如下知识点了：</p><ul><li>Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean，这个就叫控制反转，Inversion of Control（IoC）</li><li>Spring框架托管创建的Bean存放在IoC Container</li><li>Spring为了更好地让用户配置Bean，引入了不同地方式来配置Bean：xml配置、java配置、注解配置</li><li>Spring框架既然接管了Bean的生成，必然需要管理整个Bean的生命周期</li><li>应用程序代码从IoC Container中获取依赖的Bean，注入到程序中，这个过程叫<strong>依赖注入（Dependency Injection，DI）</strong>。所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述，通俗的来说IoC是设计思想，DI是实现方式</li><li>依赖注入有多种方式：构造器注入、Setter注入、变量注入</li></ul><h3 id="面向切面-AOP"><a href="#面向切面-AOP" class="headerlink" title="面向切面-AOP"></a>面向切面-AOP</h3><blockquote><p>第二个需求：给Service所有方法添加调试日志（调用方法时）</p><p>本质上是一个解耦问题。</p></blockquote><p>如果没有Spring框架，我们需要在每个service的方法中都添加记录日志的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* find user list.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> user list</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;execute method findUserList&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userDao.findUserList();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>有了Spring框架，通过@Aspect注解定义了切面，这个切面中定义了拦截所有service中的方法，并记录日志。可以明显看到，框架将日志记录和业务需求的代码解耦了，不再是侵入式的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* aspect for every methods under service package.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Around(&quot;execution(* tech.pdai.springframework.service.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">businessService</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// get attribute through annotation</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> ((MethodSignature) pjp.getSignature()).getMethod();<br>    System.out.println(<span class="hljs-string">&quot;execute method: &quot;</span> + method.getName());<br><br>    <span class="hljs-comment">// continue to process</span><br>    <span class="hljs-keyword">return</span> pjp.proceed();<br>&#125;<br></code></pre></td></tr></table></figure><p>更进一步，便更能理解为何有如下知识点了：</p><ul><li>Spring框架通过定义切面，通过拦截切点实现了不同业务模块的解耦，这个就叫做面向切面编程，Aspect Oriented Programming（AOP）</li><li>为什么@Aspect注解使用的是aspectj的jar包呢？这就引入了Aspect4J和Spring AOP的历史渊源，只有理解了Aspect4J和Spring的历史渊源才能理解有些注解上的兼容设计</li><li>如何支持更多拦截方式来实现解耦，以满足更多场景需求呢？这就是@Around、@Pointcut…等的设计</li><li>Spring是如何实现AOP的呢？这就引入代理技术，分为静态代理和动态代理，动态代理又分为JDK代理和CGLIB代理</li></ul><h2 id="Spring框架的简化开发"><a href="#Spring框架的简化开发" class="headerlink" title="Spring框架的简化开发"></a>Spring框架的简化开发</h2><blockquote><p>通过前面的介绍，初步知道Spring设计的两大要点：IOC和AOP。从框架的设计角度而言，更重要的是简化开发，比如提供更便捷的配置Bean的方法，直至0配置（即约定大于配置）。下面通过Spring历史版本的发展和Spring Boot的推出，来帮助理解Spring是如何逐步简化开发的。</p></blockquote><h3 id="Java类配置"><a href="#Java类配置" class="headerlink" title="Java类配置"></a>Java类配置</h3><p>前面的例子中，是通过xml配置方式实现的，下面通过Java配置进行改造：</p><p>将原有的.xml配置转换为Java配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">public</span> UserDaoImpl <span class="hljs-title function_">userDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;userService&quot;)</span><br>    <span class="hljs-keyword">public</span> UserServiceImpl <span class="hljs-title function_">userService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.setUserDao(userDao());<br>        <span class="hljs-keyword">return</span> userService;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;logAspect&quot;)</span><br>    <span class="hljs-keyword">public</span> LogAspect <span class="hljs-title function_">logAspect</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogAspect</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在App中加载BeansConfig的配置（AnnotationConfigApplicationContext）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// create and configure beans</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(BeansConfig.class);<br><br>        <span class="hljs-comment">// retrieve configured instance</span><br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserServiceImpl.class);<br><br>        <span class="hljs-comment">// use configured instance</span><br>        List&lt;User&gt; userList = service.findUserList();<br><br>        <span class="hljs-comment">// print info from beans</span><br>        userList.forEach(a -&gt; System.out.println(a.getName() + <span class="hljs-string">&quot;,&quot;</span> + a.getAge()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体项目机构：</p><p><img src="/2022/11/11/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/image-20221111230019634.png" alt="image-20221111230019634"></p><h3 id="注释配置"><a href="#注释配置" class="headerlink" title="注释配置"></a>注释配置</h3><p>Java 5开始提供注解支持，Spring 2.5 开始完全支持基于注解的配置。在Spring后续的版本发展也更倾向于通过注解和Java配置结合使用。</p><p>BeanConfig保留，但是不再需要在其中配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansConfig</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过在Bean中添加注解，注册Bean和注入Bean：</p><ul><li><p>UserDaoImpl增加@Repository注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;pdai&quot;</span>, <span class="hljs-number">18</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>UserServiceImpl增加@Service注解，并通过@Autowired注入userDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>App中加载配置（AnnotationConfigApplicationContext）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// create and configure beans</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(<br>                <span class="hljs-string">&quot;tech.pdai.springframework&quot;</span>);<br><br>        <span class="hljs-comment">// retrieve configured instance</span><br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> context.getBean(UserServiceImpl.class);<br><br>        <span class="hljs-comment">// use configured instance</span><br>        List&lt;User&gt; userList = service.findUserList();<br><br>        <span class="hljs-comment">// print info from beans</span><br>        userList.forEach(a -&gt; System.out.println(a.getName() + <span class="hljs-string">&quot;,&quot;</span> + a.getAge()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h3><p>SpringBoot实际上通过约定大于配置的方式，使用xx-starter统一对Bean进行默认初始化，用户只需要很少的配置就可以进行开发。</p><p>结合Spring历史版本和SpringBoot看发展：</p><p><img src="/2022/11/11/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/spring-framework-helloworld-8.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-内存</title>
    <link href="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/"/>
    <url>/2022/11/05/MySQL-%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Buffer-Pool简介"><a href="#Buffer-Pool简介" class="headerlink" title="Buffer Pool简介"></a>Buffer Pool简介</h1><h2 id="Buffer-Pool的作用"><a href="#Buffer-Pool的作用" class="headerlink" title="Buffer Pool的作用"></a>Buffer Pool的作用</h2><p>MySQL的数据是存储在磁盘中的，但是每次都直接从磁盘读数据，这样性能很差。为此InnoDB存储引擎设计了一个缓冲池，当数据从磁盘中取出来后，缓存在内存中，下次查询相同数据就直接从内存中读取，这样就提高了数据库的读写性能。</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png" alt="img"></p><p>有了缓冲池后的读写操作：</p><ul><li>读取数据时，如果数据存在于Buffer Pool中，客户端就直接读取Buffer Pool中的数据，否则才去磁盘中读取。</li><li>当修改数据时，首先将数从磁盘读到Buffer Pool中，修改Buffer Pool中数据所在页，然后将该页设置为脏页，最后由后台线程将脏页写入磁盘。</li></ul><h2 id="Buffer-Pool缓存"><a href="#Buffer-Pool缓存" class="headerlink" title="Buffer Pool缓存"></a>Buffer Pool缓存</h2><h3 id="Buffer-Pool的缓存大小"><a href="#Buffer-Pool的缓存大小" class="headerlink" title="Buffer Pool的缓存大小"></a>Buffer Pool的缓存大小</h3><p>Buffer Pool在MySQL启动的时候，向操作系统申请一片连续的内存空间，默认128MB。</p><p><code>innodb_buffer_pool_size</code>参数可以设置Buffer Pool的大小，一般建议设置为可用物理内存的60%~80%。</p><h3 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h3><p>InnoDB会把存储的数据划分为若干个页，<strong>以页作为磁盘和内存交互的基本单位</strong>，一个页的默认大小为16KB。因此Buffer Pool同样需要按页来划分。在MySQL启动的时候，InnoDB会为Buffer Pool申请一片连续的内存空间，然后按照16KB的大小划分出一个个页，Buffer Pool中的页称为<strong>缓存页</strong>。</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/bufferpool%E5%86%85%E5%AE%B9.drawio-166788020102019.png" alt="img"></p><p>刚开始的时候，这些缓存页都是空闲的，随着程序的运行才会有磁盘中的页被缓存到Buffer Pool中。因此MySQL刚启动时，使用的虚拟内存空间很大，而使用的物理内存空间很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，将虚拟地址与物理地址建立映射关系。</p><p>因为InnoDB的Buffer Pool缓存是以页为单位缓存数据的，所以如果只是查询一条记录，也需要缓存整个该记录所在页。通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到Buffer Pool后，再通过页中的页目录去定位页中的某条具体记录。</p><h3 id="控制块"><a href="#控制块" class="headerlink" title="控制块"></a>控制块</h3><blockquote><p>为了更好的管理这些在Buffer Pool中的缓存页，InnoDB为每一个缓存页都创建了一个<strong>控制块</strong>。</p></blockquote><p>控制块信息包括：</p><ul><li>缓存页的表空间</li><li>页号</li><li>缓存页地址</li><li>链表节点</li></ul><p>控制块也占有内存空间，它是放在Buffer Pool的最前面，接着才是缓存页，如图：</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" alt="img"></p><p>在控制块和缓存页之间灰色部分称为碎片空间：</p><blockquote><p>在分配了足够多的控制块和缓存页后，可能剩余的空间不够一对控制块和缓存页的大小，这部分空间就无法使用。</p></blockquote><h1 id="如何管理BufferPool"><a href="#如何管理BufferPool" class="headerlink" title="如何管理BufferPool"></a>如何管理BufferPool</h1><h2 id="空闲页管理（Free链表）"><a href="#空闲页管理（Free链表）" class="headerlink" title="空闲页管理（Free链表）"></a>空闲页管理（Free链表）</h2><p>Buffer Pool是一片连续的内存空间，当MySQL运行一段时间后，这片连续的内存空间既有空闲，也有被使用的。当我们需要从磁盘读取数据到Buffer Pool中的时候，需要找到其中空闲的缓存页。</p><p>为了能够快速的找到空闲的缓存页，通过使用链表结构，将空闲的缓存页的控制块作为链表的节点，这个链表称为<strong>Free 链表</strong>（空闲链表）。</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/freelist.drawio.png" alt="img"></p><ul><li><p>Free链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量信息。</p></li><li><p>Free链表节点是一个个的控制块，而每个控制块包含着对应的缓存页的地址，所以相当于Free链表节点都对应一个空闲的缓存页。</p></li></ul><p>有了Free链表后，每当需要从磁盘中加载一个页到Buffer Pool时，就从Free链表中取一个空闲的缓存页，并把该缓存页对应的控制块信息填上，然后将缓存页对应的控制块从Free链表中移除。</p><h2 id="脏页管理（Flush链表）"><a href="#脏页管理（Flush链表）" class="headerlink" title="脏页管理（Flush链表）"></a>脏页管理（Flush链表）</h2><p>设计Buffer Pool除了能提高读性能，还能提高写性能。也就是每次更新数据的时候，不需要每次都要写入磁盘，而是将Buffer Pool对应的缓存页标记为脏页，然后再由后台线程将脏页写入到磁盘。</p><p>为了能快速直到哪些缓存页是脏页，于是就设计出了Flush链表，它跟Free链表类似，链表的节点是控制块，区别在于Flush链表的元素都是脏页。</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/Flush.drawio.png" alt="img"></p><p>有了Flush链表后，后台线程就可以遍历Flush链表，将脏页写入到磁盘。</p><h2 id="提高-缓存命中率"><a href="#提高-缓存命中率" class="headerlink" title="提高  缓存命中率"></a>提高  缓存命中率</h2><p>Buffer Pool的大小有限，所有对于频繁访问的数据我们希望留在Buffer Pool中，而很少访问的数据则在某些时机淘汰。从而保证Buffer Pool不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据保留再Buffer Pool中。这个时候就需要使用淘汰算法来实现，最容易想到的就是LRU（Least recently used）算法。</p><h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么当空间不够的时候，就淘汰末尾最久没被使用的节点，从而腾出空间。</p><p>简单的LRU实现：</p><ul><li>当访问的页在Buffer Pool中，就直接把该页对应的LRU链表节点移动到链表的头部。</li><li>当访问的页不在Buffer Pool中，除了要把页放入到LRU链表的头部，还要淘汰LRU链表末尾的节点。</li></ul><p>至此，我们知道，Buffer Pool里有三种页和三种链表来管理数据：</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/bufferpoll_page.png" alt="img"></p><ul><li><p>Free Page（空闲页）</p><blockquote><p>表示该页未被使用，位于Free链表</p></blockquote></li><li><p>Clean Page（干净页）</p><blockquote><p> 表示此页被使用 ，但页面中的数据未发生修改，位于LRU链表</p></blockquote></li><li><p>Dirty Page（脏页）</p><blockquote><p>表示此页已被使用且被修改，其数据与磁盘上的数据不一致，需要刷盘，刷盘后变为干净页。脏页同时存在于LRU链表和Flush链表。</p></blockquote></li></ul><p>简单的LRU算法存在下面这两个问题会导致缓存命中率降低：</p><ul><li>预读失效</li><li>Buffer Pool污染</li></ul><h3 id="预读失效"><a href="#预读失效" class="headerlink" title="预读失效"></a>预读失效</h3><h4 id="什么是预读失效"><a href="#什么是预读失效" class="headerlink" title="什么是预读失效"></a>什么是预读失效</h4><p>程序是有空间局部性的，靠近当前被访问数据的数据在未来很大概率会被访问到。所以，MySQL在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘I&#x2F;O。但是这些被提前加载进来的数据页，不一定会被访问，若没有被访问，那么这个预读就相当于白做，这就是预读失效。</p><p>如果使用简单的LRU算法，这些预读页会被放到LRU链表的头部，而当Buffer Pool空间不够的时候，需要把尾部的页淘汰，但尾部的页可能比这些预读页被使用的概率更大。这样就会大大的降低缓存命中率。</p><h4 id="如何解决预读失效"><a href="#如何解决预读失效" class="headerlink" title="如何解决预读失效"></a>如何解决预读失效</h4><blockquote><p>预读失效也无法避免，但是对于大部分情况，局部性原理还是成立的。</p></blockquote><p>要避免预读失效带来的影响，最好就是让预读的页在Buffer Pool中停留的时间尽可能短，让真正被访问的页才移动到LRU链表的头部，从而保证真正被读取的热数据留在Buffer Pool中的时间尽可能长。</p><p>MySQL的解决办法：改进LRU算法，将LRU链表分为两个区：old区域和young区域。</p><p>young区域在LRU链表的前半部分，old区域在后半部分，如图所示 ：</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/young+old.png" alt="img"></p><ul><li>真正被访问的页插入young区的头部</li><li>预读的页加入到old区的头部</li><li>如果预读的页一直没有被访问，就会从old区域移除，这样就不会影响到young区域中的热点数据</li><li>可以通过参数<code>innodb_old_blocks_pc</code>来控制二者比例。默认是37，old区占37%</li></ul><h3 id="Buffer-Pool污染"><a href="#Buffer-Pool污染" class="headerlink" title="Buffer Pool污染"></a>Buffer Pool污染</h3><h4 id="什么是Buffer-Pool污染"><a href="#什么是Buffer-Pool污染" class="headerlink" title="什么是Buffer Pool污染"></a>什么是Buffer Pool污染</h4><p>当某个SQL语句扫描了大量的数据时，在Buffer Pool空间比较有限的情况下，可能回将Buffer Pool中的所有页都替换出去，导致大量热点数据被淘汰。这样等再次访问这些热点数据的时候又需要从磁盘中重新读取，这样就会严重降低缓存命中率，导致MySQL性能急剧下降。这个过程就被称为Buffer Pool污染。</p><p>注意：并不是只有查询语句查询出大量的数据才会出现Buffer Pool污染。当索引失效的时候，会发生全表扫描，即使查询结果只有少量数据，也会导致Buffer Pool污染。</p><p>例如在一个数据量很大的表中，执行该语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user where name like &quot;%xiaolin%&quot;;<br></code></pre></td></tr></table></figure><p>由于是左模糊查询，所以这条语句会发生索引失效，会进行全表扫描，查询过程如下：</p><ul><li>从磁盘读取数据页加入到LRU链表的old区域头部</li><li>然后从页中读取行记录，此时该页被访问，就把该页放到young区域头部</li><li>接下来拿行记录的name字段与匹配条件进行匹配，若符合条件，就将记录加入到结果集中</li><li>如此往复，直到扫描完全表记录</li></ul><p>经过这样的全表扫描后，原本young区域的热点数据都会被替换掉。</p><h4 id="如何解决Buffer-Pool污染"><a href="#如何解决Buffer-Pool污染" class="headerlink" title="如何解决Buffer Pool污染"></a>如何解决Buffer Pool污染</h4><blockquote><p>像前面这种全表扫描，很多缓冲页只会被访问一次，但是它却只因为被访问了一次就进入到young区域，从而导致热点数据被替换。</p></blockquote><p>LRU链表中young区域中是热点数据，只要我们提高进入young区域的门槛，就能够有效地保证真正的热点数据才会进入young区域。</p><p>MySQL的做法：进入young区域条件增加一个停留在old区域的时间判断。</p><p>具体实现：</p><ul><li>在对处于old区域的缓存页进行第一次访问的时候，在它对应的控制块中记录该访问时间</li><li>若后续访问与第一次访问在某时间间隔内，那么该访问页就继续留在old区</li><li>若后续访问域第一次访问超过某事件间隔，那么就将该缓存页从old区移动到young区头部</li></ul><p>该事件间隔由参数<code>innodb_old_blocks_time</code>控制，默认是1000ms。</p><p>这样old区数据被移动到young区头部的条件为：1. 被访问 2. 在old区域停留超过1秒</p><p>此外，MySQL还对young区域做了一个优化：为了防止young区域节点频繁地移动到头部，只有后3&#x2F;4的节点被访问才会被移动到young区域头部。</p><h2 id="脏页何时刷盘"><a href="#脏页何时刷盘" class="headerlink" title="脏页何时刷盘"></a>脏页何时刷盘</h2><p>引入了Buffer Pool后，当修改数据时，首先修改的时Buffer Pool中的数据所在页，然后将其设置为脏页，但是磁盘中还是原数据。因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致性。</p><p>但是，如果每次修改数据都将被修改的数据页刷入磁盘，则性能会很差，因此一般后会在一定的时机进行批量刷盘。</p><p>但是这些脏数据没即使刷盘，如果MySQL宕机就会丢失数据。于是InnoDB通过WAL策略，即先写日志（持久化），再将数据写入磁盘，通过redo log让MySQL拥有崩溃恢复能力。</p><p>触发脏页刷新的情况：</p><ul><li>redo log日志写满了，会主动触发脏页刷新到磁盘。</li><li>Buffer Pool空间不足，会根据LRU链表淘汰数据页，若淘汰的是脏页，需要先将脏页刷新到磁盘</li><li>MySQL认为空闲时，后台线程会定期将适量的脏页刷入磁盘</li><li>MySQL正常关闭之前，会把所有脏页刷入磁盘</li></ul><p>在我们开启了慢SQL监控后，会发现偶尔由一些用时稍长的SQL，这可能是因为在刷脏页给数据库带来的性能开销，导致数据库操作抖动。若间断地出现这种现象，就需要调大Buffer Pool空间或redo log日志的大小。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>MySQL原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-日志</title>
    <link href="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/"/>
    <url>/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>InnoDB引擎层日志：</p><ul><li><p>undo log（回滚日志）</p><blockquote><p>实现了事务中的原子性，主要用于事务回滚和MVCC</p></blockquote></li><li><p>redo log（重做日志）</p><blockquote><p>实现了事务中的持久性，主要用于掉电等故障恢复</p></blockquote></li></ul><p>Server层日志：</p><ul><li><p>binlog（归档日志）</p><blockquote><p>主要用于数据备份和主从复制</p></blockquote></li></ul><h1 id="undo-log（事务回滚，原子性）"><a href="#undo-log（事务回滚，原子性）" class="headerlink" title="undo log（事务回滚，原子性）"></a>undo log（事务回滚，原子性）</h1><h2 id="undo-log的作用"><a href="#undo-log的作用" class="headerlink" title="undo log的作用"></a>undo log的作用</h2><h3 id="作用一、回滚"><a href="#作用一、回滚" class="headerlink" title="作用一、回滚"></a>作用一、回滚</h3><p>因为MySQL默认开启自动提交事务，由<code>autocommit</code>参数决定的。我们在执行一条“增删改”语句的时候，MySQL会隐式地为每一条“增删改”语句开启事务。相当于所有的“增删改”操作都是在事务中完成的。</p><p>undo log（回滚日志），它保证了事务ACID特性的原子性（Atomicity）。</p><blockquote><p>undo log是一种用于撤销回退的日志。在事务没提交之前，MySQL会先记录更新前的数据到undo log日志文件里面，当事务回滚时，可以利用undo log来回滚。</p></blockquote><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png" alt="回滚事务"></p><p>每当InnoDB引擎对一条记录进行操作（新增、删除、修改）时，undo log都会记录回滚所需信息：</p><ul><li>插入记录。undo log将这条记录的主键值记录下来，在回滚时只需要删除主键值对应记录即可。</li><li>删除记录。undo log记录这条记录的完整内容，在回滚时插入该完整记录即可。</li><li>更新记录。undo log把被更新列的旧值记录下来，回滚时将这些列更新为旧值即可。</li></ul><p>不同操作需要记录的信息不同，对应的undo log格式也不同。</p><p>一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer指针和一个trx_id：</p><ul><li><p>通过trx_id可以直到该记录是被哪个事务修改的</p></li><li><p>通过roll_pointer指针可以将undo log串成一个链表，这个链表称为版本链</p><blockquote><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%89%88%E6%9C%AC%E9%93%BE.png" alt="版本链"></p></blockquote></li></ul><h3 id="作用二、实现MVCC"><a href="#作用二、实现MVCC" class="headerlink" title="作用二、实现MVCC"></a>作用二、实现MVCC</h3><p>undo log和Read View一起可以实现MVCC，实现快照读。</p><p>读提交和可重复读这两个隔离级别就是通过Read View + undo log实现的。</p><ul><li>读提交：每个select都生成新的Read View。</li><li>可重复读：在事务启动后执行第一个select生成Read View，之后的事务中就一直使用这个Read View。</li></ul><p>在select的时候，根据Read View中的字段和记录的两个隐藏列（trx_id和roll_pointer），判断当前记录的对于当前事务的可见性，若可见，直接读取记录，若不可见，则根据版本链找到可见的版本读取记录。这样可以控制并发事务访问同一记录时的行为，这就叫做MVCC（多版本并发控制）。</p><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png" alt="Buffer Poo"></p><h3 id="Buffer-Pool的作用"><a href="#Buffer-Pool的作用" class="headerlink" title="Buffer Pool的作用"></a>Buffer Pool的作用</h3><blockquote><p>我们更新数据需要先从磁盘读取数据，然后再在内存中修改这条记录。在修改完这条记录后会缓存在Buffer Pool中，下一次有查询语句命中该记录，就可以直接从缓存中读取，而不需要从磁盘获取，减少磁盘I&#x2F;O。</p></blockquote><ul><li>当读取数据时，若数据在Buffer Pool中，客户端直接读取Buffer Pool中的缓存数据，否则才去磁盘读取。</li><li>当修改数据时，若数据在Buffer Pool中，则直接修改Buffer Pool中的数据所在页，然后将其设置为脏页，否则需要从磁盘读取到Buffer Pool中再做修改。为了减少磁盘I&#x2F;O，脏页不会被立即写回磁盘，后续由后台线程选择何时时机将脏页写入磁盘。</li></ul><h3 id="Buffer-Pool的缓存内容"><a href="#Buffer-Pool的缓存内容" class="headerlink" title="Buffer Pool的缓存内容"></a>Buffer Pool的缓存内容</h3><h4 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h4><blockquote><p>InnoDB将存储的数据划分为若干页，<strong>以页作为磁盘与内存交互的基本单位</strong>，一个页默认16KB。</p></blockquote><p>因此Buffer Pool中同样以页来划分数据。在MySQL启动时，InnoDB会为Buffer Pool申请一片连续的内存空间，然后按照默认的16KB大小划分为一个个的页，Buffer Pool中的页就叫做缓存页。</p><p>MySQL刚启动时缓存页都是空闲的，随着程序的运行，才会由磁盘上的页被缓存到Buffer Pool中。所以在刚启动时，使用的虚拟内存空间很大，而使用的物理内存空间很小，这是因为这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟内存和物理地址建立映射关系。</p><p>因为Buffer Pool和磁盘的内存交互是以页为单位的，所以即使是只查询一条记录，InnoDB也是需要将包含该记录的整页加载到Buffer Pool中的。然后根据页中的页目录去定位具体记录。</p><h4 id="缓存内容"><a href="#缓存内容" class="headerlink" title="缓存内容"></a>缓存内容</h4><blockquote><p>除了缓存数据页和索引页，还包括Undo页、插入缓存、自适应哈希索引和锁信息。</p></blockquote><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/bufferpool%E5%86%85%E5%AE%B9.drawio.png" alt="img"></p><p>Undo页是用于暂存undo log的。undo log记录过后不会直接写入磁盘持久化，而是和修改的数据一样，通过写入到Buffe Pool的undo页中，由后台线程将这些脏页刷盘持久化。</p><h1 id="redo-log（掉电恢复，持久性）"><a href="#redo-log（掉电恢复，持久性）" class="headerlink" title="redo log（掉电恢复，持久性）"></a>redo log（掉电恢复，持久性）</h1><h2 id="WAL技术"><a href="#WAL技术" class="headerlink" title="WAL技术"></a>WAL技术</h2><p>Buffer Pool提高了读写效率，但是Buffer Pool是基于内存的，而内存中的数据会掉电丢失。为了防止断电丢失数据的问题，当有一条记录需要更新的时候，InnoDB引擎就会先更新内存（同时标记为脏页），然后将本次对该页的修改以redo log的形式记录下来，这样时更新操作就算完成。后续InnoDB引擎会在何时的时候由后台线程将脏页写回磁盘。这就是WAL（Write-Ahead logging）。</p><p>简单来说，WAL技术指得就是，MySQL得写操作不是立刻写到磁盘上，而是先写到日志，然后再在合适得时间写入磁盘。</p><p>流程如图：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/wal.png" alt="img"></p><h2 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log"></a>什么是redo log</h2><p>redo log是物理日志，记录了某个数据页做了什么修改，比如对XXX表空间的YYY数据页ZZZ便宜量的地方做了AAA更新。每执行一个事务就会产生这样的一条或多条物理日志。</p><p>在事务提交时，只要将redo log持久化到磁盘中事务就提交成功了。可以不需要等到将脏页全部持久化到磁盘中。当系统崩溃时，对于已提交的事务，虽然脏页可能没有持久化，但是redo log已经持久化，MySQL重启后可以根据redo log中的内容，可以将已提交的事务数据恢复。</p><h2 id="redo-log和undo-log"><a href="#redo-log和undo-log" class="headerlink" title="redo log和undo log"></a>redo log和undo log</h2><p>二者联系（都属于InnoDB存储引擎层日志）：</p><p>在开启事务后，InnoDB更新记录时首先会记录相应的undo log，undo log会写入Buffer Pool中的Undo页中。undo log写入Undo页，Undo页变成脏页，需要记录对应的redo log。</p><p>二者区别：</p><ul><li><p>redo log记录了此次事务完成后的数据状态，记录的时更新后的值</p><blockquote><p>事务提交之后发生崩溃，重启后根据redo log恢复已经提交的事务</p></blockquote></li><li><p>undo log记录了此次事务开始前的数据状态，记录的是更新之前的值</p><blockquote><p>事务提交之前发生崩溃，重启后根据undo log回滚到事务开始前的数据</p></blockquote></li></ul><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png" alt="事务恢复"></p><p>crash-safe能力：</p><p>redo log配合WAL技术，InnoDB可以保证数据库即使发生异常重启，之前已提交的记录都不会丢失，这个能力称为crash-safe（崩溃恢复）。所以redo log保证了事务的持久性。</p><h2 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h2><p>redo log需要写入磁盘，数据也需要写入磁盘，似乎有点多此一举？实际并不是。</p><p>写入redo log是通过追加写操作，对应的磁盘操作是顺序写。而写入数据需要先找到数据写入位置，然后再写入磁盘，对应的磁盘操作时随机写。</p><p>顺序写比随机写更高效。原因的话在于，数据库一般是以机械硬盘来存储数据，随机写每次写入都需要重新寻道，而寻道时所花费的时间就是磁盘写入操作中最耗时的一部分。</p><p>可以说WAL技术将MySQL的写操作从磁盘的随机写变成了顺序写，提高了语句的执行性能。当redo log写入完成后，数据就可以算是写入完成了（因为redo log已经包含了可以恢复数据的信息，redo log已经持久化，即使数据没有完成持久化就断电丢失，也可根据redo log恢复完成数据）。这样MySQL就可以将耗时的数据持久化工作选择合适的时候（服务器比较空闲的时候）持久化到磁盘。</p><p>所以为什么需要redo log：</p><ol><li>将写操作从随机变成顺序写，提升MySQL写入磁盘的性能。</li><li>实现事务的持久化，让MySQL具有crash-safe能力。保证MySQL在任何时候崩溃，在重启后已提交的数据也不会丢失。</li></ol><h2 id="redo-log的持久化"><a href="#redo-log的持久化" class="headerlink" title="redo log的持久化"></a>redo log的持久化</h2><h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p>在执行事务的过程中，产生redo log不是直接写入磁盘的，因为这样会产生大量的I&#x2F;O操作，而且磁盘的读写速度远远慢于内存。</p><p>redo log同样也有自己的缓存：redo log buffer。</p><p>每当产生一条redo log时，会先写入到redo log buffer中，后续再持久化到磁盘中，如图：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/redologbuf.webp" alt="事务恢复"></p><p>redo log buffer默认大小16MB，可以通过参数<code>innodb_log_Buffer_size</code>调整。增大redo log buffer可以让MySQL再处理大事务的时候不必写入磁盘，进而提升写I&#x2F;O的性能。</p><h3 id="redo-log刷盘时机"><a href="#redo-log刷盘时机" class="headerlink" title="redo log刷盘时机"></a>redo log刷盘时机</h3><ul><li>MySQL正常关闭时</li><li>当redo log buffer中记录的写入量大于一半的时候</li><li>InnoDB的后台线程每隔1秒刷一次盘</li><li>事务提交时</li></ul><h3 id="innodb-flush-log-at-trx-commit参数"><a href="#innodb-flush-log-at-trx-commit参数" class="headerlink" title="innodb_flush_log_at_trx_commit参数"></a>innodb_flush_log_at_trx_commit参数</h3><p>默认的事务提交行为：</p><p>单独执行一个更新语句的时候，InnoDB引擎会自己启动一个事务，在执行更新语句的过程中，生成的redo log先写入redo log buffer中，当事务提交时，再将redo log buffer中缓存的redo log按组的方式顺序写到磁盘。</p><p>参数<code>innodb_flush_log_at_trx_commit</code>可以控制事务提交时的刷盘策略：</p><ul><li>设置为0，表示每次事务提交时不会触发redo log buffer刷盘。</li><li>设置为1，为默认行为。</li><li>设置为2，表示在事务提交时，将redo log buffer中的文件写入操作系统的文件缓存。</li></ul><p>上面三种参数的行为如下：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/innodb_flush_log_at_trx_commit.drawio.png" alt="img"></p><p>参数为0和2时的redo log如何持久化：</p><ul><li><p>参数0：会把缓存在redo log buffer 中的redo log，通过调用write()写到操作系统的Page Cache，然后调用fsync()持久化到磁盘。</p><blockquote><p>MySQL进程崩溃会导致上一秒的所有事务数据丢失（后台线程1秒刷一次盘）</p></blockquote></li><li><p>参数2：调用fsync，将缓存在操作体统Page Cache中的redo log持久化到磁盘。</p><blockquote><p>MySQL进程崩溃不会丢失数据，只有操作系统崩溃才会丢失上一秒的所有事务数据。</p></blockquote></li></ul><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/innodb_flush_log_at_trx_commit2.drawio.png" alt="img"></p><p>这三个不同参数的应用场景：</p><p>三个参数的数据安全性和写入性能成反比，二者不可兼得。</p><ul><li>对数据安全性要求比较高的场景：设置参数为1，在每次提交事务后持久化redo log，保证提交后的记录在任何情况下都不会丢失。</li><li>一些可以容忍数据库崩溃时丢失1s数据的场景：设置参数为0，这样可以减少日志写入的磁盘I&#x2F;O操作。</li><li>安全性和性能折中方案：设置参数为2，只要操作系统不宕机，即使数据库崩溃，也不会丢失数据，同时性能也比参数1高。</li></ul><h2 id="redo-log循环写"><a href="#redo-log循环写" class="headerlink" title="redo log循环写"></a>redo log循环写</h2><p>默认情况下，InnoDB引擎有一个重做文件组（redo log Group），它由两个redo log文件组成，这两个redo日志的文件名为<code>ib_logfile0</code>和<code>ib_logfile1</code>。每个文件的大小固定且一致，假设一个文件1G，那么总共就可以记录2GB的redo日志。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84.drawio.png" alt="重做日志文件组"></p><p>重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾又回到开头，相当于一个环形。所以InnoDB引擎会先写ib_logfile0文件，当ib_logfile0被写满后切换到ib_logfile1文件，然后两个文件循环切换。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png" alt="重做日志文件组写入过程"></p><p>redo log是为了防止Buffer Pool中的脏页丢失而设计的。所以说随着系统的运行，Buffer Pool的脏页持久化到磁盘中后，对应的redo log就没有了，这个时候我们擦除这些没用的redo log，以腾出空间记录新的redo log。</p><p>redo log是以循环写的方式记录的。可以通过两个点（write pos和check point）将这个环分为两部分区域：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/checkpoint.png" alt="img"></p><ul><li>write pos和check point的移动都是顺时针方向的</li><li>write pos~check point之间的部分（红色部分）：空闲区域，用来记录新的更新操作</li><li>check point~write pos之间的部分（蓝色部分）：待落盘的脏数据页记录</li></ul><p>如果数据更新太快，redo log落盘太满，那么会出现write pos追上check point的情况：</p><p>这就意味着redo log文件写满了。此时MySQL不能再执行新的更新操作，也就是说MySQL会被阻塞停下来将Buffer Pool中的脏页刷新到磁盘中，擦除旧的redo log记录，移动check point指针，然后MySQL恢复正常。</p><p>所以说针对并发量大的系统，设置足够大小的redo log文件很重要。</p><h1 id="binlog（备份恢复，主从复制）"><a href="#binlog（备份恢复，主从复制）" class="headerlink" title="binlog（备份恢复，主从复制）"></a>binlog（备份恢复，主从复制）</h1><p>MySQL在完成一条更新操作后，Server层还会生成一条binlog，等事务提交之后，会将事务执行过程中产生的binlog同一写入到binlog文件。</p><p>binlog文件记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如SELECT和SHOW操作。</p><h2 id="binlog和redo-log"><a href="#binlog和redo-log" class="headerlink" title="binlog和redo log"></a>binlog和redo log</h2><h3 id="为什么有了binlog，还要有redo-log？"><a href="#为什么有了binlog，还要有redo-log？" class="headerlink" title="为什么有了binlog，还要有redo log？"></a>为什么有了binlog，还要有redo log？</h3><blockquote><p>存储引擎为了实现binlog没有的crash-safe能力而使用redo log。</p></blockquote><p>最开始MySQL没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe能力，binlog只能用于归档。</p><p>而InnoDB是另一家公司以插件形式引入MySQL，由于binlog没有crash-safe能力，所以InnoDB使用redo log来实现crash-sage能力。</p><h3 id="binlog和redo-log区别"><a href="#binlog和redo-log区别" class="headerlink" title="binlog和redo log区别"></a>binlog和redo log区别</h3><ol><li><p>适用对象不同</p><ul><li>binlog是MySQL的Server层实现的日志，所有存储引擎共用</li><li>redo log是Innodb存储引擎实现的日志</li></ul></li><li><p>文件格式不同</p><ul><li><p>binlog有三种格式类型</p><ul><li><p>STATEMENT</p><blockquote><p>每一条修改数据的SQL都会被记录到binlog中（相当于记录了逻辑操作，所以这种格式的binlog可以称为逻辑日志），主从复制中slave端根据SQL重现数据。</p><p>但STATEMENT有动态函数问题，比如适用了uuid或now这些函数，在主库上执行的结果于在从库执行的结果不同，这种随时变化的函数会导致主从数据不一致。</p></blockquote></li><li><p>ROW</p><blockquote><p>记录行数据最终被修改成的样子（这种格式的日志，不能称为逻辑日志）。</p><p>它解决了STATEMENT格式下动态函数的问题。但是ROW格式的缺点在于记录的binlog文件过大，比如一个批量更新的update语句，ROW格式会记录每一条变化的行记录，而STATEMENT格式只需要记录这一条update语句即可。</p></blockquote></li><li><p>MIXED</p><blockquote><p>根据情况使用ROW模式和STATEMENT模式</p></blockquote></li></ul></li><li><p>redo log时物理日志，记录的是在某个数据页做了什么修改。比如XXX表空间种的YYY数据页ZZZ偏移量的地方做了AAA更新</p></li></ul></li><li><p>写入方式不同</p><ul><li>binlog是追加写。写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log是循环写。日志空间大小固定，全部写满就从头开始，保存的是未被刷入磁盘的脏页日志。</li></ul></li><li><p>用途不同</p><ul><li>binlog用于备份恢复、主从复制</li><li>redo log用于掉电等故障恢复</li></ul></li></ol><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="主从复制实现"><a href="#主从复制实现" class="headerlink" title="主从复制实现"></a>主从复制实现</h3><blockquote><p>MySQL的主从复制依赖于binlog，也就是记录MySQL上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将binlog中的数据从主库传输到从库上。</p></blockquote><p>主从复制的过程一般是异步的。也就是主库上执行事务操作的线程不会等待复制binlog的线程同步完成。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png" alt="MySQL 主从复制过程"></p><p>MySQL集群的主从复制过程可以分为三个阶段：</p><ol><li><p>写入binlog：主库写binlog日志，提交事务，并更新本地数据</p><blockquote><p>MySQL主库收到客户端提交的事务请求后，会先写入binlog，在提交事务，更新存储引擎中的数据，事务提交后，返回给客户端“操作成功”的响应</p></blockquote></li><li><p>同步binlog：从库复制主库binlog，并写入从库暂存日志中</p><blockquote><p>从库会创建一个专门的I&#x2F;O线程，连接主库的log dump线程，用于接收主库的binlog日志，再将binlog信息写入relay log的中继日志里，再返回给主库“复制成功”的响应。</p></blockquote></li><li><p>回放binlog：回放binlog，并更新从库存储引擎中的数据</p><blockquote><p>从库会创建一个用于回放binlog的线程，去读取relay log中级日志，然后回放binlog更新存储引擎中的数据，最终实现主从的数据一致性。</p></blockquote></li></ol><h3 id="从库的作用"><a href="#从库的作用" class="headerlink" title="从库的作用"></a>从库的作用</h3><p>完成主从复制之后，可以将客户端的请求分发，写数据在主库，读数据在从库，这样读请求和写请求之间不会相互阻塞。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png" alt="MySQL 主从架构"></p><p>从库可以分担读请求负载，但是从库的数量不是越多越好。</p><p>因为每对应一个从库，主库都要创建一个log dump线程来处理来自从库的复制请求。对主库的资源消耗高，同时还受主库的网络带宽限制。</p><p>实际使用中，一个主库一般2~3个从库（1主2从1备）。</p><h3 id="MySQL其他主从复制模型"><a href="#MySQL其他主从复制模型" class="headerlink" title="MySQL其他主从复制模型"></a>MySQL其他主从复制模型</h3><ul><li><p>同步复制：MySQL主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。</p><blockquote><p>这种方式在实际的项目中，基本没法使用，因为：</p><ul><li>性能差。因为要复制到所有节点才返回响应</li><li>可用性差。主库和所有从库任一数据库出问题，都会影响业务</li></ul></blockquote></li><li><p>异步复制：MySQL主库提交的事务的线程不会等待binlog同步到各从库，就返回客户端结果。</p><blockquote><p>这种模式一旦主库宕机，数据就会发生丢失。</p></blockquote></li><li><p>半同步复制：事务线程不用等待所有的从库复制成功响应，只要其中一个从库复制成功响应，主库的事务线程就可以返回给客户端。</p><blockquote><p>这种半同步复制的方式，兼顾了异步复制和同步复制的优点。即使出现主库宕机，至少有一个从库有最新数据，不存在数据丢失的风险。</p></blockquote></li></ul><h2 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h2><blockquote><p>事务执行过程中，先把日志写到binlog cache（Server层的cache），事务提交的时候，在把binlog cache写到binlog文件中。</p></blockquote><p>MySQL给每个线程分配了一片内存用于缓冲binlog，该内存叫binlog cache。<code>binlog_cache_size</code>参数可以控制binlog cache的大小。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/binlogcache.drawio.png" alt="binlog cach"></p><p>一个事务的binlog是不能被拆开的,因此无论这个事务有多大，也要保证一次性写入。这是因为一个线程只能同时有一个事务在执行，所以每当执行一个begin&#x2F;start transaction的时候，就会默认提交上一个事务，如果一个事务的binlog被拆开，在备库执行就会被当作多个事务分段执行，这就破坏了事务的原子性，这是有问题的。</p><p>在事务提交时，执行器把binlog cache里的完整事务写入到binlog文件中（有多个binlog cache，但最终写到同一binlog文件），并清空binlog cache。</p><ul><li>write：指的是将日志写入到binlog文件，但是这个写入只是写入到操作系统的page cache中，这里不涉及磁盘I&#x2F;O。</li><li>fsync：才是将数据持久化到磁盘的额操作，这里会涉及磁盘I&#x2F;O。</li></ul><p>MySQL提供一个<code>sync_binlog </code>参数来控制数据库的fsync操作频率（每次提交事务都会write，但是什么时候fsync由该参数控制）：</p><ul><li><p>sync_binlog &#x3D; 0，表示由操作系统决定何时执行fsync将数据持久化到磁盘</p><blockquote><p>MySQL系统默认设置为0，也就是不做任何强制性磁盘刷新指令。此时性能最好，但风险最大，因为一旦操作系统宕机，还未持久化到磁盘中的数据就会丢失。</p></blockquote></li><li><p>sync_binlog &#x3D; 1，表示每次提交事务都会马上执行fsync。</p><blockquote><p>此时最安全，但是性能损耗最大。即使操作系统宕机最多也就丢失一个事务的binlog。</p></blockquote></li><li><p>sync_binlog &#x3D; N (N &gt; 1)，表示累计N个事务后才fsync。</p><blockquote><p>如果能容忍少量的binlog日志丢失风险，为了提高写入性能，一般会设置sync_binlog为100~1000。</p></blockquote></li></ul><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><h2 id="一条update语句执行的过程"><a href="#一条update语句执行的过程" class="headerlink" title="一条update语句执行的过程"></a>一条update语句执行的过程</h2><p>当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。</p><p><code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code>执行流程如下：</p><ol><li>执行器负责具体执行，会调用存储引擎接口获取id &#x3D; 1的记录：<ul><li>若id &#x3D; 1这行所在的数据页本来就在buffer pool中，就直接在数据页中搜索该记录并返回给执行器</li><li>若记录不在buffer，存储引擎会根据主键索引数从磁盘将包含该记录的页读到buffer pool中，然后在该数据页搜索该记录返回给执行器</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前后的记录是否一样：<ul><li>若一样的话就不进行后续的更新流程</li><li>若不一样，就将更新前的记录和更新后的记录都当作参数传给InnoDB层，让InnoDB真正执行更新记录的操作</li></ul></li><li>开启事务，InnoDB层更新记录前，首先要记录相应的undo log。undo log会写入到Buffer Pool中的Undo页面，不过在内存修改该Undo页面后，需要记录对应的redo log。</li><li>InnoDB层开始更新记录，会先更新内存，并标记为脏页，然后将记录写到redo log中，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择合适时机将脏页写入磁盘。这就是WAL技术，MySQL的写操作不会立刻写入磁盘，而是先将redo日志持久化到磁盘，然后再选择合适时机持久化被修改的记录。</li><li>至此，一条记录的更新完成。</li><li>再一条更新语句执行完成后，然后开始记录该语句对应的binlog。此时记录的binlog会被保存到binlog cache，并没有刷新到磁盘的binlog文件，在事务提交时才会同一将该事务运行过程中的完整binlog刷新到磁盘。</li><li>事务提交。事务提交是两阶段提交，接下来就是讲关于两阶段提交。</li></ol><h2 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="headerlink" title="为什么需要两阶段提交"></a>为什么需要两阶段提交</h2><blockquote><p>事务提交后，redo log和binlog都要持久化到磁盘，但是这是两个独立的逻辑，可能出现半成功的状态，这样就造成了两份日志之间的逻辑不一致。</p></blockquote><h3 id="如果没有两阶段提交会出现的问题"><a href="#如果没有两阶段提交会出现的问题" class="headerlink" title="如果没有两阶段提交会出现的问题"></a>如果没有两阶段提交会出现的问题</h3><p>举个例子，假设id &#x3D; 1的这行记录的name字段值为‘jay’，然后执行<code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1</code>。</p><p>如果在持久化redo log和binlog两个日志的过程中，出现半成功状态，就有两种情况：</p><ul><li><p>如果redo log刷入磁盘后，MySQL宕机，binlog还没刷入</p><blockquote><p>MySQL重启后，通过redo log能将Buffer Pool中已经更新完成的id &#x3D; 1的这行数据恢复到新值’xiaolin’，但是binlog中没有记录这条更新语句。在主从架构中，从库根据binlog复制主库数据，由于binlog丢失了这条更新语句，从库中的这行记录name字段是旧址’jay’，与主库的值不一致。</p></blockquote></li><li><p>如果binlog刷入磁盘后，MySQL宕机，redo log还没刷入</p><blockquote><p>由于redo log还没写，崩溃恢复后这个事务无效，所以主库中的id &#x3D; 1这行数据的name字段还是旧值’jay’，而binlog里面记录了这条更新语句，从库根据binlog复制数据，这一行的name字段是新值’xiaolin’，与主库的值不一致。</p></blockquote></li></ul><p>可见，在持久化redo log和binlog时，若出现半成功的情况，就会造成主从环境的数据不一致。这是因为redo log影响主库数据，binlog影响从库数据，所以redo log和binlog必须保持一致，才能保证给主从数据一致。</p><h2 id="两阶段提交的过程"><a href="#两阶段提交的过程" class="headerlink" title="两阶段提交的过程"></a>两阶段提交的过程</h2><blockquote><p>两阶段提交其实是<strong>分布式事务一致性协议</strong>，它可以保证多个逻辑操作要么全部成功，要么全部失败，不会出现半成功的状态。有点原子性的意思。</p></blockquote><p>两阶段提交把单个事务的提交拆分成两个阶段，分别是准备（Prepare）阶段和提交（Commit）阶段。每个阶段由协调者（Coordinator）和参与者（Participant）共同完成。</p><p>注意：不要把提交阶段和提交语句混淆。commit语句执行的时候，会包含准备阶段和提交阶段。</p><h3 id="拳击手的例子说明两阶段提交"><a href="#拳击手的例子说明两阶段提交" class="headerlink" title="拳击手的例子说明两阶段提交"></a>拳击手的例子说明两阶段提交</h3><p>举个拳击比赛的例子。两个拳击手（参与者）开始比赛前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？</p><ul><li><p>准备阶段</p><blockquote><p>裁判会依次询问两位拳击手是否准备好了，如果任一选手没有准备好，裁判会宣布比赛暂停（对应事务中的回滚）</p></blockquote></li><li><p>提交阶段</p><blockquote><p>当两位拳击手都准备好了，裁判比赛开始（对应事务提交成功）</p></blockquote></li></ul><h3 id="MySQL中两阶段提交的过程"><a href="#MySQL中两阶段提交的过程" class="headerlink" title="MySQL中两阶段提交的过程"></a>MySQL中两阶段提交的过程</h3><blockquote><p>在MySQL的InnoDB存储引擎中，开启binlog的情况下，MySQL需要同时维护binlog和redo log。为了保证这两个日志的一致性，MySQL使用<strong>内部XA事务</strong>，内粗XA事务由binlog作为协调者，存储引擎是参与者。</p></blockquote><p>  在客户端执行commit语句或在自动提交的情况下，MySQL内部会开启一个XA事务，分两阶段来完成XA事务的提交，如图所示：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png" alt="两阶段提交"></p><p>事务的提交过程有两个阶段，主要就是将redo log的写入拆成了两个步骤：prepare和commit，中间再穿插写入binlog：</p><ul><li><p>prepare阶段</p><blockquote><p>将XID（内部XA事务的ID）写入redo log，同时将redo log对应的事务状态设置为prepare，然后将redo log持久化到磁盘(<code>innodb_flush_log_at_trx_commit = 1</code>的作用)。</p></blockquote></li><li><p>commit阶段</p><blockquote><p>将XID写入到binlog，然后将binlog持久化到磁盘(<code>sync_binlog = 1</code>的作用)，接着调用引擎的提交任务接口，将redo log状态设置为commit。commit状态不需要立即持久化到磁盘，只需要write到文件系统的page cache中即可，因为只要binlog写磁盘成功（此时两个日志已经一致了），事务就算已经执行成功。</p></blockquote></li></ul><h2 id="异常重启会发生什么"><a href="#异常重启会发生什么" class="headerlink" title="异常重启会发生什么"></a>异常重启会发生什么</h2><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png" alt="时刻 A 与时刻 B"></p><p>MySQL重启后会顺序扫描redo log文件，碰到处于prepare状态的redo log，就拿着redo log中的XID去binlog中查看是否存在此XID：</p><ul><li><p>若binlog中不存在该XID</p><blockquote><p>说明redo log完成输盘，但是binlog还没有刷盘，则回滚事务。对应时刻A崩溃恢复的情况。</p></blockquote></li><li><p>若binlog中存在该XID</p><blockquote><p>说明redo log和binlog都已经完成了刷盘，则提交事务。对应时刻B崩溃恢复的情况。</p></blockquote></li></ul><p>可见，对于处于prepare阶段的redo log，既可以提交事务，也可以回滚事务。这取决于在binlog中是否存在于redo log的XID相同的binlog记录。所以说，两阶段提交是以binlog写成功作为事务提交成功的标识。因为binlog写成功，就意味着能在binlog中找到处于prepare状态的redo log相同的XID记录。</p><p>处于prepare阶段的redo log加上完成的binlog，重启就提交事务，MySQL为什么这样设计？</p><blockquote><p>binlog已经写入，就会被从库使用。所以说在主库上也要提交这个事务，这样就能保证主库和从库的数据一致。</p></blockquote><p>事务没提交的时候，redo log会被持久化到磁盘吗？</p><blockquote><p>会。事务执行过程中，每执行完一条语句，redo log就会写入redo log buffer中，有一个后台线程每隔一秒就会将redo log buffer中的缓存持久化到磁盘。</p><p>这些被持久化的redo log处于prepare状态，在其对应的binlog没有持久化前，就算MySQL崩溃，这些redo log因为没有对应的binlog所以不会生效，会执行回滚操作。</p></blockquote><h2 id="两阶段提交有什么问题"><a href="#两阶段提交有什么问题" class="headerlink" title="两阶段提交有什么问题"></a>两阶段提交有什么问题</h2><h3 id="问题一、磁盘I-x2F-O次数高"><a href="#问题一、磁盘I-x2F-O次数高" class="headerlink" title="问题一、磁盘I&#x2F;O次数高"></a>问题一、磁盘I&#x2F;O次数高</h3><blockquote><p>对于“双1”配置，每个事务提交都会进行两次fsync（刷盘），一次redo log刷盘，一次binlog刷盘。</p></blockquote><p>binlog和redo log在内存中都对应有缓存空间。binlog缓存在binlog cache，redo log缓存在redo log buffer，它们持久化到磁盘的时机由两个参数控制。一般为了避免日志的丢失，会将这两个参数设置为1：</p><ul><li>sync_binlog &#x3D; 1</li><li>innodb_flush_log_at_trx_commit &#x3D; 1</li></ul><p>二者都标识在事务提交的时候将缓存中的日志持久化到磁盘，这样每次提交事务都至少调用两次刷盘操作，这会称为性能瓶颈。</p><h3 id="问题二、锁竞争激烈"><a href="#问题二、锁竞争激烈" class="headerlink" title="问题二、锁竞争激烈"></a>问题二、锁竞争激烈</h3><blockquote><p>两阶段提交虽然可以保证单事务中两个日志的内容一致，但在多事务的情况下，却不能保证两个日志的提交顺序椅子。因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</p></blockquote><p>在早期的MySQL中，通过使用prepare_commit_mutex锁来保证事务提交的顺序。一个事务获取到锁时才能进入prepare阶段，直到commit阶段结束释放锁。</p><p>虽然加锁完美解决了顺序一致性的问题，但在并发量较大的时候，就会出现激烈的锁竞争，性能不佳。</p><h3 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h3><blockquote><p>组提交通过合并刷盘操作，细化锁颗粒度，提升两阶段提交的并发效率。</p></blockquote><p>MySQL引入了binlog组提交（group commit）机制，每当有多个事务提交的时候，会将多个binlog刷盘操作合并为一个，从而减少磁盘I&#x2F;O的次数。例如十个事务排队依次刷盘的时间成本是10，那么将这十个事务一次性一起刷盘，则时间成本则近似1 。</p><p>组提交机制将commit阶段拆分为三个过程：</p><ul><li>flush阶段：多个事务按进入的顺序将binlog从cache写入文件（page cache）</li><li>sync阶段：对binlog文件做fsync操作（多个事务的binlog合并一次刷盘）</li><li>commit阶段：各事务按顺序做InnoDB commit操作</li></ul><p>每一个阶段都有一个队列，分别有一个锁保护，因此保证了事务写入的顺序。第一个进入队列的事务会成为leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/commit_4.png" alt="每个阶段都有一个队列"></p><p>对这三个阶段引入队列，锁只针对每个队列保护，不再锁住整个提交事务过程。这样，锁的颗粒度减小了，多个阶段可以并发地执行，从而提升效率。</p><p>在MySQL 5.7引入了redo log的组提交机制。</p><blockquote><p>将prepare阶段融合在flush阶段，将redo log的刷盘延迟到了flush阶段中，sync阶段之前。通过延迟写redo log的方式，为redo log做了一次组写入。</p></blockquote><h4 id="flush阶段"><a href="#flush阶段" class="headerlink" title="flush阶段"></a>flush阶段</h4><blockquote><p>用于支撑redo log的组提交</p></blockquote><p>第一个事务会成为flush阶段的Leader，此后到来的事务都是Follower：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A41.png" alt="img"></p><p>接着，获取队列中的事务组（这里是绿色这组），由Leader事务对redo log做一次刷盘（write + fsync）：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A42.png" alt="img"></p><p>做完prepare阶段后，将这组事务执行过程中产生的binlog写入binlog文件（write）</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/write_binlog.png" alt="img"></p><p>该阶段结束后，该组事务的redo log完成刷盘，binlog还在操作系统的缓存中，并未持久化。若在该阶段完成后崩溃，MySQL会回滚该组事务。</p><h4 id="sync阶段"><a href="#sync阶段" class="headerlink" title="sync阶段"></a>sync阶段</h4><blockquote><p>用于支撑binlog的组提交</p></blockquote><p>一组事务的binlog写入（write）binlog文件后，并不会马上执行刷盘操作，而是等待一段时间，组合更多事务的binlog，然后再刷盘：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A44.png" alt="img"></p><p>如果在等待时，还没到时间，但是事务数量已经达到设定值，则直接将binlog刷盘：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A45.png" alt="img"></p><p>两个控制参数：</p><ul><li>等待时间。<code>binlog_group_commit_sync_delay = N</code>，表示等待N微秒后，直接调用fsync持久化binlog文件。</li><li>队列中的事务最大数量。<code>binlog_group_commit_sync_no_delay_count = N</code>，表示如果队列中的事务数达到N各，就忽视等待时间，直接刷盘</li></ul><p>这一步完成后，binlog和redo log都已经持久化。若此时崩溃，MySQL重启后会通过redo log继续事务的提交。</p><h4 id="commit阶段"><a href="#commit阶段" class="headerlink" title="commit阶段"></a>commit阶段</h4><p>进入commit阶段，调用引擎的提交事务接口，将redo log状态设置未commit：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A46.png" alt="img"></p><p>commit阶段队列的作用时承接sync阶段的事务，完成最后的引擎提交，使得sync可以尽快处理下一组事务，最大化组提交效率。</p><h1 id="MySQL磁盘I-x2F-O优化"><a href="#MySQL磁盘I-x2F-O优化" class="headerlink" title="MySQL磁盘I&#x2F;O优化"></a>MySQL磁盘I&#x2F;O优化</h1><p>在事务提交时，需要将binlog和redo log持久化，可以通过一些参数“延迟”binlog和redo log刷盘时机：</p><ul><li><p>组提交参数</p><blockquote><p><code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>，这两个参数控制在flush阶段的binlog刷盘时机（fsync）。因为binlog已经写入了系统的缓存，所以即使MySQL进程崩溃，也不会丢失数据。</p></blockquote></li><li><p>binlog刷盘时机参数</p><blockquote><p><code>sync_binlog</code>设置为大于1（常见为100~1000），表示每次提交事务都write，但是累积N个事务后才fsync，相当于延迟binlog刷盘时机。</p><p>这样做的风险在于，主机掉电会丢失N个事务的binlog日志</p></blockquote></li><li><p>redo log刷盘时机参数</p><blockquote><p><code>innodb_flush_log_at_trx_commit</code>设置为2，表示每次事务提交，都只是将redo log buffer中的redo log写入到redo log文件。写入到redo log文件，并不意味着持久化，因为操作系统有个Page Cache，用于缓存文件数据，所以写入redo log文件只是写入擦欧总系统的文件缓存，由操作系统决定持久化到磁盘的时机。</p><p>这样做的风险在于主机掉电会丢失数据。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>MySQL原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-锁</title>
    <link href="/2022/11/05/MySQL-%E9%94%81/"/>
    <url>/2022/11/05/MySQL-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL有哪些锁"><a href="#MySQL有哪些锁" class="headerlink" title="MySQL有哪些锁"></a>MySQL有哪些锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="全局锁的使用"><a href="#全局锁的使用" class="headerlink" title="全局锁的使用"></a>全局锁的使用</h3><blockquote><p>使用全局锁后，整个数据库就处于只读状态</p></blockquote><p>使用全局锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush tables with read lock<br></code></pre></td></tr></table></figure><p>释放全局锁（会话断开全局锁也会自动断开）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables<br></code></pre></td></tr></table></figure><p>全局锁会阻塞其他线程的如下操作：</p><ul><li>对数据的增删改操作，比如insert、delete、upadte等语句</li><li>对表结构的更改操作，比如alter table、drop table等语句</li></ul><h3 id="全局锁的应用场景"><a href="#全局锁的应用场景" class="headerlink" title="全局锁的应用场景"></a>全局锁的应用场景</h3><blockquote><p>全局锁的主要应用于全库逻辑备份。使用全局锁后，在备份数据库期间不会因为数据或表结构的更新导致备份文件和预期不一致。</p></blockquote><p>假设在全库逻辑备份期间，不加全局锁。观察会出现什么情况：</p><p>如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑时会涉及到多张数据库表的更新。比如在用户表中更新用户余额，在商品表中更新商品库存。</p><p>那么，在备份时，若有用户购买了商品，可能会出现如下顺序：</p><ol><li>先备份了用户表的数据（用户表还未修改余额，因为此时购买商品事件都还没发生）</li><li>有用户发起了购买商品的操作（用户表和商品表都更新了）</li><li>接着再备份商品表（此时的商品表库存已经更新）</li></ol><p>在这种情况下，备份的结果中，用户表的余额没有扣除，但是商品表中的库存减少了。备份的数据库出现表数据了不一致（被备份的数据库中表数据是一致的），这样用该备份恢复数据库的话，会导致用户的余额没减少，但是商品库存减少了（在实际的数据库中，购买商品还对应着订单表，用户余额没减少，但是订单依然存在），相当于用户白嫖了一件商品。</p><p>在全库逻辑备份期间，加上全局锁，没有数据的更新自然就不会出现数据不一致的情况。</p><h3 id="全局锁的缺点与避免"><a href="#全局锁的缺点与避免" class="headerlink" title="全局锁的缺点与避免"></a>全局锁的缺点与避免</h3><h4 id="全局锁的缺点"><a href="#全局锁的缺点" class="headerlink" title="全局锁的缺点"></a>全局锁的缺点</h4><p>加上全局锁，整个数据库都是只读状态。如果数据库很大，备份会花很长的事件，在此期间业务只能读数据，不能更新数据，造成业务停滞。</p><h4 id="使用可重复读的事务代替全局锁"><a href="#使用可重复读的事务代替全局锁" class="headerlink" title="使用可重复读的事务代替全局锁"></a>使用可重复读的事务代替全局锁</h4><p>如果数据库的引擎支持可重复读的隔离级别，那么在备份数据库之前先开启事务。因为开启事务后，会先创建Read View，然后再整个事务期间都会使用该Read View来读取数据做备份，而且由于MVCC的支持，在备份期间其他业务可以正常地对数据进行更新。</p><p>备份数据库地工具是mysqldump，在使用mysqldump时加上<code>-single-transaction</code>参数的时候，就会在备份数据库之间先开启事务。这种方法只适用于支持<strong>可重复读隔离级别的事务</strong>的存储引擎。</p><p>InnoDB存储引擎默认的事务隔离级别就是可重复读，所以可以采用这种方法来备份数据库，MyISAM不支持事务，所以适用MyISAM引擎就需要适用全局锁来备份数据库。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>加表锁的命令（对学生表：t_student加锁）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><br>//表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br></code></pre></td></tr></table></figure><p>释放表锁的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables<br></code></pre></td></tr></table></figure><p>表锁除了会限制其他线程的读写外，也会限制当前线程的读写操作。也就是说对表所加的表所是对所有线程生效的，包括当前线程。例如当前线程对学生表加了共享表锁，那么当前线程对学生表执行写操作是会被阻塞的。</p><p><strong>注意：尽量避免在InnoDB引擎中使用表锁。</strong>因为表锁的颗粒度太大，会影响并发性能，InnoDB的其中一个优势就在于它实现了颗粒度更小的行级锁。</p><h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><blockquote><p>我们不需要显式的使用MDL。</p></blockquote><h4 id="MDL锁的获取"><a href="#MDL锁的获取" class="headerlink" title="MDL锁的获取"></a>MDL锁的获取</h4><p>当我们对数据库表进行操作时，会自动给这个表加上MDL：</p><ul><li><p>对一张表进行CRUD操作时，加的时MDL读锁</p><blockquote><p>加MDL读锁，是为了防止在CRUD操作过程中其他线程对表结构做修改。</p></blockquote></li><li><p>对一张表进行表结构变更操作时，加的是MDL写锁</p><blockquote><p>加MDL写锁，是为了防止在修改表结构的时候其他线程执行CRUD操作。</p></blockquote></li></ul><h4 id="MDL锁的释放"><a href="#MDL锁的释放" class="headerlink" title="MDL锁的释放"></a>MDL锁的释放</h4><p>MDL是在事务提交后才会释放。这意味着在事务执行期间会一直持有MDL锁。</p><h4 id="一个由于MDL锁获取和释放机制带来的阻塞问题"><a href="#一个由于MDL锁获取和释放机制带来的阻塞问题" class="headerlink" title="一个由于MDL锁获取和释放机制带来的阻塞问题"></a>一个由于MDL锁获取和释放机制带来的阻塞问题</h4><p>如果数据库有一个长事务，那么在对表结构做变更操作的时候可能会导致大量的select语句阻塞导致数据库线程爆满。</p><p>比如下面这个顺序的场景：</p><ol><li>线程A先启动一个长事务（一直不提交），在事务中执行select语句，这样该事务就持有了该表的MDL读锁</li><li>然后，线程B对该表执行select语句，此时并不会阻塞，因为读锁是共享的</li><li>接着，线程C尝试修改表字段，因为线程A持有表的MDL读锁，所以线程C无法申请到MDL写锁，就会被一直阻塞</li><li>在线程C被阻塞后，后续所有对该表的select语句都会被阻塞。如果此时有对该表的大量select语句请求到来，就会有大量被阻塞的线程，导致数据库线程爆满</li></ol><p>为什么线程申请不到MDL写锁，会导致后续申请读锁的查询操作阻塞？</p><p>因为申请锁的操作会形成一个队列，按照队列顺序来申请锁。队列中写锁申请优先级高于读锁申请，所以说一旦出现MDL写锁申请阻塞，那么后续的读锁申请都会被阻塞，也就是无法进行对该表的CRUD操作。</p><p>避免该问题的办法：</p><p>在对表结构做变更之前，若有长事务对该表加上了MDL读锁，可以考虑kill掉该长事务后再做表结构的更改。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><blockquote><p>意向锁的目的是为了快速判断表里是否有记录被加锁。</p></blockquote><h4 id="意向锁的获取"><a href="#意向锁的获取" class="headerlink" title="意向锁的获取"></a>意向锁的获取</h4><p>在使用InnoDB引擎时，对表中的某些行记录加上共享锁&#x2F;独占锁之前，需要先给表加上一个意向共享&#x2F;独占锁。</p><p>也就是当执行插入、更新、删除操作时，因为这些操作会获取行锁，需要在获取行锁之前对表加上意向独占锁。普通的select是不会加行级锁的，自然不需要对表加意向锁。因为普通select语句是利用MVCC来实现一致性读，是无锁的。</p><h4 id="锁之间的互斥关系：意向锁、表锁、行锁"><a href="#锁之间的互斥关系：意向锁、表锁、行锁" class="headerlink" title="锁之间的互斥关系：意向锁、表锁、行锁"></a>锁之间的互斥关系：意向锁、表锁、行锁</h4><ul><li><p>意向锁是表级锁，不会于行锁发生冲突</p></li><li><p>意向锁之间也不会发生冲突</p></li><li><p>意向锁只会和表锁之间冲突</p></li><li><p>表锁和行锁之间是读读共享、读写互斥、谢谢互斥的</p></li></ul><h4 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h4><p>因为InnoDB是支持行锁的，如果没有意向锁，那么想要加表锁时，就需要遍历表中的记录，查看是否有行记录存在独占锁，这样效率很低。</p><p>有了意向锁，由于在对行记录加行锁之前，会对表加上意向锁。那么其他线程若要对表加表锁，可以直接查表是否有冲突得意向锁，而不用到表中一条一条的遍历行记录的行锁。</p><h3 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO-INC锁"></a>AUTO-INC锁</h3><blockquote><p>AUTO-INC锁是是实现主键自增的特殊表锁机制</p></blockquote><p>主键设置为自增，是通过对主键字段声明<code>AUTO_INCREMENT</code>属性实现的。</p><p>在插入数据时，会对表加一个AUTO-INC锁，然后自增字段被赋递增的值，等插入语句执行完成后，才释放AUTO-INC锁。</p><p>这是为了保证自增值的唯一性，在插入数据时阻塞其他插入操作，避免多个线程同时插入出现自增值相同的情况。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>AUTO-INC锁要在插入完成后才释放锁，当有大量插入操作时，因为整个插入过程都持有锁，导致大量插入操作被阻塞。在MySQL 5.1.22版本开始，InnoDB引擎提供了一种轻量级的锁用以实现自增。</p><p>该轻量级锁和AUTO-INC锁的区别在于释放锁的时机不同。轻量级锁在插入数据时，为自增字段赋予自增值后就释放锁，不需要等到整个插入语句执行完成才释放锁。降低了持有锁的时间，减少插入阻塞。</p><h4 id="InnoDB中自增锁的选择"><a href="#InnoDB中自增锁的选择" class="headerlink" title="InnoDB中自增锁的选择"></a>InnoDB中自增锁的选择</h4><p>InnoDB存储引擎提供了<code>innodb_autoinc_lock_mode</code>变量用于选择自增时的锁：</p><ul><li>为0时，采用AUTO-INC锁，语句执行完后才释放锁。</li><li>为2时，采用轻量级锁，申请完自增主键后释放锁。</li><li>为1时，普通insert语句，采用轻量级锁；类似insert … select这样的批量插入数据语句，使用AUTO-INC语句。</li></ul><h4 id="使用轻量级锁搭配binlog日志格式为statement时，在“主从复制场景”中的数据不一致问题"><a href="#使用轻量级锁搭配binlog日志格式为statement时，在“主从复制场景”中的数据不一致问题" class="headerlink" title="使用轻量级锁搭配binlog日志格式为statement时，在“主从复制场景”中的数据不一致问题"></a>使用轻量级锁搭配binlog日志格式为statement时，在“主从复制场景”中的数据不一致问题</h4><p>场景如下：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/innodb_autoinc_lock_mode=2.png" alt="img"></p><p>session A往表t中共插入了4行数据，然后sessionB复制了一份相同的表t2，然后两个session同时往表t2中插入数据。</p><p>因为轻量级锁，在申请自增主键后就释放锁，所以说插入语句时并发执行的，就可能出现这种情况：</p><ol><li>session B先插入两个记录：（1，1，1）、（2，2，2）</li><li>然后session A获得轻量级锁，插入记录：（3，5，5）</li><li>之后，session 继续插入两条记录：（4，3，3）、（5，4，4）</li></ol><p>可以看到session B的insert语句插入的四条记录生成的id不连续。</p><p>因为binlog的日志格式为statement，那么binlog只会记录这两条insert语句。建立从库是按照binlog中的SQL语句来建立建立，因为该操作是在同一线程中，SQL语句会一条一条地执行。那么就不会发生像在主库中两个session同时向表t2中插入数据的场景。所以在从库中执行session B的insert语句生成的四条记录id是连续的。这时主从库就发生了数据不一致。</p><p>解决办法：</p><p>将binlog日志格式设置为row，这样在binlog中记录的就是主库的行记录，而不是执行的语句。在主库中分配的自增值已经在binlog中了，从库执行binlog，就不需要自己分配自增值，和主库自增值保持一致。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><blockquote><p>InnoDB引擎支持行级锁，而MyISAM引擎不支持行级锁。</p></blockquote><h3 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h3><blockquote><p>记录锁锁住的是一条记录。而且分为S（Share）锁和X（exclusive）锁。</p></blockquote><p>普通的select语句时不会对记录加锁的，因为它属于快照读。</p><p>如果要在查询时对记录加行锁，可以使用以下范式查询，称为<strong>锁定读</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//对读取的记录加共享锁<br>select ... lock in share mode;<br><br>//对读取的记录加独占锁<br>select ... for update;<br></code></pre></td></tr></table></figure><p>上面这两条语句必须要在一个事务中，因为当事务提交的时候会释放锁，若不再事务中，锁一直被占用。所以在使用这两条语句前一定要加上begin、start transaction或set autocommit &#x3D; 0来开启事务。</p><p>共享锁和独占锁之间的互斥性：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="img"></p><h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><blockquote><p>间隙锁只存在于可重复读隔离级别，目的是为例解决可重复读隔离级别下当前读的幻读现象。</p></blockquote><p>假设表中有一个范围id为（3，5）的间隙锁，那么其他事务就无法插入id为4的记录，这样就有效的防止了幻读现象的发生。如图所示：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/gap%E9%94%81.drawio.png" alt="img"></p><p>间隙锁虽然存在S型和X型间隙锁，但是并没有什么区别。间隙锁之间不是互斥的，即两个事务可以同时持有包含相同间隙范围的间隙锁，因为间隙锁的目的是防止插入幻影记录而提出的。</p><h3 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h3><blockquote><p>Next-key Lock称为临键锁，是Record Lock + Gap Lock的组合，锁定一个范围，并且锁定记录本身。</p></blockquote><p>假设有一个范围id为（3，5]的next-key lock，那么其他事务不能插入id &#x3D; 4或id &#x3D; 5的记录：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/%E4%B8%B4%E9%94%AE%E9%94%81.drawio.png" alt="img"></p><p>next-key lock即能保护该记录，又能组织其他事务将新纪录插入到被保护记录前的间隙中。</p><p>因为next-key lock是间隙锁 + 记录锁，记录锁之间是由互斥性的，所以next-key lock之间也是由互斥性的。</p><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><blockquote><p> 插入意向锁是一种特殊的间隙锁。</p></blockquote><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加入了间隙锁（next-key lock也包含间隙锁）。如果有，插入操作会阻塞，直到间隙锁释放，在阻塞期间会生成一个插入意向锁，表明有事务想在该区间插入数据。</p><p>假设事务A已经对表加了一个范围id为（3，5）的间隙锁：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/gap%E9%94%81.drawio-166773701920843.png" alt="img"></p><p>当事务A还未提交的时候，事务B向该表插入一条id &#x3D; 4的记录，这时会判断到插入位置有间隙锁，于是事务B生成一个插入意向锁，将锁的状态设置未等待状态（MySQL加锁，是先生成锁结构，再设置锁状态。此时生成了插入意向锁，但是锁状态未等待状态，不代表事务获取到了锁，只有当锁状态未正常状态是，才代表事务成功获取到了锁），此时事务B阻塞，直到事务A提交。</p><p>插入意向锁和间隙锁的关系：</p><ul><li>如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点。从这个角度来说，插入意向锁就是一种特殊的间隙锁。</li><li>插入意向锁和间隙锁之间互斥。即两个事务不能再同一时间内一个拥有间隙锁，另一个拥有间隙锁区间内的插入意向锁</li></ul><h1 id="MySQL如何加锁"><a href="#MySQL如何加锁" class="headerlink" title="MySQL如何加锁"></a>MySQL如何加锁</h1><blockquote><p><strong>给记录加锁的基本单位：next-key lock</strong></p><p>它是由记录锁和间隙锁组合而成。next-key是前开后闭区间，而间隙锁是前开后开区间。但是在一些场景下，<strong>next-key lock会退化</strong>成记录锁或间隙锁。</p></blockquote><p>在使用update、delete、select … for update这些语句时，都是当前读，需要通过加锁来解决幻读问题。并且这些语句都会使用where条件，不同的where条件的加锁情况不同。</p><p>下面以select … for update来说明加锁的情况（update和delete加锁情况一样）：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/954708d2f29c2a619e861e57cdf74c11-166773923532748.png" alt="图片"></p><h2 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h2><ul><li><p>当查询的记录存在。next-key lock退化成记录锁</p><blockquote><p>因为是唯一索引，所以当查询到记录后，不会插入新的相同索引的记录。所以只需要记录锁避免修改行记录即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_test where id = 16 for update;<br></code></pre></td></tr></table></figure><p>next-key lock锁住区间(8, 16]，因为记录16存在，然后退化为Record lock 16。</p></blockquote></li><li><p>当查询的记录不存在。next-key lock退化成间隙锁</p><blockquote><p>记录不存在，只需要锁住查询记录所在区间，避免在该区间内插入数据，就不会出现幻读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_test where id = 10 for update;<br></code></pre></td></tr></table></figure><p>next-key lock锁住(8, 16]，因为记录10不存在，然后退化为gap lock(8, 16)。</p></blockquote></li></ul><h2 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h2><ul><li><p>当查询的记录存在，除了加next-key lock外，还额外加间隙锁，也就是会加两把锁</p><blockquote><p>因为非唯一索引可以插入索引相同的记录。在该索引记录存在的情况下，如果插入相同索引的记录，可能在当前索引前，也可能在当前索引后。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_test where b = 16 for update;<br></code></pre></td></tr></table></figure><p>next-key lock先锁住(8, 16]，然后因为是非唯一索引且查询记录存在，所以往后遍历查找到第一个不符合条件的值才停止，因此间隙锁为(16, 32)。即最终锁为next-key lock(8, 16]和gap lock(16, 32)。</p></blockquote></li><li><p>当查询的记录不存在，只会加next-key lock，然后退化为间隙锁</p><blockquote><p>同唯一索引查询一样</p></blockquote></li></ul><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><ul><li><p>唯一索引的范围查询</p><blockquote><p>会从找到满足条件的第一行，以等值查询方式加锁，然后往后查找满足条件的记录，若记录不在查找范围内，则会退化为间隙锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from i_test where id &gt;= 8 and id &lt; 9 for update;<br></code></pre></td></tr></table></figure><p>第一行id &#x3D; 8，所以next-key lock锁住(4, 8]，并退化成记录锁，只锁住8。然后进行范围查找，找到第一个不符合条件的记录id &#x3D; 16，然后next-key lock锁住(8, 16]，因为16不满足条件，所以退化为 (8, 16)。所以说最终的锁是record lock 8和gap lock (8, 16)。</p></blockquote></li><li><p>非唯一索引的范围查询</p><blockquote><p>跟唯一索引的范围查询的区别在于next-key lock不会退化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from i_test where b &gt;= 8 and b &lt; 9 for update;<br></code></pre></td></tr></table></figure><p> 有两个next-key lock，(4, 8]和(8, 16]。</p></blockquote></li></ul><h2 id="没有使用索引"><a href="#没有使用索引" class="headerlink" title="没有使用索引"></a>没有使用索引</h2><p>当没有使用索引的时候，会进行全表扫描，于是会对所有的记录加上next-key lock，那么就相当于整张表被锁住了（但是不是表锁，只是锁住所有记录，效果和表锁相似）。</p><p>在执行update、delete、select … for update等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描，那么会对每一条记录加next-key lock，整张表都被锁住，其余所有的需要加锁的操作都会被阻塞。这是很严重的问题。</p><h2 id="Insert-语句的加锁"><a href="#Insert-语句的加锁" class="headerlink" title="Insert 语句的加锁"></a>Insert 语句的加锁</h2><p>Insert 语句在正常执行时是不会生成锁结构的。它是靠聚簇索引记录自带的trx_id隐藏列来作为隐式锁来保护记录的，在特殊情况下，才会将隐式锁转换为显式锁。</p><p>隐式锁：</p><p>当事务需要加锁时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制叫做隐式锁。隐式锁时InnoDB实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少锁的数量，提高系统整体性能。</p><p>隐式锁转换为显式锁的场景：</p><ul><li><p>记录之间加有间隙锁</p><blockquote><p>在插入一条新记录前，如果待插入记录的下一条记录上已经被加上了间隙锁，此时会生成一个插入意向锁，并将锁设置为等待状态。然后insert语句会被阻塞。</p></blockquote></li><li><p>遇到唯一键冲突</p><blockquote><p>主键索引冲突：插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加S型记录锁</p><p>唯一二级索引冲突：插入新记录的事务会给已存在的二级索引列值重复的二级索引记录添加S型next-key lock。</p></blockquote></li></ul><h1 id="MySQL死锁"><a href="#MySQL死锁" class="headerlink" title="MySQL死锁"></a>MySQL死锁</h1><h2 id="死锁的发生"><a href="#死锁的发生" class="headerlink" title="死锁的发生"></a>死锁的发生</h2><h3 id="发生死锁的业务场景："><a href="#发生死锁的业务场景：" class="headerlink" title="发生死锁的业务场景："></a>发生死锁的业务场景：</h3><p>在新增订单时做幂等性检验。做法是在新增订单前，先通过select … for update查询订单是否存在，若不存在才插入订单记录。</p><h3 id="模拟发生死锁的场景："><a href="#模拟发生死锁的场景：" class="headerlink" title="模拟发生死锁的场景："></a>模拟发生死锁的场景：</h3><p>表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_order` (<br>  `id` int NOT NULL AUTO_INCREMENT,<br>  `order_no` int DEFAULT NULL,<br>  `create_date` datetime DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `index_order` (`order_no`) USING BTREE<br>) ENGINE=InnoDB ;<br></code></pre></td></tr></table></figure><p> 现有表记录：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/54fc00f9f87a60ab7b5ba92d824a892d.png" alt="图片"></p><p>此时有两个事务，一个插入订单1007，一个插入1008：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/90c1e01d0345de639e3426cea0390e80.png" alt="img"></p><h3 id="为什么不用普通的select语句做幂等性检验"><a href="#为什么不用普通的select语句做幂等性检验" class="headerlink" title="为什么不用普通的select语句做幂等性检验"></a>为什么不用普通的select语句做幂等性检验</h3><p>如果使用普通的select语句做幂等性检验，若两个相同订单号请求进来，就会出现重复的订单。因为普通select语句不会对记录加锁。</p><p><img src="/2022/11/05/MySQL-%E9%94%81/8ae18f10f1a89aac5e93f0e9794e469e.png" alt="img"></p><h3 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h3><p>在可重复读隔离级别下存在幻读问题。InnoDB引擎为了解决可重复读隔离级别下的幻读问题，引入了next-key lock。锁的释放时机是事务提交过后，而不是一条语句执行完。这就是造成死锁的原因。</p><p>事务A和事务B执行select … for update后都持有二级索引范围(1006, +∞]的next-key lock。在接下来的插入操作为了获取到插入意向锁，都在等待对方释放间隙锁，造成了循环等待，导致死锁。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>死锁条件：互斥、占有且等待、不可强占、循环等待</p><p>死锁发生后，通过打破<strong>循环等待</strong>来解除死锁：</p><ul><li><p>设置事务等待锁的超时时间。</p><blockquote><p>当一个事务的等待时间超过设定值后，就对事务进行回滚（相当于只要超过等待时间就当作发生了死锁）。</p><p>参数<code>innodb_lock_wait_timeout</code> 用于设置超时时间，默认50秒。</p></blockquote></li><li><p>开启主动死锁检测。</p><blockquote><p>系统主动检测到发生死锁后，主动回滚死锁链条中的某一事务，让其他事务得以继续执行。</p><p>将参数<code>innodb_deadlock_detect</code>设置为on，表示开启死锁检测，默认开启。</p></blockquote></li></ul><p>更好的方式是避免死锁的发生：</p><p>对于上面发生死锁的业务场景，可以通过对order_no字段设置唯一索引列，利用它的唯一性保证订单表不出现重复的订单。有一点不好的地方在于若插入一个已存在的订单记录会抛出异常。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>MySQL原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-事务</title>
    <link href="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h1><h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h2><p>通过一个经典的银行转账来说明。</p><p>假设我向你转账，那么转账过程由以下几个步骤组成：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/40b48e0a7c9a57ae6b78b62c3fad4048.png" alt="图片"></p><p>这个转账过程涉及两次修改数据库的操作，一次是修改我的余额，一次是修改你的余额。</p><p>如果说在操作三后服务器掉电，那么我的余额减少，但是你的余额没有增多，前凭空消失了。</p><p>对于转账这个业务来说，这两个操作时不可分割的。要么两个操作都成功，要么两个操作都失败。</p><p>数据库中的业务就是为了达到这样的效果。在转账前开启事务，等所有操作完成后提交事务。对于已经提交的事务，该事务所做的修改将生效，若在事务中途发生错误，那么该事务期间对数据库所做的修改会回滚到没执行该事务之前的状态。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>事务是由MySQL的引擎来完成的，但不是所有引擎都支持事务，比如说InnoDB引擎就支持事务，但MyISAM不支持。</p><p>实现事务必须要遵守4个特性（ACID）：</p><ul><li><p>原子性（Atomicity）</p><blockquote><p>一个事务中所有的操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。通过在事务执行过程出错时的回滚实现。</p></blockquote></li><li><p>一致性（Consistency）</p><blockquote><p>是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性。</p><p>还是以转账操作为例，A有800，B有600，共1400元，若A给B转200元，那么分为两个步骤，A扣200元，B增加200元。一致性就是要求上述步骤操作后，最后结果是A还有600，B有800，总数还是1400。而不会出现A扣了200变600，但是B没有增加，结果总数变成了1200，钱凭空消失。</p></blockquote></li><li><p>隔离性（Isolation）</p><blockquote><p>数据库允许多个事务并发执行，同时对其数据进行读写和修改。隔离性可以防止多个事务并发执行时，不会相互干扰，每一个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说一个消费者购买商品，是不会影响其他消费者购买的。</p></blockquote></li><li><p>持久性（Durability）</p><blockquote><p> 事务处理结束后，对数据的修改就是永久的，即使系统故障也不会丢失。</p></blockquote></li></ul><p>InnoDB中实现这4个特性所对应的技术：</p><ul><li>原子性：undo log（回滚日志）</li><li>持久性：redo log（重做日志）</li><li>隔离性：MVCC（多版本并发控制）或锁机制</li><li>一致性：持久性+原子性+隔离性</li></ul><h1 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h1><h2 id="并行事务带来的问题"><a href="#并行事务带来的问题" class="headerlink" title="并行事务带来的问题"></a>并行事务带来的问题</h2><p>MySQL服务器允许多个客户端连接，这就意味着MySQL需要处理并发事务。在同时处理多个事务的时候，就可能出现脏读、不可重复读、幻读的问题。</p><h3 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h3><blockquote><p>如果一个事务读到了另一个事务<strong>未提交事务修改过的数据</strong>，就意味着发生了脏读。</p></blockquote><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/10b513008ea35ee880c592a88adcb12f.png" alt="图片"></p><p>事务B读取的数据是A还未提交事务修改的数据，随时可能会发生回滚，若发生了回滚，B获得的就是过期的数据，这就称为脏读。</p><h3 id="不可重复读（non-repeatable-read）"><a href="#不可重复读（non-repeatable-read）" class="headerlink" title="不可重复读（non-repeatable read）"></a>不可重复读（non-repeatable read）</h3><blockquote><p>在一个事务内部多次读取同一个数据，如果出现前后两次读到的数据不一致的情况，就意味着发生了不可重复读。</p></blockquote><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片"></p><p>在A事务两次读取余额的操作之间，事务B修改了余额，那么A事务两次读取到的余额不同，这就是不可重复读。</p><h3 id="幻读（phantom-read）"><a href="#幻读（phantom-read）" class="headerlink" title="幻读（phantom read）"></a>幻读（phantom read）</h3><blockquote><p>事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据就意味着发生了幻读。</p></blockquote><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p><p>事务B第一次按条件读取是5条数据，然后事务A插入了一条搜索条件的数据，事务B再次按原条件搜索，读取到了6条数据。对于事务B来说，同样的搜索条件，搜出来的结果不一致，就像发生了幻觉，这就是幻读。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>并发带来的影响事务一致性性的三种现象的严重程度：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/d37bfa1678eb71ae7e33dc8f211d1ec1.png" alt="图片"></p><p>SQL标准提出了四种隔离级别来规避这些现象。隔离级别越高，性能越差，四个隔离级别如下：</p><ul><li><p>读未提交（read uncommitted）</p><blockquote><p>一个事务还未提交，它做的更改就能被其他事务看到</p></blockquote></li><li><p>读提交（read committed）</p><blockquote><p>一个事务提交过后，它做的更改才能被其他事务看到</p><p>解决了脏读现象。</p></blockquote></li><li><p>可重复读（repeatable read）（默认）</p><blockquote><p>指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</p><p>解决了脏读和不可重复读现象。</p></blockquote></li><li><p>串行化（serializable）</p><blockquote><p>对事务读写的记录加上读写锁，在多个事务对同一记录进行读写操作的时候，如果发生读写冲突，那么后访问的事务必须等待前一个事务执行完成后，才能继续执行。</p><p>解决了上述三种现象。</p></blockquote></li></ul><p>四种隔离级别的实现：</p><ul><li><p>读未提交：直接读取最新数据</p></li><li><p>串行化：通过加读写锁的方式避免并行访问</p></li><li><p>读提交和可重复读：</p><blockquote><p>通过Read View来实现，它们的区别在于创建Read View的时机不同，大家可以把Read View理解为一个数据快照。读提交是在每个语句执行前都会重新生成一个Read View，而可重复读隔离级别是启动事务时生成一个Read View，然后整个事务期间都使用这一个Read View</p></blockquote></li></ul><p>事务开启命令与事务启动时机：</p><ul><li><p>begin&#x2F;start transaction命令</p><blockquote><p>执行该命令过后，并不代表事务启动了。只有在执行该命令后执行了增删改查的SQL语句，事务才真正启动，并创建快照。</p></blockquote></li><li><p>start transaction with consistent snapshot命令</p><blockquote><p>该命令会马上启动事务并创建快照</p></blockquote></li></ul><h1 id="Read-View和MVCC"><a href="#Read-View和MVCC" class="headerlink" title="Read View和MVCC"></a>Read View和MVCC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Read-View的四个重要字段"><a href="#Read-View的四个重要字段" class="headerlink" title="Read View的四个重要字段"></a>Read View的四个重要字段</h3><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><ul><li><p>creator_trx_id</p><blockquote><p>指的是创建该Read View的事务的事务id</p></blockquote></li><li><p>m_ids</p><blockquote><p>指的是在创建Read View时，当前数据库中“活跃事务“的事务id列表。注意是一个列表，“活跃事务”指的是启动了但是还没有提交的事务。</p></blockquote></li><li><p>min_trx_id</p><blockquote><p>指的是”活跃事务“列表中事务id最小的事务，也就是m_ids中的最小值</p></blockquote></li><li><p>max_trx_id</p><blockquote><p>这个并不是m_ids中的最大值，而是创建Read View时当前数据库中应该给下一个事务的id值，也就是全局事务中最大的事务id值+1</p></blockquote></li></ul><h3 id="聚簇索引记录中跟事务相关的两个隐藏列"><a href="#聚簇索引记录中跟事务相关的两个隐藏列" class="headerlink" title="聚簇索引记录中跟事务相关的两个隐藏列"></a>聚簇索引记录中跟事务相关的两个隐藏列</h3><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/f595d13450878acd04affa82731f76c5.png" alt="图片"></p><p>聚簇索引记录中有两个隐藏列：</p><ul><li><p>trx_id</p><blockquote><p>当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务id记录在trx_id隐藏列中</p></blockquote></li><li><p>roll_pointer</p><blockquote><p>每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到undo日志中，然后roll_pointer中保存指向这个旧记录的指针，于是我们就可以通过它来找到修改前的旧记录</p></blockquote></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在创建Read View后，我们可以将聚簇索引记录中的trx_id划分为三种情况：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/ReadView.drawio.png" alt="img"></p><p>一个事务去访问记录的时候，会根据Read View与记录的trx_id做对比，来判断记录对于事务的可见性：</p><ul><li><p>trx_id &lt; min_trx_id（可见）</p><blockquote><p>表示这个版本的记录是在创建Read View前，由已经提交的事务生成。所以该版本记录对当前事务可见。</p></blockquote></li><li><p>trx_id &gt;&#x3D; max_trx_id（不可见）</p><blockquote><p>表示这个版本的记录是在创建Read View后才启动的事务生成的。所以该版本记录对当前事务不可见。</p></blockquote></li><li><p>trx_id 在二者之间</p><ul><li><p>若trx_id在m_ids列表中（不可见）</p><blockquote><p>表示生成该版本记录的活跃事务还未提交，该版本记录对当前事务不可见。</p></blockquote></li><li><p>若trx_id不在m_ids列表中（可见）</p><blockquote><p>表示生成该事务的活跃事务已经被提交，所以该版本记录对当前事务可见。</p></blockquote></li></ul></li></ul><p>这种通过”版本链“来控制并发事务访问同一记录的方式就叫做MVCC（多版本并发控制）。</p><h2 id="可重复读是如何工作的"><a href="#可重复读是如何工作的" class="headerlink" title="可重复读是如何工作的"></a>可重复读是如何工作的</h2><blockquote><p>可重复读隔离级别是启动事务时生成一个Read View，然后整个事务期间都使用这个Read View</p></blockquote><h3 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h3><p>假设事务A（事务id为51）启动后，紧接着事务B（事务id为52）也启动。</p><p>两个事务创建时的Read View和事务创建时的字段信息如下：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="img"></p><p>事务A和事务B的Read View内容如下：</p><ul><li>事务A的Read View：它的事务id是51，由于它是第一个启动的事务，它启动时活跃事务的事务就只有它本身（也就是51），那么活跃事务id列表中最小的事务id也是事务A本身，下一个事务id则是52</li><li>事务B的Read View：它的事务id是52，由于事务A是活跃的，所以此时的活跃事务的事务id列表是51和52，活跃事务id中最小的事务id是事务A，下一个事务id是53</li></ul><h3 id="事务执行与分析"><a href="#事务执行与分析" class="headerlink" title="事务执行与分析"></a>事务执行与分析</h3><p>接着，在可重复读隔离级别下，事务A和事务B按顺序执行了以下操作：</p><ol><li><p>事务B读取余额，余额为100万</p><blockquote><p>在找到记录后，先查看该记录的trx_id，发现trx_id为50，比事务B的Read View中的min_trx_id值（51）小，这意味着修改这条记录的事务在事务B启动前就已经提交了，所以该版本记录对事务B是可见的，也就是事务B可以获取到这条记录。</p></blockquote></li><li><p>事务A将余额记录修改为200万（未提交事务）</p><blockquote><p>事务A通过update语句修改了记录，这个时候MySQL会将旧数据记录到undo log中，然后新建记录保存到索引中，并以链表的方式连接新旧记录，形成版本链，如下图：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/image-20221106140535502.png" alt="image-20221106140535502"></p><p>所以最新的记录的trx_id是事务A的事务id（51）</p></blockquote></li><li><p>事务B读取余额，读到余额仍未100万</p><blockquote><p>事务B第二次读取该记录，发现trx_id值为51，在事务B的Read View的min_trx_id和max_trx_id之间，然后再判断trx_id在m_ids中，所以这条记录是被还未提交的事务修改的，所以事务B不会读取这个版本的记录。而是沿着undo log版本链往下找旧版本的记录，直到找到trx_id小于Read View的min_trx_id的第一条记录。所以事务B能读取到的是trx_id为50的记录，也就是余额为100万的记录。</p></blockquote></li><li><p>事务A提交事务</p></li><li><p>事务B读取余额，读到余额仍为100万</p><blockquote><p> 由于隔离级别是可重复读，所以事务B每次读取记录时，都是基于启动事务B时创建的Read View来判断当前版本的记录的可见性。所以，即使事务A修改余额并已提交，事务B读取记录时，读到的仍是余额为100万的这个版本。</p></blockquote></li></ol><h2 id="读提交是如何工作的"><a href="#读提交是如何工作的" class="headerlink" title="读提交是如何工作的"></a>读提交是如何工作的</h2><blockquote><p>读提交隔离级别是在每次读取数据时,都会生成一个新的Read View。</p></blockquote><p>还是同上面一样的执行流程：</p><ol><li><p>事务B读取余额，余额为100万</p><blockquote><p>同可重复读一样</p></blockquote></li><li><p>事务A将余额记录修改为200万（未提交事务）</p><blockquote><p>同可重复读一样</p></blockquote></li><li><p>事务B读取余额，读到余额仍未100万</p><blockquote><p>因为事务A还没提交。所以事务B第二次读取余额创建的Read View和第一次读取余额创建的Read View一样，所以读取到的余额也一样。</p></blockquote></li><li><p>事务A提交事务</p><blockquote><p>同可重复读一样</p></blockquote></li><li><p>事务B读取余额，读到余额为200万</p><blockquote><p>这次创建的Read View如下：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png" alt="img"></p><p> 因为事务A已经提交了，所以事务A不在活跃列表中。</p><p>trx_id为51比Read View中的min_trx_id值小，所以修改该记录的事务在创建Read View之前已经提交了，所以该版本的记录对事务B是可见的。</p></blockquote></li></ol><h1 id="可重复读的幻读解决方案"><a href="#可重复读的幻读解决方案" class="headerlink" title="可重复读的幻读解决方案"></a>可重复读的幻读解决方案</h1><p>MySQl InnoDB引擎的默认隔离级别是可重复读。但是它在很大程度上避免了幻读现象。其解决方案如下：</p><ul><li><p>针对快照读（普通select语句）</p><blockquote><p> 通过MVCC方式解决了幻读。因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据一致，即使中途有其他事务插入了一条数据，对于该事务来说是不可见的，所以就很好地避免了幻读问题。</p></blockquote></li><li><p>针对当前读（select…for update等语句）</p><blockquote><p>通过next-key lock（记录锁+间隙锁）方式解决了幻读。因为在执行select …for update语句的时候，会加上next-key lock，如果有其他事务在next-key lock锁范围内插入一条记录，那么这条插入语句就会别阻塞，无法成功插入，所以就很高地避免幻读问题。</p></blockquote></li></ul><h2 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h2><blockquote><p>官方文档定义的幻读（Phantom Read）：</p><p><em><strong>The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.</strong></em></p><p>当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻读现象。例如，如果SELECT执行了两次，但第二次返回了第一次没有返回的行，则该行时”幻像“行。</p></blockquote><p>例如，在同一事务中的T1时刻和T2时刻分别执行了如下查询语句，T1-T2之间该事务没有执行其他修改语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_test WHERE id &gt; 100;<br></code></pre></td></tr></table></figure><p>只要T1和T2时刻执行产生的结果集是不同的，那就发生了幻读问题。</p><h2 id="快照读是如何避免幻读的"><a href="#快照读是如何避免幻读的" class="headerlink" title="快照读是如何避免幻读的"></a>快照读是如何避免幻读的</h2><blockquote><p>可重复读隔离级别是由MVCC（多版本并发控制）实现的。</p></blockquote><p>启动事务后，在执行第一个查询语句后，创建一个Read View，后续的查询语句会通过这个Read View在undo log版本链中找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的。即使中途插入了新的记录，由于新纪录的版本高于事务的版本，所以事务是查询不到新数据的。</p><h2 id="当前读是如何避免幻读的"><a href="#当前读是如何避免幻读的" class="headerlink" title="当前读是如何避免幻读的"></a>当前读是如何避免幻读的</h2><blockquote><p>当前读是通过next-key lock实现的</p></blockquote><p>MySQL里除了普通查询是快照读，其他都是当前读，比如说update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。因为如果要update一条记录，若其他事务已经delete这条记录并已经提交了，如果update不获取最新记录的话就会产生冲突。另外，select … for update这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p><p>我们假设当前读的时候如果是不加锁的（实际上会加锁）的情况：</p><p>在事务A的两次相同的当前读查询语句之间，事务B插入了一条记录，导致两次查询结果不一致，出现了幻读。</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>Innodb引擎为了解决在可重复读隔离级别中使用当前读而产生的幻读问题，就引入了<strong>间隙锁</strong>。</p><p>在执行当前读的时候，在可能导致幻读的记录间隙加上间隙锁，阻塞其他事务在该范围插入记录，就可以避免当前读的幻读问题。举个例子，场景如下：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/3af285a8e70f4d4198318057eb955520.png" alt="img"></p><p>事务A执行了当前读语句，因为它读取的范围是id &gt; 2，就对表中记录加上范围为（2， +∞）的next-key lock。</p><p>然后事务B在执行插入语句的时候，由于其要插入的位置被事务A加上了next-key lock，于是事务B就会生成一个插入意向锁，同时进入等待状态，直到事务A提交了事务才执行插入操作，这就避免了由于事务B插入新记录而导致事务A发生幻读的现象。</p><h2 id="MySQL未完全解决幻读"><a href="#MySQL未完全解决幻读" class="headerlink" title="MySQL未完全解决幻读"></a>MySQL未完全解决幻读</h2><h3 id="第一个发生幻读的场景"><a href="#第一个发生幻读的场景" class="headerlink" title="第一个发生幻读的场景"></a>第一个发生幻读的场景</h3><p>以该表为例子：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/7f9df142b3594daeaaca495abb7133f5.png" alt="img"></p><p>出现幻读的一个操作时序图：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p><p>在可重复读隔离级别下，事务A第一次执行普通的select语句时生成ReadView，之后事务B像表中插入一条id为5的记录，此时该记录的trx_id是事务B的id，事务A是查不到该记录的，然后事务A对id为5的这条记录执行了更新操作（因为更新操作是当前读，可以读到其他事务提交的记录），id为5的记录的trx_id被修改为事务A的id，这样之后事务A再使用普通的select语句去查询这条记录时就可以看到该记录。</p><h3 id="第二个发生幻读的场景"><a href="#第二个发生幻读的场景" class="headerlink" title="第二个发生幻读的场景"></a>第二个发生幻读的场景</h3><p>事务A先执行普通select快照读，然后事务B插入一条数据并提交，然后事务A再执行一条当前读语句，此时也会发生幻读现象。</p><h3 id="避免上面特殊场景的幻读现象"><a href="#避免上面特殊场景的幻读现象" class="headerlink" title="避免上面特殊场景的幻读现象"></a>避免上面特殊场景的幻读现象</h3><p>再开启事务之后，马上执行select … for update这类当前读语句，因为它会对记录加next-key lock，从而阻塞其他事务在可能导致幻读的地方插入新记录。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>MySQL原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-索引</title>
    <link href="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><blockquote><p>索引就是数据的目录。</p></blockquote><p>当我们想要查阅书中的某个只是的内容的时候，使用目录可以快速定位要找的知识的位置，如果没有目录那么就需要一页一页的找。</p><p>书中的目录，就是充当索引的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。对应到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的来说索引就是数据的目录。</p><p>所谓的存储引擎，就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><h2 id="索引的分类与介绍"><a href="#索引的分类与介绍" class="headerlink" title="索引的分类与介绍"></a>索引的分类与介绍</h2><p>按不同角度分类：</p><p>数据结构：B+Tree索引、Hash索引、Full-text索引</p><p>物理存储：聚簇索引（主键索引）、二级索引（辅助索引）</p><p>字段特性：主键索引、唯一索引、普通索引、前缀索引</p><p>字段个数：单列索引、联合索引</p><h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><p>从数据结构的角度来看，MySQL常见的索引有B+tree索引、Hash索引、Full-text索引。</p><p>不同存储引擎支持的所以类型不同，支持如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" alt="img"></p><p>MySQL的默认引擎是InnoDB，InnoDB的默认索引类型是B+tree索引。</p><h3 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h3><p>从物理存储的角度看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><p>主键索引的B+ Tree和二级索引的B+ Tree的区别：</p><ul><li>主键索引的B+ Tree的叶子节点存放的是实际数据，所有的行数据都存放在主键索引的B+ Tree的叶子节点中</li><li>二级索引的B+ Tree的叶子节点存放的是主键值，而不是实际数据</li></ul><p>二者的创建：</p><ul><li><p>聚簇索引：</p><blockquote><p>在创建表时，InnoDB会根据不同场景选择不同列作为索引生成聚簇索引</p><ul><li>若有主键。默认选择使用主键作为聚簇索引的索引键</li><li>若没有主键。则选择第一个不包含NULL值的唯一列作为聚簇索引的索引键</li><li>若上面二者都没有。InnoDB则会生成一个隐式自增id列作为聚簇索引的索引键</li></ul></blockquote></li><li><p>非聚簇索引：</p><blockquote><p>其他的索引都属于辅助索引（Secondary Index），也称为二级索引或非聚簇索引。</p></blockquote></li></ul><h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><blockquote><p>主键索引就是建立在主键字段上的索引。通常在创建表的时候一起创建，一张表只有一个主键索引，索引列的值不能为空值。</p></blockquote><p>在创建表时，创建主键索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  PRIMARY KEY (index_column_1) USING BTREE<br>);<br></code></pre></td></tr></table></figure><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><blockquote><p>唯一索引是建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值。</p></blockquote><p>创建表时，创建唯一索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  UNIQUE KEY(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure><p>建表后，添加唯一索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE UNIQUE INDEX index_name<br>ON table_name(index_column_1,index_column_2,...); <br></code></pre></td></tr></table></figure><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><blockquote><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为UNIQUE。</p></blockquote><p>建表时，创建普通索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  INDEX(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure><p> 建表后，添加普通索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_name<br>ON table_name(index_column_1,index_column_2,...); <br></code></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><blockquote><p>前缀索引是指字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引。前缀索引可以建立子啊字段类型为char、varchar、binary、varbinary的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，并提升查询效率。</p></blockquote><p>创建表时，创建前缀索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name(<br>    column_list,<br>    INDEX(column_name(length))<br>); <br></code></pre></td></tr></table></figure><p>建表后添加前缀索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_name<br>ON table_name(column_name(length)); <br></code></pre></td></tr></table></figure><h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><p>从字段个数的角度来看，索引分为单列索引、联合索引。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引</li><li>建立在多列上的索引称为联合索引</li></ul><h4 id="联合索引简介："><a href="#联合索引简介：" class="headerlink" title="联合索引简介："></a>联合索引简介：</h4><p>若将上面商品表中的product_no和name字段组合成联合索引（product_no, name）。</p><p>创建联合索引的方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_product_no_name ON product(product_no, name);<br></code></pre></td></tr></table></figure><p>联合索引（product_no, name）的B+ Tree示意图：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png" alt="联合索引"></p><p>可以看到，联合索引的非叶子节点用两个字段的值作为B+ Tree的Key值。</p><p>当在联合索引查询数据时，先按照product_no字段比较，在product_no字段相同的情况下再按name字段比较。也就是说来联合索引中的B+Tree是先按product_no进行排序，再按name排序。</p><h4 id="最左匹配原则："><a href="#最左匹配原则：" class="headerlink" title="最左匹配原则："></a>最左匹配原则：</h4><p>在使用联合索引的时候，存在最左匹配原则，也就是按照最左优先的方式进行索引匹配。</p><p>在使用联合索引进行查询的时候，若不遵守最左匹配原则，联合索引会失效，这样就无法利用索引快速查询的特性了。</p><p>比如说有（a，b，c）这么三个字段组成的联合索引。</p><p>有效的查询条件：</p><ul><li>where a &#x3D; 1;</li><li>where a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3;</li><li>where b &#x3D; 1 and a &#x3D; 2;</li></ul><p>失效的查询条件：</p><ul><li>where b &#x3D; 2;</li><li>where c &#x3D; 3;</li><li>where b &#x3D; 2 and c &#x3D; 3;</li></ul><p>索引失效的原因（只有a字段是全局有序的，b和c字段是局部有序的）：</p><blockquote><p>因为联合索引（a, b, c）是按照a排序，a相同的情况下按b排序，b相同过的情况下按c排序。</p><p>所以说<strong>b和c是全局无序的，局部有序的。</strong></p><p>这样在没有遵守最左匹配原则的情况下，是无法利用到该联合索引的。</p></blockquote><h4 id="联合索引范围查询："><a href="#联合索引范围查询：" class="headerlink" title="联合索引范围查询："></a>联合索引范围查询：</h4><blockquote><p>范围查询的字段可以用到联合索引，范围查询后的字段无法用到联合查询。</p></blockquote><p>联合查询的最左匹配原则会一直向右匹配直到遇到范围查询就会停止匹配。</p><p>三条语句的联合索引使用情况（条件中的字段组成联合索引）：</p><ul><li><pre><code class="mysql">select * from t_table where a &gt; 1 and b = 2<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>  在符合<span class="hljs-keyword">a</span>&gt;<span class="hljs-number">1</span>条件的二级索引记录的范围中，b字段的值是无序的。<br><br>  进行范围扫描的起始记录时符合`<span class="hljs-keyword">a</span> &gt; <span class="hljs-number">1</span>`的第一条记录。<br><br>  所以说只有<span class="hljs-keyword">a</span>字段使用到了联合索引，b字段没有。<br><br>- ```mysql<br>  select * <span class="hljs-built_in">from</span> t_table where <span class="hljs-keyword">a</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>对于a=1的二级索引记录的范围中，b字段的值是有序的。进行范围扫描的起始记录是符合`a = 1 and b = 2 `的第一条记录。a字段和b字段都用到了联合索引。</code></pre></li><li><p>&#96;&#96;&#96;mysql<br>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b &#x3D; 2</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>  在MySQL中<span class="hljs-keyword">BETWEEN</span>类似于大于等于和小于等于的查询。<br><br>- ```mysql<br>  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;j%&#x27;</span> <span class="hljs-keyword">and</span> age = <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p><code>like j%</code>形成的扫描区间是[‘j’, ‘k’]。所以说也同上面的范围查询类似。</p><p>虽然符合‘j’前缀的name字段中的二级索引记录范围中，age字段的值是无序的。但是对于符合name &#x3D; j的二级索引记录的范围里，age字段的值是有序的。</p><p>所以进行范围扫描的起始记录是<code>name = j and age = 22</code>的第一条记录。</p><p>所以这个查询语句也用到了name和age两个字段。</p><p>图示如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/q4-2.drawio.png" alt="img"></p><p>综上：</p><blockquote><p>联合索引的最左匹配原则，在遇到范围查询如（&gt;、&lt;）的时候，停止匹配剩余字段。</p><p>但是对于&gt;&#x3D;、&lt;&#x3D;、 BETWEEN、like前缀匹配的范围查询，并不会停止匹配。</p></blockquote></li></ul><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>对于联合索引（a，b），在执行<code>select * from table where a &gt; 1 and b = 2</code>语句的时候，只有a字段能使用a字段。那么在联合索引的B+Tree中找的了符合a字段条件的主键值后，如何判断b字段是否满足条件呢？</p><ul><li>在MySQL 5.6前，只能通过回表，通过主键id到主键索引中查找出数据行，再对比b字段。</li><li>在MySQL 5.6引入的<strong>索引下推优化</strong>（index condition pushdown），可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。（在查询语句的执行计划中共，Extra为Using index condition，那么说明使用了索引下推的优化）。</li></ul><h4 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h4><p>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高。在实际开发中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的SQL使用到。</p><p>区分度：某个字段column不同值得个数&#x2F;表得总行数</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E5%8C%BA%E5%88%86%E5%BA%A6.png" alt="区分度计算公式"></p><p>例如，性别的区分度很小，不适合建立索引，或不适合排在联合索引列的靠前位置。而UUID这种字段区分度就高。</p><h4 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h4><blockquote><p>因为联合索引的有序性，所以说可以利用该特性来优化有排序的查询语句。</p></blockquote><p>例如该SQL语句的优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from order where status = 1 order by create_time asc<br></code></pre></td></tr></table></figure><ul><li><p>方案一、给status建立一个索引</p><blockquote><p>在查询时，只用到status索引，还是需要对creat_time排序</p></blockquote></li><li><p>方案二、给status和create_time列建立一个联合索引</p><blockquote><p>因为在查询的时候根据statue &#x3D; 1筛选后的数据，已经是根据creat_time拍好序了的，不需要再额外执行排序操作。这样就可以避免MySQL数据库去进行排序操作。</p></blockquote></li></ul><h3 id="B-Tree索引在存储数据中的具体实现"><a href="#B-Tree索引在存储数据中的具体实现" class="headerlink" title="B+ Tree索引在存储数据中的具体实现"></a>B+ Tree索引在存储数据中的具体实现</h3><h4 id="表结构和表数据："><a href="#表结构和表数据：" class="headerlink" title="表结构和表数据："></a>表结构和表数据：</h4><p>先创建一张表，id为主键，表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `product`  (<br>  `id` int(11) NOT NULL,<br>  `product_no` varchar(20)  DEFAULT NULL,<br>  `name` varchar(255) DEFAULT NULL,<br>  `price` decimal(10, 2) DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE<br>) CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;<br></code></pre></td></tr></table></figure><p> 表数据如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/824c43b801c64e81acb0a9b042d50311.png" alt="img"></p><h4 id="行数据在在B-Tree索引中存储的结构："><a href="#行数据在在B-Tree索引中存储的结构：" class="headerlink" title="行数据在在B+ Tree索引中存储的结构："></a>行数据在在B+ Tree索引中存储的结构：</h4><blockquote><p>B+ Tree是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每一个节点中的数据是按照主键顺序存放。</p><p>每一个父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。</p></blockquote><p>主键索引的B+ Tree如图：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/btree.drawio.png" alt="主键索引 B+Tree"></p><h4 id="通过主键查询数据："><a href="#通过主键查询数据：" class="headerlink" title="通过主键查询数据："></a>通过主键查询数据：</h4><p>若我们执行了查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from product where id = 5;<br></code></pre></td></tr></table></figure><p>主键查询的查询过程如下：</p><ol><li>将5与根节点索引数据（1，10，20）比较，5在1-10之间，根据B+ Tree搜索逻辑，找到第二层（1，4，7）；</li><li>在第二层索引数据（1，4，7）中进行查找，因为5在4-7之间，所以找到第三层叶子节点数据（4，5，6）</li><li>在叶子节点数据（4，5，6）中进行查找，然后就找到了索引值为5的行数据</li></ol><p>数据的索引和数据都是存储在硬盘中。我们可以把读取一个节点当作一次磁盘I&#x2F;O操作，那么经过上面的查询进行了3次I&#x2F;O操作。</p><p>B+ Tree存储千万级的数据只需要3-4层高度，也就是说千万级的表查询也只需要3-4次的磁盘I&#x2F;O。</p><h4 id="通过二级索引查询数据："><a href="#通过二级索引查询数据：" class="headerlink" title="通过二级索引查询数据："></a>通过二级索引查询数据：</h4><p>我们将上表中的product_no字段设置为二级索引，那么该二级索引结构如下：</p><blockquote><p>叶子节点的key为product_no字段，Value为主键值id。</p></blockquote><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png" alt="二级索引 B+Tree"></p><p>若通过二级索引查询商品，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from product where product_no = &#x27;0002&#x27;;<br></code></pre></td></tr></table></figure><p>二级索引的查询过程：</p><ol><li>先根据product_no值在二级索引的B+ Tree中找到对应得叶子节点，获取主键值</li><li>在根据主键值，在主键索引得B+ Tree中查询到对应得叶子节点，获取整行数据</li></ol><p>上面这个查询过程叫做<strong>回表</strong>，也就是要查询两个B+ Tree才能查到数据。过程如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E5%9B%9E%E8%A1%A8.drawio.png" alt="回表"></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果当查询得数据能在B+ Tree得叶子节点中查询到，这个时候就不用再通过主键索引查，例如执行如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id from product where product_no = &#x27;0002&#x27;;<br></code></pre></td></tr></table></figure><p>这种在二级索引得B+ Tree就能查询到结果得过程叫做                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              <strong>覆盖索引</strong>，也就是只需要查二级索引，不需要回表操作就能找到所需数据。</p><h2 id="什么时候需要索引"><a href="#什么时候需要索引" class="headerlink" title="什么时候需要索引"></a>什么时候需要索引</h2><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>索引的最大好处时提高查询速度。但是索引也有缺点，比如：</p><ul><li>空间占用。索引需要占用物理空间，数量越大，占用空间越大。</li><li>创建和维护索引需要消耗时间。消耗的时间随着数据量的增大而增大。</li><li>降低增删改速度。因为每次增删该索引，B+树为了维护索引的有序性，需要进行动态维护。</li></ul><h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul><li>字段有唯一性限制。例如商品编码。</li><li>经常用于<code>WHERE</code>查询条件的字段。这样可以提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于<code>GROUP BY</code>和<code>ORDER BY</code>的字段。这样在查询的时候就不需要再去做一次排序了，因为再建立了索引之后B+树中的记录都是排好序了的。</li></ul><h4 id="什么时候不需要索引？"><a href="#什么时候不需要索引？" class="headerlink" title="什么时候不需要索引？"></a>什么时候不需要索引？</h4><ul><li>WHERE条件、GROUP BY、ORDER BY里用不到的字段。索引的价值是快速定位，如果起不到定位作用的字段通常是不需要创建索引的。</li><li>区分度小的字段。区分度小的字段，例如性别，无论搜索哪一个值都得到一半左右的数据。再这种情况下，还不如不使用索引，因为查询优化器发现某种值在表中的数据行出现的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引。</li><li>经常更新的字段不用创建索引。例如电商项目中的用户余额字段不要建立索引。因为若索引字段需要频繁修改，由于要维护B+树的有序性，那么就需要频繁的重建索引，这个过程会影响数据库的性能。</li></ul><h1 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h1><h2 id="为什么采用B-树作为索引"><a href="#为什么采用B-树作为索引" class="headerlink" title="为什么采用B+树作为索引"></a>为什么采用B+树作为索引</h2><h3 id="作为索引的数据结构的要求"><a href="#作为索引的数据结构的要求" class="headerlink" title="作为索引的数据结构的要求"></a>作为索引的数据结构的要求</h3><p>MySQL的数据时持久化的，也就是数据（索引+记录）是保存在磁盘上的，这样即使设备断电，数据也不会丢失。</p><p>磁盘的访问速度很慢，磁盘中读取速度比内存满上万倍。磁盘存储数据的最小单位是扇区，扇区的大小只有512B。操作系统读取数据的最小单位是块，一个块包含多个扇区。在Linux中块为4KB，也就是一次磁盘I&#x2F;O操作会读取8个扇区。</p><p>由于数据库的索引是保存到磁盘上的，所以在通过索引查找行数据的时候，需要从磁盘中读取索引到内存，再通过索引从磁盘中找到行数据，然后读入内存。也就是说在查询过程中会发生多次磁盘I&#x2F;O，而磁盘I&#x2F;O次数越多，所消耗的时间越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘I&#x2F;O操作中完成查询工作。另外，MySQL支持范围查找，所以索引的数据结构不仅要能高效地查询单条记录，也要能高效地执行范围查找。</p><p>所以适合MySQL索引的数据结构，需要满足的要求：</p><ul><li>要在尽可能少的磁盘I&#x2F;O操作中完成查询工作</li><li>要能高效的查询某一条记录，也要能高效地执行范围查找</li></ul><h3 id="数组二分查找"><a href="#数组二分查找" class="headerlink" title="数组二分查找"></a>数组二分查找</h3><p>假设使用数组存储索引，那么我们维护这个数组为有序数组，在定位数据的时候就可以使用二分查找法：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/f01bb5e7e940231c4f39e7f1cfb449f3.png" alt="图片"></p><p>这样每次查询的时间复杂度就降为O(logN)。</p><p>数组二分查找的问题：</p><p>使用数组来存储和检索线性排序的数据简单好用，但是插入新元素的时候性能太差。在插入数据的时候，需要移动该数据后面的每一个元素，而且这个操作还是发生在磁盘中。而且在使用二分查找的时候，每次查找还需要计算中间的位置。</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树的特点就是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点。</p><p>这样我们在查询数据时，不需要计算中间节点的位置，只需要将查找的数据与节点数据进行比较。并且有序二叉查找树时非线性结构，插入节点的的时候可以放在任何位置，不需要像线性结构那样移动其余元素。</p><p>二分查找树的问题：</p><p>若每次插入的元素都是二叉查找树中的最大值，二叉查找树就会退化为一条链表。每访问一个节点就对应一次磁盘I&#x2F;O操作，树的高度越高，对应I&#x2F;O操作次数越多，性能越差。并且二分查找树不能范围查询。</p><h3 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h3><p>为例解决二叉树在极端情况下退化成链表，就提出了平衡二叉查找树（AVG）。也就是在二叉查找树的基础上增加了一些条件约束：每个节点的左子树和右子树的高度差不能超过1。这样查询操作的时间复杂度就会一直维持在O（logN）。</p><p>自平衡二叉树的问题：</p><p>随着插入元素的增多，导致树的高度变高，意味着磁盘的I&#x2F;O操作次数变多，影响整体查询效率。因为自平衡二叉树本质上是一颗二叉树，每个节点只能有两个子节点，节点增多，树高曾高，磁盘I&#x2F;O次数增多。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>为例降低树的高度，就提出了B树。它不再限制节点的子节点数量，而是允许M个子节点（M &gt; 2），从而降低树的高度。M称为B树的阶，所以B树是一个多叉树。</p><p>B树的问题：</p><p>B树的每一个节点都包含数据（索引+记录）。这就导致了在查询某节点记录的时候，加载了很多非该节点的记录数据，我们需要的是索引来判断查询节点的位置，但是由于索引和数据记录是绑定在一起的，所以无用的数据记录也被加载。这就导致了磁盘I&#x2F;O次数的增多，也占用了更多的内存资源。并且B树不支持范围查询。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树在B树的基础上做了升级：</p><ul><li>只有也只节点存放实际数据（索引+记录），非叶子节点只会存放索引</li><li>所有索引都会在叶子节点出现，叶子节点之间构成一个链表</li></ul><h5 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h5><p>B+树的非叶子节点只存放索引，所以说每个非叶子节点可以存放更多的子节点，那么B+树就比B树更加矮胖，查询底层节点的磁盘I&#x2F;O会更少。</p><h5 id="插入和删除效率"><a href="#插入和删除效率" class="headerlink" title="插入和删除效率"></a>插入和删除效率</h5><p>因为数据都存储在叶子节点，B+树有大量冗余节点，这样在删除一个节点的时候，可以直接从叶子节点删除，甚至可以不用动非叶子节点。而B树因为没有冗余节点，删除节点可能涉及复杂的树变形。插入也是同理。</p><h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><p>B树和B+树的等值查询原理一致，先从根节点查找，然后对比目标数据的范围，最后递归地进入子节点查找。</p><p>因为B+树地叶子节点之间通过链表连接。当需要进行范围查找地时候，可以先从根节点开始单点查找通过边界值，然后利用链表查找范围数据，不再需要从根节点查询，这样减少了大量地I&#x2F;O。</p><h3 id="Innodb中的B-树"><a href="#Innodb中的B-树" class="headerlink" title="Innodb中的B+树"></a>Innodb中的B+树</h3><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/dd076212a7637b9032c97a615c39dcd7.png" alt="图片"></p><p>Innodb使用的B+树的一些特点：</p><ul><li>叶子节点之间使用双向链表连接</li><li>树节点的内容是数据页，数据页中存放着用户的记录以及各种信息，每个数据页默认大小为16KB</li></ul><p>Innodb根据索引类型分为：</p><ul><li>聚簇索引。叶子节点存放的是实际数据，所有完整的用户记录存放在聚簇索引的叶子节点</li><li>二级索引。叶子节点存放的是主键值，而不是实际数据</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点中，索引Innodb引擎一定会为表创建一个聚簇索引，而且由于数据只在物理上保存一根，所以聚簇索引有且仅有一个，而二级索引可以创建多个。</p><h2 id="从数据页的角度看B-树"><a href="#从数据页的角度看B-树" class="headerlink" title="从数据页的角度看B+树"></a>从数据页的角度看B+树</h2><p>记录是按行来存储的，但是数据库的读取并不是以行为单位。否则一次I&#x2F;O只读取一行数据，效率会很低。</p><p>因此，InnoDB的数据是以<strong>数据页</strong>为单位来读写的，也就是说，当需要读取一条记录的时候，并不是将这个记录本身从磁盘读取出来，而是将该记录所在页整体读入内存。</p><p>数据库I&#x2F;O操作的最小单位是页，默认数据页的大小为16KB。也就是说数据区每次I&#x2F;O最少读&#x2F;写16KB的数据。</p><h3 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h3><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/243b1466779a9e107ae3ef0155604a17.png" alt="图片"></p><p>各部分作用：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p><h4 id="File-Header（文件头）"><a href="#File-Header（文件头）" class="headerlink" title="File Header（文件头）"></a>File Header（文件头）</h4><p>File Header中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/557d17e05ce90f18591c2305871af665.png" alt="图片"></p><p> 采用链表的结构，让数据页之间不需要是物理连续的，而是逻辑连续的。</p><h4 id="Page-Directory（页目录）"><a href="#Page-Directory（页目录）" class="headerlink" title="Page Directory（页目录）"></a>Page Directory（页目录）</h4><p>数据页的作用是存储记录，所以说数据页的重点在于如何组织数据。</p><p>数据页中的记录按照主键顺序组成单向链表。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况需要遍历完链表上的所以节点才能完成检索。</p><p>因此，数据页中有一个页记录，起到记录的索引作用。就像读书时针对章节设立的目录，通过目录快速定位对应章节的页数。</p><h5 id="页目录与记录的关系："><a href="#页目录与记录的关系：" class="headerlink" title="页目录与记录的关系："></a>页目录与记录的关系：</h5><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p><h5 id="页目录的创建过程："><a href="#页目录的创建过程：" class="headerlink" title="页目录的创建过程："></a>页目录的创建过程：</h5><ol><li>将所有记录划分为几个组，这些记录包括最大记录和虽小记录，但不包括”已删除“的记录。</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为n_owned字段（图中粉色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些偏移量会按照先后顺序存储起来，每组的地址便宜量也被称为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li></ol><h5 id="通过页目录查找记录："><a href="#通过页目录查找记录：" class="headerlink" title="通过页目录查找记录："></a>通过页目录查找记录：</h5><ol><li><p>页目录由多个槽组成，槽相当于分组记录的索引；</p></li><li><p>然后，记录按照主键值从小到大排序，索引可以通过二分法快速定位要查询记录所在槽；</p></li><li><p>定位到槽后，再遍历槽内的所有记录，找到对应的记录。无需从最小记录开始遍历整页中共的所有记录。</p></li></ol><p> 因为要遍历槽内数据，所以对每个槽（分组）中记录的条数有规定：</p><ul><li>第一个分组的记录只能有一条</li><li>最后一个分组中的记录条数范围只能在1-8条之间</li><li>剩余的分组中记录条数范围只能在4-8条之间</li></ul><h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+树是如何进行查询的？"></a>B+树是如何进行查询的？</h3><p>上面说的是在数据页中的记录的检索。因为一个数据页中的记录有限，且主键值时候有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索记录所在分组，来降低检索的时间复杂度。</p><p>当我们需要存储大量的记录时，就需要大量数据页，这个时候就需要为这些数据页建立索引，用于快速定位记录所在的页。</p><p>InnoDB采用B+树作为索引。B+树中每个节点都是一个数据页，结构示意图如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p><p>B+树特点：</p><ul><li>只有也只节点存放数据，非叶子节点仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量。</li><li>所有节点按照索引键的大小排序，构成一个双向链表，便于范围查询</li></ul><p>B+树搜索主键为6的记录的过程：</p><ol><li>从根节点，通过二分法快速定位到符合页内范围包含查询值得页。因为6在[1, 7)之间，所以到页30中查找；</li><li>在非叶子节点中，递归查找，主键值大于5，所以到叶子节点（页16）中查找</li><li>在叶子节点中，根据页目录定位记录所在槽，单位到槽后，遍历槽内记录，找到主键为6的记录</li></ol><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="一、前缀索引优化"><a href="#一、前缀索引优化" class="headerlink" title="一、前缀索引优化"></a>一、前缀索引优化</h2><blockquote><p>使用某字段中字符串的前几个字符建立索引。</p></blockquote><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引个数，降低树的高度，有效的提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>前缀索引的局限性：</p><ul><li>order by无法使用前缀索引</li><li>无法把前缀索引用作覆盖索引</li></ul><h2 id="二、覆盖索引优化"><a href="#二、覆盖索引优化" class="headerlink" title="二、覆盖索引优化"></a>二、覆盖索引优化</h2><blockquote><p>使用作为联合索引的字段覆盖查询语句中的所有字段。避免回表操作。</p></blockquote><p>当在二级索引的叶子节点中能找到查询语句中所需要的字段，那么就不需要再通过聚簇索引查询完整行记录来获取需要的字段。</p><p>例如查询商品的名称、价格，如何避免回表？</p><p>我们可以建立一个联合索引，即（商品ID、名称、价格）作为联合索引，索引中存在名称和价格字段，查询语句需要的字段可以直接在二级索引中获取，不需要再通过主键索引，避免了回表，减少了I&#x2F;O操作。</p><h2 id="三、主键索引自增"><a href="#三、主键索引自增" class="headerlink" title="三、主键索引自增"></a>三、主键索引自增</h2><blockquote><p>主键索引设置为自增，这样可以避免页分裂。</p></blockquote><p>InnoDB创建主键索引默认为聚簇索引，数据被存放到B+Tree的叶子节点上。也就是说，同一叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据被插入，数据库会根据主键将其插入对应的叶子节点中。</p><p>若使用自增主键：</p><p>每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当该叶子节点页写满后，会自动开辟一个新页面。因为每次插入一条新记录都是追加操作，不需要移动已有数据，因此插入的效率很高。</p><p>若不使用自增主键：</p><p>每次插入主键的索引值都是随机的，因此插入新的数据，可能会插入到现有数据页中间的位置，这样的话就需要移动其他数据来满足新数据的插入，甚至如果该页没有剩余空间，还需要从一个页面复制数据到另一个页面，我们称这种情况为<strong>页分裂</strong>。页分裂可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p><p><strong>此外需要注意：</strong>主键字段的长度不要太大。因为二级索引叶子节点存储的数据是主键字段值，所以说主键长度越短，二级索引占用的空间也就越小</p><h2 id="四、索引设置为NOT-NULL"><a href="#四、索引设置为NOT-NULL" class="headerlink" title="四、索引设置为NOT NULL"></a>四、索引设置为NOT NULL</h2><p>为了更好地利用索引，索引类要设置NOT NULL约束，原因如下：</p><ul><li>索引列存在NULL会使优化器做索引选择的时候更复杂，更难优化。因为可为NULL的列会使索引、索引统计和值比较都更复杂，比如进行索引统计的时候，count会省略值为NULL的行。</li><li>NULL值没有意义，但占用物理空间。允许为NULL会带来存储空间占用的问题。</li></ul><h2 id="五、防止索引失效"><a href="#五、防止索引失效" class="headerlink" title="五、防止索引失效"></a>五、防止索引失效</h2><p>常见索引失效场景：</p><ul><li>左模糊匹配</li><li>对索引列进行计算、函数、类型转换</li><li>没有遵循最左匹配原则</li><li>WHERE子句中，OR前条件为索引列，OR后条件不是索引列</li></ul><h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><p>可以使用使用explain来查看查询语句的执行计划，如图：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/798ab1331d1d6dff026e262e788f1a28.png" alt="img"></p><p>执行计划中的参数：</p><ul><li>type：数据扫描类型（重点关注）</li><li>possible_key：表示可能用到的索引</li><li>key：实际用到的索引</li><li>key_len：索引的长度</li><li>rows：预估扫描的数据行数</li></ul><h2 id="type参数"><a href="#type参数" class="headerlink" title="type参数"></a>type参数</h2><blockquote><p>type字段描述了找到所需数据时使用的扫描方式是什么。</p></blockquote><p>常见的扫描类型（根据执行效率从低到高排序）：</p><ul><li>ALL（全表扫描）</li><li>index（全索引扫描）</li><li>range（索引范围扫描）</li><li>ref（非唯一索引扫描）</li><li>eq_ref（唯一索引扫描）</li><li>const（结果只有一条的主键或唯一索引扫描）</li></ul><h3 id="index和all"><a href="#index和all" class="headerlink" title="index和all"></a>index和all</h3><p>二者差不多，all采用全表扫描。而index是对索引表进行全扫描，比all好在不需要再对数据进行排序，但是开销依然很大。所以要尽量避免全表扫描和全索引扫描。</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>range表示采用索引范围扫描，一般再WHERE子句中使用&lt;、&gt;、in、between等关键字，只检索给定范围的行，属于范围查找。</p><p>从这一几倍开始，索引的作用会越来越明显，因此我们要尽量让SQL查询可以使用到range这一级别及以上的type访问方式。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref类型标识采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据可能是多条。因为使用了索引，但该索引列的值并不唯一，有重复，这样即使使用索引快速找到了第一条符合条件的数据，但仍不能停止，要进行目标值附件的小范围扫描。但是它的好处是它只需要在一个很小的范围内扫描，因为索引是有序的。</p><h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>eq_ref类型是使用主键或唯一索引产生的访问方式，通常使用在多表联查中。</p><p>比如，对两张表进行联查，关联条件是两张表的user_id相等，且user_id是唯一索引，那么使用EXPLAIN进行执行计划查看的时候，type就会显式eq_ref。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const类型表示使用了主键或唯一索引与常量值进行比较，例如<code>select name from product where id = 1</code>。</p><p>const和eq_ref都使用了主键或唯一索引，不过这两个类型有所区别：const是与常量进行比较，查询效率更快，而eq_ref通常用于多表联查中。</p><h2 id="extra参数"><a href="#extra参数" class="headerlink" title="extra参数"></a>extra参数</h2><p>extra中的几个重要参考指标：</p><ul><li><p>Using filesort（使用排序算法）</p><blockquote><p>当查询语句中包含group by操作，而且无法利用索引完成排序操作的时候，这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率很低，所以要避免这种问题的出现。</p></blockquote></li><li><p>Using tmporary（使用临时表）</p><blockquote><p>使用了临时表保存中间结果，MySQL在对查询结果进行排序时使用临时表，常见于排序order by和分组查询group by。效率低，要避免这种问题的出现。</p></blockquote></li><li><p>Using index（使用索引覆盖）</p><blockquote><p>所需的数据只需在索引即可全部获得，无须再到表中去数据，也就是使用了索引覆盖，避免了回表操作，效率不错。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>MySQL原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-select语句的执行过程</title>
    <link href="/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>MySQL执行一条查询语句的流程：</p><p><img src="/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><p>MySQL的架构分为两层：</p><ul><li><p>Server层：负责建立连接、分析和执行SQL</p><blockquote><p>核心模块：连接器、查询缓存、解析器、预处理器、优化器、执行器</p><p>实现内置函数：时间、日期、数学、加密函数</p><p>实现跨存储引擎的功能：存储过程、触发器、视图</p></blockquote></li><li><p>存储引擎层：负责数据的存储和提取</p><blockquote><p>MySQL的存储引擎：InnoDB、MyISAM、Memory</p><p>不同存储引擎共用一个Server层。</p><p>索引的数据结构在存储引擎层实现，不同引擎支持的索引类型也不同。</p></blockquote></li></ul><h1 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h1><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><blockquote><p>MySQL连接的过程需要TCP三次握手，因为MySQL是基于TCO协议进行传输。</p></blockquote><p>命令行连接MySQL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-u 指定用户名，管理员角色名为 root；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span><br>mysql -h$ip -u$user -p<br></code></pre></td></tr></table></figure><p>关于用户的权限：</p><p>如果用户名和密码都没有问题，那么连接器就会获取用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限的验证。所以，如果一个用户已经建立一个连接，在中途管理员修改了该用户的权限，也不会影响已经存在的连接的权限。</p><h2 id="连接的管理"><a href="#连接的管理" class="headerlink" title="连接的管理"></a>连接的管理</h2><h3 id="查看连接数量"><a href="#查看连接数量" class="headerlink" title="查看连接数量"></a>查看连接数量</h3><p>在登录MySQL服务器后，使用<code>show processlist</code>命令</p><p><img src="/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png" alt="img"></p><p>Command列表示连接的状态，Sleep状态的Time列表示其空闲的时长</p><h3 id="空闲连接的断开"><a href="#空闲连接的断开" class="headerlink" title="空闲连接的断开"></a>空闲连接的断开</h3><ul><li><p>MySQL自动断开：</p><blockquote><p>MySQL定义了空闲连接的最大空闲时长，由<code>wait_timeout</code>参数控制，默认8小时，若超过  该是时长，连接器会自动断开连接。</p></blockquote></li><li><p>手动断开：</p><blockquote><p>使用<code>kill connection + id</code>的命令，可以主动断开连接</p></blockquote></li></ul><p>一个连接被服务器断开后，客户端并不会马上感知到，只有等客户端再发起下一个请求的时候才会报错。</p><h3 id="连接数量限制"><a href="#连接数量限制" class="headerlink" title="连接数量限制"></a>连接数量限制</h3><p>MySQL服务支持的最大连接数由<code>max_connection</code>参数控制。</p><h3 id="MySQL长连接"><a href="#MySQL长连接" class="headerlink" title="MySQL长连接"></a>MySQL长连接</h3><blockquote><p>MySQL也和HTTP一样，有长连接和短链接的概念。</p></blockquote><p><strong>使用长连接的好处：</strong></p><p>使用长连接可以减少建立连接和断开连接的过程</p><p><strong>使用长连接的问题：</strong></p><p>使用长连接后可能会占用内存增多。因为MySQL在执行查询过程中临时使用内存管理连接对象，这些连接对象只有在连接断开的时候才会释放。如果长连接累计很多，将导致MySQL服务器占用内存过大，可能会被系统强制回收，导致MySQL服务器异常重启。</p><p><strong>长连接内存占用问题的解决：</strong></p><ul><li><p>方法一、服务器定时断开长连接</p></li><li><p>方法二、客户端主动重置连接</p><blockquote><p>客户端在执行了一个很大的操作过后，在代码中调用<code>mysql_reset_connection</code>函数来重置连接，达到释放内存的效果。重置连接不需要重连和重新做权限验证，只是将连接恢复至刚刚创建时的状态。</p></blockquote></li></ul><h2 id="连接器工作总结"><a href="#连接器工作总结" class="headerlink" title="连接器工作总结"></a>连接器工作总结</h2><ul><li>与客户端进行TCP三次握手建立连接</li><li>验证用户名和密码，若错误，则报错</li><li>用户名和密码都正确，会读取用户的权限并保存，用于该连接后续的权限逻辑判断</li></ul><h1 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a><del>第二步：查询缓存</del></h1><blockquote><p>MySQL 8.0后的版本已经将查询缓存删掉了。</p><p>查询缓存属于Server层，移除的是Server层的查询缓存，而不是Innodb存储引擎的buffer pool。</p></blockquote><p>查询缓存的执行步骤：</p><ol><li><p>连接器工作完成后，客户端可以向MySQL发送SQL语句，MySQL服务器在收到SQL语句后，就会解析SQL语句的额第一个字段，看看是什么类型的语句。</p></li><li><p>若是查询语句，MySQL则会先去查询缓存中找是否有这条语句执行后的缓存数据。查询缓存是以Key-Value的形式保存在内存中，Key为SQL查询语句，Value为SQL语句查询结果。</p></li><li><p>若查询的语句命中查询缓存，那么就直接返回value给客户端，若没有命中，则继续执行查询流程，执行完后，将查询结果缓存。</p></li></ol><p>查询缓存被抛弃的原因：</p><p>对于更新比较频繁的表，查询缓存的命中率很低，因为只要有一个表有更新，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用，刚好这个表就有更新操作了，那么这个缓存还没被使用过就被清空了。</p><h1 id="第三步：解析SQL"><a href="#第三步：解析SQL" class="headerlink" title="第三步：解析SQL"></a>第三步：解析SQL</h1><p>在执行SQL查询语句之前，MySQL会对SQL语句做解析，由<strong>解析器</strong>完成。</p><ol><li><p>词法分析</p><blockquote><p>MySQL会根据输入的SQL语句识别关键字，构建出SQL语法树，这样方便后面的模块获取SQL类型、表名、字段名、where条件等。</p></blockquote></li><li><p>语法分析</p><blockquote><p>根据词法分析的结果，语法解析器会根据语法规则，判断这个SQL语句是否满足MySQL语法。</p></blockquote></li></ol><p>在这个阶段会检测拼写错误和语法错误，而表和字段是否存在的判断不是在解析器中完成的。</p><h1 id="第四步：执行SQL"><a href="#第四步：执行SQL" class="headerlink" title="第四步：执行SQL"></a>第四步：执行SQL</h1><p>执行分为三个阶段：</p><ol><li><p>prepare阶段，预处理</p></li><li><p>optimize阶段，优化</p></li><li><p>execute阶段，执行</p></li></ol><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>预处理器的工作：</p><ul><li><p>检查SQL查询语句中的表或字段是否存在。</p></li><li><p>将<code>select *</code> 中的<code>*</code>符号，拓展为表上的所有列。</p></li></ul><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过预处理阶段后，需要为SQL查询语句制定的一个<strong>执行计划</strong>。</p><p>执行计划的制定由优化器完成，优化器基于查询成本考虑会选择成本最低的方案（主要是索引的选择）。</p><p>explain命令：</p><blockquote><p>在查询语句前面加个explain命令，就会输出这条查询语句的执行计划（注意只是计划，而不是真正执行这条语句）。</p></blockquote><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>经过优化器优化，确定了执行计划，接下来就要真正开始执行语句了。</p><p>执行计划的执行由执行器完成，在执行过程中，执行器会和存储引擎交互，交互是以记录为单位。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>MySQL原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。</p><p>使用设计者模式的<strong>目的</strong>：</p><ul><li>为了实现软件开发的可维护、可扩展</li><li>尽量复用代码</li><li>降低代码的耦合度</li></ul><p>设计模式主要是基于OOP编程提炼的，它基于以下几个<strong>原则</strong>：</p><ul><li><p>开闭原则</p><blockquote><p>软件应对扩展开放，而对修改关闭。</p><p>具体指的是，在增加新功能的时候，最好不要通过修改原有代码来增加功能，而是通过增加新的代码来完成新的功能。</p></blockquote></li><li><p>里氏替换原则</p><blockquote><p>如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行</p></blockquote></li></ul><p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计地复杂度和灵活性，并意识到设计模式并不是完成的。</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>关注点：如何创建对象。</p><p>核心思想：要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p><h2 id="1-工厂方法（Factory-Method）"><a href="#1-工厂方法（Factory-Method）" class="headerlink" title="1. 工厂方法（Factory Method）"></a>1. 工厂方法（Factory Method）</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。</p></blockquote><h3 id="Number工厂方法"><a href="#Number工厂方法" class="headerlink" title="Number工厂方法"></a>Number工厂方法</h3><p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品。</p><p>以解析String到Number的工厂为例，解释工厂方法。</p><p>Number工厂定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象工厂：NumberFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-comment">//抽象产品：Number</span><br>    Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span>;<br>&#125;<br><span class="hljs-comment">//实际工厂：NumberFactoryImpl</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//实际产品；BigDecimal</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端获取实际工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在抽象工厂接口中定义一个静态方法getFactory来获取真正的工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-comment">// 创建方法:</span><br>    Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span>;<br><br>    <span class="hljs-comment">// 获取工厂实例:</span><br>    <span class="hljs-keyword">static</span> NumberFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> impl;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">NumberFactory</span> <span class="hljs-variable">impl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFactoryImpl</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在客户端中，只需要和工厂接口NumberFactory和抽象产品交互：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NumberFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> NumberFactory.getFactory();<br><span class="hljs-type">Number</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> factory.parse(<span class="hljs-string">&quot;123.456&quot;</span>);<br></code></pre></td></tr></table></figure><p>调用方可以完全忽略真正的工厂和实际的产品，这样即使创建产品的代码变化也不会影响到调用方。</p><h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><blockquote><p>很多时候我们不需要抽象工厂，而是直接通过工厂类的静态方法来返回产品</p></blockquote><p>去掉抽象工厂接口后的静态工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java标准库中就有很多静态工厂方法设计的类，比如Integer和List。</p><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><p>Integer即是产品又是静态工厂。它提供了静态方法valueOf()来创建Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缓存优化：</strong></p><p>使用Integer.valueOf()和new Integer()之间的区别：</p><ul><li><p>使用new来获取一个Integer一定是新建一个对象。</p></li><li><p>而使用valueOf()来获取一个对象，工厂方法可以选择new一个新的Integer，也可以返回一个缓存的Integer。这样就可以避免创建过多重复的Integer对象。因为对于调用方而言，它不关心Integer的创建细节。</p></li></ul><p>工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p><h4 id="lIST"><a href="#lIST" class="headerlink" title="lIST"></a>lIST</h4><p>这个静态工厂方法接收可变参数，然后返回List接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意：调用方获取的产品总是List接口，而且并不关心它的实际类型（里氏替换原则）。</p><h2 id="2-抽象工厂（Abstract-Factory）"><a href="#2-抽象工厂（Abstract-Factory）" class="headerlink" title="2. 抽象工厂（Abstract Factory）"></a>2. 抽象工厂（Abstract Factory）</h2><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></blockquote><p>抽象工厂模式和工厂方法不太一样，它需要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建。因此这个抽象工厂会对应到多个实际工厂，而每个实际工厂负责创建多个实际产品。</p><p>关系示意图如下：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030102323353.png" alt="image-20221030102323353"></p><p>这种模式有点类似于多个供应商提供一系列类型的产品。</p><p>举个例子，我们希望位用户提供一个Markdown文本转HTML和Word的服务，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象工厂接口：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-comment">// 创建Html文档:</span><br>    HtmlDocument <span class="hljs-title function_">createHtml</span><span class="hljs-params">(String md)</span>;<br>    <span class="hljs-comment">// 创建Word文档:</span><br>    WordDocument <span class="hljs-title function_">createWord</span><span class="hljs-params">(String md)</span>;<br>&#125;<br><br><span class="hljs-comment">//抽象产品接口：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HtmlDocument</span> &#123;<br>    String <span class="hljs-title function_">toHtml</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WordDocument</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面只是定义了接口，对于用户而言，只需要接触上面的接口。具体的实现比较困难，由供应商来完成。</p><p>供应商FastDoc Soft的产品便宜，并且转换速度快。供应商GoodDoc Soft的产品贵，但是转换效果好。我们可以同时使用这两家供应商的产品，以便给免费用户和付费用户提供差异化的服务。</p><p>FaseDoc Soft的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实际的产品</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastHtmlDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HtmlDocument</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toHtml</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastWordDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WordDocument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ...<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实际的工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> HtmlDocument <span class="hljs-title function_">createHtml</span><span class="hljs-params">(String md)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastHtmlDocument</span>(md);<br>    &#125;<br>    <span class="hljs-keyword">public</span> WordDocument <span class="hljs-title function_">createWord</span><span class="hljs-params">(String md)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastWordDocument</span>(md);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用Fast Doc的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建AbstractFactory，实际类型是FastFactory:</span><br><span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastFactory</span>();<br><span class="hljs-comment">// 生成Html文档:</span><br><span class="hljs-type">HtmlDocument</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> factory.createHtml(<span class="hljs-string">&quot;#Hello\nHello, world!&quot;</span>);<br>html.save(Paths.get(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;fast.html&quot;</span>));<br><span class="hljs-comment">// 生成Word文档:</span><br><span class="hljs-type">WordDocument</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> factory.createWord(<span class="hljs-string">&quot;#Hello\nHello, world!&quot;</span>);<br>word.save(Paths.get(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;fast.doc&quot;</span>));<br></code></pre></td></tr></table></figure><p>如果客户端要调用不同的服务，只需要把new FastFactory换成new其他的实际工厂即可。</p><p>如果将获取实际工厂的代码封装到AbstractFactory中，那么在客户端则可以和实际工厂完全解耦，要调用不同的服务只需要不同过的名字即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建AbstractFactory，实际类型是FastFactory:</span><br><span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> FastFactory.createFactory(<span class="hljs-string">&quot;fast&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractFactory <span class="hljs-title function_">createFactory</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (name.equalsIgnoreCase(<span class="hljs-string">&quot;fast&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.equalsIgnoreCase(<span class="hljs-string">&quot;good&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GoodFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid factory name&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-生成器-Builder"><a href="#3-生成器-Builder" class="headerlink" title="3. 生成器(Builder)"></a>3. 生成器(Builder)</h2><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>生成器模式是使用多个“小型”工厂来最终创建出一个完成对象。当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p><h3 id="Markdown转HTML"><a href="#Markdown转HTML" class="headerlink" title="Markdown转HTML"></a>Markdown转HTML</h3><p>如果说是针对以下一行文本的转换，使用一个转换器即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markd"># this is a heading<br></code></pre></td></tr></table></figure><p>如果将整个Markdown文档转HTML看作一行一行的转换，每一行根据语法，调用不同的转换器：</p><ul><li>#开头，使用HeadingBuilder转换</li><li>&gt;开头，使用QuoteBuilder转换</li><li>—开头，使用HrBuider转换</li><li>其余使用ParagraphBuilder转换</li></ul><p>HtmlBuider写出来如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HtmlBuilder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HeadingBuilder</span> <span class="hljs-variable">headingBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeadingBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HrBuilder</span> <span class="hljs-variable">hrBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HrBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ParagraphBuilder</span> <span class="hljs-variable">paragraphBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParagraphBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">QuoteBuilder</span> <span class="hljs-variable">quoteBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuoteBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toHtml</span><span class="hljs-params">(String markdown)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">//读取每一行，根据不同的语法，调用不同的子Builder</span><br>        markdown.lines().forEach(line -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;#&quot;</span>)) &#123;<br>                buffer.append(headingBuilder.buildHeading(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;&gt;&quot;</span>)) &#123;<br>                buffer.append(quoteBuilder.buildQuote(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;---&quot;</span>)) &#123;<br>                buffer.append(hrBuilder.buildHr(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                buffer.append(paragraphBuilder.buildParagraph(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们只需要针对每一种类型编写对应的Builder，如果需要修改或增加一种语法，只需要修改或增加一个Builder即可，不需要对整个HtmlBuilder进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeadingBuilder</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">buildHeading</span><span class="hljs-params">(String line)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (line.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            n++;<br>            line = line.substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;&lt;h%d&gt;%s&lt;/h%d&gt;&quot;</span>, n, line.strip(), n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，使用Builder模式，适用于创建比较复杂的对象，先一步一步构造出零件，最后再将零件组装成一个整体对象。</p><h3 id="MimeMessage"><a href="#MimeMessage" class="headerlink" title="MimeMessage"></a>MimeMessage</h3><p>JavaMail的MimeMessage就可以看作是一个Builder模式，只不过它既是Builder也是最终产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 构造产品</span><br><span class="hljs-type">Multipart</span> <span class="hljs-variable">multipart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMultipart</span>();<br><span class="hljs-comment">// 添加text:</span><br><span class="hljs-type">BodyPart</span> <span class="hljs-variable">textpart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeBodyPart</span>();<br>textpart.setContent(body, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>multipart.addBodyPart(textpart);<br><span class="hljs-comment">// 添加image:</span><br><span class="hljs-type">BodyPart</span> <span class="hljs-variable">imagepart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeBodyPart</span>();<br>imagepart.setFileName(fileName);<br>imagepart.setDataHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayDataSource</span>(input, <span class="hljs-string">&quot;application/octet-stream&quot;</span>)));<br>multipart.addBodyPart(imagepart);<br><br><span class="hljs-comment">// 2. 发送邮件</span><br><span class="hljs-type">MimeMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMessage</span>(session);<br><span class="hljs-comment">// 设置发送方地址:</span><br>message.setFrom(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InternetAddress</span>(<span class="hljs-string">&quot;me@example.com&quot;</span>));<br><span class="hljs-comment">// 设置接收方地址:</span><br>message.setRecipient(Message.RecipientType.TO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternetAddress</span>(<span class="hljs-string">&quot;xiaoming@somewhere.com&quot;</span>));<br><span class="hljs-comment">// 设置邮件主题:</span><br>message.setSubject(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">// 设置邮件内容为multipart:</span><br>message.setContent(multipart);<br></code></pre></td></tr></table></figure><h3 id="链式调用的构造器"><a href="#链式调用的构造器" class="headerlink" title="链式调用的构造器"></a>链式调用的构造器</h3><p>很多时候，可以简化Builder模式，以链式调用的方式来创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>builder.append(secure ? <span class="hljs-string">&quot;https://&quot;</span> : <span class="hljs-string">&quot;http://&quot;</span>)<br>       .append(<span class="hljs-string">&quot;www.liaoxuefeng.com&quot;</span>)<br>       .append(<span class="hljs-string">&quot;/&quot;</span>)<br>       .append(<span class="hljs-string">&quot;?t=0&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> builder.toString();<br></code></pre></td></tr></table></figure><p>例如构造URL字符串，可以适用Builder模式编写URLBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> URLBuilder.builder() <span class="hljs-comment">// 创建Builder</span><br>        .setDomain(<span class="hljs-string">&quot;www.liaoxuefeng.com&quot;</span>) <span class="hljs-comment">// 设置domain</span><br>        .setScheme(<span class="hljs-string">&quot;https&quot;</span>) <span class="hljs-comment">// 设置scheme</span><br>        .setPath(<span class="hljs-string">&quot;/&quot;</span>) <span class="hljs-comment">// 设置路径</span><br>        .setQuery(Map.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;K&amp;R&quot;</span>)) <span class="hljs-comment">// 设置query</span><br>        .build(); <span class="hljs-comment">// 完成build</span><br></code></pre></td></tr></table></figure><h2 id="4-原型（Prototype）"><a href="#4-原型（Prototype）" class="headerlink" title="4. 原型（Prototype）"></a>4. 原型（Prototype）</h2><blockquote><p>用原型实例指定创建对象的类型，并且通过拷贝这些原型创建新的对象。</p></blockquote><p>JDK中的原型模式：</p><p>如果我们已经有一个String[]数组，想要再创建一个一摸一样的String[]数组该如何实现？</p><p>实际上创建过程很简单，创建一个同样大小的新数组，然后将数组元素一一复制到新数组即可。如果我们将这个过程封装一下，那么就是原型模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原型:</span><br>String[] original = &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span> &#125;;<br><span class="hljs-comment">// 新对象:</span><br>String[] copy = Arrays.copyOf(original, original.length);<br></code></pre></td></tr></table></figure><p>Object的clone() 方法：</p><p>对于一个普通类，要实现原型的拷贝，可以通过Object提供的clone()方法，需要实现一个Cloneable接口标记来标识对象是“可复制的”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-comment">// 复制新对象并返回:</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        std.id = <span class="hljs-built_in">this</span>.id;<br>        std.name = <span class="hljs-built_in">this</span>.name;<br>        std.score = <span class="hljs-built_in">this</span>.score;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>clone()方法的缺点：</p><p>因为clone()的方法签名是在Object中，返回的类型也是Object，所以需要强制转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">std1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>std1.setId(<span class="hljs-number">123</span>);<br>std1.setName(<span class="hljs-string">&quot;Bob&quot;</span>);<br>std1.setScore(<span class="hljs-number">88</span>);<br><span class="hljs-comment">// 复制新对象:</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">std2</span> <span class="hljs-operator">=</span> (Student) std1.clone();<span class="hljs-comment">//clone得到是Object对象，需要强制转型</span><br>System.out.println(std1);<br>System.out.println(std2);<br>System.out.println(std1 == std2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>所以说使用原型模式的更好方法是定义一个copy()方法，返回明确的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        std.id = <span class="hljs-built_in">this</span>.id;<br>        std.name = <span class="hljs-built_in">this</span>.name;<br>        std.score = <span class="hljs-built_in">this</span>.score;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给拎一个对象共享的。只有存储简单类型的“值”对象可以复制。</p><h2 id="5-单例"><a href="#5-单例" class="headerlink" title="5. 单例"></a>5. 单例</h2><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote><h3 id="单例创建与获取"><a href="#单例创建与获取" class="headerlink" title="单例创建与获取"></a>单例创建与获取</h3><p>如何创建单例：</p><p>因为这个类只有一个实例，一次不能通过new来创建实例。所以，单例的构造方法必须是private，这样就防止调用方通过new来创建实例，但是再类的内部，可以用一个静态字段来引用唯一创建的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何获取单例：</p><ul><li><p>对外提供一个静态方法，直接放回实例</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 通过静态方法返回实例:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>直接把static变量暴露给外部</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>综上，单例模式的实现只需要如下操作：</p><ul><li>只有private构造方法，确保外部无法实例化；</li><li>通过private static变量持有唯一实例，确保全局唯一性；</li><li>通过public static方法返回此唯一实例，使外部调用方能获取到实例。</li></ul><h3 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h3><h4 id="延迟加载单例的实现"><a href="#延迟加载单例的实现" class="headerlink" title="延迟加载单例的实现"></a>延迟加载单例的实现</h4><p>延迟加载，即在调用方第一次调用getInstance()时才初始化全局唯一实例，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在多线程中，上面这种写法是错误的，在多线程竞争中会创建多个实例，必须对整个方法加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>加锁严重影响性能，可以使用双重检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Java内存模型的重排序，上面的双重检查会导致实例还未初始化完成，引用就被暴露，还需要使用volatile修饰单例变量。要实现线程安全的延时加载，可以通过Java的ClassLoader机制完成。</p><p>如果没有特殊需求，使用Singleton模式的时候，最好不要使用延迟加载，这样更简单。</p><h4 id="通过枚举类的实现"><a href="#通过枚举类的实现" class="headerlink" title="通过枚举类的实现"></a>通过枚举类的实现</h4><p>因为Java保证枚举类的每个枚举都是单例，所以编写一个只有一个枚举的类即可实现单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">World</span> &#123;<br>    <span class="hljs-comment">// 唯一枚举:</span><br>INSTANCE;<br>    <br><span class="hljs-comment">//枚举类可以定义自己的字段、方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;world&quot;</span>;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> World.INSTANCE.getName();<br></code></pre></td></tr></table></figure><p>枚举实现单例模式还避免了第一种方法实现单例模式的一个潜在问题：即序列化和反序列化会绕过普通类的private构造方法从而创建多个实例。而枚举类就没有这个问题。</p><h4 id="通过约定实现"><a href="#通过约定实现" class="headerlink" title="通过约定实现"></a>通过约定实现</h4><p>何时使用Singleton？</p><p>实际上，很多应用程序，尤其是Web程序，大部分服务类都应该被视作Singleton。</p><p>如果全部都按照Singleton的写法来实现这些服务会很麻烦，所以，通常 通过约定让框（例如Spring）来实例化这些类，让框架来保证只有一个实例，调用方自觉通过框架获取实例，而不是new操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 表示一个单例组件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，除非确实有必要，否则Singleton模式一般以“约定”为主，不会可以去实现它。</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式主要设计如何组合各种对象以便获得更好、更灵活得结构。</p><p>虽然面向对象得继承机制提供了最基本得子类扩展父类得功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p><h2 id="6-适配器（Adapter）"><a href="#6-适配器（Adapter）" class="headerlink" title="6. 适配器（Adapter）"></a>6. 适配器（Adapter）</h2><blockquote><p>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>如果一个接口需要B接口，但是传入的对象缺是A接口，需要如何解决？</p><p>例如：我们已有一个Task类，实现了Callable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Long&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> num;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> &#123;<br>        <span class="hljs-built_in">this</span>.num = num;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; n &lt;= <span class="hljs-built_in">this</span>.num; n++) &#123;<br>            r = r + n;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + r);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若我们想通过一个线程去执行它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-number">123450000L</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(callable); <span class="hljs-comment">// compile error!</span><br>thread.start();<br></code></pre></td></tr></table></figure><p>上面的代码无法编译，因为Thread接收Runable接口，不能接收Callable接口。怎么解决？</p><p>方法一、改写Task类，把实现Callable接口改为Runable接口。</p><blockquote><p>这样做可以让Thread这儿的代码正常运行，但是Task在其他地方可能正作为Callable被引用，改写Task的接口会导致其他正常工作的代码无法编译。即牵一发而动全身。</p></blockquote><p>方法二、不改写Task类，而是用一个新建一个Adapter类来包装Task</p><blockquote><p>首先，Adapter实现Runable接口，作为参数传入Thread</p><p>然后，Adapter通过持有Task实例，实际的方法调用是调用被Adapter包装的Task</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-number">123450000L</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>(callable));<br>thread.start();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 引用待转换接口:</span><br>    <span class="hljs-keyword">private</span> Callable&lt;?&gt; callable;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RunnableAdapter</span><span class="hljs-params">(Callable&lt;?&gt; callable)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callable = callable;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现指定接口:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 将指定接口调用委托给转换接口调用:</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            callable.call();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java标准库中适配器模式的应用：</p><ul><li><p>List[] Arrays.asList(T[])</p><blockquote><p>若我们持有一个String[]，但是需要的是List接口，则可以通过一个Adapter来转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;Good&quot;</span>, <span class="hljs-string">&quot;morning&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>&#125;;<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(exist));<br></code></pre></td></tr></table></figure><p>List[] Arrays.asList([])就相当于一个转换器，可以把数组转换为List</p></blockquote></li><li><p>InputStreamReader</p><blockquote><p>若我们持有一个InputStream，但是希望调用readText(Reader)方法，需要的是一个Reader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> Files.newInputStream(Paths.get(<span class="hljs-string">&quot;/path/to/file&quot;</span>));<br><span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(input, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>readText(reader);<br></code></pre></td></tr></table></figure><p>InputStreamReader就是Java标准库提供的Adapter，它负责将InputStream适配为Reader</p></blockquote></li></ul><p>面向抽象编程原则（面向抽象编程）：</p><p>如果上面的readText(Reader)方法参数从Reader改为FileReader，那么我们需要将InputStream适配为FileReader，直接使用inputStreamReader进行转换得到的是Reader，无法使用，这个时候就会跟麻烦。所以说，我们需要面向抽象编程，持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类型，想要做一些改动就会很困难。</p><h2 id="7-桥接（Bridge）"><a href="#7-桥接（Bridge）" class="headerlink" title="7. 桥接（Bridge）"></a>7. 桥接（Bridge）</h2><blockquote><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p></blockquote><p>假设某汽车厂商生产三个品牌地汽车：Big、Tiny和Boss，每个品牌又可以选择燃油、纯电和混合动力。</p><p>若使用传统的继承来表示最终车型，则有三个抽象类和九个最终子类：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030184005805.png" alt="image-20221030184005805"></p><p>若要新增一个品牌，或新增新引擎的车（比如核动力），那么子类的数量增长更快。</p><p>桥接模式就是为了避免直接继承带来的子类数量暴增问题。</p><p>桥接模式的解决办法：</p><ul><li><p>首先把Car按品牌进行子类化，但是每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br> <span class="hljs-comment">// 引用Engine:</span><br> <span class="hljs-keyword">protected</span> Engine engine;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Engine engine)</span> &#123;<br>     <span class="hljs-built_in">this</span>.engine = engine;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>紧接着，在一个“修正”的抽象类RefindeCar中定义一些额外操作：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RefinedCar</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">super</span>(engine);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.engine.start();<br>        System.out.println(<span class="hljs-string">&quot;Drive &quot;</span> + getBrand() + <span class="hljs-string">&quot; car...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getBrand</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>最终，不同品牌的继承自RefinderCar。不同的引擎继承自Engine</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RefinedCar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BossCar</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">super</span>(engine);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBrand</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Boss&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HybridEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Start Hybrid Engine...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>客户端通过自己选择一个品牌，在配合一种引擎，得到最终的Car：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RefinedCar</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BossCar</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HybridEngine</span>());<br>car.drive();<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>桥接模式的好处在于，如果要增加一种引擎，只需要针对Engine派生一个新的子类，如果需要增加一个品牌，只需要针对RefindedCar派生一个子类。任何RefindedCar的子类和任何Engine都可以自由组合，即一辆车的两个维度：品牌和引擎都可以独立地变化。</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030185415196.png" alt="image-20221030185415196"></p><p>桥接模式实现比较复杂，实际应用也非常少，但是它提供的设计思想值得借鉴，即：</p><p><strong>不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</strong></p><h2 id="8-组合（Composite）"><a href="#8-组合（Composite）" class="headerlink" title="8. 组合（Composite）"></a>8. 组合（Composite）</h2><blockquote><p>将对象组合成树形结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><p>组合模式经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p><p>以XML的树形表示为例：</p><p>在XML或HTML中，从根节点开始，每个节点都能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。</p><p>若要以树的结构抽象XML，我们先抽象出节点Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 添加一个节点为子节点:</span><br>    Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>;<br>    <span class="hljs-comment">// 获取子节点:</span><br>    List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 输出为XML:</span><br>    String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于&lt;abc&gt;这样的节点，我们称之为ElementNode，它可以作为容器包含多个子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElementNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ElementNode</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br>        list.add(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;&quot;</span> + name + <span class="hljs-string">&quot;&gt;\n&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;/&quot;</span> + name + <span class="hljs-string">&quot;&gt;\n&quot;</span>;<br>        <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;&quot;</span>, start, end);<br>        list.forEach(node -&gt; &#123;<br>            sj.add(node.toXml() + <span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> sj.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于普通文本，我们把它看作TextNode，它没有子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">private</span> String text;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TextNode</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-built_in">this</span>.text = text;<br>&#125;<br><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> List.of();<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> text;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，还可以有注释节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">private</span> String text;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CommentNode</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-built_in">this</span>.text = text;<br>&#125;<br><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> List.of();<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;!-- &quot;</span> + text + <span class="hljs-string">&quot; --&gt;&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过ElementNode、TextNode和CommentNode，我们就可以构造出一颗树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;school&quot;</span>);<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;classA&quot;</span>)<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Tom&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Alice&quot;</span>)));<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;classB&quot;</span>)<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Bob&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Grace&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommentNode</span>(<span class="hljs-string">&quot;comment...&quot;</span>)));<br>System.out.println(root.toXml());<br></code></pre></td></tr></table></figure><p>最后通过root节点输出的XML如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">classA</span>&gt;</span><br>Tom<br>Alice<br><span class="hljs-tag">&lt;/<span class="hljs-name">classA</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">classB</span>&gt;</span><br>Bob<br>Grace<br><span class="hljs-comment">&lt;!-- comment... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">classB</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可见，使用Composite模式，需要先统一单个节点以及“容器”节点的接口：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030191508298.png" alt="image-20221030191508298"></p><p>作为容器节点的ElementNode又可以添加任意个Node，这样就可以构成层级结构。</p><p>类似的，像是文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p><h2 id="9-装饰器（Decorator）"><a href="#9-装饰器（Decorator）" class="headerlink" title="9. 装饰器（Decorator）"></a>9. 装饰器（Decorator）</h2><blockquote><p>动态地给一个对象添加一些额外地职责。就增加功能来说，相比生成子类更灵活。</p></blockquote><p>装饰器模式，是一种在运行期动态地给某个对象的实例增加功能的方法。</p><p>在Java标准库中，InputStream是抽象类，FileInputStream、ServletInputStream、Socket.getInputStream ()这些都是最终数据源。如果说现在，我们要给不同的数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加数据源或功能，那么子类数量会暴涨。</p><p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最汇总通过醋和获得我们想要地功能。</p><p>例如：给FileInputStream增加缓冲和解压缩功能，用Decorator模式地写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建原始的数据源:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.gz&quot;</span>);<br><span class="hljs-comment">// 增加缓冲功能:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br><span class="hljs-comment">// 增加解压缩功能:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">gis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GZIPInputStream</span>(bis);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GZIPInputStream</span>( <span class="hljs-comment">// 第二层装饰</span><br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>( <span class="hljs-comment">// 第一层装饰</span><br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.gz&quot;</span>) <span class="hljs-comment">// 核心功能</span><br>                        ));<br></code></pre></td></tr></table></figure><p>观察BufferedInputStream和GZIPInputStream的继承关系，它们都是从FilterInputStream继承来的，而FilterInputStream是一个抽象类。</p><p>用图表示Decorator模式：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030192800637.png" alt="image-20221030192800637"></p><ul><li><p>最顶层的Component是接口。对应到IO就是InputStream这个抽象类。</p></li><li><p>ComponentA、ComponentB则是实际的子类。对应到IO就是FileInputStream、ServletInputStream这些数据源。</p></li><li><p>Decorator是用于实现各个附加功能的抽象装饰器。对应到IO就是FileInputStream</p></li><li><p>而从Decorator派生的就是一个个的装饰器，它们每个都有独立的功能。对应到IO就是BufferedInputStream、GZIPInputStream等</p></li></ul><p>Decorator模式有什么好处？</p><p>它实际把核心功能和附加功能给分开了。核心功能指FileInputStream这些真正读取数据的数据源，附加功能指的是缓冲、压缩、解密这些功能。如果我们要增加核心功能，就增加Component的子类，例如ByteInputStream。如果我们要增加附加功能，就增加Decorator的子类，例如CipherInputStream。两个部分可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p><p>如何设计完整地Decorator模式？</p><p>以HTML文本渲染为例，文本可以附加一些效果，如加粗、变斜体、加下划线等。为了实现动态地附加效果，可以采用Decorator模式。</p><ul><li><p>定义顶层接口TextNode：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-comment">// 设置text:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span>;<br>    <span class="hljs-comment">// 获取text:</span><br>    String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>核心节点：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpanNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-keyword">private</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;span&gt;&quot;</span> + text + <span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>抽象的Decorator类：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-comment">//持有一个TextNode</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> TextNode target;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">NodeDecorator</span><span class="hljs-params">(TextNode target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target.setText(text);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>具体的Decorator类：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BoldDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NodeDecorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BoldDecorator</span><span class="hljs-params">(TextNode target)</span> &#123;<br>        <span class="hljs-built_in">super</span>(target);<br>    &#125;<br><span class="hljs-comment">//附加功能</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;b&gt;&quot;</span> + target.getText() + <span class="hljs-string">&quot;&lt;/b&gt;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>客户端组合使用Decorator：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>();<br><span class="hljs-type">TextNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoldDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UnderlineDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>()));<br><span class="hljs-type">TextNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItalicDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BoldDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>()));<br>n1.setText(<span class="hljs-string">&quot;Hello&quot;</span>);<br>n2.setText(<span class="hljs-string">&quot;Decorated&quot;</span>);<br>n3.setText(<span class="hljs-string">&quot;World&quot;</span>);<br>System.out.println(n1.getText());<br><span class="hljs-comment">// 输出&lt;span&gt;Hello&lt;/span&gt;</span><br><br>System.out.println(n2.getText());<br><span class="hljs-comment">// 输出&lt;b&gt;&lt;u&gt;&lt;span&gt;Decorated&lt;/span&gt;&lt;/u&gt;&lt;/b&gt;</span><br><br>System.out.println(n3.getText());<br><span class="hljs-comment">// 输出&lt;i&gt;&lt;b&gt;&lt;span&gt;World&lt;/span&gt;&lt;/b&gt;&lt;/i&gt;</span><br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="10-外观（Facade）"><a href="#10-外观（Facade）" class="headerlink" title="10. 外观（Facade）"></a>10. 外观（Facade）</h2><blockquote><p>为系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></blockquote><p>外观模式的基本思想：</p><p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p><p>以注册公司为例，假设组测公司需要三步：</p><ol><li>向工商局申请营业执照；</li><li>在银行开设账户；</li><li>在税务局开设纳税号；</li></ol><p>三个接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工商注册:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminOfIndustry</span> &#123;<br>    <span class="hljs-keyword">public</span> Company <span class="hljs-title function_">register</span><span class="hljs-params">(String name)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 银行开户:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">openAccount</span><span class="hljs-params">(String companyId)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 纳税登记:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Taxation</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">applyTaxCode</span><span class="hljs-params">(String companyId)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户为了注册公司，需要逐步的去调用这些接口，比较麻烦，这个时候，直接将这些流程全部委托给中介：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>    <span class="hljs-keyword">public</span> Company <span class="hljs-title function_">openCompany</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Company</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.admin.register(name);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.bank.openAccount(c.getId());<br>        c.setBankAccount(bankAccount);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">taxCode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.taxation.applyTaxCode(c.getId());<br>        c.setTaxCode(taxCode);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，用户需要注册公司，只需要调用中介这一个接口，再由中介去执行其他具体流程，用户不需要关心中介如何完成注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用户委托中介注册公司</span><br><span class="hljs-type">Company</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> facade.openCompany(<span class="hljs-string">&quot;Facade Software Ltd.&quot;</span>);<br></code></pre></td></tr></table></figure><p>很多Web程序，内部由多个子系统提供服务，经常使用一个统一的Facade入口，例如一个RestApiController，使得外部用户调用的时候，只需要关系Facade提供的接口，不用管内部是哪个子系统处理的。</p><p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，其本质也是一个Facade（外观的外观），但可以附加一些用户认证、限流限速的额外服务。</p><h2 id="11-享元（Flyweight）"><a href="#11-享元（Flyweight）" class="headerlink" title="11. 享元（Flyweight）"></a>11. 享元（Flyweight）</h2><blockquote><p>运用共享技术有效地支持大量细粒度地对象。</p></blockquote><p>核心思想：</p><p>如果一个对象实例一经创建就不可变，那么反复创建相同地实例就没有必要，直接向调用方返回一个共享地实例就行，这样既节省内粗，又可以减少创建对象地过程，提高运行速度。</p><p>享元模式在Java标准库中地应用：Byte、Integer都是不变类。以Integer为例，通过Integer.valueOf()这个静态方法创建Integer实例，当传入地int范围在-128~到+127之间时，会直接返回缓存地Integer实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>        System.out.println(n1 == n2); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于Byte来说，因为Byte只有256个状态，所以通过Byte.valueOf()创建地Byte实例全部都是缓存对象。</p><p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓冲地实例，而不是新建实例，从而实现不可变实例的复用。（总是使用工厂方法来获取实例，而不是通过new创建实例，可以更好地复用对象）。</p><p>在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不被每次查询数据库或者读取文件，而是直接返回内存中缓存地数据。</p><p>以Student为例，设计一个静态工厂方法，在内部可以返回缓存的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 持有缓存:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Student&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 静态工厂方法:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> id + <span class="hljs-string">&quot;\n&quot;</span> + name;<br>        <span class="hljs-comment">// 先查找缓存:</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-comment">// 若没有缓存：</span><br>        <span class="hljs-keyword">if</span> (std == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 创建新对象</span><br>            System.out.println(String.format(<span class="hljs-string">&quot;create new Student(%s, %s)&quot;</span>, id, name));<br>            std = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, name);<br>            <span class="hljs-comment">// 放入缓存</span><br>            cache.put(key, std);<br>        <span class="hljs-comment">// 若已缓存：</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(String.format(<span class="hljs-string">&quot;return cached Student(%s, %s)&quot;</span>, std.id, std.name));<br>        &#125;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br><span class="hljs-comment">// Student属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">// Student构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际的应用中，我们经常使用成熟的缓存库，例如Guava的Cache，因为它提供了最大缓存数量限制、定时过期等实用功能。</p><h2 id="12-代理（Proxy）"><a href="#12-代理（Proxy）" class="headerlink" title="12. 代理（Proxy）"></a>12. 代理（Proxy）</h2><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><h3 id="Proxy对比Adapter"><a href="#Proxy对比Adapter" class="headerlink" title="Proxy对比Adapter"></a>Proxy对比Adapter</h3><p>Adapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BAdapter</span><span class="hljs-params">(A a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        a.a();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Proxy:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AProxy</span><span class="hljs-params">(A a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//do somthing</span><br>        <span class="hljs-built_in">this</span>.a.a();<br>        <span class="hljs-comment">//do somthing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>区别：</p><ul><li><p>Adapter是将接口A转换为接口B（适配）</p><blockquote><p>目的是为例让只能调用接口B的方法,通过Adapter的转换可以调用接口A。</p></blockquote></li><li><p>Proxy只是将接口A再包了一层（增强）</p><blockquote><p>目的是在不修改原有接口的前提下，对原有接口的方法进行增强。</p><p>可以在调用原接口方法的前后执行扩展操作。</p></blockquote></li></ul><p>可以通过Proxy设计方法进行权限检查，只有拥有对应权限的用户才可以真正调用目标接口方法。</p><p>为什么实用Proxy，而不是直接将权限检查写到接口A的内部？</p><ul><li>编写代码的原则：<ul><li>职责清晰：一个类只负责一件事</li><li>易于测试：一次只测一个功能</li></ul></li><li>代码解耦<ul><li>实用Proxy实现权限检查，代码更加清晰、简介<ul><li>A接口：只定义接口</li><li>ABusinuess类：实现A接口的业务逻辑</li><li>APermissionProxy类：只实现A接口的权限检查代理</li></ul></li><li>如果需要增加其他类型的代理，比如日志记录的代理。不需要对现有A接口、ABusiness类进行修改，只需要再写一个Proxy类即可</li></ul></li></ul><h3 id="Peoxy的应用："><a href="#Peoxy的应用：" class="headerlink" title="Peoxy的应用："></a>Peoxy的应用：</h3><ul><li><p>远程代理（Remote Proxy）</p><blockquote><p>本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法的访问转换成远程调用，然后返回结果。</p><p>Java内置的RMI机制就是一个完整的代理模式</p></blockquote></li><li><p>虚代理（Virtual Proxy）</p><blockquote><p>让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。</p><p>JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p></blockquote></li><li><p>保护代理（Protection Proxy）</p><blockquote><p>用于控制对原始对象的访问，常用于权限鉴定</p></blockquote></li><li><p>智能引用（Smart Reference）</p><blockquote><p>如果有很多客户端对它进行访问，通过内部的计数器可以再外部调用者都不使用后自动释放。</p></blockquote></li></ul><h3 id="通过代理模式编写一个JDBC连接池："><a href="#通过代理模式编写一个JDBC连接池：" class="headerlink" title="通过代理模式编写一个JDBC连接池："></a>通过代理模式编写一个JDBC连接池：</h3><p>调用者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataSource</span> <span class="hljs-variable">lazyDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyDataSource</span>(jdbcUrl, jdbcUsername, jdbcPassword);<br><br>System.out.println(<span class="hljs-string">&quot;get lazy connection...&quot;</span>);<br><span class="hljs-comment">//没有真正打开Connection</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> lazyDataSource.getConnection()) &#123;<br>    <span class="hljs-comment">// 打开了真正的Connection</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> conn.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM students&quot;</span>)) &#123; <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> ps.executeQuery()) &#123;<br>            <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>                System.out.println(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="虚代理LazyConnectionProxy的实现"><a href="#虚代理LazyConnectionProxy的实现" class="headerlink" title="虚代理LazyConnectionProxy的实现"></a>虚代理LazyConnectionProxy的实现</h4><p>首先针对Connection接口实现一个抽象代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractConnectionProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br><br>    <span class="hljs-comment">// 抽象方法获取实际的Connection:</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 实现Connection接口的每一个方法:</span><br>    <span class="hljs-keyword">public</span> Statement <span class="hljs-title function_">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> getRealConnection().createStatement();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> getRealConnection().prepareStatement(sql);<br>    &#125;<br><br>    ...其他代理方法...<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractConnectionProxy抽象代理类的作用时把Connection接口定义的方法全部实现一遍，后面编写LazyConnectionProxy只需要继承它，就不需要再一一实现Connection接口方法。</p><p>LazyConnectionProxy实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyConnectionProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConnectionProxy</span> &#123;<br>    <span class="hljs-keyword">private</span> Supplier&lt;Connection&gt; supplier;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LazyConnectionProxy</span><span class="hljs-params">(Supplier&lt;Connection&gt; supplier)</span> &#123;<br>        <span class="hljs-built_in">this</span>.supplier = supplier;<br>    &#125;<br><br>    <span class="hljs-comment">// 覆写close方法：只有target不为null时才需要关闭:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Close connection: &quot;</span> + target);<br>            <span class="hljs-built_in">super</span>.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) &#123;<br>            target = supplier.get();<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有执行任何SQL语句，那么target字段始终为null。只有第一次执行SQL语句时（调用prepareStatement()方法时，会触发getRealConnection()调用），才会真正打开实际的JDBC连接。</p><h4 id="编写LazyDateSource"><a href="#编写LazyDateSource" class="headerlink" title="编写LazyDateSource"></a>编写LazyDateSource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataSource</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LazyDataSource</span><span class="hljs-params">(String url, String username, String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyConnectionProxy</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>                System.out.println(<span class="hljs-string">&quot;Open connection: &quot;</span> + conn);<br>                <span class="hljs-keyword">return</span> conn;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重复使用连接"><a href="#重复使用连接" class="headerlink" title="重复使用连接"></a>重复使用连接</h4><p>连接池实现复用Connection也是使用的代理模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledConnectionProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConnectionProxy</span> &#123;<br>    <span class="hljs-comment">// 实际的Connection:</span><br>    Connection target;<br>    <span class="hljs-comment">// 空闲队列:</span><br>    Queue&lt;PooledConnectionProxy&gt; idleQueue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PooledConnectionProxy</span><span class="hljs-params">(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.idleQueue = idleQueue;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fake close and released to idle queue for future reuse: &quot;</span> + target);<br>        <span class="hljs-comment">// 并没有调用实际Connection的close()方法,</span><br>        <span class="hljs-comment">// 而是把自己放入空闲队列:</span><br>        idleQueue.offer(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复用连接的关键在于覆写close()方法，它并没有真正关闭底层JDBC连接，而是将自己放回一个空闲队列，以便下次使用。</p><p>空闲队列由PooledDataSource维护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataSource</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">// 维护一个空闲队列:</span><br>    <span class="hljs-keyword">private</span> Queue&lt;PooledConnectionProxy&gt; idleQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PooledDataSource</span><span class="hljs-params">(String url, String username, String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><span class="hljs-comment">// 获取一个连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">// 首先试图获取一个空闲连接:</span><br>        <span class="hljs-type">PooledConnectionProxy</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> idleQueue.poll();<br>        <span class="hljs-comment">// 没有空闲连接时，打开一个新连接:</span><br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>            conn = openNewConnection();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Return pooled connection: &quot;</span> + conn.target);<br>        &#125;<br>        <span class="hljs-keyword">return</span> conn;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> PooledConnectionProxy <span class="hljs-title function_">openNewConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>        System.out.println(<span class="hljs-string">&quot;Open new connection: &quot;</span> + conn);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledConnectionProxy</span>(idleQueue, conn);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们实际使用的DataSource，都是基于代理模式实现的，原理同上，但是增加了更多的如动态伸缩功能（一个连接空闲一段时间后自动关闭）。</p><p>Proxy模式与Decorater的区别：</p><ul><li>Decorator模式让调用者自己创建核心类，然后组和各种功能</li><li>Proxy模式绝不能让调用者自己创建再组合，否则就是失去了代理的功能。Proxy模式让调用者认为自己获取到的是核心接口，但实际是代理类。</li></ul><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式主要设计算法和对象之间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p><h2 id="13-责任链（Chain-of-Responsibility）"><a href="#13-责任链（Chain-of-Responsibility）" class="headerlink" title="13. 责任链（Chain of Responsibility）"></a>13. 责任链（Chain of Responsibility）</h2><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p></blockquote><p>责任链模式是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到某个处理成功为止。</p><p>责任链模式把多个处理器串成链，然后让请求在链上传递：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031114411897.png" alt="image-20221031114411897"></p><p>在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：</p><ul><li>Manager：只能审核1000元以下的报销</li><li>Director：只能审核10000元以下的报销</li><li>CEO：可以审核任意额度</li></ul><p>用责任链模式设计这个报销流程时，每个审核者只关心自己责任范围内的请求，并处理它。对于超过自己责任范围的，扔给下一个审核者处理，这样，将来需要添加审核者的时候，不用改动现有逻辑。</p><p>责任链模式的实现：</p><ol><li><p>抽象出请求对象，它将在责任链上传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Request</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> BigDecimal amount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Request</span><span class="hljs-params">(String name, BigDecimal amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>抽象出处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-comment">// 返回Boolean.TRUE = 成功</span><br>    <span class="hljs-comment">// 返回Boolean.FALSE = 拒绝</span><br>    <span class="hljs-comment">// 返回null = 交下一个处理</span><br>Boolean <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>做好约定：如果返回Boolean.TRUE，表示处理成功，如果返回Boolean.FALSE，表示处理失败（请求被拒绝），如果返回null，则交由下一个Handler处理。</p></li><li><p>编写具体的处理器：ManagerHandler、DirectorHandler和CEOHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManagerHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">// 如果超过1000元，处理不了，交下一个处理:</span><br>        <span class="hljs-keyword">if</span> (request.getAmount().compareTo(BigDecimal.valueOf(<span class="hljs-number">1000</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对Bob有偏见:</span><br>        <span class="hljs-keyword">return</span> !request.getName().equalsIgnoreCase(<span class="hljs-string">&quot;bob&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将Handler组合起来，变成一个链，通过一个统一入口处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-comment">// 持有所有Handler:</span><br>    <span class="hljs-keyword">private</span> List&lt;Handler&gt; handlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handlers.add(handler);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">// 依次调用每个Handler:</span><br>        <span class="hljs-keyword">for</span> (Handler handler : handlers) &#123;<br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> handler.process(request);<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果返回TRUE或FALSE，处理结束:</span><br>                System.out.println(request + <span class="hljs-string">&quot; &quot;</span> + (r ? <span class="hljs-string">&quot;Approved by &quot;</span> : <span class="hljs-string">&quot;Denied by &quot;</span>) + handler.getClass().getSimpleName());<br>                <span class="hljs-keyword">return</span> r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Could not handle request: &quot;</span> + request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在客户端组装责任链，然后用责任链处理请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造责任链:</span><br><span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ManagerHandler</span>());<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectorHandler</span>());<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CEOHandler</span>());<br><span class="hljs-comment">// 处理请求:</span><br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.45&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1234.56&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;12345.67&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123456.78&quot;</span>)));<br></code></pre></td></tr></table></figure></li></ol><p>责任链中Handler添加的顺序很重要，如果顺序不对，处理结果可能不符合要求。</p><p>责任链模式变种：</p><ul><li><p>有些责任链的实现方式是通过Handler手动调用下一个Handler来传递Request，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!canProcess(request)) &#123;<br>            <span class="hljs-comment">// 手动交给下一个Handler处理:</span><br>            next.process(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>还有的责任链模式，每个Handler都有机会处理Request，通常这种责任链被称为拦截器（Interceptor）或过滤器（Filter），它们的目的不是找到某个Handler处理掉Request，而是每个Handler都做一些工作，比如：</p><ul><li>记录日志</li><li>检查权限</li><li>准备相关资源</li><li>…</li></ul><p>例如JavaEE的Servlet规范定义的Filter就是一种责任链。它不但允许每个Filter都有机会处理请求，还允许每个Filter决定是否将请求“放行”给下一个Filter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuditFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        log(req);<br>        <span class="hljs-keyword">if</span> (check(req)) &#123;<br>            <span class="hljs-comment">// 放行:</span><br>            chain.doFilter(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 拒绝:</span><br>            sendError(resp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式不但允许一个Filter自行决定处理ServletRequest和ServletResponse，还可以“伪造”ServletRequest和ServletResponse以便让下一个Filter处理，能实现非常复杂的功能。</p></li></ul><h2 id="14-命令（Command）"><a href="#14-命令（Command）" class="headerlink" title="14. 命令（Command）"></a>14. 命令（Command）</h2><blockquote><p>将一个请求封装成一个对象，从而使你可用不同的请求对客户端进行参数化，对请求判定或记录请求日志，以及支持可撤销的操作。</p></blockquote><p>命令模式是指把一个请求封装成一个命令，然后执行该命令。</p><p>以一个编辑器为例子，看看如何实现简单的编辑操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paste</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> getFromClipBoard();<br>        add(text);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;<br>        buffer.append(s);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (buffer.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.deleteCharAt(buffer.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用一个StringBuilder模拟一个文本编辑器，它支持copy() 、paste ()、add()、delete()等方法。</p><p>上面这个TextEditor的调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>editor.add(<span class="hljs-string">&quot;Command pattern in text editor.\n&quot;</span>);<br>editor.copy();<br>editor.paste();<br>System.out.println(editor.getState());<br></code></pre></td></tr></table></figure><p>调用方需要了解TextEditor的所有接口信息。</p><p>如果改成命令模式，我们需要将调用方发送命令，和执行命令分开。通过引入一个Command接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方创建一个对应的Command，然后执行，并不关心内部是如何执行的：</p><ul><li><p>实现具体的Command</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-comment">// 持有执行者对象:</span><br>    <span class="hljs-keyword">private</span> TextEditor receiver;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyCommand</span><span class="hljs-params">(TextEditor receiver)</span> &#123;<br>        <span class="hljs-built_in">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        receiver.copy();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasteCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> TextEditor receiver;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PasteCommand</span><span class="hljs-params">(TextEditor receiver)</span> &#123;<br>        <span class="hljs-built_in">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        receiver.paste();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将Command和TextEditor组装一下，调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>editor.add(<span class="hljs-string">&quot;Command pattern in text editor.\n&quot;</span>);<br><br><span class="hljs-comment">// 执行一个CopyCommand:</span><br><span class="hljs-type">Command</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyCommand</span>(editor);<br>copy.execute();<br>editor.add(<span class="hljs-string">&quot;----\n&quot;</span>);<br><br><span class="hljs-comment">// 执行一个PasteCommand:</span><br><span class="hljs-type">Command</span> <span class="hljs-variable">paste</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasteCommand</span>(editor);<br>paste.execute();<br>System.out.println(editor.getState());<br></code></pre></td></tr></table></figure></li></ul><p>命令模式的结构：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031190100636.png" alt="image-20221031190100636"></p><p>使用命令模式增加了一定的复杂度，对于简单系统，直接调用会更直观且简单。但是当系统复杂到一定程度的时候，比如要给TextEditor增加Undo、Redo功能，则使用命令行模式逻辑会清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把执行过的一系列命令使用List保存起来，这样就能支持Undo和Redo。这个时候我们又需要一个Invoker对象，负责执行命令并保存历史命令：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031190609564.png" alt="image-20221031190609564"></p><h2 id="15-解释器（Interpreter）"><a href="#15-解释器（Interpreter）" class="headerlink" title="15. 解释器（Interpreter）"></a>15. 解释器（Interpreter）</h2><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>解释模式是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。</p><p>例如，针对以下的匹配条件：</p><ul><li>以+开头的数字表示的区号和电话号码，如+8615566666666</li><li>以英文开头，后接英文和数字，并以.分隔的域名，如<a href="http://www.google.com/">www.google.com</a></li><li>以&#x2F;开头的文件路径，如&#x2F;path&#x2F;to&#x2F;file.txt</li><li>…</li></ul><p>因此，需要一种通用的表达方式——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p><p>实现一个完成的正则表达式解释器很复杂，但是使用解释器模式很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;+861012345678&quot;</span>;<br>System.out.println(s.matches(<span class="hljs-string">&quot;^\\+\\d+$&quot;</span>));<br></code></pre></td></tr></table></figure><p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也很复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p><h2 id="16-迭代器（Iterator）"><a href="#16-迭代器（Iterator）" class="headerlink" title="16. 迭代器（Iterator）"></a>16. 迭代器（Iterator）</h2><blockquote><p> 提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。</p></blockquote><p>迭代器模式实际上在Java集合类汇中已经广泛使用了。</p><p>我们以List为例，要遍历ArrayList，即使我们直到它的内部存储了一个Object[]数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。</p><p>如果使用Iterator遍历，那么，ArrayList和LinkedList都可以以一种统一的接口来遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = ...<br>Iterator&lt;String&gt; it = list.iterator()<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>&#125;<br><br><span class="hljs-comment">//Iterator模式十分有用，Java允许把任何支持Iterator的集合对象用foreach来遍历</span><br>List&lt;String&gt; list = ...<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>Iterator模式的实现：</p><p>实现Iterator模式的关键是返回一个Iterator对象。该对象知道集合内部结构，它可以实现倒序遍历。</p><p>自定义一个集合，通过Iterator模式实现倒序遍历，使用Java的内部类实现Iterator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseArrayCollection</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">private</span> T[] array;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReverseArrayCollection</span><span class="hljs-params">(T... objs)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = Arrays.copyOfRange(objs, <span class="hljs-number">0</span>, objs.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReverseIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>        <span class="hljs-comment">// 索引位置:</span><br>        <span class="hljs-type">int</span> index;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReverseIterator</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 创建Iterator时,索引在数组末尾:</span><br>            <span class="hljs-built_in">this</span>.index = ReverseArrayCollection.<span class="hljs-built_in">this</span>.array.length;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):</span><br>            <span class="hljs-keyword">return</span> index &gt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 将索引移动到下一个元素并返回(倒序往前移动):</span><br>            index--;<br>            <span class="hljs-keyword">return</span> array[index];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用内部类的好处是内部类隐含地持有一个它所在对象地this引用，可以通过ReverseArrayCollection.this引用到它所在地集合。</p><p>上述的地代码实现地逻辑非常简单，但是在实际的应用中，如果考虑多线程访问，则需要仔细设计避免多线程安全问题。</p><h2 id="17-中介（Meiator）"><a href="#17-中介（Meiator）" class="headerlink" title="17. 中介（Meiator）"></a>17. 中介（Meiator）</h2><blockquote><p>用一个中介对象来封装一系列的对象交互。中介者使个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互。</p></blockquote><p>中介模式又称调停者模式，它地目的是把多方会谈变成双方会谈，从而实现多方地松耦合。</p><p>一个多选框的例子：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205600593.png" alt="image-20221031205600593"></p><p>这个小系统有4个参与对象：</p><ul><li>多选框</li><li>“选择全部”按钮</li><li>“取消所有”按钮</li><li>反选按钮</li></ul><p>它的复杂性在于，当多选框变化时，它会影响”选择全部“和”取消所有“按钮的状态（是否可点击），当用户点击某个按钮时，又会影响多选框和其他按钮的状态。</p><p>所以说这是一个多方会谈，逻辑写起来很复杂：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205849415.png" alt="image-20221031205849415"></p><p>如果我们引入一个中介，把多方会谈变成多个单方会谈，虽然多了一个对象，但对象之间的关系就变得简单了：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205959983.png" alt="image-20221031205959983"></p><p>使用中介模式来实现上面得UI组件交互：</p><ol><li><p>首先把UI组件画出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderFrame</span>(<span class="hljs-string">&quot;Hanburger&quot;</span>, <span class="hljs-string">&quot;Nugget&quot;</span>, <span class="hljs-string">&quot;Chip&quot;</span>, <span class="hljs-string">&quot;Coffee&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFrame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span> &#123;<br>    <span class="hljs-comment">//Frame</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderFrame</span><span class="hljs-params">(String... names)</span> &#123;<br>        setTitle(<span class="hljs-string">&quot;Order&quot;</span>);<br>        setSize(<span class="hljs-number">460</span>, <span class="hljs-number">200</span>);<br>        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>        <span class="hljs-type">Container</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getContentPane();<br>        c.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>(FlowLayout.LEADING, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>));<br>        c.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;Use Mediator Pattern&quot;</span>));<br>        <span class="hljs-comment">//添加多选框</span><br>        List&lt;JCheckBox&gt; checkboxList = addCheckBox(names);<br>        <span class="hljs-comment">//添加三个按钮</span><br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectAll</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Select All&quot;</span>);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectNone</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Select None&quot;</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectInverse</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Inverse Select&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mediator</span>(checkBoxList, selectAll, selectNone, selectInverse);<br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br><span class="hljs-comment">//多选框</span><br>    <span class="hljs-keyword">private</span> List&lt;JCheckBox&gt; <span class="hljs-title function_">addCheckBox</span><span class="hljs-params">(String... names)</span> &#123;<br>        <span class="hljs-type">JPanel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>        panel.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;Menu:&quot;</span>));<br>        List&lt;JCheckBox&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-type">JCheckBox</span> <span class="hljs-variable">checkbox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JCheckBox</span>(name);<br>            list.add(checkbox);<br>            panel.add(checkbox);<br>        &#125;<br>        getContentPane().add(panel);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><span class="hljs-comment">//按钮</span><br>    <span class="hljs-keyword">private</span> JButton <span class="hljs-title function_">addButton</span><span class="hljs-params">(String label)</span> &#123;<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(label);<br>        getContentPane().add(button);<br>        <span class="hljs-keyword">return</span> button;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设计Mediator类，它引用4个UI组件，并负责跟它们交互：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-comment">// 引用UI组件:</span><br>    <span class="hljs-keyword">private</span> List&lt;JCheckBox&gt; checkBoxList;<br>    <span class="hljs-keyword">private</span> JButton selectAll;<br>    <span class="hljs-keyword">private</span> JButton selectNone;<br>    <span class="hljs-keyword">private</span> JButton selectInverse;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mediator</span><span class="hljs-params">(List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse)</span> &#123;<br>        <span class="hljs-built_in">this</span>.checkBoxList = checkBoxList;<br>        <span class="hljs-built_in">this</span>.selectAll = selectAll;<br>        <span class="hljs-built_in">this</span>.selectNone = selectNone;<br>        <span class="hljs-built_in">this</span>.selectInverse = selectInverse;<br>        <span class="hljs-comment">// 绑定事件:</span><br>        <span class="hljs-built_in">this</span>.checkBoxList.forEach(checkBox -&gt; &#123;<br>            checkBox.addChangeListener(<span class="hljs-built_in">this</span>::onCheckBoxChanged);<br>        &#125;);<br>        <span class="hljs-built_in">this</span>.selectAll.addActionListener(<span class="hljs-built_in">this</span>::onSelectAllClicked);<br>        <span class="hljs-built_in">this</span>.selectNone.addActionListener(<span class="hljs-built_in">this</span>::onSelectNoneClicked);<br>        <span class="hljs-built_in">this</span>.selectInverse.addActionListener(<span class="hljs-built_in">this</span>::onSelectInverseClicked);<br>    &#125;<br><br>    <span class="hljs-comment">// 当checkbox有变化时:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCheckBoxChanged</span><span class="hljs-params">(ChangeEvent event)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">allChecked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">allUnchecked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> checkBox : checkBoxList) &#123;<br>            <span class="hljs-keyword">if</span> (checkBox.isSelected()) &#123;<br>                allUnchecked = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                allChecked = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        selectAll.setEnabled(!allChecked);<br>        selectNone.setEnabled(!allUnchecked);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select all:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectAllClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="hljs-literal">true</span>));<br>        selectAll.setEnabled(<span class="hljs-literal">false</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select none:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectNoneClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="hljs-literal">false</span>));<br>        selectAll.setEnabled(<span class="hljs-literal">true</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select inverse:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectInverseClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));<br>        onCheckBoxChanged(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>使用Mediator模式后的好处：</p><ul><li>各个UI组件互不引用，这样就减少了组件之间的耦合关系</li><li>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件</li><li>如果新增一个UI组件，我们只需要修改Mediator更新状&#x3D;状态的逻辑，现有的其他UI组件代码不变</li></ul><p>Mediator模式经常用在有众多交互组件的UI上。为例简化UI程序，MVC模式以及MVVM模式都可以看作时Mediator模式的扩展。</p><h2 id="18-备忘录（Memento）"><a href="#18-备忘录（Memento）" class="headerlink" title="18. 备忘录（Memento）"></a>18. 备忘录（Memento）</h2><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p></blockquote><p>备忘录模式，主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p><p>其实我们使用的几乎所有软件都用到了备忘录模式。</p><ul><li>最简单的备忘录模式就是保存到文件，打开文件。</li><li>对于文本编辑器来说，保存就是把TextEditor类的字符串存储到文件，打开就是恢复TextEditor类的状态。</li><li>对于图像编辑器来说，原理也是一样，只是保存和恢复的数据格式比较复杂而已。</li><li>java的序列化也可以看作是备忘录模式</li><li>文本编辑器的Redo、Undo功能也可以使用备忘录模式实现</li></ul><p>标准的备忘录模式有这么几个角色：</p><ul><li>Memonto： 存储的内部状态</li><li>Originator：创建一个备忘录并设置其状态</li><li>Caretake：负责保存备忘录</li></ul><p>在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似TextEditor的类，增加getState() 和setState()就可以了。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        buffer.append(ch);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;<br>        buffer.append(s);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (buffer.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.deleteCharAt(buffer.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//备忘录功能：</span><br>    <span class="hljs-comment">// 获取状态</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 恢复状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.buffer.delete(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.buffer.length());<br>        <span class="hljs-built_in">this</span>.buffer.append(state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-观察者（Observer）"><a href="#19-观察者（Observer）" class="headerlink" title="19. 观察者（Observer）"></a>19. 观察者（Observer）</h2><blockquote><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><p>观察者模式又称发布-订阅模式。它时一种通知机制，让发送方（被观察者）和接收房间（观察者）能彼此分离，互不影响。</p><p>一个例子，假设一个电商网站，有多个Product，同时Customer和Admin对商品上架、价格修改都感兴趣，希望第一时间获得通知。于是Store可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    Customer customer;<br>    Admin admin;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, Product&gt; products = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//新增商品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNewProduct</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(name, price);<br>        products.put(p.getName(), p);<br>        <span class="hljs-comment">// 通知用户:</span><br>        customer.onPublished(p);<br>        <span class="hljs-comment">// 通知管理员:</span><br>        admin.onPublished(p);<br>    &#125;<br>    <br><span class="hljs-comment">//修改商品价格</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProductPrice</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> products.get(name);<br>        p.setPrice(price);<br>        <span class="hljs-comment">// 通知用户:</span><br>        customer.onPriceChanged(p);<br>        <span class="hljs-comment">// 通知管理员:</span><br>        admin.onPriceChanged(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Store类的问题：它直接引用了Cunstomer和Admin。如果要新加入观察者需要修改整个Store类，属性、构造方法、每一个通知方法。问题的根源在于Store希望发送通知给关系Product的对象，但Store并不想知道这些人是谁。</p><p>观察者模式就是要分离被观察者和观察者之间的耦合关系。想要实现这一目标很简单，Store不直接引用Customer和Admin，它引用一个ProductObserver接口的List即可，任何想要观察Store，只要实现这一接口，并把自己注册到Store即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;ProductObserver&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Map&lt;String, Product&gt; products = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 注册观察者:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(ProductObserver observer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.observers.add(observer);<br>    &#125;<br><br>    <span class="hljs-comment">// 取消注册:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(ProductObserver observer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNewProduct</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(name, price);<br>        products.put(p.getName(), p);<br>        <span class="hljs-comment">// 通知观察者:</span><br>        observers.forEach(o -&gt; o.onPublished(p));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProductPrice</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> products.get(name);<br>        p.setPrice(price);<br>        <span class="hljs-comment">// 通知观察者:</span><br>        observers.forEach(o -&gt; o.onPriceChanged(p));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样要增加新的观察者就不需要改动Store类的代码，只需要在客户端调用的时候注册观察者，如果要创建新型的额观察者，也只需要实现Productor接口，并在客户端注册即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// observer:</span><br><span class="hljs-type">Admin</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Admin</span>();<br><span class="hljs-type">Customer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br><span class="hljs-comment">// store:</span><br><span class="hljs-type">Store</span> <span class="hljs-variable">store</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>();<br><span class="hljs-comment">// 注册观察者:</span><br>store.addObserver(a);<br>store.addObserver(c);<br><span class="hljs-comment">// 注册匿名观察者</span><br>store.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductObserver</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPublished</span><span class="hljs-params">(Product product)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[Log] on product published: &quot;</span> + product);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPriceChanged</span><span class="hljs-params">(Product product)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[Log] on product price changed: &quot;</span> + product);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>观察者模式图示：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031213754596.png" alt="image-20221031213754596"></p><p>观察者模式变体：</p><ol><li><p>将被观察者也抽象为接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//被观察者接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductObservable</span> &#123; <span class="hljs-comment">// 注意此处拼写是Observable不是Observer!</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(ProductObserver observer)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(ProductObserver observer)</span>;<br>&#125;<br><span class="hljs-comment">//对应的被观察者实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductObservable</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>把通知变成一个Event对象。不再由多种通知，而是统一为Event通知，观察者在自己从Event对象中读取通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductObserver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(ProductEvent event)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>广义上的观察者模式包括所有的消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031214337749.png" alt="image-20221031214337749"></p><p>消息发送方称为Producer，消息接收方称为Consumer。Producer发送消息的时候必须选择发送到哪个Topic，Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。使用消息系统实现观察者模式的时候，Producer和Consumer甚至经常不是在同一台机器上，并且双方对彼此一无所知，以为注册观察者这个动作都是在消息系统中完成的，而不是在Producer内部完成。</p><p>此外，观察者模式中的通知Observe是依靠语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">observers.forEach(o -&gt; o.onPublished(p));<br></code></pre></td></tr></table></figure><p>这说明，各个观察者是依次获取同步通知，需要一个观察者处理完通知后，下一个观察者才能获取到通知。</p><ul><li>如果观察者处理通知很慢，下一个观察者就不能及时获取通知。</li><li>如果观察者在处理通知的时候出现异常，那么还需要被观察者来处理异常</li></ul><p>Java标准库由Java.util.Observable类和Observer接口，用于帮助实现观察者模式，但是很难用，不推荐使用。</p><h2 id="20-状态（State）"><a href="#20-状态（State）" class="headerlink" title="20. 状态（State）"></a>20. 状态（State）</h2><blockquote><p>允许一个对象在其内部状态改变它的行为。对象看起来似乎修改了它的类。</p></blockquote><p>状态模式经常用在带有状态的对象中。</p><p>什么是状态？以QQ为例，一个用户的QQ的几种状态：</p><ul><li>离线</li><li>正在登录</li><li>在线</li><li>忙</li></ul><p>如何表示状态？定义一个enum就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (state == ONLINE) &#123;<br>    <span class="hljs-comment">// 闪烁图标</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BUSY) &#123;<br>    reply(<span class="hljs-string">&quot;现在忙，稍后回复&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...<br></code></pre></td></tr></table></figure><p>状态模式的目的就是把上面一大堆的if…else… 的逻辑拆分到不同的状态中，将来增加状态就只需要再多写一个状态类即可。</p><p>例如，设计一个聊天机器人，有两个状态：未连接、已连接。</p><p>未连接状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisconnectedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bye!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reply</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>已连接状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, I&#x27;m Bob.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reply</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-keyword">if</span> (input.endsWith(<span class="hljs-string">&quot;?&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Yes. &quot;</span> + input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;!&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (input.endsWith(<span class="hljs-string">&quot;.&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;!&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;?&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>状态模式的关键设计思想在于状态切换，引入BotContext完成状态转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BotContext</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisconnectedState</span>();<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">chat</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-comment">// 收到hello切换到在线状态:</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;hello&quot;</span>.equalsIgnoreCase(input)) &#123;<br>state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectedState</span>();<br><span class="hljs-keyword">return</span> state.init();<br>       <span class="hljs-comment">//  收到bye切换到离线状态:</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bye&quot;</span>.equalsIgnoreCase(input)) &#123;<br>state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisconnectedState</span>();<br><span class="hljs-keyword">return</span> state.init();<br>&#125;<br>        <br>        <span class="hljs-comment">// 调用state的reply方法</span><br><span class="hljs-keyword">return</span> state.reply(input);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-策略（Strategy）"><a href="#21-策略（Strategy）" class="headerlink" title="21. 策略（Strategy）"></a>21. 策略（Strategy）</h2><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。使得算法可以独立于使用它的客户而变化。</p></blockquote><p>策略模式指定义一组算法，并将其封装到一个对象中。然后在运行时，可以灵活地使用其中一个算法。</p><h3 id="Arrays-sort-方法中的策略模式"><a href="#Arrays-sort-方法中的策略模式" class="headerlink" title="Arrays.sort()方法中的策略模式"></a>Arrays.sort()方法中的策略模式</h3><p>Java标准库中策略模式的应用：</p><p>以排序为例，看看Arrays.sort()的排序实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        String[] array = &#123; <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span> &#125;;<br>        Arrays.sort(array, String::compareToIgnoreCase);<br>        System.out.println(Arrays.toString(array));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sort()中的策略：</p><ul><li>String::compareToIgnoreCase就是一个算法，它忽略大小写排序。</li><li>若我们想要倒序排序，就传入(s1, s2) -&gt; s1.compareTo(s2)</li></ul><p>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)，观察方法，它在内部实现了TimSort排序（归并排序优化版本），但是排序算法在比较两个元素大小的时候，需要我们传入的Comparator对象，才能完成比较。因此，这里的策略指的是比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以是根据字符串长度比较。</p><p>上面排序中的策略模式，实际指的是，在方法中，流程是确定的，但是某些关键步骤的算法依赖调用方传入的策略。这样，传入不同的策略，即可获得不同的结果，大大增强系统的灵活性。</p><h3 id="购物结算的折扣策略"><a href="#购物结算的折扣策略" class="headerlink" title="购物结算的折扣策略"></a>购物结算的折扣策略</h3><p>一个完整的策略模式所需：</p><ul><li>定义策略</li><li>使用策略的上下文。</li></ul><p>以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>先定义打折策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-comment">// 计算折扣额度:</span><br>    BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现各种策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通用户策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-comment">// 普通会员打九折:</span><br>        <span class="hljs-keyword">return</span> total.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.1&quot;</span>)).setScale(<span class="hljs-number">2</span>, RoundingMode.DOWN);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//满减策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-comment">// 满100减20优惠:</span><br>        <span class="hljs-keyword">return</span> total.compareTo(BigDecimal.valueOf(<span class="hljs-number">100</span>)) &gt;= <span class="hljs-number">0</span> ? BigDecimal.valueOf(<span class="hljs-number">20</span>) : BigDecimal.ZERO;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用策略，需要一个上下文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountContext</span> &#123;<br>    <span class="hljs-comment">// 持有某个策略:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DiscountStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDiscountStrategy</span>();<br><br>    <span class="hljs-comment">// 允许客户端设置新策略:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(DiscountStrategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-keyword">return</span> total.subtract(<span class="hljs-built_in">this</span>.strategy.getDiscount(total)).setScale(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>调用方必须先创建一个DiscountContext，并指定一个策略（或使用默认策略），再调用DiscountContext的获取折扣后价格方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DiscountContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiscountContext</span>();<br><br><span class="hljs-comment">// 默认使用普通会员折扣:</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay1</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay1);<br><br><span class="hljs-comment">// 使用满减折扣:</span><br>ctx.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OverDiscountStrategy</span>());<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay2</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay2);<br><br><span class="hljs-comment">// 使用Prime会员折扣:</span><br>ctx.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrimeDiscountStrategy</span>());<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay3</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay3);<br></code></pre></td></tr></table></figure><p>完整的策略模式图示如下：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031224335921.png" alt="image-20221031224335921"></p><p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽象出来作为”策略“参数传入，从而使得新增策略不必修改原有逻辑。</p><h2 id="22-模板方法（Templat-Method）"><a href="#22-模板方法（Templat-Method）" class="headerlink" title="22. 模板方法（Templat Method）"></a>22. 模板方法（Templat Method）</h2><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><p>模板方法的主要思想：定义一个操作的一系列步骤，对于某些暂不确定的步骤，留给子类实现，这样不同过的子类就可以定义出不同的步骤。</p><p>因此，模板方法的核心在于定义一个”骨架“。</p><p>加入我们开发一个从数据库读取设置的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Setting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> readFromDatabase(key);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">readFromDatabase</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库读取</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于从数据库读取数据比较满，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库。但是怎么实现缓存，暂时还没想好，但是不妨碍我们写出使用缓存的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Setting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 先从缓存读取:</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> lookupCache(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在缓存中未找到,从数据库读取:</span><br>            value = readFromDatabase(key);<br>            System.out.println(<span class="hljs-string">&quot;[DEBUG] load from db: &quot;</span> + key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>            <span class="hljs-comment">// 放入缓存:</span><br>            putIntoCache(key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;[DEBUG] load from cache: &quot;</span> + key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个流程没问题，但是，lookupCache(Key)和putIntoCache(Key, value)这两个方法还根本没有实现，无法通过编译。我们可以声明两个抽象方法，并将Setting也改为抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> lookupCache(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            value = readFromDatabase(key);<br>            putIntoCache(key, value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，整个类为抽象类，如何实现lookupCache(Key)和putIntoCache(key, value)这两个方法就交给子类即可。子类不需要关系核心代码getSetting(Key)的逻辑，它只需要关心如何完成两个子任务。</p><p>假设我们希望用一个Map做缓存，那么可以写一个LocalSetting：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalSetting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        cache.put(key, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要使用Redis做缓存，那么可以再写一个RedisSetting：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisSetting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">RedisClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> RedisClient.create(<span class="hljs-string">&quot;redis://localhost:6379&quot;</span>);<br><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;<br>            RedisCommands&lt;String, String&gt; commands = connection.sync();<br>            <span class="hljs-keyword">return</span> commands.get(key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        <span class="hljs-keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;<br>            RedisCommands&lt;String, String&gt; commands = connection.sync();<br>            commands.set(key, value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端使用缓存：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用本地缓存</span><br><span class="hljs-type">AbstractSetting</span> <span class="hljs-variable">setting1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalSetting</span>();<br>System.out.println(<span class="hljs-string">&quot;test = &quot;</span> + setting1.getSetting(<span class="hljs-string">&quot;test&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;test = &quot;</span> + setting1.getSetting(<span class="hljs-string">&quot;test&quot;</span>));<br><span class="hljs-comment">// 使用Redis缓存</span><br><span class="hljs-type">AbstractSetting</span> <span class="hljs-variable">setting2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisSetting</span>();<br>System.out.println(<span class="hljs-string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="hljs-string">&quot;autosave&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="hljs-string">&quot;autosave&quot;</span>));<br></code></pre></td></tr></table></figure><p>模板方法的核心思想：父类定义骨架，子类实现细节。</p><p>安全问题：</p><ul><li><p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用final。</p></li><li><p>对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见。</p></li></ul><p>Java标准库中模板方法的应用：</p><ul><li>AbstractList</li><li>AbstractQueuedSynchronizer</li></ul><h2 id="23-访问者（Visitor）"><a href="#23-访问者（Visitor）" class="headerlink" title="23. 访问者（Visitor）"></a>23. 访问者（Visitor）</h2><blockquote><p>表示一个作用于某对象结构中的各元素的操作。它使哪可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></blockquote><p>访问者模式是一种操作一组操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p><p>访问者模式的设计比较复杂，Gof原始的访问者模式：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031231737824-16672294603681.png" alt="image-20221031231737824"></p><p>上述模式的复杂之处在于上述访问者模式为了实现所谓的”双重分派“，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出”双重分派“反而加大了代码的复杂性。</p><p>简化的访问者模式：</p><p>假设我们要递归遍历某个文件夹的所有子文件和文件夹，然后找出.java文件。</p><p>一般做法，写个递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(File dir, List&lt;File&gt; collector)</span> &#123;<br>    <span class="hljs-keyword">for</span> (File file : dir.listFiles()) &#123;<br>        <span class="hljs-keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>            collector.add(file);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isDir()) &#123;<br>            <span class="hljs-comment">// 递归调用:</span><br>            scan(file, collector);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的问题在于，扫描目录和处理.java文件的逻辑混在一起。如果下次需要增加一个清理.class文件的功能，那么就必须重写扫描逻辑。</p><p>因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离，以后如果要新增操作（例如清理.class文件），只需要新增访问者，不需要改变现有逻辑。</p><p>用访问者模式改写：</p><ol><li><p>定义访问者接口，即定义访问者能干的事儿：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-comment">// 访问文件夹:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span>;<br>    <span class="hljs-comment">// 访问文件:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义能持有文件夹和文件的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStructure</span> &#123;<br>    <span class="hljs-comment">// 根目录:</span><br>    <span class="hljs-keyword">private</span> File path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileStructure</span><span class="hljs-params">(File path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>为FileStructure增加一个handle()方法，传入一个访问者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStructure</span> &#123;<br>    ...<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>scan(<span class="hljs-built_in">this</span>.path, visitor);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(File file, Visitor visitor)</span> &#123;<br><span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>            <span class="hljs-comment">// 让访问者处理文件夹:</span><br>visitor.visitDir(file);<br><span class="hljs-keyword">for</span> (File sub : file.listFiles()) &#123;<br>                <span class="hljs-comment">// 递归处理子文件夹:</span><br>scan(sub, visitor);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>            <span class="hljs-comment">// 让访问者处理文件:</span><br>visitor.visitFile(file);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样访问者的行为抽象出来了。若要实现一种操作，例如查找.class文件，就传入JavaFileVisitor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileStructure</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileStructure</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;.&quot;</span>));<br>fs.handle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaFileVisitor</span>());<br></code></pre></td></tr></table></figure></li><li><p>实现Visitor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查找.class文件的Visitor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaFileVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Visit dir: &quot;</span> + dir);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span> &#123;<br>        <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Found java file: &quot;</span> + file);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//清理.class文件的Visitor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassFileCleanerVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span> &#123;<br><span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;<br>System.out.println(<span class="hljs-string">&quot;Will clean class file: &quot;</span> + file);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>可见，访问者模式的核心就是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在”访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p><p>Java标准库提供的Files.walkFileTree()已经实现了一个访问者模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.walkFileTree(Paths.get(<span class="hljs-string">&quot;.&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFileVisitor</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现一个FileVisitor:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt; &#123;<br>    <span class="hljs-comment">// 处理Directory:</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre visit dir: &quot;</span> + dir);<br>        <span class="hljs-comment">// 返回CONTINUE表示继续访问:</span><br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理File:</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;visit file: &quot;</span> + file);<br>        <span class="hljs-comment">// 返回CONTINUE表示继续访问:</span><br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Files.walkFileTree()允许访问者返回FileVisitResult.CONTINUE以便继续访问，或者返回FileVisitResult.TERMINATE停止访问。</p><p>类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Hanlder作为访问者处理XML的各个节点。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/10/25/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/10/25/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><h2 id="通过ArrayList简单了解泛型"><a href="#通过ArrayList简单了解泛型" class="headerlink" title="通过ArrayList简单了解泛型"></a>通过ArrayList简单了解泛型</h2><p>首先通过Java标准库提供的ArrayList来了解一下什么是泛型，泛型有什么作用。</p><p>ArrayList可以看作“可变长度”的数组，底层使用Object []数组来存储数据。</p><p>一个简易的可以存储任何类型数据的ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;<br>    <span class="hljs-keyword">private</span> Object[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object e)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要让ArrayList只存储String类型，会有几个缺点：</p><ul><li><p>存的时候，非String类型的数据也能存入ArrayList中</p></li><li><p>取的时候，需要强制转型。第一，麻烦；第二，如果存入的不是String，那么转型失败抛出异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">// 获取到Object，必须强制转型为String:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">0</span>);<br><br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// ERROR: ClassCastException:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>要解决上面的问题，可以为String单独编写一种ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringArrayList</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String e)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样存入的是String、取出的也一定是String，不需要强制转型。</p><p>但是如果要存储Integer或其他类型数据，那么就需要为每种数据类型定义一个ArrayList。</p><p>JDK中的class成百上千，为每种class编写一个ArrayList是不现实的。所以说泛型就出现了。</p><p>通过泛型，将ArrayList变成一种模板：ArrayList<T>：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T e)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>T可以是任何class。编写一个模板，就可以创建任意类型的ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建可以存储String的ArrayList:</span><br>ArrayList&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-comment">// 创建可以存储Float的ArrayList:</span><br>ArrayList&lt;Float&gt; floatList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Float&gt;();<br><span class="hljs-comment">// 创建可以存储Person的ArrayList:</span><br>ArrayList&lt;Person&gt; personList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Person&gt;();<br></code></pre></td></tr></table></figure><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>在Java标准库中的ArrayList<T>实现了List<T>接口，它可以向上转型为List<T>。</T></T></T></p><p>特别注意：</p><ul><li>ArrayList<Integer> 可以向上转型为List<Integer></Integer></Integer></li><li>ArrayList<Integer>不能向上转型为Array List<Number>或List<Number></Number></Number></Integer></li></ul><p>为什么不能？</p><p>一、通过反证法来证明</p><p>如果可以转型的话的话，观察代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建ArrayList&lt;Integer&gt;类型：</span><br>ArrayList&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-comment">// 添加一个Integer：</span><br>integerList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// “向上转型”为ArrayList&lt;Number&gt;：</span><br>ArrayList&lt;Number&gt; numberList = integerList;<br><span class="hljs-comment">// 添加一个Float，因为Float也是Number：</span><br>numberList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>(<span class="hljs-number">12.34</span>));<br><span class="hljs-comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> integerList.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// ClassCastException!</span><br></code></pre></td></tr></table></figure><p>如果我们把ArrayList<Integer>转型为ArrayList<Number>，那么转型过后就可以接收Float类型的数据，因为Float是Number的子类。但是转型过后的ArrayList<Number>实际是一个ArrayList<Integer>对象，不能接收Float类型。简单来说：</Integer></Number></Number></Integer></p><ul><li>如果ArrayList<Integer>可以转型为Array List<Number>，那么按照道理，转型过后应该可以接收Float类型数据</Number></Integer></li><li>但是实际上转型过后，它的实际类型是ArrayLsit<Integer>，不能够接收Float类型数据</Integer></li></ul><p>二、继承关系</p><p>ArrayList<Integer> 和ArrayList<Number>两者完全没有继承关系</Number></Integer></p><h1 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>使用ArrayList时，如果不定义泛型类型，泛型类型实际上就是Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译器警告:</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.add(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">//取出需要强制类型转换</span><br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">0</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>不定义泛型类型的话，只能把<T>当Object使用，没有发挥泛型的优势。</T></p><p>当我们定义泛型<String>后，List,<T>的泛型接口变为强类型List<String>:</String></T></String></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无编译器警告:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.add(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 无强制转型:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>如果编译器能自动推断出泛型类型，就可以省略后面的泛型类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br><span class="hljs-comment">//省略后</span><br>List&lt;Number&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>除了ArrayList<T>这种类可以使用泛型，还可以在接口中使用泛型。</T></p><p>例如Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable<T>这个接口：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h1><p>泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如ArrayList<T>，但是集合类Java库有提供，所以说我们很少需要编写泛型类。</T></p><h2 id="编写泛型类的步骤："><a href="#编写泛型类的步骤：" class="headerlink" title="编写泛型类的步骤："></a>编写泛型类的步骤：</h2><p>一、首先按照某种非泛型类为基础，来编写泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-keyword">private</span> String first;<br>    <span class="hljs-keyword">private</span> String last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(String first, String last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 二、标记所有特定的类，这里是String，将其替换为T，并为泛型类声明<T></T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写熟练过后，可以直接从T开始编写。</p><h2 id="静态泛型方法"><a href="#静态泛型方法" class="headerlink" title="静态泛型方法"></a>静态泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// 对静态方法使用&lt;T&gt;:</span><br>    <span class="hljs-comment">// 会编译错误</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;T&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为静态方法是属于类的，不属于实例对象。而上面的泛型<T>都是通过创建对象的时候才传入的。对于静态方法，无法使用上面的泛型类型T。</T></p><p>在修饰符static后面加上泛型<T>，编译就能通过。如下：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实例的&lt;T&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// 可以编译通过:</span><br>    <span class="hljs-comment">//静态方法的&lt;T&gt;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;T&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这两个<T>不是同一个<T>。所以对于静态方法的泛型类型和实例对象的泛型类型应该区分开来。如下：</T></T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(K first, K last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h2><p>如果我们希望Pair存储两个类型不同的对象，可以使用&lt;T, K&gt;指定多个泛型类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T, K&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> K last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, K last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，指出两种类型即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String, Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h1 id="泛型的实现（擦除法）"><a href="#泛型的实现（擦除法）" class="headerlink" title="泛型的实现（擦除法）"></a>泛型的实现（擦除法）</h1><blockquote><p>泛型是一种类似”模板代码”的技术，不同语言的泛型实现方式不同。</p><p>Java语言的泛型实现是擦除法（Type Erasure）。</p></blockquote><h2 id="擦除法简介"><a href="#擦除法简介" class="headerlink" title="擦除法简介"></a>擦除法简介</h2><p>所谓擦拭法，指的是虚拟机对泛型一无所知，所有的工作都是编译器做的。</p><p>例如，若我们编写了一个泛型类Pair <T>， 源码如下：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br><span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br></code></pre></td></tr></table></figure><p>经过编译器的编译，对泛型的“擦除”，虚拟机中所见如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-keyword">private</span> Object first;<br>    <span class="hljs-keyword">private</span> Object last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(Object first, Object last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pair</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> (String) p.getFirst();<br><span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> (String) p.getLast();<br></code></pre></td></tr></table></figure><p>Java通过擦除法所做的工作：</p><ul><li>编译器将所有的类型<T>视为Object处理</T></li><li>需要转型的时候，编译器根据<T>实现安全的强制类型转换</T></li></ul><h2 id="擦除法的局限"><a href="#擦除法的局限" class="headerlink" title="擦除法的局限"></a>擦除法的局限</h2><ul><li><p><T>不能是基本类型。</T></p><blockquote><p>例如int，因为编译过后的实际类型是Object，Object类型无法持有基本类型。</p></blockquote></li><li><p>无法取得带泛型的Class。</p><blockquote><p>观察如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Pair&lt;String&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> p1.getClass();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p2.getClass();<br>        <span class="hljs-comment">//p1和p2是不同的泛型实例，但是它们是同一个class</span><br>        <span class="hljs-comment">//即无论T为什么类型，getClass返回的都是同一个Class实例</span><br>        <span class="hljs-comment">//因为编译过后它们都是Pair&lt;Object&gt;</span><br>        System.out.println(c1==c2); <span class="hljs-comment">// true</span><br>        System.out.println(c1==Pair.class); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>无法判断带泛型的类型</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br><span class="hljs-comment">// Compile error:</span><br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Pair&lt;String&gt;) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因和前面一样，并不存在Pair<String>.class，而是只有唯一的Pair.class</String></p></blockquote></li><li><p>在泛型类中，不能直接实例化T类型</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Compile error:</span><br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>擦除过后的实际语句为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p>所以说在泛型类中不管T是什么类型，最后都是Object。所以说编译器会阻止这种类型不对的代码。</p><p>如果要实例化T类型，那么就需要传入额外的Class<T>参数，借助反射来实例化：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> &#123;<br>        first = clazz.newInstance();<br>        last = clazz.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="不恰当的覆写方法"><a href="#不恰当的覆写方法" class="headerlink" title="不恰当的覆写方法"></a>不恰当的覆写方法</h2><p>如下代码，看似正确却无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">this</span> <span class="hljs-operator">=</span>= t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为定义的equals(T t)经过泛型擦除过后变成equals(Object t)，而这个方法是继承只Object的，相当于覆写了Object的方法。而编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>解决办法：换衣个方法名，避免于Object.equals(Object) 的冲突</p><h2 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h2><blockquote><p>一个类可以继承自一个泛型类。</p></blockquote><p>例如：父类是Pair<Integer>，子类是IntPair，可以这样继承：</Integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Integer&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，因为子类IntPair并没有泛型类型，所以直接使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntPair</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntPair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="父类的泛型类型T的继承"><a href="#父类的泛型类型T的继承" class="headerlink" title="父类的泛型类型T的继承"></a>父类的泛型类型T的继承</h3><p>因为泛型擦除，所以我们无法获取Pair<T>的T类型。即给定一个变量Pair<Integer> p实例，无法从p中获取到Integer类型。</Integer></T></p><p>但是在泛型的继承中，编译器会把泛型类型的父类中的类型T保存到子类的class文件中。</p><p>所以在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p><p>获取父类的泛型类型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//获取子类的Class实例</span><br>        Class&lt;IntPair&gt; clazz = IntPair.class;<br>        <span class="hljs-comment">//从Class实例中获取Type</span><br>        <span class="hljs-type">Type</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> clazz.getGenericSuperclass();<br>        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">pt</span> <span class="hljs-operator">=</span> (ParameterizedType) t;<br>            Type[] types = pt.getActualTypeArguments(); <span class="hljs-comment">// 可能有多个泛型类型</span><br>            <span class="hljs-type">Type</span> <span class="hljs-variable">firstType</span> <span class="hljs-operator">=</span> types[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 取第一个泛型类型</span><br>            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;<br>            System.out.println(typeClass); <span class="hljs-comment">// Integer</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IntPair</span><span class="hljs-params">(Integer first, Integer last)</span> &#123;<br>        <span class="hljs-built_in">super</span>(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于Type"><a href="#关于Type" class="headerlink" title="关于Type"></a>关于Type</h3><p>由于Java引入了泛型，所以只用Class类标识类型已经不够了。</p><p>所以说Java的类型结构如下：</p><ul><li>父接口Type<ul><li>子接口<ul><li>ParameterizedType</li><li>GenericArrayType</li><li>WildcardType</li><li>TypeVariable</li></ul></li><li>实现类<ul><li>Class</li></ul></li></ul></li></ul><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><h2 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h2><p>在泛型的继承关系中：Pair<Integer>不是Pair<Number>的子类。</Number></Integer></p><h3 id="场景考虑"><a href="#场景考虑" class="headerlink" title="场景考虑"></a>场景考虑</h3><p>首先我们定义了一个pair<T>：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirst</span><span class="hljs-params">(T first)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLast</span><span class="hljs-params">(T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后编写一个工具类PairHelper，其中有一个静态方法，将Pair<Number> 作为参数传入：</Number></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PairHelper</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;Number&gt; p)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用这个静态方法的时候，我们出入一个Pair<Number>实例：</Number></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> PairHelper.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Number&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>注意：传入的类型是Pair<Number>，但Pair<Number>中的实际参数是Integer</Number></Number></p><p>但是如果直接传入Pair<Integer>会编译错误：</Integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> PairHelper.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Number&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">//编译报错</span><br>incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;<br></code></pre></td></tr></table></figure><p>因为add方法传入的参数是Pair<Number>，所以编译器不允许传入Pair<Integer>。</Integer></Number></p><p>但是按照add方法的代码逻辑来说，传入Pair<Integer>是符合要求的。</Integer></p><h3 id="extends的引入"><a href="#extends的引入" class="headerlink" title="extends的引入"></a>extends的引入</h3><p>这里的需求就是：让方法接收泛型类型为Number及其子类的Pair类型</p><p>Pair&lt;? extends Number&gt; 即可实现该需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意：是给方法传入参数的时候使用Pair&lt;? extends Number&gt;，而不是在Pair泛型定义的时候，定义时仍是Pair&lt;T&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用&lt;? extends Number&gt;过后，add方法可以传入各种Pair类型，比如说Pair<Double>、Pair<BigDecimal>等，因为Double和BigDecimal都是Number的子类。</BigDecimal></Double></p><? extends Number>称为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number。### extends的语义（只读）#### get方法我们考察对Pair<? extends Number>类型调用getFirst()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br>    <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>&#125;<br></code></pre></td></tr></table></figure>getFirst()方法编译过后的实际签名为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; getFirst();<br></code></pre></td></tr></table></figure>即返回值是Number或Number的子类，因此使用getFirst方法获取的返回值可以安全的赋值给Number类型的变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> p.getFirst();<br></code></pre></td></tr></table></figure>不能使用Number的子类接收返回值，因为编译器只能确定返回的类型一定是Number及其子类，但是具体类型无法确定。#### set方法对Pair<? extends Number>类型调用setFirst()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br>        p.setFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(first.intValue() + <span class="hljs-number">100</span>));<br>        p.setLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(last.intValue() + <span class="hljs-number">100</span>));<br>        <span class="hljs-keyword">return</span> p.getFirst().intValue() + p.getFirst().intValue();<br>&#125;<br><br><span class="hljs-comment">//会得到编译错误</span><br>incompatible types: Integer cannot be converted to CAP#<span class="hljs-number">1</span><br>where CAP#<span class="hljs-number">1</span> is a fresh type-variable:<br>    CAP#<span class="hljs-number">1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> from capture of ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span><br></code></pre></td></tr></table></figure>这是因为<? extends Number>通配符的一个重要限制：> 无法传递任何Number的子类型给setFirst(? extends Number)方法(除了null)。还是利用反证法来证明这个限制的合理性：> 假设传入add方法的是Pair<Integer>，如果没有这个限制，，那么通过setFirst方法可以传入Number类型及其子类，也就是说可以传入Double类型的参数，那么显然是Pair<Integer>  是无法接收Double类型的数据的。### 具体分析Pair<T>定义（简化）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirst</span><span class="hljs-params">(T first)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>将Pair<? extends Number>作为参数传入方法： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>    p.setFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(first.intValue() + <span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure>传入add方法的p的泛型类型可以是Number类型及其子类。- 那么对p调用get，得到的返回值可能是Integer、Double等，但是一定是Number的子类，所以使用Number可以安全的接收。- 对p调用set方法，由于p的具体泛型类型不知道，p可以接收的类型也不能确定，除了null是一定可以接收的。相当于<? extends Number>把add方法接收的Pair的泛型类型限定在null和Number之间。从Pair中取数据，一定在null和Number之间，所以可以用Number接收。往Pair中存数据，因为Pair能够接收的数据在null和Number之间，只有null能被所有不同泛型类型接收。### extends通配符的作用 考察List<T>接口，它实现一个类似可变数组的列表，其定义如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 获取个数</span><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>; <span class="hljs-comment">// 根据索引获取指定元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T t)</span>; <span class="hljs-comment">// 添加一个新元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(T t)</span>; <span class="hljs-comment">// 删除一个已有元素</span><br>&#125;<br></code></pre></td></tr></table></figure>如果我们要定义一个方法来处理List<T>类型列表中的每一个元素：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sumOfList</span><span class="hljs-params">(List&lt;? extends Integer&gt; list)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.get(i);<br>        sum = sum + n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>为什么定义方法的参数类型是List<? extends Integer>而不是List<Integer>?- 从方法内部的代码看，使用二者是完全一样的。- 但是由于<? extends Integer>的限制，能确保编写的方法对List只进行读操作  > 因为List<? extends Integer>的限制：  >  > - 允许调用List的get方法获取Integer的引用  > - 不允许调用List的set方法传入任何类型数据（除了null）  >  > 因此，定义方法参数类型List<? extends Integer>表名该方法内部只会读取List的元素，不会修改List的元素，即对List<? extends Integer>进行只读操作。### 使用extends限定T类型前面讨论的都是将泛型作为参数传入方法时，限定传入泛型的泛型类型。在定义泛型类型的时候，也可以使用extends通配符来限定能够创建的泛型的泛型类型。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; &#123; ... &#125;<br><span class="hljs-comment">//使用extends限定过后，就只能创建Number及其子类型泛型的实例</span><br>Pair&lt;Number&gt; p1 = <span class="hljs-literal">null</span>;<br>Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Pair&lt;Double&gt; p3 = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//非Number类型的泛型无法通过编译</span><br>Pair&lt;String&gt; p1 = <span class="hljs-literal">null</span>; <span class="hljs-comment">// compile error!</span><br>Pair&lt;Object&gt; p2 = <span class="hljs-literal">null</span>; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure>## super通配符基本同extends通配符，具体不赘述。## 对比extends和super作为方法参数，二者的区别：- <? extend T>允许调用泛型的T get()获取T的实例，但不允许调用set(T)传入T的引用- <? super T> 允许调用set(T)传入T的引用，但不允许调用T get()获取T的实例即一个限定只读，一个限定只写。### extends和super的特性应用先来看看Collections类定义的静态方法copy()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i);<br>            dest.add(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>它的作用是将一个List的元素复制到另一个List中。- 第一个参数：List<? super T> dest。限定只写- 第二个参数：List<? extends T> src。限定只读这个copy ()方法的定义就完美地展示了extends和super的意图：- copy方法内部不会读取dest- cope方法内部不会修改src这是由编译器检查来实现的，如果在copy方法中修改了src或读取了dest，编译器会报错。### PECS原则> Producer Extends Consumer Super。>> PECS原则就是便于记忆何时是使用extends，何时使用super即如果需要返回T，它是生产者Producer，要使用extens通配符如果需要写入T，它是消费者Consumer，要使用super通配符还是以Collections的copy()方法为例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i); <span class="hljs-comment">// src是producer</span><br>            dest.add(t); <span class="hljs-comment">// dest是consumer</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>- src需要返回T，是生产者，因此声明为List<? extends T>- dest需要写入T，是消费者，因此声明为List<? super T>## 无限定通配符前面讨论了<? extends T>和<? super T>作为方法参数的作用。实际上，Java的泛型还允许无限定通配符(Unbounded Wildcard Type)，即只定义一个？：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sample</span><span class="hljs-params">(Pair&lt;?&gt; p)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><?><p>通配符的语义：不能调用set(T)，也不能调用T get()，即不能读也不能写。</p><?>通配符的作用：可以进行null判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNull</span><span class="hljs-params">(Pair&lt;?&gt; p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p.getFirst() == <span class="hljs-literal">null</span> || p.getLast() == <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><?><p>通配符的特点：Pair&lt;?&gt;是所有Pair<T>的超类</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>    Pair&lt;?&gt; p2 = p; <span class="hljs-comment">// 安全地向上转型</span><br>    System.out.println(p2.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p2.getLast());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h1><h2 id="泛型的反射API"><a href="#泛型的反射API" class="headerlink" title="泛型的反射API"></a>泛型的反射API</h2><h3 id="Class-lt-T-gt"><a href="#Class-lt-T-gt" class="headerlink" title="Class&lt;T&gt;"></a>Class&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// compile warning:</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) clazz.newInstance();<br><br><span class="hljs-comment">// no warning:</span><br>Class&lt;String&gt; clazz = String.class;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> clazz.newInstance();<br></code></pre></td></tr></table></figure><p> 调用Class的getSuperclass()方法返回的Class类型是Class&lt;? super T&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;? <span class="hljs-built_in">super</span> String&gt; sup = String.class.getSuperclass();<br></code></pre></td></tr></table></figure><h3 id="Constructor-lt-T-gt"><a href="#Constructor-lt-T-gt" class="headerlink" title="Constructor&lt;T&gt;"></a>Constructor&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Integer&gt; clazz = Integer.class;<br>Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="hljs-type">int</span>.class);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cons.newInstance(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><h3 id="声明与创建泛型数组"><a href="#声明与创建泛型数组" class="headerlink" title="声明与创建泛型数组"></a>声明与创建泛型数组</h3><p>我们可以声明带泛型的数组，但是不能直接使用new操作符创建带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt;[] ps = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ok</span><br>Pair&lt;String&gt;[] ps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;String&gt;[<span class="hljs-number">2</span>]; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>要创建带泛型的数组需要强制转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><h3 id="使用泛型数组"><a href="#使用泛型数组" class="headerlink" title="使用泛型数组"></a>使用泛型数组</h3><p>不安全的使用泛型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>[<span class="hljs-number">2</span>];<br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>ps[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;String&gt;(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Integer&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// ClassCastException:</span><br>Pair&lt;String&gt; p = ps[<span class="hljs-number">1</span>];<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> p.getFirst();<br></code></pre></td></tr></table></figure><blockquote><p>数组实际上运行期没有泛型，编译器可以强制检查变量ps，因为它的类型是泛型数组。</p><p>但是编译器不会检查便变量arr，因为它不是泛型数组。</p><p>但是arr和ps实际都指向同一个数组，操作arr没有泛型数组的限制，可能导致从ps获取元素出错。</p></blockquote><p>如果要安全的使用泛型数组，必须扔掉arr的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p> 带泛型的数组实际上是编译器的类型擦除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>[<span class="hljs-number">2</span>];<br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>System.out.println(ps.getClass() == Pair[].class); <span class="hljs-comment">// true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (String) arr[<span class="hljs-number">0</span>].getFirst();<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> ps[<span class="hljs-number">0</span>].getFirst();<br></code></pre></td></tr></table></figure><p>所以我们不能在发行类中直接创建泛型数组T[]，因为擦拭后代码变为Object[]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abc</span>&lt;T&gt; &#123;<br>    T[] createArray() &#123;<br>        <span class="hljs-comment">// compile error</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">5</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同创建T实例一样，创建泛型数组也需要借助Class&lt;T&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T[] createArray(Class&lt;T&gt; cls) &#123;<br>    <span class="hljs-keyword">return</span> (T[]) Array.newInstance(cls, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以在静态方法中使用泛型可变参数来创建泛型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayHelper</span> &#123;<br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br><br>String[] ss = ArrayHelper.asArray(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>Integer[] ns = ArrayHelper.asArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>使用泛型可变参数创建泛型数组这种方法很危险：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] arr = asArray(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// ClassCastException:</span><br>        String[] firstTwo = pickTwo(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        System.out.println(Arrays.toString(firstTwo));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;<br>        <span class="hljs-keyword">return</span> asArray(k1, k2);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接通过类调用asArray静态方法没有问题。但是在类的另一个静态方法pickTwo中调用asArray，则会抛出异常ClassCastExeption。</p><p>因为泛型擦除，在pickTwo方法内部K被擦除为Object，所以k1和k2都是Object类型数据，那么将k1和k2传入asArray方法返回的就是Object[]数组。</p><p>编译器对所有的可变泛型参数都会发出警告。除非确认完全没有问题，才可以使用@SafeVarargs消除警告。</p></Integer></T></T></T></Integer></Integer>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解</title>
    <link href="/2022/10/25/%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/10/25/%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、注解简介"><a href="#一、注解简介" class="headerlink" title="一、注解简介"></a>一、注解简介</h1><h2 id="什么是注解（Annotation）？"><a href="#什么是注解（Annotation）？" class="headerlink" title="什么是注解（Annotation）？"></a>什么是注解（Annotation）？</h2><blockquote><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p><p>注解会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此注解是一种用作标注的“元数据”</p></blockquote><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p><p>注解可以根据其生命周期分为三类：</p><ul><li><p>仅编译器（由编译器使用的注解）</p><blockquote><p>@Override：让编译器检查该方法是否正确地实现了覆写</p><p>@SuppressWarnings：告诉编译器忽略此处代码产生地警告</p><p>这类注解不会被编译进入.class文件，它们只在编译的时候起作用。</p></blockquote></li><li><p>仅class文件（由工具处理.class文件使用的注解）</p><blockquote><p>有些工具会在加载class的时候，对class做动态修改，实现一些功能。</p><p>这些注解会被编译进入.class文件，但加载结束后并不会存在内存中。</p><p>这类注解只被一些底层库使用，一般我们不必自己处理。</p></blockquote></li><li><p>运行期（在程序运行期能够读取的注解）</p><blockquote><p>这类注解在加载后一直存在于JVM中，这也是最常用的注解。</p><p>例如：一个配置了@PostConstruct的方法会在调用构造方法后被自动调用（这是Java代码读取该注解实现的功能，JVm并不会识别该注解）</p></blockquote></li></ul><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>配置参数:</p><blockquote><p>定义一个注解的时候，可以定义配置参数，可以设置默认值。</p></blockquote><p>配置参数类型：</p><blockquote><p>配置参数可以包括：基本类型、String、Classs以及枚举的数组。</p><p>因为配置参数必须是常量，限制配置参数为以上类型，就保证了其为常量。</p></blockquote><p>使用注解：</p><blockquote><p>因为注解的配置参数可以有默认值。所以说使用注解的时候，若某个参数没有传入值，则使用默认参数。</p><p>所有注解都会有一个名为value的配置参数，如果说直写常量，相当于是给value传参。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-meta">@Check(min=0, max=100, value=55)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-meta">@Check(value=99)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> p;<br><br>    <span class="hljs-meta">@Check(99)</span> <span class="hljs-comment">// @Check(value=99)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> x;<br><br>    <span class="hljs-meta">@Check</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、定义注解"><a href="#二、定义注解" class="headerlink" title="二、定义注解"></a>二、定义注解</h1><blockquote><p>Java语言使用@interface语法来定义注解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解的参数类似无参方法，可以用default设定一个默认值。最常用的参数应当命名为value</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><blockquote><p>有一些注解可以修饰其他注解，这些注解就称为元注解。</p></blockquote><p>Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h3 id="Target（最常用）"><a href="#Target（最常用）" class="headerlink" title="@Target（最常用）"></a>@Target（最常用）</h3><blockquote><p>@Target可以定义Annotation能够被应用于源码的哪些位置。</p></blockquote><p>不同参数代表被修饰的注解可以使用的位置：</p><ul><li>类或接口：ElementType.TYPE</li><li>字段：ElementType.FIELD</li><li>方法：ElementType.METHOD</li><li>构造方法：ElementType.CONSTRUCTOR</li><li>方法参数：ElementType.PARAMETER</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义@Report可以用在方法或字段上</span><br><span class="hljs-meta">@Target(&#123;</span><br><span class="hljs-meta">    ElementType.METHOD,</span><br><span class="hljs-meta">    ElementType.FIELD</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//定义@Report可用在方法上</span><br><span class="hljs-comment">//实际上@Target定义value是ElementType[]数组，只有一个元素的时候，可以省略数组的写法</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Retention（必备）"><a href="#Retention（必备）" class="headerlink" title="@Retention（必备）"></a>@Retention（必备）</h3><blockquote><p>@Retention定义了Anotation的生命周期。</p></blockquote><ul><li>仅编译器：RetentionPolicy.SOURCE</li><li>仅class文件：RetentionPolicy.CLASS</li><li>运行期：RetentionPolicy.RUNTIME</li></ul><p>如果没有@Retention，默认该Annotation生命周期为CLASS。</p><p>注意：因为我们自定义的Annotation都是RUNTIME，多以在自定义注解的时候一定要加上@Retention(RetentionPolicy.RUNTIME)这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Repeatable（不常用）"><a href="#Repeatable（不常用）" class="headerlink" title="@Repeatable（不常用）"></a>@Repeatable（不常用）</h3><blockquote><p>@Repeatable定义了Annotaion是否可以重复。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(Reports.class)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Reports &#123;<br>    Report[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Peport注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Report(type=1, level=&quot;debug&quot;)</span><br><span class="hljs-meta">@Report(type=2, level=&quot;warning&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><blockquote><p>使用@Inherited定义子类是否可以继承父类定义的Annotation。</p><p>注意：@Inherited仅针对@Target(ElementType.Type)类型的annotation有效，并且仅针对class的继承，对interface的继承无效。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果一个类用到了@Report：</span><br><span class="hljs-meta">@Report(type=1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br><span class="hljs-comment">//它的子类默认也定义了该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何定义Annotation"><a href="#如何定义Annotation" class="headerlink" title="如何定义Annotation"></a>如何定义Annotation</h2><p>步骤一、用@interface定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤二、添加参数、默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤三、用元注解注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Target、@Retention必须设置</span><br><span class="hljs-comment">//@Inherited、@Repeatable一般不需要</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、处理注解"><a href="#三、处理注解" class="headerlink" title="三、处理注解"></a>三、处理注解</h1><p>Java的注解对代码逻辑没有任何影响。</p><p>根据@Retention的配置：</p><ul><li>SOURCE类型的注解在编译器结束就被丢弃（只使用）</li><li>CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM（由底层工具库使用）</li><li>RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序（经常使用，且还需要编写）</li></ul><p>SOURCE和CLASS类型的注解不需要我们编写。所以说，我们只讨论如何读取RUNTIME类型的注解。</p><h2 id="读取注解"><a href="#读取注解" class="headerlink" title="读取注解"></a>读取注解</h2><blockquote><p>因为注解定义后也是一种class，说有注解都继承自java.lang.annotation.Annotation，因此读取注解，需要使用反射API。</p></blockquote><p>Class、Field、Method哈Constructor这几个类都实现了Annotation相关的反射API。</p><ul><li><p>isAnnotationPresent(Class)：判断某注解是否存在</p><blockquote><p>返回boolean类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断@Report是否存在于Person类:</span><br>Person.class.isAnnotationPresent(Report.class);<br></code></pre></td></tr></table></figure></li><li><p>getAnnotation(Class)：使用反射获取Annotation</p><blockquote><p>如果某注解不存在，使用getAnnotion获取会返回null。</p><p>所以在使用getAnnotation前，可以使用isAnnotationPresent来判断注解是否存在</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Person定义的@Report注解:</span><br><span class="hljs-type">Report</span> <span class="hljs-variable">report</span> <span class="hljs-operator">=</span> Person.class.getAnnotation(Report.class);<br><span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> report.type();<br><span class="hljs-type">String</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> report.level();<br></code></pre></td></tr></table></figure></li></ul><p>上面的示例是获取Class的注解，但是对于方法而言，方法本身可以有注解，方法的参数也可以有注解。</p><ul><li><p>获取方法本身的注解</p><blockquote><p> 和获取Class的注解一样，对Mehod对象调用对应方法即可。</p></blockquote></li><li><p>获取方法参数的注解</p><blockquote><p>因为方法可以有多个参数，每个参数可以有多个注解。所以说获取方法参数的注解需要一个二维数组。</p></blockquote><p>方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-meta">@Range(max=5)</span> String name, <span class="hljs-meta">@NotNull</span> String prefix)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取方法参数的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Method实例:</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ...<br><span class="hljs-comment">// 获取所有参数的Annotation:</span><br>Annotation[][] annos = m.getParameterAnnotations();<br><span class="hljs-comment">// 第一个参数（索引为0）的所有Annotation:</span><br>Annotation[] annosOfName = annos[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (Annotation anno : annosOfName) &#123;<br>    <span class="hljs-keyword">if</span> (anno <span class="hljs-keyword">instanceof</span> Range) &#123; <span class="hljs-comment">// @Range注解</span><br>        <span class="hljs-type">Range</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Range) anno;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anno <span class="hljs-keyword">instanceof</span> NotNull) &#123; <span class="hljs-comment">// @NotNull注解</span><br>        <span class="hljs-type">NotNull</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (NotNull) anno;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用注解-1"><a href="#使用注解-1" class="headerlink" title="使用注解"></a>使用注解</h2><p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。</p><h4 id="来看一个-Range注解的例子："><a href="#来看一个-Range注解的例子：" class="headerlink" title="来看一个@Range注解的例子："></a>来看一个@Range注解的例子：</h4><p>我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义</p><p><strong>@Range注解定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Range &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">255</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用@Range注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Range(min=1, max=20)</span><br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-meta">@Range(max=10)</span><br>    <span class="hljs-keyword">public</span> String city;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面只是定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。</p><p>我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(Person person)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException,ReflectiveOperationException &#123;<br>    <span class="hljs-comment">// 遍历所有Field:</span><br>    <span class="hljs-keyword">for</span> (Field field : person.getClass().getFields()) &#123;<br>        <span class="hljs-comment">// 获取Field定义的@Range:</span><br>        <span class="hljs-type">Range</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> field.getAnnotation(Range.class);<br>        <span class="hljs-comment">// 如果@Range存在:</span><br>        <span class="hljs-keyword">if</span> (range != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 获取Field的值:</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.get(person);<br>            <span class="hljs-comment">// 如果值是String:</span><br>            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) value;<br>                <span class="hljs-comment">// 判断值是否满足@Range的min/max:</span><br>                <span class="hljs-keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid field: &quot;</span> + field.getName());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/10/25/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/25/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>处理int等基本类型外，Java的其他类型全部都是class（包括interface）。</p><p>例如：</p><ul><li>String</li><li>Object</li><li>Runable</li><li>Exception</li><li>…</li></ul><p>所以说class的本质就是数据类型（Type）。无继承关系的数据类型无法赋值。</p><h2 id="class动态加载"><a href="#class动态加载" class="headerlink" title="class动态加载"></a>class动态加载</h2><p>class由JVM在执行过程中动态加载。JVM在第一次读取到一种class类型时，将其加载进内存。每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。</p><p>注意：这里的Class类型是一个名叫Class的class。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Class</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以String类为例。当JVM加载String类时，它首先读取String.class文件到内存，然后为String类创建一个Class实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>(String);<br></code></pre></td></tr></table></figure><p>这个Class实例时JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法为private，<strong>只有JVM能创建Class实例</strong>，我们自己的Java程序是无法创建Class实例的。</p><p>所以JVM持有的每个Class实例都指向一个数据类型（Class或interface）：</p><p><img src="/2022/10/25/%E5%8F%8D%E5%B0%84/image-20221025203443827.png" alt="image-20221025203443827"></p><p>一个Class实例包含了该class的所有完整信息：</p><p><img src="/2022/10/25/%E5%8F%8D%E5%B0%84/image-20221025203520398.png" alt="image-20221025203520398"></p><p>JVM动态加载特性：程序执行的时候，当JVM发现需要使用到某个类的时候，才会首次加载该类。</p><p>动态加载class的特性对于Java程序非常重要。利用JVM动态加载class的特性，我们才能在运行期根据不同条件加载不同的实现类。</p><p>例如：Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。</p><p>利用JVM动态加载的特性，大致实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">/ Commons Logging优先使用Log4j:<br><span class="hljs-type">LogFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (isClassPresent(<span class="hljs-string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;<br>    factory = createLog4j();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    factory = createJdkLog();<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isClassPresent</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class.forName(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等。因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。</p><p><strong>这种通过Class实例获取class信息的方法称为反射（Reflection）</strong>。</p><p>获取Class实例的方法：</p><ul><li><p>通过class的静态变量class获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> String.class;<br></code></pre></td></tr></table></figure></li><li><p>通过实例变量的getClass()方法获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> s.getClass();<br></code></pre></td></tr></table></figure></li><li><p>根据class的完成类名，通过静态方法Class.forName()获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>因为Class实例在JVM中是唯一的，所以不同方法获取的Class实例是同一个。</p><p><strong>Class实例和instanceof的区别：</strong></p><ul><li>instanceof不但匹配指定的类型，还匹配指定类型的子类</li><li>使用&#x3D;&#x3D;判段class实例可以精确地判断数据类型，不能做子类型比较</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Integer; <span class="hljs-comment">// true，因为n是Integer类型</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Number; <span class="hljs-comment">// true，因为n是Number类型的子类</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> n.getClass() == Integer.class; <span class="hljs-comment">// true，因为n.getClass()返回Integer.class</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> n.getClass() == Number.class; <span class="hljs-comment">// false，因为Integer.class!=Number.class</span><br></code></pre></td></tr></table></figure><p>二者的使用场景：</p><p>通常情况下，我们使用instanceof判断数据类型，因为面向抽象编程地时候，我们不关心具体地子类型。</p><p>当需要精确判断一个类型是不是某个class的时候，我们才使用&#x3D;&#x3D;来判断class实例。</p><p><strong>通过Class实例创建对应类型的实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取String的Class实例:</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-comment">// 创建一个String实例:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) cls.newInstance();<br></code></pre></td></tr></table></figure><p>上述代码相当于new String()。</p><p>通过Class.nweInstance()可以创建类实例，但是它只能调用public的无参构造方法。</p><h1 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h1><h2 id="获取字段信息"><a href="#获取字段信息" class="headerlink" title="获取字段信息"></a>获取字段信息</h2><p>通过Class实例获取字段信息的方法：</p><ul><li>Field getField(name)：根据字段名获取当前类某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getField()：获取所有的public的field（包括父类）</li><li>Field[] get DeclaredFields()：获取所有的field（不包括父类）</li></ul><p>Field对象包含一个字段的所有信息：</p><ul><li>getName()：返回字段名称。返回值为String</li><li>getType()：返回字段类型。返回值也是一个Class实例</li><li>int getModifiers()：返回字段的修饰符。返回值是一个int，不同bit表示不同的含义</li></ul><p>以String的value字段为例，获取其字段信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//String的value字段定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value;<br>&#125;<br><span class="hljs-comment">//获取该字段信息</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> String.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>f.getName(); <span class="hljs-comment">// &quot;value&quot;</span><br>f.getType(); <span class="hljs-comment">// class [B 表示byte[]类型</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> f.getModifiers();<br>Modifier.isFinal(m); <span class="hljs-comment">// true</span><br>Modifier.isPublic(m); <span class="hljs-comment">// false</span><br>Modifier.isProtected(m); <span class="hljs-comment">// false</span><br>Modifier.isPrivate(m); <span class="hljs-comment">// true</span><br>Modifier.isStatic(m); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h2><p><strong>获取字段值的步骤：</strong></p><ol><li>通过实例对象获取Class实例</li><li>由Class实例获取字段对应的Field</li><li>使用获取的Field获取实例对象的字段值</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>);<br>        <span class="hljs-comment">//1. 获取Class</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClass();<br>        <span class="hljs-comment">//2. 获取Field</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//3. 获取字段值</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> f.get(p);<br>        System.out.println(value); <span class="hljs-comment">// &quot;Xiao Ming&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//private无法通过Field获取值</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码执行会抛出IllegalAccessException异常。因为name字段的访问权限时private，正常情况下Main类无法访问Person类的private字段。</p><p>若想要访问实例对象的private字段，则可以先对Field对象执行setAccessible(true)方法，该方法的意思是，不管这个字段的访问权限如何，一律允许访问。</p><p><strong>反射破坏封装：</strong></p><p>通过反射，可以获取对象的private字段的值，这破坏了类的封装。</p><p>既然反射和可以破坏封装，那么封装的意义在哪儿？</p><ul><li>正常情况下，我们总是通过p.name来访问Person的name字段，编译器会根据字段的访问权限来决定是否允许访问字段，这就达到了数据封装的目的。</li><li>而反射是一种非常规的用法，使用反射获取字段值，首先代码繁琐，其次，它更多地是给工具或者底层框架来使用的，目的是在不知道目标实例对象任何信息的情况下，获取特定字段的值。</li><li>setAccessible(true)不是一定成功。如果JVM运行期存在SecurityManager，那么它会根据队则进行检查，可能会阻止对某些类（例如以java和javax开头的package中的类）调用setAccessible(true)，这样可以保证JVM核心库的安全</li></ul><h2 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h2><p>设置字段的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Field.set(Object, Object)<br></code></pre></td></tr></table></figure><ul><li>第一个Object参数是指定需要修改字段值的实例对象</li><li>第二个Object参数是要设置的字段值</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>);<br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Xiao Ming&quot;</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClass();<br>        <br>        <span class="hljs-comment">//获取Field、设置访问权限、设置字段值</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        f.set(p, <span class="hljs-string">&quot;Xiao Hong&quot;</span>);<br>        <br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Xiao Hong&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h1><h2 id="获取Method"><a href="#获取Method" class="headerlink" title="获取Method"></a>获取Method</h2><p>Class类中获取Mehod的方法：</p><blockquote><p>这些方法的含义同上面获取字段方法的含义基本相同。</p><p>name为方法名字</p><p>Class为方法参数对应的Class实例</p></blockquote><ul><li>Method getMehod(name, Class…)</li><li>Method getDeclaredMethod(name, Class…)</li><li>Method getMehods()</li><li>Method get DeclaredMethods()</li></ul><p>Method对象包含一个方法的所有信息：</p><ul><li>String getName()</li><li>Class getReturnType()</li><li>Class[] getParameterTypes()</li><li>int getModifiers()</li></ul><h2 id="通过Method调用方法"><a href="#通过Method调用方法" class="headerlink" title="通过Method调用方法"></a>通过Method调用方法</h2><h3 id="调用普通方法"><a href="#调用普通方法" class="headerlink" title="调用普通方法"></a>调用普通方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-comment">//--常规调用--</span><br><span class="hljs-type">String</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">6</span>); <span class="hljs-comment">// &quot;world&quot;</span><br><br><span class="hljs-comment">//--反射调用--</span><br><span class="hljs-comment">// 获取String substring(int)方法，参数为int:</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> String.class.getMethod(<span class="hljs-string">&quot;substring&quot;</span>, <span class="hljs-type">int</span>.class);<br><span class="hljs-comment">// 在s对象上调用该方法并获取结果:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (String) m.invoke(s, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>对Mehod实例调用invoke就相当于调用该方法</p><ul><li>invoke的第一个参数是对象实例，即在哪个实例上调用该方法</li><li>后面的可变参数要与方法参数一致</li></ul><h3 id="调用静态方法："><a href="#调用静态方法：" class="headerlink" title="调用静态方法："></a>调用静态方法：</h3><p>在调用invoke的时候第一个参数传null即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Integer.parseInt(String)方法，参数为String:</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Integer.class.getMethod(<span class="hljs-string">&quot;parseInt&quot;</span>, String.class);<br><span class="hljs-comment">// 调用该静态方法并获取结果:</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (Integer) m.invoke(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;12345&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="调用非public方法"><a href="#调用非public方法" class="headerlink" title="调用非public方法"></a>调用非public方法</h3><p>通过setAccessible(true)获取访问权限后再调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.getClass().getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        m.setAccessible(<span class="hljs-literal">true</span>);<br>        m.invoke(p, <span class="hljs-string">&quot;Bob&quot;</span>);<br>        System.out.println(p.name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>考察这么一种情况：</p><p>父类Person定义了Hello()方法，并且它的子类也覆写了hello()方法。那么从Person.class获取的Method，作用域Student实例时，调用的方法是Person的hello方法还是Student的hello方法？</p><p>结果：</p><p>通过反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//反射调用方法的代码</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Person.class.getMethod(<span class="hljs-string">&quot;hello&quot;</span>);<br>m.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br><br><span class="hljs-comment">//上述放射代码等价于如下代码</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>p.hello();<br></code></pre></td></tr></table></figure><h1 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h1><p>反射创建实例的方法：</p><ul><li><p>可以通过Class的newInstance方法来反射创建新的实例。但是它只能调用该类的public无参构造方法。</p></li><li><p>如果需要调用类的其他构造方法，那么则需要通过获取Constructor对象来创建实例。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取构造方法Integer(int):</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons1</span> <span class="hljs-operator">=</span> Integer.class.getConstructor(<span class="hljs-type">int</span>.class);<br>        <span class="hljs-comment">// 调用构造方法:</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> (Integer) cons1.newInstance(<span class="hljs-number">123</span>);<br>        System.out.println(n1);<br><br>        <span class="hljs-comment">// 获取构造方法Integer(String)</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons2</span> <span class="hljs-operator">=</span> Integer.class.getConstructor(String.class);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> (Integer) cons2.newInstance(<span class="hljs-string">&quot;456&quot;</span>);<br>        System.out.println(n2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取Constructor也有四种方法，同上面获取Field和Mehtod类似，不再赘述。</p><p>同样调用private的Construcor时，也需要使用setAccessible(true)设置允许访问。</p><p>注意：Constructor总是当前类定义的构造方法，和父类无关（构造方法无法继承和重载），因此不存在多态问题。</p><h1 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h1><h2 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a>获取父类的Class</h2><p>有了Class实例，我们还可以通过该Class实例获取父类的Class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.class;<br>        <span class="hljs-comment">//Integer父类Number</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.getSuperclass();<br>        System.out.println(n);<br>        <span class="hljs-comment">//Number父类Object</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> n.getSuperclass();<br>        System.out.println(o);<br>        <span class="hljs-comment">//Object父类null</span><br>        System.out.println(o.getSuperclass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a>获取interface</h2><h4 id="获取类实现的接口："><a href="#获取类实现的接口：" class="headerlink" title="获取类实现的接口："></a>获取类实现的接口：</h4><p>由于一个类可以实现一个或多个接口，通过Class实例，可以获取类实现的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Integer.class;<br>        <span class="hljs-comment">//interface也是Class</span><br>        Class[] is = s.getInterfaces();<br>        <span class="hljs-keyword">for</span> (Class i : is) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括父类实现的接口类型。</p><h4 id="获取接口的父接口："><a href="#获取接口的父接口：" class="headerlink" title="获取接口的父接口："></a>获取接口的父接口：</h4><p>因为接口可以继承接口，如果要获取接口的父接口，不能对interface的Class实例调用getSuperclass()，获取接口的父接口要用getinterfaces()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(java.io.DataInputStream.class.getSuperclass()); <br><span class="hljs-comment">// 输出java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span><br><br>System.out.println(java.io.Closeable.class.getSuperclass()); <br><span class="hljs-comment">// 输出null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span><br></code></pre></td></tr></table></figure><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>如果需要判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isDouble</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Double; <span class="hljs-comment">// false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isInteger</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Integer; <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isNumber</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Number; <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isSerializable</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> java.io.Serializable; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Integer i = ?</span><br>Integer.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Integer</span><br><span class="hljs-comment">// Number n = ?</span><br>Number.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Number</span><br><span class="hljs-comment">// Object o = ?</span><br>Object.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Object</span><br><span class="hljs-comment">// Integer i = ?</span><br>Integer.class.isAssignableFrom(Number.class); <span class="hljs-comment">// false，因为Number不能赋值给Integer</span><br></code></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><blockquote><p>动态代理（Dynamic Proxy）机制：可以在运行期动态创建某个interface的实例</p></blockquote><p>Java中class和interface的区别：</p><ul><li>class不可实例化</li><li>interface不能实例化</li></ul><h2 id="interface类型变量的获取"><a href="#interface类型变量的获取" class="headerlink" title="interface类型变量的获取"></a>interface类型变量的获取</h2><h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">morning</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><span class="hljs-comment">//编写实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">morning</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Good morning, &quot;</span> + name);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//创建实例，转型为接口调用</span><br><span class="hljs-type">Hello</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorld</span>();<br>hello.morning(<span class="hljs-string">&quot;Bob&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="通过动态代理获取"><a href="#通过动态代理获取" class="headerlink" title="通过动态代理获取"></a>通过动态代理获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1. 定义一个InvocationHandler实例。它负责实现接口的方法调用</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                System.out.println(method);<br>                <span class="hljs-comment">//通过接口方法名，可以对不同的方法执行不同的操作</span><br>                <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;morning&quot;</span>)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Good morning, &quot;</span> + args[<span class="hljs-number">0</span>]);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//2. 通过Proxy.newProxyInstance()创建interface实例</span><br>        <span class="hljs-comment">//3. 并将返回的Object强制转型为接口</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> (Hello) Proxy.newProxyInstance(<br>            <span class="hljs-comment">//ClassLoader。通常就是接口类的ClassLoader</span><br>            Hello.class.getClassLoader(), <br>            <span class="hljs-comment">//传入要实现的接口</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Hello.class &#125;, <br>            <span class="hljs-comment">//传入处理调用方法的InvocationHandler</span><br>            handler);<br>        hello.morning(<span class="hljs-string">&quot;Bob&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">morning</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理实际上是JVM在<strong>运行期动态创建class字节码并加载</strong>的过程。</p><p>上面的动态代理写成静态实现类大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloDynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Hello</span> &#123;<br>    InvocationHandler handler;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloDynamicProxy</span><span class="hljs-params">(InvocationHandler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">morning</span><span class="hljs-params">(String name)</span> &#123;<br>        handler.invoke(<br>           <span class="hljs-built_in">this</span>,<br>           Hello.class.getMethod(<span class="hljs-string">&quot;morning&quot;</span>, String.class),<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; name &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理就是相当于JVM帮我们自动编写了一个上述类（不需要源码，由JVM直接生成字节码）。并不存在什么可以直接实例化接口的方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在程序运行中会出现各种<strong>错误</strong>，例如：</p><ul><li>用户造成的错误：<ul><li>输入错误类型</li><li>程序想要读某个文件，但是已经被用户删除了</li></ul></li><li>随机出现，且无法避免的错误：<ul><li>网络中断</li><li>内存耗尽，程序崩溃</li><li>用户点击“打印”，但是根本没有打印机</li></ul></li></ul><p>一个健壮的程序必须处理各种各样的错误。所谓的错误，就是程序调用某个函数的时候，如果失败，就表示出错。</p><p>程序如何获知调用失败的信息？</p><ul><li><p>方法一：约定返回错误码</p><blockquote><p>预定返回不同的内容表示不同的执行情况。</p></blockquote></li><li><p>方法二：在语言层面上提供一个异常处理机制</p><blockquote><p>Java内置了一层异常处理机制，总是使用异常来表示错误。</p><p>异常是一种class，因此它本身带有类型信息。</p><p>异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离。</p></blockquote></li></ul><h2 id="Java异常继承关系"><a href="#Java异常继承关系" class="headerlink" title="Java异常继承关系"></a>Java异常继承关系</h2><p><img src="/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20221024215512715.png" alt="image-20221024215512715"></p><ul><li>Throwable<ul><li><strong>Error：严重错误，程序一般无法处理</strong><ul><li>OutOfMemoryError：内存耗尽</li><li>NoClassDefFoundError：无法加载某个Class</li><li>StackOverflowError：栈溢出</li></ul></li><li><strong>Exception：运行时错误，可以被捕获并处理</strong><ul><li><strong>RuntimeException：程序逻辑错误，需要修复程序本身</strong><ul><li>NullPointerException</li><li>IndexOutOfBoundsException</li><li>IllegalArgumentException<ul><li>NumberFormatException：数值类型的格式错误</li></ul></li></ul></li><li><strong>非RuntimeException：这些异常时程序逻辑处理的一部分(编译器强制处理)</strong><ul><li>IOException<ul><li>FileNotFoundException：未找到文件</li><li>SocketException：读取网络失败</li></ul></li></ul></li></ul></li></ul></li></ul><p>Java对异常处理的规定：</p><ul><li><p>必须捕获的异常：Checked Exception</p><blockquote><p>包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception</p></blockquote></li><li><p>不需要捕获的异常</p><blockquote><p>包括Error及其子类，RuntimeException及其子类</p></blockquote></li></ul><h1 id="异常的抛出、传播和捕获"><a href="#异常的抛出、传播和捕获" class="headerlink" title="异常的抛出、传播和捕获"></a>异常的抛出、传播和捕获</h1><h2 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h2><p>如果说程序出现了需要抛出异常的情况，可以抛出异常，分为两步：</p><ul><li>new一个Excepion实例</li><li>使用throw语句抛出</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span> <span class="hljs-keyword">throws</span> NumberFormatException &#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(<span class="hljs-string">&quot;null&quot;</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>throw和throws：</p><ul><li><p>方法通过throw<strong>抛出</strong>异常实例</p></li><li><p>throws<strong>声明</strong>方法可能会抛出的异常</p></li></ul><h2 id="异常的传播与捕获"><a href="#异常的传播与捕获" class="headerlink" title="异常的传播与捕获"></a>异常的传播与捕获</h2><p>catch异常过后，可以选择处理异常，也可以选择再抛出。再次抛出可以使用另一个异常将原始的异常封装。即新建异常时，将原始异常作为参数传入。也可以直接原封不动地抛出。</p><p>异常传播示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-comment">//捕获并处理异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process1();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//捕获异常，并抛出</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process2();<br>        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(e);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//源头抛出异常</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>异常的栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以从栈信息中查看到完成的方法调用链</span><br><br><span class="hljs-comment">//第二次被抛出时的异常信息</span><br>java.lang.IllegalArgumentException: java.lang.NullPointerException<br>    at Main.process1(Main.java:<span class="hljs-number">15</span>)<br>    at Main.main(Main.java:<span class="hljs-number">5</span>)<br><span class="hljs-comment">//原始异常信息</span><br>Caused by: java.lang.NullPointerException<br>    at Main.process2(Main.java:<span class="hljs-number">20</span>)<br>    at Main.process1(Main.java:<span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure><h2 id="关于finally"><a href="#关于finally" class="headerlink" title="关于finally"></a>关于finally</h2><ul><li><p>在try…catch…finally代码块中不论是否捕获异常，finally代码块都会执行。</p></li><li><p>若在finally代码块中抛出异常，那么原来在catch中准备抛出的异常就会丢失。</p><blockquote><p>如何解决：</p><p>在finally代码块中，新建异常后，使用addSuppressed方法将catch中捕获的异常填进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Exception</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Integer.parseInt(<span class="hljs-string">&quot;abc&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            origin = e;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>            <span class="hljs-keyword">if</span> (origin != <span class="hljs-literal">null</span>) &#123;<br>                e.addSuppressed(origin);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>绝大多数情况不要在finally中抛出异常。</p></blockquote></li></ul><p>finally中的代码在什么时候执行：</p><p>如果try、catch中没有return语句的话，finally中的代码就相当于添加到try和catch代码块的末尾。</p><p>如果说有return，那么finally中的代码在return前执行，准确的说是被return的代码执行完毕，return前。</p><p>例如：return i++;</p><p>执行的步骤，先执行i++获取最终需要return的值，然后执行return。finally代码块就是在i++执行完毕后，return前执行。</p><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>当需要在代码中抛出异常时，尽量使用JDK已定义的异常类型。</p><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系很重要。</p><p>常见的自定义异常做法：</p><ol><li><p>自定义一个BaseException作为“根异常”，然后派生出各种业务类型的异常。</p></li><li><p>BaseException需要从一个合适的Exception派生，通常从RuntimeException派生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(String message, Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其他的业务类型的异常就可以从BaseException派生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseException</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginFailedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseException</span> &#123;<br>&#125;<br><br>...<br></code></pre></td></tr></table></figure></li></ol><p>从RuntimeException继承BaseException的原因：不需要强制try catch</p><h1 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>在所有的RumtimeException异常中，NullPointerException时最常碰到的。</p><p>NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常时由JVM抛出的。（指针这个概念来自C语言，Java语言中并无指针。我们定义的变量实际上是引用，Null Pointer更确切地来说是Null Reference，不过二者区别不大）</p><h2 id="处理NPE"><a href="#处理NPE" class="headerlink" title="处理NPE"></a>处理NPE</h2><p>首先明确NullPointerException是一种代码逻辑错误，遇到NPE，遵循原则是早暴露，早修复，严禁使用try catch来隐藏这种编码错误。</p><p>异常分为两种：</p><ul><li>一种是代码的逻辑错误，需要修复代码。比如一个String为null，然后调用了String的方法。</li><li>另一种是无法避免的外界错误。比如尝试连接网络，网络连接失败，这种异常是代码逻辑的一部分，需要在代码中try catch处理这种异常</li></ul><p>好的编码习惯可以降低NPE的产生，例如：</p><ul><li><p>在成员变量定义的时候初始化</p></li><li><p>使用空字符串””，而不是默认的null</p></li><li><p>使用空数组，而不是默认的null</p></li></ul><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Math.abs(-<span class="hljs-number">123.45</span>);<br>    <span class="hljs-keyword">assert</span> x &gt;= <span class="hljs-number">0</span>;<br>    System.out.println(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>assert x &gt;&#x3D; 0 即为断言，断言预期x &gt;&#x3D; 0 为true。如果计算结果为false，则断言失败，抛出AssertionError。</p><blockquote><p>使用assert语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">assert</span> x &gt;= <span class="hljs-number">0</span> : <span class="hljs-string">&quot;x must &gt;= 0&quot;</span>;<br></code></pre></td></tr></table></figure><p>在抛出异常的时候会带上消息“x must &gt;&#x3D; 0”，更加方便调试</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Java断言的特点：断言失败会抛出AssertionError异常，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开法和测试阶段。</p><p>例如：</p><p>可恢复的程序错误，不应该使用断言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">assert</span> arr != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;array cannot be null&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JVM默认关闭断言指令，遇到assert语句就自动忽略了，不执行。</p><p>要执行assert语句，必须给Java虚拟机传递-enableassertions（简写-ea）参数启动断言。</p><p><strong>注意：在实际开发中很少使用断言。更好的方法是编写单元测试。</strong></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="JDK-Logging"><a href="#JDK-Logging" class="headerlink" title="JDK Logging"></a>JDK Logging</h2><h3 id="日志简介"><a href="#日志简介" class="headerlink" title="日志简介"></a>日志简介</h3><p>没有日志系统时的错误排查过程：</p><blockquote><p>在编写程序的过程中，发现程序运行结果于预期不符合，怎么半？</p><p>使用System.out.println()打印出执行过程中的某些变量，观察每一步的结果于代码逻辑是否符合，然后有针对性地修改代码。</p><p>代码修改好了，然后删除没用地System.out.println()语句。</p><p>又出问题了，再加上System.out.println()语句。</p></blockquote><p>日志的引入：</p><blockquote><p>反复的Sytem.out.println()语句插入与删除，非常麻烦，所以就引入了日志（Logging），它地目的就是为了取代System.out.println()。</p></blockquote><p>输出日志，而不是System.out.println()的好处：</p><ul><li>可以设置输出样式。避免自己重复写”Error: “ + var</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志</li><li>可以重定向到文件。这样可以再程序运行结束后查看日志</li><li>可以按包名控制日志级别。只输出某些包的日志</li></ul><h3 id="如何使用日志"><a href="#如何使用日志" class="headerlink" title="如何使用日志"></a>如何使用日志</h3><p>Java标准库内置了日志包：java.util.logging，我们可以直接使用。</p><p>简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getGlobal();<br>        logger.info(<span class="hljs-string">&quot;start process...&quot;</span>);<br>        logger.warning(<span class="hljs-string">&quot;memory is running out...&quot;</span>);<br>        logger.fine(<span class="hljs-string">&quot;ignored.&quot;</span>);<br>        logger.severe(<span class="hljs-string">&quot;process will be terminated...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Mar <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br>INFO: start process...<br>Mar <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br>WARNING: memory is running out...<br>Mar <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br>SEVERE: process will be terminated...<br></code></pre></td></tr></table></figure><p>日志包含的信息：时间、调用类、调用方法等</p><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>在上面的例子中，4条日志，只打印了3条，logger.fine()没有打印。这是因为，日志的输出可以设定级别。</p><p>JDK的Logging定义了7个日志级别，从严重到普通：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINERST</li></ul><p>因为默认的级别是INFO，因此，INFO级别一下的日志，不会被打印出来。</p><p>使用日志级别的好处在于：调整日志级别就可以屏蔽掉很多调式无关的日志输出。</p><h3 id="内置Logging的局限"><a href="#内置Logging的局限" class="headerlink" title="内置Logging的局限"></a>内置Logging的局限</h3><ul><li>Loggin系统在JVM启动时读取配置文件并完成初始化，一旦开始运行mian()方法，就无法修改配置</li><li>配置不方便，需要在JVM启动时传参：-Djava.util.logging.config.file&#x3D;&lt;config-file-name&gt;</li></ul><h2 id="Commens-Logging"><a href="#Commens-Logging" class="headerlink" title="Commens Logging"></a>Commens Logging</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>和Java标准库提供的日志不同，Commens Logging是一个第三方日志库，它是由Apache创建的日志模块。</p><p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commens Logging自动搜索并使用Log4j，如果没有找到Log4j，再使用JDK logging。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p><ul><li><p>第一步：通过LogFactory获取Log类的实例</p></li><li><p>第二步：使用Log实例的方法打日志</p></li></ul><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//因为Commons Logging是第三方提供的库，所以要在工程中导入Jar包才能正常使用。</span><br><span class="hljs-comment">//commons-logging-1.2.jar</span><br><span class="hljs-keyword">import</span> org.apache.commons.logging.Log;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory.getLog(Main.class);<br>        log.info(<span class="hljs-string">&quot;start...&quot;</span>);<br>        log.warn(<span class="hljs-string">&quot;end.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Commons Logging定义的六个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO ：默认</li><li>DEBUG</li><li>TRACE</li></ul><p>使用Commons Logging时，如果在静态方法中引用Log，通常直接定义一个静态类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在静态方法中引用Log:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory.getLog(Main.class);<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实例方法中引用Log，通常定义一个实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在实例方法中引用Log:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory.getLog(getClass());<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到：实例变量log的获取方式是LogFactory.getLog(getClass())，而不是LogFactory.getLog(Person.class)。这样的好处在于，子类继承Person类后，继承其属性log，所以在子类中可以直接使用该log实例，无需改动代码。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在子类中使用父类实例化的log:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;bar&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Java类的动态特性，LogFactory.getLog(getClass())，在父类中相当于LogFactory.getLog(Person.class)，在子类中相当于LogFactory.getLog(Student.class)</p><p>Commeons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    log.error(<span class="hljs-string">&quot;got exception!&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Log4Jj"><a href="#Log4Jj" class="headerlink" title="Log4Jj"></a>Log4Jj</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Commons Logging可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p><p>Log4j是一种非常流行的日志框架，它是一个组件化设计的日志系统。</p><p>其框架大概如下：</p><p><img src="/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20221025114909589.png" alt="image-20221025114909589"></p><ol><li>Appender：</li></ol><p>当使用Log4j输出一条日志时，Log4j自动通过不同的Appender把一条日志输出到不同的目的地。</p><ul><li>console：输出到屏幕</li><li>file：输出到文件</li><li>socket：通过网络输出到远程计算机</li><li>jdbc：输出到数据库</li></ul><ol start="2"><li>Filter：</li></ol><p>在输出日志的过程中，通过Filter来过滤那些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志</p><ol start="3"><li>Layout：</li></ol><p>最后通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><p>在实际的使用中不需要关心Log4j的API，而是通过配置文件来配置它。</p><p>以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。</p><p>配置文件示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义日志格式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义文件名变量 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义Appender，即目的地 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到屏幕 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">bufferedIO</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1 MB&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 保留最近10份 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置Log4j比较繁琐，但是一旦配置完成，使用起来就非常方便。</p><h4 id="Jar包导入："><a href="#Jar包导入：" class="headerlink" title="Jar包导入："></a>Jar包导入：</h4><p>Log4j是一个第三方库，所以使用前需要导入其jar包：</p><ul><li>log4j-api-2.x.jar</li><li>log4j-core-2.x.jar</li><li>log4j-jcl-2.x.jar</li></ul><p>因为Commens Logging会自动发现并使用Log4j，所以还需要导入</p><ul><li>commons-logging-1.2.jar</li></ul><h4 id="使用日志"><a href="#使用日志" class="headerlink" title="使用日志"></a>使用日志</h4><p>只需要按照Commons Logging的写法，不需要改动任何代码，就可以得到Log4j的日志输出。</p><p>在开发阶段，始终使用Commens Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件，只需要把正确的配置文件和Log4j相关的jar包导入，就可以把日志自动换成Log4j写入，无需修改任何代码。</p><h2 id="SLF4J和Logback"><a href="#SLF4J和Logback" class="headerlink" title="SLF4J和Logback"></a>SLF4J和Logback</h2><p>前面的Commons Logging和Log4j，他们一个充当日志API，一个负责实现日志底层实现。而SLF4J和Logback也是类似的关系。</p><h3 id="SLF4J对比Commens-Logging接口"><a href="#SLF4J对比Commens-Logging接口" class="headerlink" title="SLF4J对比Commens Logging接口"></a>SLF4J对比Commens Logging接口</h3><h4 id="字符串拼接的改进"><a href="#字符串拼接的改进" class="headerlink" title="字符串拼接的改进"></a>字符串拼接的改进</h4><p>在Commens Logging中是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br>p.setScore(score);<br>log.info(<span class="hljs-string">&quot;Set score &quot;</span> + score + <span class="hljs-string">&quot; for Person &quot;</span> + p.getName() + <span class="hljs-string">&quot; ok.&quot;</span>);<br></code></pre></td></tr></table></figure><p>SLF4J中是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br>p.setScore(score);<br>logger.info(<span class="hljs-string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());<br></code></pre></td></tr></table></figure><p>SLF4J传入带占位符的字符串，使用后面的变量自动替换占位符，使用起来更加自然。</p><h3 id="接口对比"><a href="#接口对比" class="headerlink" title="接口对比"></a>接口对比</h3><p><img src="/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20221025171850623.png" alt="image-20221025171850623"></p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ol><li>使用也同Commons加Log4J类似，需要先导入对应的包：</li></ol><ul><li>slf4j-api-1.7.x.jar</li><li>logback-classic-1.2.x.jar</li><li>logback-core-1.2.x.jar</li></ul><ol start="2"><li>同样需要导入一个Logback的配置文件：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>log/output.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>1MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>代码中调用：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(getClass());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-生产者与消费者问题</title>
    <link href="/2022/10/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者模式可以让我们加深对并发编程的理解。</p><p>所谓的生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一类是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据后直接放置在共享数据区中，不需要关心消费者的行为，而消费者只需要从共享数据区中去获取数据，就不再需要去关心生产者的行为。</p><p>这个共享数据区中应该具备这样的线程间并发协作的功能：</p><ul><li>如果共享数据区已满的话，阻塞生产者继续生产数据放置入内</li><li>如果共享数据区为空的话，阻塞消费者继续消费数据</li></ul><p>生产者-消费者的实现有下面三种方式：</p><ul><li>使用Object的wait&#x2F;notify的消息通知机制</li><li>使用Lock的Condition的await&#x2F;signal的消息通知机制</li><li>使用BlockingQueue实现</li></ul><h1 id="wait-x2F-notify的消息通知机制"><a href="#wait-x2F-notify的消息通知机制" class="headerlink" title="wait&#x2F;notify的消息通知机制"></a>wait&#x2F;notify的消息通知机制</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li><p>wait ()</p><blockquote><ul><li><p>该方法用来将当前线程置入休眠状态，直到接收到通知或被中断为止</p></li><li><p>只能在同步方法或同步块中调用wait()方法。</p><blockquote><p>在调用wait()方法之前，线程必须要获得该对象的对象监视器锁，若调用前没有获取锁，则会抛出IllegalMonitorStateException异常，这是个Runtime异常。</p></blockquote></li><li><p>调用wait ()方法之后，当前线程会释放锁。</p></li><li><p>如果再次获取到锁的话，当前线程才能从wait()方法处成功返回</p></li></ul></blockquote></li><li><p>notify()</p><blockquote><ul><li>该方法也需要在同步方法或同步块中调用。</li><li>该方法从等待队列中随机挑选一个处于WAITING状态的线程发出通知，使得被通知的线程由随机队列移入同步队列中，等待有机会再一次获取锁，从而使得调用wait()方法的线程能够从wait()方法处退出。</li><li>调用notify后，当前线程不会马上释放该对象锁，而是要等到程序退出同步块后，当前线程才会释放锁</li></ul></blockquote></li><li><p>notifyAll()</p><blockquote><p>与notify()方法不同的一点在于，notifyAll会通知所有等待线程。</p></blockquote></li></ul><h2 id="wait-x2F-notify潜在的一些问题"><a href="#wait-x2F-notify潜在的一些问题" class="headerlink" title="wait&#x2F;notify潜在的一些问题"></a>wait&#x2F;notify潜在的一些问题</h2><h3 id="问题一、notify早期通知（通知遗漏）"><a href="#问题一、notify早期通知（通知遗漏）" class="headerlink" title="问题一、notify早期通知（通知遗漏）"></a>问题一、notify早期通知（通知遗漏）</h3><p>notify通知遗漏很容易理解，即当threadA还没开始wait的时候，threadB已经notify了。这样，threadB的通知是没有任何响应的，而threadA在notify后wait，便会一直阻塞等待，直到被其他线程打断。</p><p>解决方案：</p><p>添加一个状态标志，让waitThread在调用wait方法前判断通知是否已经发出，如果通知已经发出，则waitThread就不再wait。</p><h3 id="问题二、等待wait的条件发生变化"><a href="#问题二、等待wait的条件发生变化" class="headerlink" title="问题二、等待wait的条件发生变化"></a>问题二、等待wait的条件发生变化</h3><p>如果线程在等待时接收到了通知，但是之后等待的条件发生了变化，并没有对等待条件进行判断，也会导致程序出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionChange</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; lockObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(lockObject);<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(lockObject);<br>        <span class="hljs-type">Productor</span> <span class="hljs-variable">productor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(lockObject);<br>        <span class="hljs-comment">//两个消费者线程</span><br>        consumer1.start();<br>        consumer2.start();<br>        <span class="hljs-comment">//一个生产者线程</span><br>        productor.start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;String&gt; lock;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//这里使用if的话，就会存在wait条件变化造成程序错误的问题</span><br>                    <span class="hljs-keyword">if</span> (lock.isEmpty()) &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; list为空&quot;</span>);<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 调用wait方法&quot;</span>);<br>                        lock.wait();<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  wait方法结束&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> lock.remove(<span class="hljs-number">0</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 取出第一个元素为：&quot;</span> + element);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;String&gt; lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 开始添加元素&quot;</span>);<br>                lock.add(Thread.currentThread().getName());<br>                lock.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br>会报异常：<br>    <br>Exception in thread <span class="hljs-string">&quot;Thread-1&quot;</span> Thread-<span class="hljs-number">0</span> list为空<br>Thread-<span class="hljs-number">0</span> 调用wait方法<br>Thread-<span class="hljs-number">1</span> list为空<br>Thread-<span class="hljs-number">1</span> 调用wait方法<br>Thread-<span class="hljs-number">2</span> 开始添加元素<br>Thread-<span class="hljs-number">1</span>  wait方法结束<br>java.lang.IndexOutOfBoundsException: Index: <span class="hljs-number">0</span>, Size: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>异常原因分析：</p><p>两个消费者启动的时候，List为空。都被阻塞，等待被唤醒后消费List中的数据。</p><p>一个生产者，生产数据过后，notifyAll，两个消费者都被唤醒，第一个消费者正常消费数据，此时List为空，第二个消费者再消费数据的时候List为空，抛出异常。</p><p>即第二个消费者从wait方法退出过后wait条件已经发生变化，再执行程序就出错了</p><p>解决方案：在wait退出之后再对条件进行判断即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改Customer线程的run方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//如果lock为空的话，进入进入循环wait</span><br>            <span class="hljs-keyword">while</span> (lock.isEmpty()) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; list为空&quot;</span>);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 调用wait方法&quot;</span>);<br>                lock.wait();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  wait方法结束&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//出循环后此时lock不为空</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> lock.remove(<span class="hljs-number">0</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 取出第一个元素为：&quot;</span> + element);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题三、”假死“状态"><a href="#问题三、”假死“状态" class="headerlink" title="问题三、”假死“状态"></a>问题三、”假死“状态</h3><p>问题：</p><p>如果时多消费者和多生产者情况，如果使用notify方法可能会出现”假死“的情况，即唤醒的时同类线程。</p><p>原因分析：</p><p>假设当多个生产者线程调用wait阻塞，当其中一个生产者获取到对象锁之后使用notif通知处于等待状态的线程（有生产者和消费者）如果唤醒的仍是生产者线程，就会造成所有的生产者线程都处于等待状态</p><p>解决办法：</p><p>使用notify方法替换notifyAll方法如果使用的是Lock，就将signal替换为signalAll方法</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Object提供的消息通知机制应该遵循如下条件：</p><ul><li><p>永远在while循环中对条件进行判断</p><blockquote><p>在使用线程的等待&#x2F;通知机制时，一般要在while循环中调用wait()方法，因此需要配合使用一个Boolean变量（或其他wait条件），满足wait条件时，进入while循环，执行wait()方法，不满足wait条件时，跳出循环，执行后续代码</p></blockquote></li><li><p>使用notifyAll而不是notify</p></li></ul><p>使用范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The standard idiom for calling the wait method in Java</span><br><span class="hljs-keyword">synchronized</span> (sharedObject) &#123;<br>    <span class="hljs-keyword">while</span> (condition) &#123;<br>    sharedObject.wait();<br>        <span class="hljs-comment">// (Releases lock, and reacquires on wakeup)</span><br>    &#125;<br>    <span class="hljs-comment">// do action based upon condition e.g. take or put into queue</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wait-x2F-notifyAll实现生产者-消费者"><a href="#wait-x2F-notifyAll实现生产者-消费者" class="headerlink" title="wait&#x2F;notifyAll实现生产者-消费者"></a>wait&#x2F;notifyAll实现生产者-消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(linkedList, <span class="hljs-number">8</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(linkedList));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxLength;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List list, <span class="hljs-type">int</span> maxLength)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.maxLength = maxLength;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (list) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (list.size() == maxLength) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list以达到最大容量，进行wait&quot;</span>);<br>                            list.wait();<br>                            System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                        &#125;<br>                        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 生产数据&quot;</span> + i);<br>                        list.add(i);<br>                        list.notifyAll();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List list)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (list) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list为空，进行wait&quot;</span>);<br>                            list.wait();<br>                            System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                        &#125;<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  消费数据：&quot;</span> + element);<br>                        list.notifyAll();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Lock中Conditionn的await-x2F-signal"><a href="#Lock中Conditionn的await-x2F-signal" class="headerlink" title="Lock中Conditionn的await&#x2F;signal"></a>Lock中Conditionn的await&#x2F;signal</h1><p>使用Lock.lock()代替syncchronized(Objcet)</p><p>使用Condition的await()和signal()代替Object的wait()和notify()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(linkedList, <span class="hljs-number">8</span>, lock));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(linkedList, lock));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxLength;<br>        <span class="hljs-keyword">private</span> Lock lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List list, <span class="hljs-type">int</span> maxLength, Lock lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.maxLength = maxLength;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (list.size() == maxLength) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list以达到最大容量，进行wait&quot;</span>);<br>                        full.await();<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                    System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 生产数据&quot;</span> + i);<br>                    list.add(i);<br>                    empty.signalAll();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> Lock lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List list, Lock lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list为空，进行wait&quot;</span>);<br>                        empty.await();<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>                    System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  消费数据：&quot;</span> + element);<br>                    full.signalAll();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>BlockingQueue会自动阻塞生产者和消费者线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(queue));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(queue));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> BlockingQueue queue;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(BlockingQueue queue)</span> &#123;<br>            <span class="hljs-built_in">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                    System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;生产数据&quot;</span> + i);<br>                    queue.put(i);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> BlockingQueue queue;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(BlockingQueue queue)</span> &#123;<br>            <span class="hljs-built_in">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> (Integer) queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在消费数据&quot;</span> + element);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java多线程相关完结。完全参考：<a href="https://github.com/CL0610/Java-concurrency">https://github.com/CL0610/Java-concurrency</a></p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发工具类</title>
    <link href="/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>业务场景：</strong></p><p>在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务后，主线程才能继续往下执行业务功能。</p><p>解决方案：</p><ul><li>使用Thread类的join方法，让主线程等待被join的线程执行完毕后，主线程才能继续往下执行。</li><li>也可以使用线程间消息通信机制（wait和notify）</li><li>Java并发工具类中为我们提供了类似“倒计时”这样的工具类，也就是CountDownLathch来完成这种业务场景</li></ul><p><strong>CountDownLatch的通俗解释：</strong></p><p>若有6个运动员参与比赛，一个裁判员在终点计时。每个运动员到达终点，裁判员就少一个计时任务，当所有运动员到达终点，裁判员任务完完成，才能继续执行其他操作。6个运动员可以类比为六个线程，裁判员类比为一个主线程，当运动员到达终点时，调用CountDownLatch.countDown()方法对计数器减一，直到计数器为0，裁判员主线程才能继续往下执行。</p><h2 id="CountDownLatch的主要方法"><a href="#CountDownLatch的主要方法" class="headerlink" title="CountDownLatch的主要方法"></a>CountDownLatch的主要方法</h2><p>构造方法：</p><ul><li><p>public CountDownLatch(int count)</p><blockquote><p>构造方法传入一个整数N，之后调用countdown方法会对N减一，当N捡到0时，之前因为调用await方法阻塞的线程会被唤醒会继续执行。</p></blockquote></li></ul><p>使用方法：</p><ul><li><p>await() throws InterruptedException</p><blockquote><p> 调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行</p></blockquote></li><li><p>await(long timeout, TimeUnit unit)</p><blockquote><p>在await方法的基础上，增加了超时等待机制</p></blockquote></li><li><p>countDown()</p><blockquote><p>使CountDownLatch计数值N减1</p></blockquote></li><li><p>long getCount()</p><blockquote><p>获取当前CountDownLatch中的计数值</p></blockquote></li></ul><h2 id="解释示例的代码实现"><a href="#解释示例的代码实现" class="headerlink" title="解释示例的代码实现"></a>解释示例的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br> <span class="hljs-comment">//运动员线程需要关注的起跑信号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//裁判员线程需要关注的六个运动员都到达终点的信号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">endSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//主线程裁判员线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">//创建六个运动员线程并提交给线程池执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 运动员等待裁判员响哨！！！&quot;</span>);<br>                    <span class="hljs-comment">//运动员等待起跑信号</span><br>                    startSignal.await();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在全力冲刺&quot;</span>);<br>                    endSignal.countDown();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  到达终点&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//起跑信号，六个运动员起跑</span><br>        System.out.println(<span class="hljs-string">&quot;裁判员发号施令啦！！！&quot;</span>);<br>        startSignal.countDown();<br>        <span class="hljs-comment">//结束信号，裁判员宣布比赛结束</span><br>        endSignal.await();<br>        System.out.println(<span class="hljs-string">&quot;所有运动员到达终点，比赛结束！&quot;</span>);<br>        executorService.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br>输出结果：<br>    <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span> 运动员等待裁判员响哨！！！<br>裁判员发号施令啦！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  到达终点<br>所有运动员到达终点，比赛结束！<br></code></pre></td></tr></table></figure><p>注意：代码中设置了两个CountDownLatch，一个startSignal用于让裁判员发送开始信号给运动员，一个endSignal用于让裁判员接收结束信号。</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>CyclicBarrier也是一种多线程并发控制的使用工具，和CountDownLatch一样具有等待计数的功能，但是更加强大。</p><p>通俗解释：</p><p>还是上面的运动会例子，模拟运动员入场的情况。假设有6条跑道，需要6个运动员都到达跑到起点后，才能吹哨开始跑步。跑道起点相当于一个barrier，是临界点，6个运动员类比成线程的话，到达临界点的线程会阻塞，需要等待到达临界点的线程到达六个，阻塞在临界点的线程才会解除阻塞继续执行。</p><p>CyclicBarrier在使用一次过后，仍然有效，可以继续当计数器使用，这是和CountDownLatch的区别之一。</p><p>示意图：</p><p><img src="/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/16334ad72bdd4ca3tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="CyclicBarrier执行示意图.jpg"></p><h2 id="CyclicBarrier的主要方法"><a href="#CyclicBarrier的主要方法" class="headerlink" title="CyclicBarrier的主要方法"></a>CyclicBarrier的主要方法</h2><p>构造方法：</p><p>public CyclicBarrier(int parties, Runnable barrierAction)</p><p>使用方法：</p><ul><li><p>await()</p><blockquote><p>等待所有的线程都到达指定的临界点</p></blockquote></li><li><p>awat(long timeout, TimeUnit unit)</p><blockquote><p>在await方法基础上增加超时等待机制</p></blockquote></li><li><p>int getNumberWaiting()</p><blockquote><p>获取当前有多少个线程阻塞等待在临界点上</p></blockquote></li><li><p>boolean isBroken()</p><blockquote><p>用于查询阻塞等待的线程是否被中断</p></blockquote></li><li><p>void reset()</p><blockquote><p>将屏障重置为初始状态，如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException</p></blockquote></li></ul><h2 id="解释示例的代码实现："><a href="#解释示例的代码实现：" class="headerlink" title="解释示例的代码实现："></a>解释示例的代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-comment">//创建计数为6的CyclicBarrier，并设置线程到齐后的执行函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">6</span>, () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;所有运动员入场，裁判员一声令下！！！！！&quot;</span>);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;运动员准备进场，全场欢呼............&quot;</span>);<br>        <br>        <span class="hljs-comment">//创建六个运动员线程并提交给线程池执行</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">6</span>; i++) &#123;<br>            service.execute(() -&amp;gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 运动员，进场&quot;</span>);<br>                    <span class="hljs-comment">//在barrier阻塞，等待其他线程到齐</span><br>                    barrier.await();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  运动员出发&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>&#125;<br>&#125;<br><br>输出结果：<br>运动员准备进场，全场欢呼............<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span> 运动员，进场<br>所有运动员入场，裁判员一声令下！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  运动员出发<br></code></pre></td></tr></table></figure><h2 id="CountDownLatch与CyclicBarrier比较"><a href="#CountDownLatch与CyclicBarrier比较" class="headerlink" title="CountDownLatch与CyclicBarrier比较"></a>CountDownLatch与CyclicBarrier比较</h2><p>二者都是用于控制并发的工具类，都可以理解成维护一个计数器，但是二者的侧重点不同：</p><ul><li>CountDownLatch一般用于某个线程A等待其他若干线程执行完任务后，它才执行（一个线程等多个线程）。而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行（多个线程互相等待）。</li><li>调用CountDownLatch的countDown方法不会阻塞当前线程；而调用CyclicBarrier的await方法会阻塞当前线程，直到CyclicBarrier指定的线程数量到达，才继续往下执行。</li><li>CountDownLatch方法较少，使用简单。而CyclicBarrier提供的方法更多，可以同通过getNumberWaiting()、isBroken()方法获取当前多个线程的状态，并且再构造方法中可以传入barrierAction，指定当所有线程都到达时执行的业务功能。</li><li>CountDownLatch是一次性的，不能复用，而CyclicBarrier可以复用。</li></ul><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Semaphore可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。</p><p>Semaphore就相当于一个许可证，线程需要先通过acquire方法获取该许可证，该线程才能继续执行下去，否则只能在该方法处阻塞等待。当执行完业务功能够，通过release()方法将许可证归还，以便其他线程能够获得许可证继续执行。</p><p>业务场景：</p><p>Semaphore可以用作流量控制，特别是公共资源有限的应用场景，比如数据库连接。加入有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有10个，这个时候就需要使用Semaphore来控制能够并发访问到数据库连接资源的线程数只有10个。在限制资源使用的应用场景下，Semaphore是特别合适的。</p><h2 id="Semaphore的主要方法"><a href="#Semaphore的主要方法" class="headerlink" title="Semaphore的主要方法"></a>Semaphore的主要方法</h2><p>构造方法：</p><ul><li><p>Semaphore(int permits)</p></li><li><p>Semaphore(int permits, boolean fair)</p></li></ul><p>获取与释放许可的方法：</p><ul><li>acquire()</li><li>acquire(int permits)</li><li>release()</li><li>release(int permits)</li><li>boolean tryAcquire()</li><li>boolean tryAcquire(int permits)</li><li>boolean tryAcquire(long timeout, TimeUnit unit)</li><li>Boolean try Acquire(int premits, long timeout, TimeUnit unit)</li></ul><p>获取许可证和阻塞线程信息的方法：</p><ul><li>int availablePermits()</li><li>int getQueueLength()</li><li>boolean hasQueuedThreads()</li><li>Collections<Thread> getQueueThreads()</Thread></li></ul><h2 id="使用示例代码实现"><a href="#使用示例代码实现" class="headerlink" title="使用示例代码实现"></a>使用示例代码实现</h2><p>模拟场景：</p><p>有一天，班主任需要班上10个同学到讲台上来填写一个表格，但是老师只准备了5只笔，因此只能保证同时只有5名同学能够拿到笔填写表格，没有拿到笔的同学需要等待前面拿到笔的同学用完笔放回，才能拿到笔填写表格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-comment">//表示老师只有5支笔</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//表示10个学生</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//创建10个学生线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  同学准备获取笔......&quot;</span>);<br>                    semaphore.acquire();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  同学获取到笔&quot;</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  填写表格ing.....&quot;</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                    semaphore.release();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  填写完表格，归还了笔！！！！！！&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        service.shutdown();<br>    &#125;<br>&#125;<br>输出结果<br>    <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  填写表格ing.....<br><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  同学准备获取笔......<br><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  填写完表格，归还了笔！！！！！！<br></code></pre></td></tr></table></figure><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。</p><p>具体交换数据是通过exchange() 方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程都到达同步点，两个线程就可以交换数据。</p><h2 id="Exchanger的主要方法"><a href="#Exchanger的主要方法" class="headerlink" title="Exchanger的主要方法"></a>Exchanger的主要方法</h2><p>构造方法：</p><p>只有一个简单的无参构造方法</p><p>主要方法：</p><ul><li>V exchange(V x)</li><li>V exchange(V x, long timeout, timeUnit unit)</li></ul><h2 id="使用示例代码实现-1"><a href="#使用示例代码实现-1" class="headerlink" title="使用示例代码实现"></a>使用示例代码实现</h2><p>模拟场景：</p><p>在青春洋溢的中学时代，下课期间，男生经常会给走廊里为自己喜欢的女孩送情书。男生会先到女孩教师门口，然后等女孩出来，教师门口就是一个同步点，然后彼此交换信物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//代表男生和女生</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//男生线程</span><br>        service.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//男生对女生说的话</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">girl</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;我其实暗恋你很久了......&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;女孩儿说：&quot;</span> + girl);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//女生线程</span><br>        service.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;女生慢慢的从教室你走出来......&quot;</span>);<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                <span class="hljs-comment">//女生说的话</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">boy</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;我也很喜欢你......&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;男孩儿说：&quot;</span> + boy);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br>输出结果：<br><br>女生慢慢的从教室你走出来......<br>男孩儿说：我其实暗恋你很久了......<br>女孩儿说：我也很喜欢你......<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-atomic包</title>
    <link href="/2022/10/21/Java%E5%B9%B6%E5%8F%91-atomic%E5%8C%85/"/>
    <url>/2022/10/21/Java%E5%B9%B6%E5%8F%91-atomic%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="原子操作类简介"><a href="#原子操作类简介" class="headerlink" title="原子操作类简介"></a>原子操作类简介</h1><p>并发问题：</p><p>并发编程中很容易出现并发安全的例子。比如说多线程执行i++，就可能无法获取正确的结果。常用的解决办法是使用Synchronized进行控制来达到线程安全的目的。但是synchronized采用的是悲观锁策略，并不是特别高效的一种解决方案。</p><p>高效的解决方案：</p><p>在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并且能保证线程安全的更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p><h1 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h1><p>原子更新基本类型的工具类：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>这几个类的用法基本一致，以AtomicInteger为例：</p><ul><li>getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值（a &#x3D; newValue）</li><li>addAndGet(int delta)：原值加上输入数值，返回最后结果（a +&#x3D; delta）</li><li>incrementAndGet()：原值加1，返回自增后的结果（a++）</li><li>getAndIncrement()：原值加1，返回自增前的旧值（++a）</li></ul><p>实现原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AtomicInteger的getAndIncrement方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//AtomicInteger的compareAndSet方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">boolean</span> expect, <span class="hljs-type">boolean</span> update)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> expect ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> update ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, e, u);<br>&#125;<br><span class="hljs-comment">//原子类中Unsafe实例的获取</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br></code></pre></td></tr></table></figure><p>由上面源码可见，这些原子类的方法都是通过调用Unsafe类的CAS操作来实现的。</p><h1 id="原子更新数组类型"><a href="#原子更新数组类型" class="headerlink" title="原子更新数组类型"></a>原子更新数组类型</h1><p>原子更新数组中元素的类：</p><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><p>几个类的用法一致，以AtomicIntegerArray为例：</p><ul><li>addAndGet(int i, int delta)：将数组中索引为i的元素加上delta，并返回相加后的值</li><li>getAndIncrement(int i)：将数组中索引为i的元素自增1，并返回自增前的值</li><li>compareAndSet(int i, int expect, int update)：CAS更新索引为i的元素的值</li></ul><h1 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h1><p>原子更新引用类型变量的类：</p><ul><li>AtomicReference：原子更新引用类型</li><li>AtomicReferenceFieldUpdater：原子更新引用类型中的字段</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型</li></ul><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicReference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>        reference.set(user1);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> reference.getAndSet(user2);<br>        <br>        System.out.println(user);<br>        System.out.println(reference.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String userName;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.userName = userName;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;userName=&#x27;&quot;</span> + userName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>&#125;<br>&#125;<br><br>输出结果：<br>User&#123;userName=<span class="hljs-string">&#x27;a&#x27;</span>, age=<span class="hljs-number">1</span>&#125;<br>User&#123;userName=<span class="hljs-string">&#x27;b&#x27;</span>, age=<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="原子更新字段类型"><a href="#原子更新字段类型" class="headerlink" title="原子更新字段类型"></a>原子更新字段类型</h1><p>原子更新对象字段的类：</p><ul><li>AtomicIntegeFieldUpdater：原子更新对象的整形字段</li><li>AtomicLongFieldUpdater</li><li>AtomicStampedReference：原子更新引用类型。这种更新方式带有版本号，解决了ABA的问题</li></ul><p>使用步骤：</p><ol><li>原子更新字段类都是抽象类，只能通过其静态方法newUpdater来创建一个更新器，并在创建的时候指定要更新的类和属性</li><li>更新类的属性必须使用public volatile进行修饰</li></ol><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicDemo</span> &#123;<br><span class="hljs-comment">//指定类和属性，创建更新器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> <br>        AtomicIntegerFieldUpdater.newUpdater(User.class,<span class="hljs-string">&quot;age&quot;</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//使用更新器更新指定类的指定属性</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> updater.getAndAdd(user, <span class="hljs-number">5</span>);<br>        <br>        System.out.println(oldValue);<br>        System.out.println(updater.get(user));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String userName;<br>     <span class="hljs-comment">//public volatile修饰的属性，可以使用原子更新字段类更新</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.userName = userName;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>    &#125;<br>&#125;<br><br>输出结果：<br><span class="hljs-number">1</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-FutureTask</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p> 在Executors框架体系中，FutureTask用来表示<strong>可获取结果的异步任务</strong>。</p></blockquote><p>FutureTask实现了Future接口，提供的方法：</p><ul><li>启动和取消异步任务</li><li>查询异步任务是否执行完毕</li><li>获取最终的异步任务结果</li></ul><p>FutureTask中定义的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>在《Java并发编程的艺术》一书中，作者根据FutureTask.run()方法的执行时机，将其分了3中状态：</p><ul><li><p>未启动</p><blockquote><p>当创建一个 FutureTask，但是FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态</p></blockquote></li><li><p>已启动</p><blockquote><p>FutureTask.run()方法正在被执行的过程中，FutureTask处于已启动状态</p></blockquote></li><li><p>已完成</p><blockquote><p>FutureTask变为已完成状态的几种情况</p><ul><li>FutureTasl.run()方法正常执行结束</li><li>FutureTask.cancel()方法取消任务</li><li>在执行过程中抛出异常</li></ul></blockquote></li></ul><p>状态变化过程图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/16334a72fd345345tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="FutureTask状态迁移图.jpg"></p><p>不同状态对get和cancel方法的影响：</p><ul><li><p>get方法</p><blockquote><p>未完成状态：会导致线程阻塞</p><p>已完成状态：立即返回结果或抛出异常</p></blockquote></li><li><p>cancel方法</p><blockquote><p>未启动：该任务永远不会再执行</p><p>已启动：</p><p>FutureTask.cancel(true)方法将以中断方式来阻止任务继续执行</p><p>FutureTask.cancel(false)将不会对正在执行任务的线程有影响</p><p>已完成：返回false</p></blockquote></li></ul><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/16334a72fd899d43tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="FutureTask的get和cancel的执行示意图.jpg"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>FutureTask对象的执行：</p><p>FutureTask除了实现了Future接口，还实现了Runnable接口。因此可以将FutureTask交给Executror执行，也可以由调用的线程直接执行FutureTask.run () 。</p><p>FutureTask对象的获取：</p><p>可以通过ExecutorService.submit ()方法返回一个FutureTask对象</p><p>应用场景：</p><ul><li>当一个线程需要等待另一个线程执行完成后它才能继续执行，此时可以使用FutureTask</li><li>若有多个线程执行多个任务，每个任务只能执行一次。当多个线程试图执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完成后才能继续执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ScheduledThreadPoolExecutor</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ScheduledThreadPoolExecutor用途：</p><ul><li>在给定延时后执行异步任务</li><li>周期性执行任务</li></ul><p>相对于任务调度Timer来说，其功能更加强大。Timer只能使用一个后台线程执行任务，而ScheduledThreadPoolExecutor则可以指定后台线程的个数。</p><p>ScheduledThreadPoolExecutor类的UML图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/16334a21947ee154tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>从UML中可以看出：</p><ul><li><p>继承自ThreadPoolExecutor类</p><blockquote><p>拥有execute()和submit()提交异步任务的基础功能</p></blockquote></li><li><p>实现了ScheduledExecutorService接口</p><blockquote><p>该接口定义了能够延迟执行任务和周期性执行任务的功能</p></blockquote></li><li><p>包含两个重要类：DelayedWorkQueue和ScheduledFutureTask</p></li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), handler);<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadPoolExecutor中可以设定的参数：</p><ul><li>maximumPoolSize：线程池能创建线程的最大个数</li><li>keepAliveTime：空闲线程存活时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列</li><li>corePoolSize：核心线程池大小</li><li>threadFactory：创建线程的工厂类</li><li>handler：饱和策略</li></ul><p>ScheduledThreadPoolExecutor是通过调用ThreadPoolExecutor的构造方法进行构造的。</p><p>可定制参数：</p><ul><li>corePoolSize</li><li>threadFactory</li><li>handler</li></ul><p>已指定参数：</p><ul><li>maximumPoolSize：Integer.MAX_VALUE</li><li>keepAliveTime：0</li><li>unit：NANOSECONDS</li><li>workQueue：DelayedWorkQueue</li></ul><h2 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h2><p>ScheduledThreadPoolExexecutor实现了ScheduledExecutorService接口，该接口定义了可延时执行异步任务和可周期性执行异步任务的特有功能。相应方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1 延时执行异步任务</span><br><br><span class="hljs-comment">//这里传入的是实现Runnable接口的任务，因此通过ScheduledFuture.get()获取结果为null</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                       <span class="hljs-type">long</span> delay, TimeUnit unit);<br><span class="hljs-comment">//这里传入的是实现Callable接口的任务，因此，返回的是任务的最终计算结果</span><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">                                           <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br><span class="hljs-comment">//2 周期性执行异步任务</span><br><br><span class="hljs-comment">//当达到延时时间initialDelay后，任务开始执行。</span><br><span class="hljs-comment">//以上一个任务开始的时间计时，period时间过去后，检测上一个任务是否执行完毕</span><br><span class="hljs-comment">//如果上一个任务执行完毕，则当前任务立即执行</span><br><span class="hljs-comment">//如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit);<br><span class="hljs-comment">//当达到延时时间initialDelay后，任务开始执行。</span><br><span class="hljs-comment">//上一个任务执行结束后到下一次任务执行，中间延时时间间隔为delay。</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                     <span class="hljs-type">long</span> initialDelay,<br>                                                     <span class="hljs-type">long</span> delay,<br>                                                     TimeUnit unit);<br></code></pre></td></tr></table></figure><h1 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h1><p>上面特有方法执行，实际上是将提交的任务转换为ScheduledFutureTask类。</p><p>例如schedule方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay,<br>                                   TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//Runable转换为ScheduledFutureTask</span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(<br>        command, <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay, unit))<br>    );<br>    <span class="hljs-comment">//提交执行ScheduledFutureTask</span><br>    delayedExecute(t);<br>    <span class="hljs-comment">//返回ScheduledFutureTask</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程池最大的作用是将任务和线程解耦。</p><p>线程是任务的执行者，任务是ScheduledFutureTask，任何线程执行任务都是通过调用run()方法。为了保证ScheduledThreadPoolExecutor能够延迟执行任务以及周期性执行任务，ScheduledFutureTask重写了run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<br>        cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//1 如果不是周期性执行任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>        <span class="hljs-comment">//直接调用run方法</span><br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();<br><span class="hljs-comment">//2 如果是周期性执行任务的话</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>        <span class="hljs-comment">//重设下一次执行任务的时间</span><br>        setNextRunTime();<br>        <span class="hljs-comment">//将下一次待执行的任务放置到DelayedWorkQueue中</span><br>        reExecutePeriodic(outerTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h1><p>DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。</p><p>在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列任务，执行时间越接近当前时间的任务在队列的前面。</p><p>为什么要使用DelayedWorkQueue？</p><ul><li><p>定时任务执行时需要取出最近要执行的任务，所以每次队列出队的一定钥匙执行时间最靠前的任务。</p></li><li><p>DelayedWorkQueue是一个优先级队列，它基于堆结构，插入和删除操作最坏的时间复杂度都是O(logN)。</p></li></ul><p>DelayedWorkQueue的数据结构（底层采用数组存储任务）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DelayedWorkQueue是由一个大小为16的数组组成</span><br><span class="hljs-comment">//数组元素为实现RunnableScheduleFuture接口的类，实际上为ScheduledFutureTask</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>以ScheduledThreadPoolExecutor的schedule方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay,<br>                                   TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-comment">//1 将提交的任务转换成ScheduledFutureTask</span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(<br>        command,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay, unit))<br>    );<br>    <span class="hljs-comment">//2 延时执行任务ScheduledFutureTask</span><br>delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-comment">//2.1 如果当前线程池已经关闭，拒绝任务</span><br>    <span class="hljs-keyword">if</span> (isShutdown())<br>        reject(task);<br>    <span class="hljs-comment">//2.2 若线程池没有关闭，将任务放入阻塞队列中</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.getQueue().add(task);<br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>            remove(task))<br>            task.cancel(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">else</span><br><span class="hljs-comment">//保证至少有一个线程启动，即使corePoolSize=0</span><br>            ensurePrestart();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取现在的线程数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());<br>    <span class="hljs-comment">//1 若核心线程池没满，新建线程</span><br>    <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//2 若corePoolSize为0，则会保证有一个线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>addWorker()方法就是新建线程：</p><ul><li><p>ensurePrestart()方法的关键在于addWorker()方法，该方法的主要功能：新建Worker类。</p></li><li><p>当执行任务时，会调用被Worker重写的run方法，进而执行runWorker方法。在runWorker方法中会调用getTask方法从阻塞队列中不断获取任务进行执行，直到从阻塞队列中获取的任务为null的时候，线程结束终止。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="ScheduledThreadPoolExecutor的异同"><a href="#ScheduledThreadPoolExecutor的异同" class="headerlink" title="ScheduledThreadPoolExecutor的异同"></a>ScheduledThreadPoolExecutor的异同</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor类，因此整体功能一致：</p><ul><li>线程池主要负责创建线程（Worker类）</li><li>线程从阻塞队列中不断获取新的异步任务，直到阻塞队列为空</li></ul><p>ScheduledThreadPoolExecutor相较于ThreadPoolExecutor类增加了延时执行任务和可周期性执行任务的特性：</p><ul><li>重新设计了任务类ScheduleFutureTash，重写其run方法使其具有上述特性</li><li>通过阻塞队列DelayedWorkQueue保证越靠近当前时间执行的任务先执行</li></ul><h2 id="线程池的解耦"><a href="#线程池的解耦" class="headerlink" title="线程池的解耦"></a>线程池的解耦</h2><p>线程池设计时的三个关键要素是：任务、执行者和任务结果。线程池的设计思想就是将这三个要素解耦：</p><ul><li><p>执行者</p><blockquote><p>任务的执行机制，完全交给Worker类，也就是进一步封装了Thread。</p><p>向线程池提交任务，无论是ThreadPoolExecutor的execute方法和submit方法，还是ScheduledThredPoolExecutor的schedule方法，其执行流程都如下：</p><ol><li>将任务移入阻塞队列</li><li>通过addWork方法新建Work类，并通过runWorker方法启动线程</li><li>不断从阻塞队列中共获取异步任务交给Worker执行，直到阻塞队列为空</li></ol></blockquote></li><li><p>任务</p><blockquote><p>任务是实现了Runnable接口和Callable接口的实现类。</p><p>ThreadPoolExecutor中将任务转换成FutureTask类</p><p>ScheduledThreadPoolExecutor中将任务转换成ScheduleFutureTask类，该类继承自FutureTask，并重写run方法</p></blockquote></li><li><p>任务结果</p><blockquote><p>任务提交过后，可以通过Future接口的类获取任务结果。</p><p>ThreadPoolExecutor中实际为FutureTask类</p><p>ScheduledThreadPoolExecutor中则是ScheduledFutureTask类</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-线程池实现原理</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><p>在实际的使用中，线程池是很占用系统资源的，如果对线程管理不善很容易导致系统问题。所以在大多数并发框架中都会使用线程池来管理线程。</p><p>使用线程池的好处：</p><ul><li><p>降低资源消耗</p><blockquote><p>通过复用已存的线程，来减少线程的创建于销毁</p></blockquote></li><li><p>提高系统响应速度</p><blockquote><p>通过复用线程，省去了创建线程的过程，因此从整体上提升了系统的响应速度</p></blockquote></li><li><p>提高线程的可管理性</p><blockquote><p>线程是稀缺资源，如果无限制地创建线程，不仅会消耗系统资源，还会降低系统的稳定性。所以需要线程池来管理线程</p></blockquote></li></ul><h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><p>并发任务提交给线程池，线程池分配线程去执行任务的过程：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/163349e503061169tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>线程池执行所提交任务的几个阶段：</p><ol><li><p>核心线程池：</p><blockquote><p>先判断线程池中的核心线程池所有的线程是否都在执行任务。若不是，则创建一个核心线程执行刚提交的任务，否则进入第2步</p></blockquote></li><li><p>阻塞队列：</p><blockquote><p>若阻塞队列没有满，则将任务放置于阻塞队列中，否则进入第3步</p></blockquote></li><li><p>线程池：</p><blockquote><p>若线程池中所有线程都在执行任务，则交给饱和策略处理，否则创建一个新的线程来执行任务</p></blockquote></li></ol><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><h2 id="ThreadPoolExecutor的构造方法"><a href="#ThreadPoolExecutor的构造方法" class="headerlink" title="ThreadPoolExecutor的构造方法"></a>ThreadPoolExecutor的构造方法</h2><p>创建线程池主要是通过ThreadPoolExecutor类来完成，其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize,<br>                   <span class="hljs-type">int</span> maximumPoolSize,<br>                   <span class="hljs-type">long</span> keepAliveTime,<br>                   TimeUnit unit,<br>                   BlockingQueue&lt;Runnable&gt; workQueue,<br>                   ThreadFactory threadFactory,<br>                   RejectedExecutionHandler handler)<br></code></pre></td></tr></table></figure><p>参数解析：</p><ul><li><p>corePoolSize：核心线程池大小</p><blockquote><p>当提交一个任务时，如果当前核心线程池的线程个数没有达到corePoolSize，则会创建一个新的线程用于执行所提交的任务，即使核心线程池中有空闲线程。</p><p>如果调用prestartCoreThread()或者prestartAllCoreThreads()，线程池在创建的时候，会创建并启动所有的核心线程。</p></blockquote></li><li><p>maximumPoolSize：线程池能创建线程的最大个数</p><blockquote><p>如果阻塞队列已满（此时核心线程池肯定也已满），但是当前线程个数没有超过允许创建的最大线程数，则会创建一个新的线程用于执行任务。</p></blockquote></li><li><p>keepAliveTime：空闲线程存活时间</p><blockquote><p>当线程池的线程个数超过corePoolSize，并且线程空闲时间超过了keepAliveTime的话，将会销毁这些空闲线程以降低系统资源消耗。</p></blockquote></li><li><p>unit：时间单位</p><blockquote><p>为keepAliveTime指定时间单位</p></blockquote></li><li><p>workQueue：阻塞队列</p><blockquote><p>用于保存任务的阻塞队列。</p></blockquote></li><li><p>threadFactory：创建线程的工厂类</p><blockquote><p>可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字，如果出现并发问题，方便排查。</p></blockquote></li><li><p>handler：饱和策略</p><blockquote><p>当线程池已满，再提交任务需要策略来处理。有如下策略：</p><ul><li><p>AbortPolicy</p><blockquote><p>直接拒绝所提交的任务，并抛出RejectedExecutionException异常</p></blockquote></li><li><p>CallerRunsPlicy</p><blockquote><p>只用调用者所在得线程来执行任务</p></blockquote></li><li><p>DiscardPolicy</p><blockquote><p>不处理直接丢弃提交的任务</p></blockquote></li><li><p>DiscardOldestPolicy</p><blockquote><p>丢弃阻塞队列中存放最久的任务，执行当前任务</p></blockquote></li></ul></blockquote></li></ul><h2 id="线程池执行逻辑"><a href="#线程池执行逻辑" class="headerlink" title="线程池执行逻辑"></a>线程池执行逻辑</h2><p>通过ThreadPoolExecutor创建线程池后，通过其execute方法提交任务给线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-comment">//如果线程池的线程个数少于corePoolSize则创建新线程执行当前任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-comment">//如果线程个数大于corePoolSize或者创建线程失败，则将任务存放在阻塞队列workQueue中</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><span class="hljs-comment">//如果当前任务无法放进阻塞队列中，则创建新的线程来执行任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程示意图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/163349e50368064btplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="execute执行过程示意图.jpg"></p><p>执行逻辑：</p><ol><li>如果当前运行的线程少于corePoolSize，则创建新的线程来执行新的任务</li><li>如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中</li><li>如果workQueue队列已满的话，则会创建新的线程来执行任务</li><li>如果线程个数已经超过maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来处理</li></ol><h1 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h1><p>关闭线程池有两个方法：</p><ul><li><p>shutdown</p><blockquote><p>只是将线程池的状态设置未SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p></blockquote></li><li><p>shutdownNow</p><blockquote><p>首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表</p></blockquote></li></ul><p>二者的原理都是通过遍历线程池中所有的线程，然后依次中断线程。shutdown方法会将正在执行的任务执行完，而shutdownNow会直接中断正在执行的任务。</p><p>调用任意一个方法，isShutdown方法都会返回true，当所有的线程都关闭成功，才表示线程池成功关闭，这时调用isTerminated方法才会返回true。</p><h1 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h1><p>想要合理配置线程池，首先要分析任务特性，有以下几个角度：</p><ul><li><p>任务的性质：CPU密集型任务、IO密集型任务和混合型任务</p><blockquote><p>CPU密集型任务，因为CPU本身很少空闲，配置尽可能少地线程数量，如Ncpu+1个线程。</p><p>IO密集型任务，因为需要等待IO操作，线程并非一直执行任务，应该配置尽可能多，如2Ncpu。</p><p>混合型任务，如果可以拆分，则将其拆分未一个CPU密集型任务一个IO密集型任务。</p><p>cpu数量可以通过Runtime.getRuntime().availableProcessors()方法获取。</p></blockquote></li><li><p>任务的优先级</p><blockquote><p>优先级不同的任务，可以使用优先队列PriorityBlockingQueue来处理</p><p>它可以让优先级高的任务优先执行，但是优先级低的任务可能会出现“饥饿”永远无法执行</p></blockquote></li><li><p>任务的执行时间</p><blockquote><p>执行时间不同的任务可以交给不同规模的线程池处理。</p><p>或者使用优先队列，让执行时间短的任务先执行。</p></blockquote></li><li><p>任务的依赖性：是否依赖其他系统资源，如数据库连接</p><blockquote><p>依赖数据库连接的任务，因为线程提交SQL后需要等待数据库返回结果，等待中CPU空闲，那么线程数量根据CPU空闲时间越大，设置数量越多，这样更好地利用CPU资源。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-BlockingQueue</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/</url>
    
    <content type="html"><![CDATA[<h1 id="BlockingQueue简介"><a href="#BlockingQueue简介" class="headerlink" title="BlockingQueue简介"></a>BlockingQueue简介</h1><p>在JDK中的Collection集合框架中的各种容器类如实现List，Map，Queue接口的容器类，但是这些容器类都不是线程安全的，除了使用Collections可以将其转换位线程安全的容器，JDK中的Concurrent包中还提供了线程安全的容器。如实现List接口的CopyOnWriteArrayList，实现了Map接口的ConcurrentHashMap，实现了Queue接口的ConcurrentLinkedQueue。</p><p>阻塞队列的用途：</p><p>在最常见的“生产者-消费者”问题中，队列常常被作为线程间操作的容器，这样可以将生产和消费的业务功能解耦，生产者将生产出来的数据放置在数据容器中，而消费者仅仅需要从数据容器中获取数据即可。阻塞队列提供了可阻塞的插入的移除的方法，当队列容器已满，生产者线程会被阻塞，知道队列未满，当队列容器为空时，消费者线程会被阻塞，知道队列非空为止。</p><h1 id="阻塞队列的基本操作"><a href="#阻塞队列的基本操作" class="headerlink" title="阻塞队列的基本操作"></a>阻塞队列的基本操作</h1><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267ca3fc39tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>插入元素：</p><ul><li><p>add(E e)</p><blockquote><p>队列满时候，插入失败抛出IllegalStateException异常</p></blockquote></li><li><p>offer(E e)</p><blockquote><p>插入成功返回true，否则false</p></blockquote></li><li><p>put(E e)</p><blockquote><p>若阻塞队列已经满了，put线程会被阻塞，知道阻塞队列有空余容量可供使用</p></blockquote></li></ul><p>删除元素：</p><ul><li><p>remove(Object o)</p><blockquote><p>删除成功返回true，否则false</p></blockquote></li><li><p>poll()</p><blockquote><p>删除并返回队头元素，若为空，返回null</p></blockquote></li><li><p>take()</p><blockquote><p>删除并返回队头元素，若为空，take线程阻塞直到阻塞队列不为空</p></blockquote></li><li><p>poll(long timeout, TimeUnit unit)</p><blockquote><p>基本同take方法，增加了超时退出的功能（阻塞超过给定时长，该线程直接退出）</p></blockquote></li></ul><p>查看元素：</p><ul><li><p>element()</p><blockquote><p> 获取头元素，若队列为空，抛出异常NoSuchElementException</p></blockquote></li><li><p>peek()</p><blockquote><p> 获取头元素，若队列为空，抛出异常NoSuchElementException</p></blockquote></li></ul><h1 id="常用的BlockingQueue实现类"><a href="#常用的BlockingQueue实现类" class="headerlink" title="常用的BlockingQueue实现类"></a>常用的BlockingQueue实现类</h1><h2 id="常用实现类简介："><a href="#常用实现类简介：" class="headerlink" title="常用实现类简介："></a>常用实现类简介：</h2><ul><li><p>ArrayBlockingQueue</p><blockquote><p>ArrayBlockingQueue是由<strong>数组</strong>实现的<strong>有界阻塞队列</strong>。</p><p>该队列命令元素<strong>FIFO</strong>。因此，队列中元素按照进入队列时间排序。</p><p>ArrayBlockingQueue可作为“有界数据缓冲区”，一旦被创建，其<strong>容量不能改变</strong>。</p><p>线程访问队列的公平性：</p><ul><li><p>默认是非公平性访问，即一旦ArrauBlockingQueue可以被访问时，长时间阻塞的线程可能依然无法访问到ArrayBlockingQueue。</p></li><li><p>若要保证公平性，则在new ArrayBlockingQueue的时候加上true参数，获取公平性的Array BlockingQueue</p></li></ul></blockquote></li><li><p>LinkedBlockingQueue</p><blockquote><p>LinkedBlockingQueue使用链表实现的有界阻塞队列。</p><p>同样满足FIFO特性。比ArrayBlockingQueue相比具有更高的吞吐量。</p><p>为了防止LinkedBlockingQueue容量迅速增大，损耗大量内存，通常在创建LinkedBlockingQueue对象的时候会指定其大小，若未指定，其容量为Integer.MAX_VALUE</p></blockquote></li><li><p>PriorityBlockingQueue</p><blockquote><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。</p><p>排序方式：</p><ul><li>默认情况下元素采用自然顺序进行排序</li><li>也可以通过自定义类的compareTo()方法指定元素的排序规则</li><li>或则在初始化时通过构造器参数Comparator来指定排序规则</li></ul></blockquote></li><li><p>SynchronousQueue</p><blockquote><p>SynchronousQueue每个插入操作必须等待另一个线程进行相应的删除操作。</p><p>因此，SynchronousQueue实际上没有存储任何数据，删除和插入线程需要相互等待对方。</p><p>SynchronousQueue也可以通过构造器参数为其指定公平性</p></blockquote></li><li><p>LinkedTransferQueue</p><blockquote><p>LinkedTransferQueue是一个由链表数据结构构成的无界阻塞队列。</p><p>该队列实现了TransferQueue接口，与其他阻塞队列的不同方法：</p><ul><li><p>transfer(E e)</p><blockquote><p>如果当前有线程在执行take()方法或可延时的poll()方法进行消费数据，生产者线程可以调用transfer方法将数据直接传递给消费者线程。</p><p>若当前没有消费者线程消费数据，生产者线程会将数据插入队尾，直到有消费者进行消费才能退出</p></blockquote></li><li><p>tryTransfer(E e)</p><blockquote><p>与transfer相比，若当前没有线程在消费数据，则立即返回false。</p></blockquote></li><li><p>tryTransfer(E e, long timeout, timeUnit unit)</p><blockquote><p>与transfer相比，增加了超时特性，若超过规定时间没有消费者消费数据，则返回false</p></blockquote></li></ul></blockquote></li><li><p>LinkedBlockingDequeue</p><blockquote><p>LinkedBlockingDequeue是基于链表数据结构的有界阻塞双端队列。</p><p>LinkedBlockingDeque具有双端队列特性，其基本操作如下：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267d1586d2tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>LinkedBlockingDque实现的是BlockingDeque接口，而LinkedBlockingQueue实现的是BlockingQueue接口</p><p>两个接口区别如下：（两个接口的功能可以等价使用）</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267d5efe67tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p></blockquote></li><li><p>DelayQueue</p><blockquote><p>DelayQueue是一个存放实现Delayed接口数据的无界阻塞队列。</p><p>只有当数据对象的延时时间达到时才能插入到队列进行存储。</p><p>若当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过poll方法获取元素返回null。</p><p>所谓的数据延时期满时，是通过Delayed接口的getDelay()来进行判断的，若返回值小于等于0，说明数据元素的延时期已满。</p></blockquote></li></ul><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>阻塞队列最核心的功能是，可以阻塞式地插入和删除队列元素。当队列为空，会阻塞消费者线程，直至队列非空时，通知被阻塞地消费者线程；当队列满时，会阻塞插入数据地线程，直至队列未满时，通知被阻塞的生产者线程。</p><p>多线程中的消息通知最常用的是lock的condition机制。</p><h4 id="主要属性："><a href="#主要属性：" class="headerlink" title="主要属性："></a>主要属性：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存储数据相关的属性：</span><br><span class="hljs-comment">/** The queued items */</span><br><span class="hljs-keyword">final</span> Object[] items;<br><br><span class="hljs-comment">/** items index for next take, poll, peek or remove */</span><br><span class="hljs-type">int</span> takeIndex;<br><br><span class="hljs-comment">/** items index for next put, offer, or add */</span><br><span class="hljs-type">int</span> putIndex;<br><br><span class="hljs-comment">/** Number of elements in the queue */</span><br><span class="hljs-type">int</span> count;<br><br><span class="hljs-comment">//消息通知相关的属性：</span><br><span class="hljs-comment">/** Main lock guarding all access */</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><br><span class="hljs-comment">/** Condition for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-comment">/** Condition for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br><span class="hljs-comment">//构造方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    <span class="hljs-comment">//创建lock和condition</span><br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put方法："><a href="#put方法：" class="headerlink" title="put方法："></a>put方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//如果当前队列已满，将线程移入到notFull等待队列中</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br><span class="hljs-comment">//满足插入数据的要求，直接进行入队操作</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br><span class="hljs-comment">//1 插入数据</span><br>    items[putIndex] = x;<br>    <span class="hljs-comment">//更新putIndex和count属性</span><br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br><span class="hljs-comment">//2 通知消费者线程，当前队列中有数据可供消费</span><br>    notEmpty.signal();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="take方法："><a href="#take方法：" class="headerlink" title="take方法："></a>take方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//如果队列为空，没有数据，将消费者线程移入等待队列中</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br><span class="hljs-comment">//获取数据</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//1 获取数据</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    <span class="hljs-comment">//置为null，帮助GC</span><br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//更新takeInde和count属性</span><br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>        itrs.elementDequeued();<br>    <span class="hljs-comment">//2 通知被阻塞的生产者线程</span><br>notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><h4 id="主要属性：-1"><a href="#主要属性：-1" class="headerlink" title="主要属性："></a>主要属性：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Current number of elements */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">//头尾节点指针</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><span class="hljs-comment">//读锁与非空等待队列</span><br><span class="hljs-comment">/** Lock held by take, poll, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/** Wait queue for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<br><br><span class="hljs-comment">//写锁与未满等待队列</span><br><span class="hljs-comment">/** Lock held by put, offer, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/** Wait queue for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<br><br><span class="hljs-comment">//Node节点定义：</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>Node&lt;?&gt; next;<br><br>Node(E x) &#123; item = x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put方法：-1"><a href="#put方法：-1" class="headerlink" title="put方法："></a>put方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//封装数据为Node</span><br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    putLock.lockInterruptibly();<br>    <span class="hljs-comment">//插入Node</span><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//1 如果队列已满，则阻塞当前线程，将其移入等待队列</span><br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br>            notFull.await();<br>        &#125;<br><span class="hljs-comment">//2 入队操作，插入数据</span><br>        enqueue(node);<br>        <span class="hljs-comment">//3 如果入队过后队列还没有满，唤醒其他被阻塞的生产者线程</span><br>        c = count.getAndIncrement();<br>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>            notFull.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        putLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>        signalNotEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="take方法：-1"><a href="#take方法：-1" class="headerlink" title="take方法："></a>take方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    E x;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;<br>    takeLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件</span><br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>            notEmpty.await();<br>        &#125;<br><span class="hljs-comment">//移除队头元素，获取数据</span><br>        x = dequeue();<br>        c = count.getAndDecrement();<br>        <span class="hljs-comment">//如果当前满足移除元素的条件，则通知被阻塞的消费者线程</span><br><span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>            notEmpty.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        takeLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == capacity)<br>        signalNotFull();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ABQ和LBQ比较"><a href="#ABQ和LBQ比较" class="headerlink" title="ABQ和LBQ比较"></a>ABQ和LBQ比较</h3><p>相同点：</p><p>都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性。</p><p>不同点：</p><ul><li>底层实现：ABQ是数组，LBQ是链表</li><li>锁：ABQ插入和删除采用同一个锁，LBQ在插入和删除分别一个锁，降低阻塞，提高并发效率</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ThreadLocal</title>
    <link href="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/"/>
    <url>/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h1><p>加锁的弊端：</p><blockquote><p>多线程编程中通过synchronized或者lock控制对临界区资源的同步顺序从而解决线程安全的问题。</p><p>通过加锁的方式或让未获取锁的线程阻塞等待，这种方式时间效率并不是很好。</p></blockquote><p>空间换时间：</p><blockquote><p>线程安全问题的核心在于多个线程会对同一临界区共享资源进行操作，若让每个线程使用自己的“共享资源”，那么多个线程互相隔离，就不会出现线程安全的问题。这实际上是一种“空间换时间”的方案，每个线程拥有自己的“共享资源”会占用大量内存，但是不需要同步也就避免了阻塞等待的情况。</p></blockquote><p>虽然ThreadLocal并不是在java.util.concurrent包中而在Java.lang包中，但是我更倾向于将其作为一种并发容器（虽然真实存放的数据是ThreadLocalMap）进行归类。</p><p>从ThreadLocal这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量的副本，达到人手一份的效果，各自用各自的就可以避免共享资源的竞争。</p><h1 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h1><h2 id="void-set-T-value"><a href="#void-set-T-value" class="headerlink" title="void set (T value)"></a>void set (T value)</h2><blockquote><p>set方法设置在前线程中的threadLocal变量的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程实例对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//2. 通过当前线程实例获取到ThreadLocalMap对象</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//3. 如果Map不为null,则以当前threadLocl实例为key,值为value进行存入</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br><span class="hljs-comment">//4.map为null,则新建ThreadLocalMap并存入value</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ThreadLocalMap：</p><ul><li><p>数据真正存放在ThreadLocalMap中，key为当前threadLocal实例</p></li><li><p>ThreadLocalMap的引用作为Thread类的一个属性，被Thread维护</p><ul><li>getMap方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>createMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="T-get"><a href="#T-get" class="headerlink" title="T get()"></a>T get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程的实例对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//2. 获取当前线程的threadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//3. 获取map中当前threadLocal实例为key的值的entry</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//4. 当前entitiy不为null的话，就返回相应的值value</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>map为空时的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//若map已经创建</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-comment">//若map还没创建</span><br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-comment">//initialValue类为protected，表示继承ThreadLocal的类可以通过重写该方法设置默认值</span><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="void-remove"><a href="#void-remove" class="headerlink" title="void remove()"></a>void remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程的threadLocalMap</span><br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br> <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//2. 从map中删除以当前threadLocal实例为key的键值对</span><br>m.remove(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ThreadLocalMap详解"><a href="#ThreadLocalMap详解" class="headerlink" title="ThreadLocalMap详解"></a>ThreadLocalMap详解</h1><p>ThreadLocal类的get、set和remove都是通过调用其属性threadLocals（ThreadLocalMap）的getEntry、set和remove实现的。</p><h2 id="Entry数据结构"><a href="#Entry数据结构" class="headerlink" title="Entry数据结构"></a>Entry数据结构</h2><p>ThreadLocalMap是ThreadLocal的一个静态内部类。和大多数容器一样，其内部维护了一个数组，ThreadLocalMap内部维护了一个Entry类型的tabel数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>    <span class="hljs-comment">//数组会根据需要扩容</span><br>    <span class="hljs-comment">//数组的长度必须是2的幂次方</span><br>    <span class="hljs-keyword">private</span> Entry[] table;<br>    ...<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br>Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>    <span class="hljs-built_in">super</span>(k);<br>    value = v;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Entry是一个以ThreadLocal为key，Object为value的键值对。</p></li><li><p>ThreadLocal是弱引用，因为Entry继承了WeakReference。</p></li><li><p>Entry的构造方法中，调用了super(k)将ThreadLocal实例包装成一个WeakReference</p></li></ul><h2 id="Thread、ThreadLocal、ThreadLocalMap之间的关系"><a href="#Thread、ThreadLocal、ThreadLocalMap之间的关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap之间的关系"></a>Thread、ThreadLocal、ThreadLocalMap之间的关系</h2><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbmNlbnRfd2VuMDc2Ng==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>ThreadLocal数据实际的存放：</p><blockquote><p>每一个线程实例都有一个ThreadLoaclMap实例的属性，ThreadLocalMap中维护了一个Entry数组用于存放不同ThreadLocal实例存放的数据。</p></blockquote><p>通过ThreadLocal存取数据：</p><blockquote><p>ThreadLocal不存储数据，其提供一些方法，操作这些数据。</p><p>通过当前线程实例获取当前线程实例的ThreadLocalMap（在不同的方法中执行，获取的是不同的ThreadLocalMap），然后使用ThreadLocal本身作为key，从ThreadLocalMap中的Entry数组中获取ThreadLocal存放在当前线程中的value。</p></blockquote><p>ThreadLocal根据当前线程获取当前线程对应的ThreadLocalMap（每个线程对应一个ThreadLocalMap），该ThreadLocalMap可以存储多个不同ThreadLocal实例存储在当前线程中的数据（一个ThreadLocal实例可以分别在多个线程中存储一个value）</p><p>ThreadLocal内存泄漏问题：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/16334681776bb805tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="ThreadLocal各引用间的关系"></p><p>Entry中的key是弱引用，当ThreadLocal实例引用被置为null后，这个ThreadLocal实例不可达，会被GC回收，那么ThreadLocalMap中就会出现key为null的额Entry，这个Entry无法被访问，也无法被回收。若线程不结束，这个key为null的Entry会一直存在，无法回收，造成内存泄漏。虽然在线程结束后，线程相关的所有类都会被回收，但是在实际的开发中，会使用线程池，线程为了被复用不会主动结束，这样垃圾也就一直不能被回收。所以在使用完ThreadLocal后，主动的通过remove移除对应的Entry，避免内存泄漏。</p><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><p>ThreadLocalMap通过散列表进行实现。在了解set方法前，先回顾下散列表的相关知识。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。</p><p>理想散列表：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177649b66tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="理想散列表的一个示意图"></p><p>散列冲突：</p><p>在理想状态下，哈希函数可以将关键字均匀地分散到数组地不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称之为散列冲突。</p><p>散列冲突解决：</p><ul><li><p>分离链表法</p><blockquote><p>分离链表法使用链表解决冲突，将散列值相同的元素都保存在一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素。</p><p>典型实现为HashMap和ConcurrentHashMap的拉链法。</p><p>示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177fb894ctplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="分离链表法示意图"></p></blockquote></li><li><p>开放定址法</p><blockquote><p>开放定址法不会创建链表，当关键字散列到的数组单元已经被另一个关键字占用的时候，就会尝试在数组中寻找其他单元，直到找到空的单元。探测数组空单元的方法有很多，最简单的一种为线性探测法。线性探测法就是从发生冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。</p><p>示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177ede9abtplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="开放定址法示意图"></p></blockquote></li></ul><p>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用分离链表法。</p><p>因为ThreadLocalMap中打散列值分散十分均匀，很少发生冲突，并且ThreadLocalMap经常要清除无用对象，使用纯数组更方便。</p><h3 id="set方法源码"><a href="#set方法源码" class="headerlink" title="set方法源码"></a>set方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">//根据threadLocal的hashCode确定Entry应该存放的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp;amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//采用开放地址法，hash冲突的时候使用线性探测</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//覆盖旧Entry</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//当key为null时，说明threadLocal强引用已经被释放掉，那么就无法</span><br>        <span class="hljs-comment">//再通过这个key获取threadLocalMap中对应的entry，这里就存在内存泄漏的可能性</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//用当前插入的值替换掉这个key为null的“脏”entry</span><br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//新建entry并插入table中i处</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <br>    <span class="hljs-comment">//插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容</span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><p>set方法中需要注意的点：</p><ol><li><p>ThreadLocal的hashcode？</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the next hash code.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal实例的hashCode是通过nextHashCode()方法实现的，该方法通过一个AtomicInteger加上0x61c88647来实现。0x61c88647这个数可以保证hash表的每个散列桶能均匀分布。</p></blockquote></li><li><p>怎样确定新值插入到哈希表中的位置？</p><blockquote><p>该操作源码为： key.threadLocalHashCode &amp; (len - 1)，同HashMap和ConcurrentHashMap等容器的方式一样，利用当前key的hashCode与哈希表想与（因为哈希表大小总是2的幂次方，所以想与操作等同于一个取模操作），这样就可以通过key分配到具体的哈希桶中。</p></blockquote></li><li><p>怎样解决hash冲突？</p><blockquote><p>源码中通过nextIndex(i, len)方法来解决hash冲突，该方法为((i + 1 &lt; len) ? i + 1 : 0)，也就是线性探测。</p></blockquote></li><li><p>怎样解决“脏”Entry？</p><blockquote><p>在分析ThreadLocal、ThreadLocalMap和Enty的关系的时候，我们知道ThreadLocal可能存在内存泄漏，在源码中针对key为null的Entry称之为“stale entry”，直译为不新鲜的entry，可以理解为“脏entry”。</p><p>set方法的for循环中寻找到和当前key相同的可覆盖entry的时候，若该entry为“脏entry”则通过replaceStaleEntry方法来解决脏entry。若当前table[i]为null，直接插入新entry后也会执行cleanSomeSlots来解决脏entry问题。</p></blockquote></li><li><p>如何进行扩容？</p><blockquote><p>threshold的确定：</p><p>threshold表示当前哈希表的可用容量。</p><p>在第一次对ThreadLocal进行赋值的时候会创建一个大小为16的ThreadLocalMap，并通过setThreshold方法设置threshold 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next size value at which to resize.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Set the resize threshold to maintain at worst a 2/3 load factor.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其值为哈希数组长度乘以2&#x2F;3，也就是说加载因子为2&#x2F;3。（加载因子过小，内存利用率不高但是hash冲突可能性小，过大，hash冲突的可能性增大）</p><p>resize()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Double the capacity of the table.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1 创建新数组，长度为原数组的2倍</span><br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//2 移动旧数组元素到新数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-comment">//遍历过程中如果遇到脏entry的话</span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//直接置value为null,有助于value能够被回收</span><br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//重新确定entry在新数组的位置，然后进行插入</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    .-*<br>                    看，。看来你h90 <span class="hljs-number">798</span> = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>           &#125;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//3 设置新哈希表的threshHold和size属性</span><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="getEntry方法"><a href="#getEntry方法" class="headerlink" title="getEntry方法"></a>getEntry方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br><span class="hljs-comment">//1. 确定在散列数组中的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//2. 根据索引i获取entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br><span class="hljs-comment">//3. 满足条件则返回该entry</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br><span class="hljs-comment">//4. 未查找到满足条件的entry，额外在做的处理(hash冲突)</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-comment">//找到和查询的key相同的entry则返回</span><br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//解决脏entry的问题</span><br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//继续向后环形查找</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove the entry for key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br><span class="hljs-comment">//将entry的key置为null</span><br>            e.clear();<br><span class="hljs-comment">//将该entry的value也置为null</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Thread-Local的使用场景"><a href="#Thread-Local的使用场景" class="headerlink" title="Thread Local的使用场景"></a>Thread Local的使用场景</h1><p>ThreadLocal不是用来解决共享对象的多线程访问问题的，数据实质上是放在每个thread实例引用的threadLocalMap中，也就是说每个不同的线程都拥有专属于自己的数据容器（threadLcoalMap），彼此不印象。</p><p>因此ThreadLocal只适用于共享对象会造成线程安全问题的业务场景。比如hibernate中通过threadLocal管理Session就是一个典型的案例，不同的请求线程（用户）拥有自己的Session，若将session共享出去被多线程访问，必然带来线程安全问题。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ConcurrentLinkedQueue</title>
    <link href="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/"/>
    <url>/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/</url>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentLinkedQueue简介"><a href="#ConcurrentLinkedQueue简介" class="headerlink" title="ConcurrentLinkedQueue简介"></a>ConcurrentLinkedQueue简介</h1><p>ConcurrentLinkedQueue是一个线程安全的队列，其数据结构是链表。</p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>ConcurrentLinkedQueue的底层节点类Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        <span class="hljs-keyword">volatile</span> E item;<br>        <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br>.......<br>&#125;<br></code></pre></td></tr></table></figure><p>Node包含两个属性：（都使用volatile修饰，保证内存可见性）</p><ul><li><p>一个数据域item，用于保存数据</p></li><li><p>一个next指针，用于构成链式队列</p></li></ul><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;<br></code></pre></td></tr></table></figure><p>ConcurrentLinkedQueue通过持有链表的头尾节点来管理队列。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentLinkedQueue</span><span class="hljs-params">()</span> &#123;<br>    head = tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/1633459982863c26tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="1.ConcurrentLinkedQueue初始化状态.png"></p><h2 id="操作Node的几个CAS操作"><a href="#操作Node的几个CAS操作" class="headerlink" title="操作Node的几个CAS操作"></a>操作Node的几个CAS操作</h2><p>在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更改Node中的数据域item</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casItem</span><span class="hljs-params">(E cmp, E val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, itemOffset, cmp, val);<br>&#125;<br><span class="hljs-comment">//更改Node中的指针域next</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySetNext</span><span class="hljs-params">(Node&lt;E&gt; val)</span> &#123;<br>    UNSAFE.putOrderedObject(<span class="hljs-built_in">this</span>, nextOffset, val);<br>&#125;<br><span class="hljs-comment">//更改Node中的指针域next</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, nextOffset, cmp, val);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些方法实际上通过UNSAFE实例的方式，UNSAFE位sun.misc.Unsafe类，该类是hotspot底层方法。</p><h1 id="offer-方法"><a href="#offer-方法" class="headerlink" title="offer()方法"></a>offer()方法</h1><p>关于offer源码的思考方向：</p><ul><li><p>单线程offer</p></li><li><p>多个线程offer</p></li><li><p>部分线程offer，部分线程poll</p><ul><li><p>offer的速度快于poll</p><blockquote><p>队列长度越来越长，offer在队列尾部操作，poll在队头，两个线程不会互相影响</p></blockquote></li><li><p>poll的速度快于offer</p><blockquote><p>队列会越来越短，offer线程和poll线程会出现“交集”，这一时刻可以称offer线程和poll线程同时操作的节点为临界点。</p><p>对于该临界点poll和offer的发生相对顺序的思考角度：</p><ul><li><p>offer-poll-offer</p><blockquote><p>当offer线程在Node1后扎入Node2时，此时poll线程已经将Node1删除，这种情况需要在offer方法中考虑</p></blockquote></li><li><p>poll-offer-poll</p><blockquote><p>当poll线程准备删除节点（队列为空），此时offer线程插入一个节点使得队列为非空，这种情况应该是poll线程考虑</p></blockquote></li></ul></blockquote></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//null判断</span><br>    checkNotNull(e);<br>    <span class="hljs-comment">//将数据包装成一个Node类</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>    <span class="hljs-comment">//循环直到成功插入Node</span><br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<br>        <span class="hljs-comment">//t为tail,但是tail并不一定指向真正的尾节点，因为tail是被延迟更新的</span><br>        <span class="hljs-comment">//p为指针用于寻找真正尾节点，q用于辅助p判断是否到达尾节点</span><br>        Node&lt;E&gt; q = p.next;<br>        <span class="hljs-comment">//1 p为尾节点，执行插入</span><br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//CAS插入新节点，如果CAS失败会在下一次循环重试</span><br>            <span class="hljs-keyword">if</span> (p.casNext(<span class="hljs-literal">null</span>, newNode)) &#123;<br>                <span class="hljs-comment">//插入节点成功后更新tail（tail延迟更新机制）</span><br>                <span class="hljs-comment">//p为真尾节点，t为tail，如果tail没有指向真尾节点，则更新tail</span><br>                <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// hop two nodes at a time</span><br>                casTail(t, newNode);  <span class="hljs-comment">// Failure is OK.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//2 p不为尾节点，移动p指针直到找到尾节点</span><br>        <span class="hljs-comment">//2.1 p节点其next指向自己，这种节点称之为哨兵节点，说明在本线程执行offer的过程中，p节点被删除了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>            p = (t != (t = tail)) ? t : head;<br>        <span class="hljs-comment">//2.2 如果p指向的不是真正的尾节点</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//移动p指针，寻找真正尾节点</span><br>            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单线程offer分析"><a href="#单线程offer分析" class="headerlink" title="单线程offer分析"></a>单线程offer分析</h2><p>单线程相关代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br></code></pre></td></tr></table></figure><p>在单线程中，条件(p !&#x3D; t &amp;&amp; t !&#x3D; (t &#x3D; tail))一定为false，所以单线程offer中该代码段等价于p &#x3D; q</p><h2 id="多线程offer分析"><a href="#多线程offer分析" class="headerlink" title="多线程offer分析"></a>多线程offer分析</h2><p>多线程offer相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">t != (t = tail))<br></code></pre></td></tr></table></figure><p>若在执行offer操作的过程中，有其他的offer线程执行完毕（tail值可能更新），左边t为旧值压入栈中，右边t被赋予新的tail值，该表达式为真，说明tail更新，直接将tail赋予p</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599933a4aabtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="5.线程A和线程B有可能的执行时序.png"></p><h2 id="offer-poll-offer分析"><a href="#offer-poll-offer分析" class="headerlink" title="offer-poll-offer分析"></a>offer-poll-offer分析</h2><p>初始状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599c2390c2btplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="10.offer和poll相互影响分析时队列初始状态.png"></p><p>在执行offer的时候，有一个线程完成poll：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599cd4cbdabtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="11.线程A和线程B可能存在的执行时序.png"></p><p>另一个线程完成poll后的状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599d7d92981tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="12.线程B进行poll后队列的状态图.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>    p = (t != (t = tail)) ? t : head;<br></code></pre></td></tr></table></figure><p>p &#x3D;&#x3D; q表示在当前线程在执行offer操作的时候，其他线程已经将p设置为哨兵节点了，此时需要重新给p赋值来寻找真正的尾节点</p><p>由前面的多线程分析可知，若t !&#x3D; (t &#x3D; tail))为真，说明在当前线程执行offer期间tail更新了，则将p置为tail，若没有，则将p置为head（因为其他线程设置哨兵节点的时候肯定会更新head）</p><h1 id="poll-方法"><a href="#poll-方法" class="headerlink" title="poll()方法"></a>poll()方法</h1><p>poll方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//标记点</span><br>    restartFromHead: <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//初始化h,p,q</span><br>        <span class="hljs-comment">//p指针用于寻找真正的头节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;; p = q) &#123;<br>            <span class="hljs-keyword">final</span> E item;<br>            <span class="hljs-comment">//1 若p为头节点，CAS将其数据item置为null（若CAS失败，则会等待下一次循环重试）</span><br>            <span class="hljs-keyword">if</span> ((item = p.item) != <span class="hljs-literal">null</span> &amp;&amp; p.casItem(item, <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-comment">//1.1 若真正的头节点不为head，则更新head</span><br>                <span class="hljs-keyword">if</span> (p != h) <span class="hljs-comment">// hop two nodes at a time</span><br>                    <span class="hljs-comment">//若p为尾节点，则将p置为head，若p不为尾节点，则将p.next置为head</span><br>                    updateHead(h, ((q = p.next) != <span class="hljs-literal">null</span>) ? q : p);<br>                <span class="hljs-comment">//1.2 返回头节点数据</span><br>                <span class="hljs-keyword">return</span> item;<br>            &#125;<br>            <span class="hljs-comment">//2 若队列为空，返回null</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                updateHead(h, p);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//3 若p已经被其他线程给poll出去了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>                <span class="hljs-comment">//返回标记点重试poll操作</span><br>                <span class="hljs-keyword">continue</span> restartFromHead;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更新head</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateHead</span><span class="hljs-params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> &#123;<br>    <span class="hljs-keyword">if</span> (h != p &amp;&amp; casHead(h, p))<br>        <span class="hljs-comment">//lazySetNext将h的next设置为其自己</span><br>        h.lazySetNext(h);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="head属性的延迟更新"><a href="#head属性的延迟更新" class="headerlink" title="head属性的延迟更新"></a>head属性的延迟更新</h2><p>初始状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599936bd919tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="6.队列初始状态.png"></p><p>第一次poll过后的状态：</p><blockquote><p>只是简单的将head指向的节点item置为null，标记其已经被poll出去了</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/163345999f3d68bbtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="7.队列出队操作后的状态.png"></p><p>第二次poll：</p><ul><li><p>第一次循环结束：</p><blockquote><p>第一次循环p指针指向的不是真正的head，所以第一次循环只是移动p指针</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599bd85583btplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="8.经过一次循环后的状态.png"></p></li><li><p>第二次循环结束：</p><blockquote><p>经过第一次循环移动p指着过后，此时p已经指向真正的头节点，此时执行updateHead设置head</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599be78fddetplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="9.Node2从队列中出队后的状态.png"></p></li></ul><h2 id="单线程poll分析"><a href="#单线程poll分析" class="headerlink" title="单线程poll分析"></a>单线程poll分析</h2><ul><li>若p指向节点的item不为null，说明该节点为真正头节点（待删除节点）<ul><li>若p与head相等，只需要将其item置为null，不需要真正执行删除</li><li>若不相等，则需要使用updateHead更新head，真正执行删除（）</li><li>最后返回item即可。</li></ul></li><li>若p指向的节点item为null，说明该节点并非真正的头节点，那么就需要移动p指针寻找真正头节点（item不为null的节点）</li></ul><h2 id="多线程poll分析"><a href="#多线程poll分析" class="headerlink" title="多线程poll分析"></a>多线程poll分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>    <span class="hljs-keyword">continue</span> restartFromHead;<br></code></pre></td></tr></table></figure><p>p &#x3D;&#x3D; q说明p指向的节点已经称为哨兵节点，即已经被其他线程poll出去了，则需要从restartFromHead重新开始执行poll，重新用到的是最新的head</p><h2 id="poll-offer-poll情况分析"><a href="#poll-offer-poll情况分析" class="headerlink" title="poll-offer-poll情况分析"></a>poll-offer-poll情况分析</h2><p>在执行poll线程的时候，若执行到else if ((q &#x3D; p.next) &#x3D;&#x3D; null) 已经判断队列为空了，这时另一个线程完成了offer操作，此时线程已经判断队列为空，但是实际上队列不为空，该线程仍会返回null</p><p>所以说判断空队列不能通过poll操作返回null进行判断，而是要使用isEmpty方法进行判断。</p><h1 id="HOPS的设计"><a href="#HOPS的设计" class="headerlink" title="HOPS的设计"></a>HOPS的设计</h1><h2 id="tail和head更新触发机制"><a href="#tail和head更新触发机制" class="headerlink" title="tail和head更新触发机制"></a>tail和head更新触发机制</h2><p>通过上面个的offer和poll的分析，我们可知tail和head的更新是延迟的，二者的更新触发机制：</p><ul><li>tail更新：当tail指向的节点的下一个节点不为null的时候（不是真正的尾节点），会执行定位队列真正尾节点的操作，找到尾节点后完成插入操作之后，才会通过casTail进行tail的更新；当tail指向的下一个节点为null的时候，只插入节点不更新tail</li><li>head更新：当head指向的节点的item域为null的时候，会执行定位队列真正头节点的操作，找到头节点后完成删除之后，通过updateHead更新head，当head指向的item不为null的时候，只删除节点不更新head</li></ul><h2 id="延迟更新的目的"><a href="#延迟更新的目的" class="headerlink" title="延迟更新的目的"></a>延迟更新的目的</h2><p>更新tail和head是CAS操作，使用延迟更新可以减少CAS更新的操作。通过p指针定位头尾节点操作，来代替每次都CAS更新头尾节点的操作，提高offer和poll操作的效率。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-CopyOnWriteArrayList</title>
    <link href="/2022/10/18/Java%E5%B9%B6%E5%8F%91-CopyOnWriteArrayList/"/>
    <url>/2022/10/18/Java%E5%B9%B6%E5%8F%91-CopyOnWriteArrayList/</url>
    
    <content type="html"><![CDATA[<h1 id="CopyOnWriteArrayList简介"><a href="#CopyOnWriteArrayList简介" class="headerlink" title="CopyOnWriteArrayList简介"></a>CopyOnWriteArrayList简介</h1><p>ArrayList并不是线程安全的，可以使用Vector，或者Collections的静态方法将ArrayList包装成一个线程安全的类，这两种方式都是使用synchronized加锁的方式，利用独占锁来保证线程安全的，效率低。</p><p>业务场景，很多业务都是读多写少的：</p><ul><li><p>比如系统配置信息，除了在初始进行系统配置的时候需要写入数据，其他大部分时刻都只需要读取配置</p></li><li><p>又比如白名单、黑名单</p></li></ul><p>读多写少的情况可以使用ReentrantReadWriteLock：</p><ul><li>优点：读写分离，读读之间不会阻塞</li><li>局限：写锁被写线程获取后，读线程会被阻塞</li></ul><p>CopyOnWriteArrayList容器可以解决读写锁的局限性。</p><h1 id="COW的设计思想"><a href="#COW的设计思想" class="headerlink" title="COW的设计思想"></a>COW的设计思想</h1><p>COW通俗理解：</p><p>COW通俗的理解是当我们往容器中添加一个元素的时候，不直接往容器中添加，而是先将当前容器进行Copy，复制出来一个新的容器，然后将元素添加到新的容器中，添加完元素后，再将原容器的引用指向新容器。</p><p>对CopyOnWrite容器进行并发读的时候，不用加锁，因为当前容器不会添加新元素。</p><p>对CopyOnWrite容器进行并发写的时候，是在新建的容器中执行写，所以读取到的数据会有延迟，放弃了数据实时性。</p><p>数据实时性：</p><p>若是简单的使用读写锁，在写锁被获取后，读写线程都会被阻塞，只有当写锁释放后，读线程才有机会获取到读锁读取数据。站在读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性。COW通过<strong>牺牲数据实时性</strong>，满足数据的最终一致性来避免读线程的阻塞。</p><h1 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h1><p>数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//该数组只能通过getArray()和setArray()方法访问</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></td></tr></table></figure><ul><li><p>CopyOnWriteArrayList内部维护的是一个数组。</p></li><li><p>该数组引用被volatile修饰，保证其可见性。</p></li></ul><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><span class="hljs-keyword">final</span> Object[] getArray() &#123;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br><span class="hljs-comment">//1. 使用Lock,保证写线程在同一时刻只有一个</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//2. 获取旧数组引用</span><br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br><span class="hljs-comment">//3. 创建新的数组，并将旧数组的数据复制到新数组中</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//4. 往新数组中添加新的数据</span><br>newElements[len] = e;<br><span class="hljs-comment">//5. 将旧数组引用指向新的数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="COW-vs-读写锁"><a href="#COW-vs-读写锁" class="headerlink" title="COW vs 读写锁"></a>COW vs 读写锁</h2><p>相同点：</p><ul><li>两种都是通过读写分离的思想实现</li><li>读线程间是互不阻塞的</li></ul><p>不同点：</p><ul><li>读写锁：为了实现数据实时性，在写锁被获取后，读线程会被阻塞。为了解决“脏读”问题，读锁被获取后，写线程会被阻塞</li><li>COW则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延迟感知的，因此读线程永远不会被阻塞。</li></ul><h2 id="COW的缺点"><a href="#COW的缺点" class="headerlink" title="COW的缺点"></a>COW的缺点</h2><ul><li>内存占用问题：因为COW的运行机制，在写操作的时候，内存中会有两个对象（旧容器和新容器）。</li><li>数据一致性问题：COW容器只能保证数据的最终一致性，不能保证数据的实时一致性。（弱一致性）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-ConcurrentHashMap</title>
    <link href="/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/"/>
    <url>/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashmap简介"><a href="#ConcurrentHashmap简介" class="headerlink" title="ConcurrentHashmap简介"></a>ConcurrentHashmap简介</h1><p>HashMap在多线程情况下扩容可能会陷入死循环。</p><p>线程安全的map使用：</p><ul><li>hashtable类</li><li>Collections提供的方法将map包装成线程安全的map。Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</li><li>concurrentHashMap</li></ul><p>上面两种方式都是通过synchronized关键字来实现线程安全的。</p><p>concurrentHashMap的不同版本：</p><ul><li><p>JDK1.6</p><blockquote><ul><li>segment继承ReentrantLock充当锁的角色,为每一个segement提供线程安全保障</li><li>每个segment维护了哈希散列表的若干个桶,每个桶由HashEntry构成链表</li></ul></blockquote></li><li><p>JDK1.8</p><blockquote><ul><li><p>通过synchronized和CAS无锁操作</p><blockquote><p>1.8中的synchronized引入了锁升级的机制，使得其性能相较于ReentrantLock的性能持平甚至更优</p></blockquote></li><li><p>底层数据结构改变为数组 + 链表 + 红黑树</p></li></ul></blockquote></li></ul><h1 id="关键属性及类"><a href="#关键属性及类" class="headerlink" title="关键属性及类"></a>关键属性及类</h1><h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><ul><li><p>table</p><blockquote><p>volatile Node&lt;K,V&gt;[] table：装载Node的数组</p><p>作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是2的幂次方</p></blockquote></li><li><p>nextTable</p><blockquote><p>volatile Node&lt;K,V&gt; nextTabele：扩容时使用</p><p>平时为null，在扩容的时候为非null</p></blockquote></li><li><p>sizeCtl</p><blockquote><p>volatile int sizeCtl：用于控制table数组的大小</p><p>根据是否初始化和是否正在扩容有集中情况：</p><ul><li><p>值为负：</p><ul><li>-1：正在初始化</li><li>-N：当前正有N-1个线程进行扩容操作</li></ul></li><li><p>值为正：</p><ul><li><p>如果数组为null，表示table正在初始化，sizeCtl表示初始化数组的长度</p></li><li><p>若数组不为null，表示已经初始化完毕，sizeCtl表示临界值</p><blockquote><p>插入节点数超过临界值后需要扩容，具体指数组容量乘以加载因子（loadFactor）</p></blockquote></li><li><p>当值为0时，即数组长度为默认初始长度</p></li></ul></li></ul></blockquote></li><li><p>sun.misc.Unsafe U</p><blockquote><p>ConcurrentHashMap的实现中大量的使用CAS来修改ConcurrentHashMap的一些属性。就是通过调用Unsafe类的compareAndSwapXXXX的方法实现的。</p><p>该类提供了一些可以直接操控内存和线程的底层操作，可以理解为Java中的“指针”。</p><p>该成员变量的获取是在静态代码中执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        U = sun.misc.Unsafe.getUnsafe();<br>        .......<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li><p>Node</p><blockquote><p>Node类实现了Map.Entry接口，主要存放key-value对，且拥有next域，由于链接成链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>TreeNode</p><blockquote><p>继承于Node类。</p><p>而红黑树的操作是针对TreeBin类，TreeNode会被TreeBin封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-type">boolean</span> red;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>TreeBin</p><blockquote><p>TreeBin，不负责包装用户的key-value信息，而是包装很多的TreeNode节点。</p><p>ConcurrentHashMap的“数组”中，存放的是TreeBin对象，而不是TreeNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    TreeNode&lt;K,V&gt; root;<br>    <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<br>    <span class="hljs-keyword">volatile</span> Thread waiter;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lockState;<br>    <span class="hljs-comment">// values for lockState</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WRITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">READER</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>ForwardingNode</p><blockquote><p>该节点在扩容的时候才会出现，其key、value和hash全为null。</p><p>其拥有nextTable指针引用新的table数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;<br>    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.nextTable = tab;<br>    &#125;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h1 id="重点方法解析"><a href="#重点方法解析" class="headerlink" title="重点方法解析"></a>重点方法解析</h1><h2 id="CAS关键操作"><a href="#CAS关键操作" class="headerlink" title="CAS关键操作"></a>CAS关键操作</h2><p>ConcurrentHashMap中会大量使用CAS修改它的属性和一些操作，在理解其他方法之前先了解如下几个常用的CAS算法，用于保障线程安全。</p><ul><li><p>tabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取table数组中索引为i的Node元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>casTabAt</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//CAS操作设置table数组中索引为i的元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i,</span><br><span class="hljs-params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;<br>    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置table数组中索引为i的元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;<br>    U.putObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="实例构造器方法"><a href="#实例构造器方法" class="headerlink" title="实例构造器方法"></a>实例构造器方法</h2><h3 id="ConcurrentHashMap提供的构造器方法："><a href="#ConcurrentHashMap提供的构造器方法：" class="headerlink" title="ConcurrentHashMap提供的构造器方法："></a>ConcurrentHashMap提供的构造器方法：</h3><p>构造器方法只是确定了table数组的长度，并未进行table数组的初始化。等到第一次插入数据的时候，table数组才真正进行初始化工作。</p><ul><li><p>ConcurrentHashMap()</p><blockquote><p>默认map大小为16</p></blockquote></li><li><p>ConcurrentHashMap(int initalCapacity)</p><blockquote><p>给定map的大小</p></blockquote></li><li><p>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</p><blockquote><p>给定一个map用于创建ConcurrentHashMap</p></blockquote></li><li><p>ConcurrentHashMap(int initialCapacity, float loadFactor)</p><blockquote><p>给定map的大小和记载因子</p></blockquote></li><li><p>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</p><blockquote><p>给定map的大小、加载因子和并发度（预计同时操作数据的线程）</p></blockquote></li></ul><h3 id="给定map大小的构造器方法解析"><a href="#给定map大小的构造器方法解析" class="headerlink" title="给定map大小的构造器方法解析"></a>给定map大小的构造器方法解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造器的工作只有给sizeCtl赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br><span class="hljs-comment">//1. 小于0直接抛异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ?<br>               MAXIMUM_CAPACITY :<br>               <span class="hljs-comment">//将输入的值转化为一个2的幂次方数</span><br>               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));<br><span class="hljs-comment">//3. 赋值给sizeCtl</span><br>    <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-comment">//若table还未初始化，或者table的长度为0，通过while循环执行初始化</span><br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1 sizeCtl &lt; 0，说明已经有线程在初始化table了</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">//让出CPU时间片</span><br>            Thread.yield();<br>        <span class="hljs-comment">//2 CAS设置sizeCtl状态为-1，表示有线程在执行初始化</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">//2.1 若CAS成功，说明没有其他线程在执行初始化，则当前线程执行初始化工作</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//得出数组的大小</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//这里才真正的初始化数组</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br><span class="hljs-comment">//计算数组中可用的大小：实际大小n*0.75（加载因子）</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//在finally中为sizeCtl赋值，退出初始化状态</span><br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-comment">//初始化完成，退出while循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//2.2 若CAS失败，说明有其他线程在执行初始化且CAS竞争成功，则线程在while循环中spin直到初始化操作完成</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-comment">//计算key的hash值（spread对hashCode进行重哈希，以减小Hash冲突）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br><span class="hljs-comment">//1 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <br>        <span class="hljs-comment">//获取table中索引为i的元素f</span><br><span class="hljs-comment">//2 tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br><span class="hljs-comment">//3 当前正在扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-comment">//4 索引i处已经有数据，将node插入该处的链表或树</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//使用同步代码块的方式，锁定</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br><span class="hljs-comment">//4.1 当前为链表，在链表中插入新的键值对</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">//初始化指针e，每一次循环都会将e后移动，有两个出口</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-comment">//出口一、若节点key与要插入的key相同，则覆盖旧值即可</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-comment">//出口二、e到达链表结尾，新建节点插入链表</span><br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br><span class="hljs-comment">//4.2 当前为红黑树，将新的键值对插入到红黑树中</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">//4.3 插入完键值对后再根据实际大小看是否需要转换成红黑树</span><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//临界值为8</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//5 对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcurrentHashMap是一个哈希桶数组，结构如下：</p><p><img src="/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/163344e982f9eed4tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="ConcurrentHashMap散列桶数组结构示意图"></p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br><span class="hljs-comment">//重hash</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//1. table[i]桶节点的key与查找的key相同，则直接返回</span><br><span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br><span class="hljs-comment">//2. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//3. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br><span class="hljs-comment">//1. 新建Node数组，容量为之前的两倍</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// initiating</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nextTable = nextTab;<br>        transferIndex = n;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br><span class="hljs-comment">//2. 新建forwardingNode引用，在之后会用到</span><br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>        <span class="hljs-comment">// 3. 确定遍历中的索引i</span><br><span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-type">int</span> nextIndex, nextBound;<br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                advance = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                     (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                      nextBound = (nextIndex &gt; stride ?<br>                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//4.将原数组中的元素复制到新数组中去</span><br><span class="hljs-comment">//4.5 for循环退出，扩容结束修改sizeCtl属性</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-type">int</span> sc;<br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                nextTable = <span class="hljs-literal">null</span>;<br>                table = nextTab;<br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    <span class="hljs-keyword">return</span>;<br>                finishing = advance = <span class="hljs-literal">true</span>;<br>                i = n; <span class="hljs-comment">// recheck before commit</span><br>            &#125;<br>        &#125;<br><span class="hljs-comment">//4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符)</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br><span class="hljs-comment">//4.2 如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    Node&lt;K,V&gt; ln, hn;<br>                    <span class="hljs-comment">//4.3 处理当前节点为链表的头结点的情况</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        ...<br>                    <span class="hljs-comment">//4.4 处理当前节点是TreeBin时的情况 </span><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        ...<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于ConcurrentHashmap的size-方法"><a href="#关于ConcurrentHashmap的size-方法" class="headerlink" title="关于ConcurrentHashmap的size()方法"></a>关于ConcurrentHashmap的size()方法</h2><p>对于ConcurrenHashMap来说，这个table中到底装了多少个Node是不确定的，因为多线程的关系。</p><p>不可能像GC时“stop the world”暂停所有线程来统计，所以说这个数量是个估计值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6、7中的ConcurrentHashmap：</p><ul><li>使用Segment来减小锁的颗粒度，分割成若干个Segment，在put的时候锁住对应的Segment，get的时候不加锁</li><li>使用volatile来保证可见性</li><li>当要统计全局时（如size），首先会尝试多次计算modcount，若这几次尝试中没有其他线程进行修改操作，直接返回size，若有，则需要依次锁住所有Segment来计算</li><li>put定位节点：先定位到具体Segment，再在Segment中定位到具体的桶</li></ul><p>JDK8之后：</p><ul><li>不使用Segment而是采用Node，锁住Node来减小锁粒度</li><li>设计了MOVED状态，当resize的过程中，其他执行put的线程会帮助resize</li><li>CAS替代锁，使用了3个CAS操作来确保对Node的一些操作的原子性</li><li>sizeCtl的不同值来代表不同的状态，起到控制作用</li><li>采用synchronized而不是ReentrantLock</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-LockSupport</title>
    <link href="/2022/10/18/Java%E5%B9%B6%E5%8F%91-LockSupport/"/>
    <url>/2022/10/18/Java%E5%B9%B6%E5%8F%91-LockSupport/</url>
    
    <content type="html"><![CDATA[<h1 id="LockSupport简介"><a href="#LockSupport简介" class="headerlink" title="LockSupport简介"></a>LockSupport简介</h1><p>调用LockSupport场景：</p><ul><li><p>AQS的底层实现中</p></li><li><p>锁的实现</p></li><li><p>Condition中，线程的等待&#x2F;通知机制</p></li></ul><p>LockSupport位于java.util.concurrent.locks包下，LockSupport时线程的阻塞原语，用来阻塞和唤醒线程。</p><p>每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可以在线程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用unpark()使其可用。但是注意，许可不可重入，也就是说只能调用一次park()方法，否则会一直阻塞。</p><h1 id="LockSupport方法介绍"><a href="#LockSupport方法介绍" class="headerlink" title="LockSupport方法介绍"></a>LockSupport方法介绍</h1><p>阻塞线程：</p><ul><li><p>void park()</p><blockquote><p>唤醒当前线程，如果调用unpark方法或者当前线程被中断，才能从park()方法中返回</p></blockquote></li><li><p>void park(Object blocker)</p><blockquote><p>功能同park()，入参增加了一个Object对象，用于记录导致线程阻塞的阻塞对象，方便进行问题排查</p></blockquote></li><li><p>void parkNanos(long nanos)</p><blockquote><p>增加了超时返回特性</p></blockquote></li><li><p>void parkNanos(Object blocker, long nanos)</p></li><li><p>void parkUntil(long deadline)</p><blockquote><p>阻塞档期那线程，知道deadline</p></blockquote></li><li><p>void parkUntil(Object blocker, long deadline)</p></li></ul><p>唤醒线程：</p><ul><li><p>void unpark(Thread thread)</p><blockquote><p>唤醒处于阻塞状态的指定线程</p></blockquote></li></ul><h1 id="LockSupport底层"><a href="#LockSupport底层" class="headerlink" title="LockSupport底层"></a>LockSupport底层</h1><p>LockSupport阻塞和唤醒线程的功能都是依赖于sun.misc.Unsafe类实现。</p><p>阻塞线程方法都有一个带Object阻塞对象的重载方法。该阻塞对象用于记录阻塞对象，类似于synchronized阻塞了线程dump线程时，都会有阻塞对象的藐视。在Java5推出LockSupport的时候遗漏了这一点，所以说在Java6中补充了这些带Object阻塞对象的重载方法。</p><p>synchronized与LockSupport阻塞区别：</p><ul><li>synchronized使线程阻塞，线程进入BLOCKED状态</li><li>LockSupport方法阻塞线程，线程进入WAITING状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Condition</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/</url>
    
    <content type="html"><![CDATA[<h1 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h1><p>等待通知机制的实现：</p><ul><li><p>Object：</p><blockquote><p>任何一个Java对象都是继承自Object类，在线程间实现通信往往会使用到Object的的wait()和notify()来实现等待&#x2F;通知机制。</p><p> Object的wait()和notify()是与对象监视器配合完成线程间的等待&#x2F;通知机制</p></blockquote></li><li><p>Condition:</p><blockquote><p>Condition实现和Object类wait()和notify()同样功能。</p><p>Condition是与Lock配合完成等待&#x2F;通知机制</p></blockquote></li></ul><p>前者是java底层级别的，Condition是语言级别的，具有更高的可控性和扩展性。</p><p>Condition支持，但Object方式不支持的功能特性：</p><ul><li>可以不响应中断</li><li>多个等待队列：Condition能够至此多个等待队列（new多个Condition对象）</li><li>设置超时时间</li></ul><p>Condition对应于Object的等待通知机制的方法：</p><ul><li><p>针对Object的wait方法</p><blockquote><p>Condition提供的方法：</p><ul><li>void await() throws InterruptedException</li></ul><blockquote><p>当前线程进入等待状态，如果其他线程调用condition的signal方法，并且当前线程获取锁，从await方法返回，如果在等待状态中被中断会抛出被中断异常</p></blockquote><ul><li>long awaitNanos(long nanosTimeout)</li></ul><blockquote><p>当前线程进入等待状态，直到被通知、中断或超时</p></blockquote><ul><li><p>boolean await(long time, TimeUnit unit) throws InterruptedException</p></li><li><p>boolean awatiUntil(Date deadline) throws InterruptedException</p></li></ul></blockquote></li><li><p>针对Object的notify方法</p><blockquote><p>Conditon提供的方法:</p><ul><li>void signal()</li></ul><blockquote><p>唤醒一个等待在condition上的线程，将该线程从等待队列转移到同步队列中，如果被唤醒的线程能够在同步队列中竞争到锁，则可以从等待方法中返回</p></blockquote><ul><li>void signalAll()</li></ul><blockquote><p>于signal的区别在于，signalAll会唤醒所有等待在condition上的线程</p></blockquote></blockquote></li></ul><h1 id="Condition实现原理"><a href="#Condition实现原理" class="headerlink" title="Condition实现原理"></a>Condition实现原理</h1><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><h3 id="新建condition对象："><a href="#新建condition对象：" class="headerlink" title="新建condition对象："></a>新建condition对象：</h3><p>创建condition对象是通过lock.newConditon()，这个方法实际上会new出一个ConditionObject对象，该类是AQS的一个内部类。condition要配合lock使用，而lock的实现又依赖于AQS，所以说CondetionObject作为AQS的一个内部类比较合理。</p><h3 id="等待队列："><a href="#等待队列：" class="headerlink" title="等待队列："></a>等待队列：</h3><p>在锁机制的实现上，AQS内部维护一个同步队列，若是独占式锁的话，获取锁失败的线程会尾插入同步队列。AQS通过head和tail指针来维护同步队列。</p><p>同样，condition内粗维护一个等待队列，调用condition.await() 方法的线程会加入到等待等待队列中，并将线程状态转换为等待状态。ConditionObject同样通过持有等待队列的头尾指针来管理队列。等待队列是通过复用Node类，使用其nextWaiter属性实现，可知其为单向队列。</p><p>Condition中的头尾节点成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//等待队列头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br><span class="hljs-comment">//等待队列尾节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br></code></pre></td></tr></table></figure><p>Node节点中的关于等待队列的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//后继节点</span><br>Node nextWaiter;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e65f9685tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="AQS持有多个Condition.png"></p><p>ConditionObject是AQS的内部类，因此每个ConditionObject能够访问到AQS提供的方法，相当于每个Condition都拥有所属同步器的引用。</p><h2 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h2><p>当调用condition.await() 方法后会使得当前获取lock的线程进入等待队列，直到被signal唤醒，使得当前线程从等待队列移至同步队列，直到线程获取锁后才从await方法中返回</p><p>awati ()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-comment">// 1. 将当前线程包装成Node，尾插入到等待队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br><span class="hljs-comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">// 3. 当前线程进入到等待状态</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><span class="hljs-comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br><span class="hljs-comment">// 5. 处理被中断的情况</span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将线程添加到等待队列"><a href="#将线程添加到等待队列" class="headerlink" title="将线程添加到等待队列"></a>将线程添加到等待队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br><span class="hljs-comment">//将当前线程包装成Node</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>    <span class="hljs-comment">//若为插入等待队列的一个节点，初始化firstWaiter</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-comment">//否则，尾插入</span><br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br><span class="hljs-comment">//更新lastWaiter</span><br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="释放锁的过程"><a href="#释放锁的过程" class="headerlink" title="释放锁的过程"></a>释放锁的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br><span class="hljs-comment">//成功释放同步状态</span><br>            failed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//不成功释放同步状态抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何从await中退出"><a href="#如何从await中退出" class="headerlink" title="如何从await中退出"></a>如何从await中退出</h3><p>第一次调用condition.await ()方法时，会进入这个while循环中，然后通过LockSupport.park(this)使得当前线程进入等待状态。</p><p>若要退出await方法，前提就是退出这个while循环，有两个出口：</p><ol><li><p>逻辑走到break退出while循环</p></li><li><p>while循环中逻辑判断为false</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//出口1: 若当前节点被移动到同步队列中，退出循环</span><br><span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">//当前线程进入到等待状态</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//出口2：若当前节点对应的线程被中断，break</span><br>    <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出while循环的条件：当前线程被中断或者调用condition.signal方法将当前节点移动到了同步队列。</p><p>退出while循环后会调用acquireQueued(node, savedState)，该方法自旋获取同步状态，直至成功（获取锁）。</p><h3 id="await执行示意图"><a href="#await执行示意图" class="headerlink" title="await执行示意图"></a>await执行示意图</h3><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e74cead3tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="await方法示意图"></p><h3 id="condition特性的实现"><a href="#condition特性的实现" class="headerlink" title="condition特性的实现"></a>condition特性的实现</h3><h4 id="超时机制的支持"><a href="#超时机制的支持" class="headerlink" title="超时机制的支持"></a>超时机制的支持</h4><p>实现基本于AQS中的tryAcquire方法一致。</p><h4 id="不响应中断支持"><a href="#不响应中断支持" class="headerlink" title="不响应中断支持"></a>不响应中断支持</h4><p>想要不响应中断可以调用condition.awaitUninterruptibly()方法，方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法基本于await()方法一致，只不过是减少了对中断的处理，省略了reportInterruptAfterWait方法抛出被中断异常</p><h2 id="signal实现原理"><a href="#signal实现原理" class="headerlink" title="signal实现原理"></a>signal实现原理</h2><p>signal()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 先检测当前线程是否已经获取lock</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//2. 获取等待队列中第一个节点，之后的操作都是针对这个节点</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure><p>doSignal()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>    <span class="hljs-comment">//do-while至少执行一次</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//1. 移动firstWaiter指针，若移动后指向null说明等待队列为空</span><br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//将lastWaiter置null</span><br>            lastWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//2. 将头结点从等待队列中移除，帮助垃圾回收</span><br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//3. while中transferForSignal方法对头结点做真正的处理</span><br>    <span class="hljs-comment">//transferForSignal将头节点插入同步队列</span><br>    <span class="hljs-comment">//若返回true，则表示插入成功，while循环结束</span><br>   <span class="hljs-comment">//若返回false，表示插入失败，while逻辑判断中的（frist = firstWaiter）移动first指针，再重复do-while逻辑</span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>transferForSignal(Node node)源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//传入参数node为等待队列的头节点</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-comment">//1. CAS更新node状态为0</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-comment">//若CAS失败，说明有多线程冲突，返回false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">//2. 将该节点尾插入到同步队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-comment">//看当前线程能否直接获取锁被唤醒</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-comment">//3. 节点插入同步队列成功后，返回true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>signal执行示意图：</p><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e7650d62tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="signal执行示意图"></p><p>signalAll()：</p><p>signalAll()和signal ()方法区别在于doSignalAll()方法：循环将等待队列中的节点移入同步队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;<br>    lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br>        transferForSignal(first);<br>        first = next;<br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="await与signal结合思考"><a href="#await与signal结合思考" class="headerlink" title="await与signal结合思考"></a>await与signal结合思考</h1><p>等待&#x2F;通知机制，这种机制能够解决最经典的问题“生产者与消费者问题”。</p><p>await和signal方法就像是一个开关控制着线程A（等待方）和线程B（通知方）。</p><p>关系示意图：</p><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e7911395tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="condition下的等待通知机制.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ReentrantReadWriteLock</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[<h1 id="读写锁简介"><a href="#读写锁简介" class="headerlink" title="读写锁简介"></a>读写锁简介</h1><p>独占锁与共享锁：</p><blockquote><p>独占式获取锁，同一时刻只有一个线程能够获取锁。</p><p>而在一些业务场景中，大部分只是读数据，写数据很少，读数据不会影响数据的正确性，使用独占锁的话会出现性能瓶颈。</p><p>读锁允许同一时刻被多个线程获取，但是写锁会阻塞所有的读写线程。</p></blockquote><ul><li>独占锁：<ul><li>Java关键字synchronized</li><li>concurrents包中实现Lock接口的ReentrantLock</li></ul></li><li>共享锁：<ul><li>concurrents包中实现Lock接口的ReentrantReadWriteLock</li></ul></li></ul><p>读写锁的特性：</p><ul><li>公平性选择：至此非公平（默认）和公平的锁获取方式，非公平吞吐量更优</li><li>重入性：支持重入，读锁获取后能再次获取，写锁获取后能够再次获取写锁，同时也能够获取读锁</li><li>锁降级：遵循获取写锁，获取读锁，再释放写锁的次序，写锁能够降级为读锁</li></ul><p>关于读写锁的的几个问题：</p><ul><li>读写锁是如何是心啊分别记录读写状态的</li><li>写锁是怎样获取去和释放的</li><li>读锁是怎样获取和释放的</li></ul><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><h2 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h2><p>写锁在同一时刻不能被多个线程所获取，所以说写锁是独占式锁。实现写锁的同步语义是通过重写AQS中的tryAcquire方法实现的。</p><h3 id="tryAcquire-源码：（获取写锁）"><a href="#tryAcquire-源码：（获取写锁）" class="headerlink" title="tryAcquire ()源码：（获取写锁）"></a>tryAcquire ()源码：（获取写锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//同步状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">//写锁状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>    <br>    <span class="hljs-comment">//1 锁已经被线程获取，只有重入写锁能够获取锁</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1.1 判断是否满足重入条件</span><br>        <span class="hljs-comment">//若当前线程不是获取锁的线程，或读锁已经被获取（c != 0 且 w == 0，说明读锁被获取）</span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>            <span class="hljs-comment">//不满足重入条件，获取锁失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">//走到这儿，说明当前线程已经获取读锁</span><br>        <span class="hljs-comment">//1.2 执行重入写锁的操作</span><br>        <span class="hljs-comment">//写锁计数溢出</span><br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br><span class="hljs-comment">//修改写锁同步状态</span><br>        setState(c + acquires);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">//2 锁未被任何线程获取</span><br>    <span class="hljs-comment">//2.1 若被阻塞，或者CAS修改同步状态失败，获取锁失败</span><br>    <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//2.2 否则获取写锁成功，设置当前线程独占锁</span><br>    setExclusiveOwnerThread(current);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于同步状态："><a href="#关于同步状态：" class="headerlink" title="关于同步状态："></a>关于同步状态：</h3><blockquote><p>读锁和写锁的获取次数都保存在同步状态这一个变量中，高16位保存的是读状态，低十六位保存的是写状态</p></blockquote><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/163262ec97ebeac9tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="读写锁的读写状态设计.png"></p><p>获取写状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写状态通过掩码（0x0000FFFF）与同步状态相与获取</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br></code></pre></td></tr></table></figure><p>获取读状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读状态通过同步状态右移16位获取</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;<br></code></pre></td></tr></table></figure><h2 id="写锁释放"><a href="#写锁释放" class="headerlink" title="写锁释放"></a>写锁释放</h2><p>tryRelease()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-comment">//1. 同步状态减去写状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br><span class="hljs-comment">//2. 当前写状态是否为0，为0则释放写锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (free)<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//3. 不为0则更新同步状态</span><br>    setState(nextc);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><h2 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h2><p>tryAcquiredShared()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">//1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前</span><br><span class="hljs-comment">// 线程获取读锁失败返回-1</span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>        getExclusiveOwnerThread() != current)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>        r &lt; MAX_COUNT &amp;&amp;<br><span class="hljs-comment">//2. 当前线程获取读锁</span><br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<br><span class="hljs-comment">//3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法</span><br><span class="hljs-comment">//返回当前获取读锁的次数</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>            firstReader = current;<br>            firstReaderHoldCount = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>            firstReaderHoldCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                cachedHoldCounter = rh = readHolds.get();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                readHolds.set(rh);<br>            rh.count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-comment">//4. 处理在第二步中CAS操作失败的自旋已经实现重入性</span><br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读锁释放"><a href="#读锁释放" class="headerlink" title="读锁释放"></a>读锁释放</h2><p>tryReleaseShared()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 前面还是为了实现getReadHoldCount等新功能</span><br>    <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>        <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;</span><br>        <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)<br>            firstReader = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span><br>            firstReaderHoldCount--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>        <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>            rh = readHolds.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> rh.count;<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>            readHolds.remove();<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> unmatchedUnlockException();<br>        &#125;<br>        --rh.count;<br>    &#125;<br>    <span class="hljs-comment">// 自旋CAS释放读锁</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h1><p>写锁能够降级为读锁，不支持锁升级。写锁在获取读锁后释放写锁，则写锁降级为读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// Must release read lock before acquiring write lock</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck state because another thread might have</span><br>                <span class="hljs-comment">// acquired write lock and changed state before we did.</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>            cacheValid = <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-comment">// Downgrade by acquiring read lock before releasing write lock</span><br>          rwl.readLock().lock();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          rwl.writeLock().unlock(); <span class="hljs-comment">// Unlock write, still hold read</span><br>        &#125;<br>      &#125;<br> <br>      <span class="hljs-keyword">try</span> &#123;<br>        use(data);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        rwl.readLock().unlock();<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ReentrantLock</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantLock/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h1 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h1><p>ReentrantLock重入锁，是实现Lock接口的一个类。</p><ul><li><p>支持<strong>重入性</strong>，表示能够对共享资源重复加锁，即当前获取该锁的线程再次获取不会被阻塞。Java关键字synchronized通过获取自增，释放自减的方式实现重入。</p></li><li><p>ReentrantLock还支持<strong>公平锁和非公平锁</strong>两种方式。</p></li></ul><h1 id="重入性的实现原理"><a href="#重入性的实现原理" class="headerlink" title="重入性的实现原理"></a>重入性的实现原理</h1><h2 id="支持重入性需要解决的两个问题"><a href="#支持重入性需要解决的两个问题" class="headerlink" title="支持重入性需要解决的两个问题"></a>支持重入性需要解决的两个问题</h2><ul><li>在获取锁的时候，如果已经获取锁的线程是当前线程的话直接再次获取成功</li><li>由于锁会被获取n次，那么只有在锁同样被释放n次过后，该锁才算完全释放</li></ul><h2 id="实现重入性的核心方法"><a href="#实现重入性的核心方法" class="headerlink" title="实现重入性的核心方法"></a>实现重入性的核心方法</h2><blockquote><p>同步组件通过重写AQS的几个protected方法来表达自己的同步语义</p></blockquote><h3 id="nonfairTryAcquire"><a href="#nonfairTryAcquire" class="headerlink" title="nonfairTryAcquire()"></a>nonfairTryAcquire()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//1 如果该锁未被任何线程占有，该锁能被当前线程获取</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//2 检查占有线程是否是当前线程</span><br>    <span class="hljs-comment">//2.1 若是，锁重入，返回true</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>       <span class="hljs-comment">//计算重入后的锁重入次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-comment">//避免锁重入次数逸出int范围（几乎不会出现，增加程序健壮性）</span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        <span class="hljs-comment">//设置重入后的锁状态</span><br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//2.2 若不是，直接返回false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">//当前没有获取锁的线程不能释放锁</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//1 同步状态减1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">//free表示锁完全被释放（获取n次锁，释放n次锁，即为完全释放。）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//2 只有当同步状态为0时，锁完全被释放</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-comment">//3 返回锁释放状态free（完全释放为true，还没有释放完为false）</span><br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><h2 id="ReentrantLock的构造方法"><a href="#ReentrantLock的构造方法" class="headerlink" title="ReentrantLock的构造方法"></a>ReentrantLock的构造方法</h2><blockquote><p>构造方法的主要内容就是指定同步器。</p><p>ReentrantLock内部有两个实现了AQS的同步器，一个是公平锁，另一个是非公平锁。</p></blockquote><p>无参构造（非公平锁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>传入boolean值指定是否为公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公平锁的tryAcquire-方法"><a href="#公平锁的tryAcquire-方法" class="headerlink" title="公平锁的tryAcquire()方法"></a>公平锁的tryAcquire()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在非公平锁的基础上，增加了前驱节点判断，有前驱节点的话就不能获取锁，保证按照入队顺序获取锁</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//若当前锁没有线程获取</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果有前驱节点，则获取锁失败（公平锁的实现逻辑）</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//若当前线程已经拿到锁</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><ul><li>“饥饿”现象：<ul><li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源上的绝对顺序。</li><li>而非公平锁，刚释放锁的线程再次参与锁竞争，可能继续获取锁，有可能导致其他线程永远获取不到锁，造成“饥饿”现象</li></ul></li><li>性能：<ul><li>公平锁为了保证获取锁的FIFO顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销</li><li>所以ReentrantLock默认选择的是非公平锁，则是为了减少部分上下文切换，保证系统更大的吞吐量</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-AQS深入理解</title>
    <link href="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <url>/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h1><p>在同步组件的实现中，AQS是核心部分</p><p>同步组件的实现者通过AQS提供的模板方法实现同步组件的同步语义</p><p>AQS则实现了对同步状态的管理，以及对阻塞线程的排队、等待和通知等一些底层的实现</p><p>AQS核心：</p><ul><li>同步队列</li><li>独占式锁的获取于释放</li><li>共享锁的获取和释放</li><li>可中断锁、超时等待锁获取</li></ul><p>AQS提供的模板方法：</p><ul><li><p>独占式锁</p><ul><li><p>void acquire(int arg)</p><blockquote><p>独占式获取同步状态，如果获取失败则插入同步队列进行等待</p></blockquote></li><li><p>void acquireInterruptibly(int arg)</p><blockquote><p>与acquire方法相同，但在同步队列中进行等待的时候可以检测中断</p></blockquote></li><li><p>boolean tryAcquireNanos(int arg, long nanosTimeout)</p><blockquote><p>在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获取同步状态返回false</p></blockquote></li><li><p>boolean release(int arg)</p><blockquote><p>释放同步状态，该方法会唤醒在同步队列中的下一个节点</p></blockquote></li></ul></li><li><p>共享式锁</p><ul><li><p>void acquireShared (int arg)</p><blockquote><p>共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态</p></blockquote></li><li><p>void acquireSharedInterruptibly(int arg)</p><blockquote><p>在acquireShared方法基础上增加了能响应中断的功能</p></blockquote></li><li><p>boolean tryAcquireSharedNanos(int arg, long nanoTimeout)</p><blockquote><p>在acquireSharedInterruptibly基础上增加了超时等待的功能</p></blockquote></li><li><p>boolean releaseShared(int arg)</p><blockquote><p>共享式释放同步状态</p></blockquote></li></ul></li></ul><h1 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h1><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。</p><h2 id="同步队列的数据结构"><a href="#同步队列的数据结构" class="headerlink" title="同步队列的数据结构"></a>同步队列的数据结构</h2><p>就数据结构而言，队列的实现有两种：数组、链表</p><p>AQS中的同步队列则是通过<strong>链表</strong>方式进行实现。</p><p>对于AQS同步队列的一些问题：</p><ul><li>节点的数据结构是什么样的？</li><li>同步队列是单项还是双向？</li><li>同步队列带不带头节点？</li></ul><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node是AQS的一个静态内部类，用来保存获取同步状态失败的线程引用以及等待状态信息</p><p>Node的属性：</p><ul><li><p>volatile int waitStatus</p><blockquote><p>节点状态</p><ul><li><p>int CANCELLED &#x3D; 1</p><blockquote><p>节点从同步队列中取消</p></blockquote></li><li><p>int INITIAL  &#x3D; 0</p><blockquote><p>初始状态</p></blockquote></li><li><p>int SIGNAL &#x3D; -1</p><blockquote><p>后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点能都运行</p></blockquote></li><li><p>int CONDITION &#x3D; -2</p><blockquote><p>当前节点进入等待队列</p></blockquote></li><li><p>int PROPAGATE &#x3D; -3</p><blockquote><p>表示下一次共享式同步状态获取将会无条件传播下去</p></blockquote></li></ul></blockquote></li><li><p>volatile Thread thread</p><blockquote><p>当前节点所封装的线程</p></blockquote></li><li><p>volatile Node prev</p><blockquote><p>同步队列前驱动节点</p></blockquote></li><li><p>volatile Node next</p><blockquote><p>同步队列后继节点</p></blockquote></li><li><p>Node nextWatier</p><blockquote><p>等待队列中的下一个节点</p></blockquote></li></ul><h2 id="AQS对同步队列的管理"><a href="#AQS对同步队列的管理" class="headerlink" title="AQS对同步队列的管理"></a>AQS对同步队列的管理</h2><p>AQS通过持有同步队列的头尾节点的指针来对节点进行管理</p><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637bb25796tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对节点和同步队列的了解：</p><ul><li>节点的数据结构，即AQS的静态内部类Node，节点的等待状态等信息</li><li>同步队列是一个双向队列，AQS通过持有头尾节点的指针管理同步队列</li></ul><p>同步队列和锁的关系：</p><p>节点的入队和出队实际上对应着锁的获取和释放两个操作获取锁失败进行入队操作，获取锁成功进行出队操作。</p><h1 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h1><p>方法分析层级（数字表示层级）：</p><ul><li><p>1 lock()</p><blockquote><p>实现Lock接口的锁的获取锁的方法</p></blockquote><ul><li><p>2 acquire()</p><blockquote><p>lock ()方法通过调用锁中的继承自AQS的内部类的acqure方法来获取锁</p></blockquote><ul><li><p>3 addWaiter()</p><blockquote><p>将当前线程打包成Node插入同步队列</p></blockquote><ul><li><p>4 enq()</p><blockquote><p>完成同步队列头节点初始化，并将Node插入同步队列</p></blockquote></li></ul></li><li><p>3 acquireQueued()</p><blockquote><p>阻塞排队获取锁</p></blockquote><ul><li><p>4 shouldParkAfterFailedAcquire()</p><blockquote><p>将前置节点状态设置为SIGNAL</p></blockquote></li><li><p>4 parkAndCheckInterrupt()</p><blockquote><p>阻塞当前线程，并检测当前线程是否被中断</p></blockquote></li></ul></li></ul></li></ul></li></ul><h2 id="独占式锁的获取（acquire）"><a href="#独占式锁的获取（acquire）" class="headerlink" title="独占式锁的获取（acquire）"></a>独占式锁的获取（acquire）</h2><p>在使用lock.lock()方法获取独占式锁的时候，获取失败就将当前线程加入同步队列，成功则线程执行。</p><p>lock()实际调用的是AQS的acquire()方法。</p><p>acquire ()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><span class="hljs-comment">//先看同步状态是否获取成功，如果成功则方法结束返回</span><br><span class="hljs-comment">//若失败则先调用addWaiter()方法再调用acquireQueued()方法</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>源码通过逻辑运算的短路特性来精简语句，以下是我写的逻辑更清晰一点的啰嗦语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//1 如果获取同步状态失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg))&#123;<br>        <span class="hljs-comment">//1.1 将当前线程打包成Node节点插入同步队列，并返回打包好的Node节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>        <span class="hljs-comment">//1.2 Node节点排队获取锁</span><br>        <span class="hljs-keyword">if</span>(acquireQueued(node, arg))&#123;<br>            selfInterupt();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2 如果获取成功，方法结束返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="addWaiter-方法"><a href="#addWaiter-方法" class="headerlink" title="addWaiter() 方法"></a>addWaiter() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">//1 将当前线程打包成Node类型</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">//2 将Node插入同步队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//2.1 尾节点不为null，当前节点尾插入的方式插入同步队列中</span><br>        node.prev = pred;<br>        <span class="hljs-comment">//如果CAS插入成功，则直接返回，若CAS失败则通过enq()方法插入</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2.2 尾节点为null，说明当前线程是第一个加入同步队列进行等待的线</span><br>    enq(node);<br>    <span class="hljs-comment">//3 返回打包好的node节点</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//获取tail的指针</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">//tail为null，在未插入节点之前需要初始化头节点</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">//1 初始化头结点。通过CAS设置头节点，避免因为多线程竞争导致重复初始化头节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        <span class="hljs-comment">//tail不为null，</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//2 尾插入，若CAS操作失败，可通过for循环不断进行CAS插入</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acquireQueued（）方法"><a href="#acquireQueued（）方法" class="headerlink" title="acquireQueued（）方法"></a>acquireQueued（）方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//1 获得当前节点的先驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">//2 当前节点能否获取独占式锁</span><br>            <span class="hljs-comment">//2.1 获取锁成功，获取锁的节点出队</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">//队列头指针用指向当前节点</span><br>                setHead(node);<br>                <span class="hljs-comment">//释放前驱节点，帮助GC回收</span><br>                p.next = <span class="hljs-literal">null</span>;<br>                <br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">//2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span><br>            <span class="hljs-comment">//使用CAS将前驱节点状态由INITIAL设置成SIGNAL，若CAS失败则通过for循环不断重试</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node))&#123;<br>                <span class="hljs-comment">//当节点状态设置成功，则阻塞当前线程</span><br>                <span class="hljs-keyword">if</span>(parkAndCheckInterrupt()))&#123;<br>                    interrupted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;  <br>            <span class="hljs-comment">/*上面一段代码的源码</span><br><span class="hljs-comment">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="hljs-comment">                    parkAndCheckInterrupt())</span><br><span class="hljs-comment">                    interrupted = true;</span><br><span class="hljs-comment">            */</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">//若前驱节点状态已经为SIGNAL，直接返回true</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//若前驱节点状态为CANCELLED，往前寻找状态不为CANCELLED的节点作为前驱节点</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    <span class="hljs-comment">//其他情况，使用CAS将前驱动节点状态改为SIGNAL</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//使得该线程阻塞</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//返回当前线程是否被中断</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acquire-方法流程图"><a href="#acquire-方法流程图" class="headerlink" title="acquire ()方法流程图"></a>acquire ()方法流程图</h3><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637c891cc2tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="独占式锁获取（acquire()方法）流程图.png"></p><h2 id="独占式锁的释放（release）"><a href="#独占式锁的释放（release）" class="headerlink" title="独占式锁的释放（release）"></a>独占式锁的释放（release）</h2><p>release()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//如果释放锁成功</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//唤醒后继节点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">//1 若当前要释放锁的node状态为负数，则将其状态置0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//2 唤醒后续节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">//若后继节点为null或状态为CANCELLED</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//从尾节点往前寻找一个没有被CANCELLED的节点</span><br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">//若s为null说明没有有效后继节点了，则不需要唤醒线程</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//后继节点不为null时唤醒后继节点对应的线程</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="独占式锁小结"><a href="#独占式锁小结" class="headerlink" title="独占式锁小结"></a>独占式锁小结</h3><ul><li>线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头节点初始化工作以及CAS操作失败的重试</li><li>线程获取锁是一个自旋的过程，当且仅当当前线程的前驱节点是头节点并且成功获取同步状态时，节点出队，即该节点引用的线程获得锁，否则，当不满足条件时就会调用LockSupport.park()方法使得线程阻塞</li><li>释放锁得时候会唤醒后继节点</li></ul><p>总的来说：在获取同步状态时，AQS维护一个同步队列，获取同步状态失败得线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是*<em>前驱节点是头节点并且成功获得了同步状态</em>。在释放同步状态时，同步器会调用unparkSuucessor()方法唤醒后继节点。</p><h2 id="可中断式获取锁（acquireInterruptibly）"><a href="#可中断式获取锁（acquireInterruptibly）" class="headerlink" title="可中断式获取锁（acquireInterruptibly）"></a>可中断式获取锁（acquireInterruptibly）</h2><p>acquireInterruptilbly()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//若线程已经被中断，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">//尝试获取锁。若获取锁成功，直接方法结束</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>        <span class="hljs-comment">//获取锁失败，进行可中断式获取锁</span><br>        doAcquireInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-comment">//将节点插入到同步队列中</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">//获取锁出队</span><br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br><span class="hljs-comment">//线程中断抛异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>acquireInterruptibly()与acquire()的关系：</p><ul><li>该方法与acquire方法逻辑几乎一致</li><li>唯一的区别在于，当parkAndCheckInterrupt()返回true时的处理<ul><li>acquire()将interrupted属性置为true</li><li>acquireInterruptilbly()直接抛出异常</li></ul></li></ul><h2 id="超时等待式获取锁（tryAcquireNanos）"><a href="#超时等待式获取锁（tryAcquireNanos）" class="headerlink" title="超时等待式获取锁（tryAcquireNanos）"></a>超时等待式获取锁（tryAcquireNanos）</h2><p>调用lock.tryLock()方式达到超时等待式获取锁，该方法只有在如下情况下才会返回：</p><ul><li>在超时时间内，成功获取锁</li><li>在超时时间内，被中断</li><li>超时时间结束，仍未获得锁</li></ul><p>tryAcquireNanos()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//若线程被中断，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">//若能直接获取锁，则返回true</span><br>    <span class="hljs-keyword">if</span>(tryAcquire(arg))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//若获取锁失败，尝试超时等待式获取锁</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> doAcquireNanos(arg, nanosTimeout);<br>    &#125;<br>    <span class="hljs-comment">//上面一小段的源码：return tryAcquire(arg) || (arg, nanosTimeout);</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//1. 根据超时时间和当前时间计算出截止时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><span class="hljs-comment">//2. 当前线程获得锁出队列</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">// 3.1 重新计算超时时间</span><br>            nanosTimeout = deadline - System.nanoTime();<br>            <span class="hljs-comment">// 3.2 已经超时返回false</span><br><span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 3.3 线程阻塞等待 </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                nanosTimeout &gt; spinForTimeoutThreshold)<br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>            <span class="hljs-comment">// 3.4 线程被中断抛出被中断异常</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序逻辑：</p><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637d087f5etplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="超时等待式获取锁（doAcquireNanos()方法）"></p><p>程序逻辑同可响应中断式独占锁基本一致，唯一不同在于，获取锁失败后的超时时间处理。</p><ul><li>理论截至时间计算：根据当前系统内和时间超时时间计算出截至时间</li><li>超时判断：截至时间减去系统当前时间<ul><li>若为负，超时直接返回false</li><li>若为正，调用LockSupport.parkNanos()阻塞当前线程</li></ul></li></ul><p>增加了独立的中断检测。</p><h1 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h1><h2 id="共享锁的获取（acquireShared）"><a href="#共享锁的获取（acquireShared）" class="headerlink" title="共享锁的获取（acquireShared）"></a>共享锁的获取（acquireShared）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//tryAcquireShared返回值大于等于0的话表示获取锁成功</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//获取锁失败，执行共享式获取锁</span><br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; ) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//当该节点的前驱节点是头结点且成功获取同步状态</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享锁的释放（releaseShared）"><a href="#共享锁的释放（releaseShared）" class="headerlink" title="共享锁的释放（releaseShared）"></a>共享锁的释放（releaseShared）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">     * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">     * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">     * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">     * fails, if so rechecking.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                 <span class="hljs-comment">// loop to recheck cases</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;           <br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-comment">// loop on failed CAS</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <br>        &#125;<br>        <span class="hljs-comment">// loop if head changed</span><br>        <span class="hljs-keyword">if</span> (h == head)                   <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理"><a href="#可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理" class="headerlink" title="可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理"></a>可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理</h2>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Lock与AQS初识</title>
    <link href="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/"/>
    <url>/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h1><h2 id="包结构："><a href="#包结构：" class="headerlink" title="包结构："></a>包结构：</h2><ul><li>atomic子包</li><li>locks子包</li><li>阻塞队列以及executors</li></ul><h2 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h2><blockquote><p>底层依赖volatile和CAS</p></blockquote><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff7cb847ctplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><h1 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h1><p>锁使用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</p><h2 id="Lock接口与syncronized"><a href="#Lock接口与syncronized" class="headerlink" title="Lock接口与syncronized"></a>Lock接口与syncronized</h2><p>在Lock接口出现之前，Java程序主要靠synchronized关键字实现锁。</p><p>Lock拥有比synchronized更多的同步特性：</p><ul><li>主动控制锁获取与释放</li><li>可中断获取锁</li><li>超时获取锁</li></ul><p>注意：synchronized同步块执行完成或者遇到异常，锁会自动释放，而Lock需要主动调用unlock()方法释放锁，所以需要在finally块中释放。</p><h2 id="Lock接口API"><a href="#Lock接口API" class="headerlink" title="Lock接口API"></a>Lock接口API</h2><ul><li><p>void lock()</p><blockquote><p>阻塞式获取锁</p></blockquote></li><li><p>void lockInterruptibly() throws InterruptedException</p><blockquote><p>阻塞式获取锁，获取锁的过程能够响应中断</p></blockquote></li><li><p>boolean tryLock()</p><blockquote><p>非阻塞式、响应中断、立即返回，获取锁返回true，失败返回false</p></blockquote></li><li><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</p><blockquote><p>超时获取锁，未超时且未中断能够获取锁</p></blockquote></li><li><p>Condition newCondition()</p><blockquote><p>获取与lock绑定的等待通知组件（当前线程必须获取了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回）</p></blockquote><h2 id="Lock接口的实现"><a href="#Lock接口的实现" class="headerlink" title="Lock接口的实现"></a>Lock接口的实现</h2></li></ul><p>concurrent.locks包中实现了Lock接口的类的实现方式</p><ul><li>类中包含一个继承自AQS的静态内部类</li><li>通过调用该类的方法实现Lock接口的方法</li></ul><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><blockquote><p>AQS全称AbstractQueuedSynchronizer，简称同步器。</p></blockquote><p>作用：同步器用来构建锁和其他同步组件的基础框架</p><p>实现：依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列</p><p>子类需要重写的方法：</p><ul><li>修改同步状态的方法<ul><li>getState</li><li>setState</li><li>compareAndSetState</li></ul></li><li>实现排队和阻塞机制的方法</li></ul><p>同步器和锁的关系：</p><ul><li><p>同步器是实现锁的关键，锁聚合同步器，利用同步器实现锁的语义</p></li><li><p>锁面向使用者，定义使用者与锁交互的接口，隐藏了实现的细节</p></li><li><p>同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理、线程的排队、等待和唤醒等底层操作</p></li><li><p>二者分别屏蔽了使用者和实现者所需要关注的领域</p></li></ul><h2 id="AQS的模板方法设计模式"><a href="#AQS的模板方法设计模式" class="headerlink" title="AQS的模板方法设计模式"></a>AQS的模板方法设计模式</h2><blockquote><p>AQS开放一些方法给子类进行重写。同步组件调用同步器的方法，而这些方法又会调用子类重写的方法。</p></blockquote><ul><li>同步组件（锁和同步工具）的实现依赖于同步器AQS，在同步器的实现中，使用AQS的方式推荐被定义未继承了AQS的静态内部类</li><li>AQS采用模板方法进行设计，AQS的peotected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法的时候就会调用被重写的方法</li><li>AQS负责同步状态的管理，线程的排队、等待和唤醒等底层操作，而Lock等同步组件主要专注于实现同步语义</li><li>在重写AQS的方法是，使用AQS提供的getState()、setState()、compareAndSetState()方法进行同步状态的修改</li></ul><p>可重写的方法：</p><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff7d16b38tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>AQS为同步组件提供的模板方法（大概分为三类）：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中等待线程情况</li></ul><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff87fe8bftplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p><strong>同步组件通过AQS提供的模板方法实现自己的同步语义</strong></p><h1 id="同步组件与AQS的关系"><a href="#同步组件与AQS的关系" class="headerlink" title="同步组件与AQS的关系"></a>同步组件与AQS的关系</h1><h2 id="同步组件实现者的角度："><a href="#同步组件实现者的角度：" class="headerlink" title="同步组件实现者的角度："></a>同步组件实现者的角度：</h2><p>通过可重写的方法：</p><ul><li>独占式：<ul><li>tryAcquire()</li><li>tryRelease()</li></ul></li><li>共享式：<ul><li>tryAcquireShared()</li><li>tryReleaseShared()</li></ul></li></ul><p>通过这些方法告诉AQS如何判断当前同步状态是否成功获取或者失败。</p><p>同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。</p><h2 id="AQS的角度"><a href="#AQS的角度" class="headerlink" title="AQS的角度"></a>AQS的角度</h2><p>对于AQS来所，只需要同步组件返回的true和false即可，因为AQS会对true和false有不同的操作，true会认为当前线程获取同步组件成功而直接返回，若为falseAQS也会执行将当前线程插入同步队列等一系列方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步组件通过重写AQS的方法实现字节想要表达的同步语义，而AQS只需要同步组件表达的true和false来执行不同的处理。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发关键字</title>
    <link href="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a>synchronized简介</h2><p>线程安全问题的主要来源于JMM的设计，集中在</p><ul><li>主内存和工作内存导致内存可见性问题</li><li>重排序导致的有序性问题</li></ul><p>多线程的意义在于多个线程协作共同完成一件事情，那么多个线程就必然需要访问共享数据。</p><p>如何保证共享数据的线程安全问题？即每个线程依次访问该共享变量，synchronize关键字具有让每个线程依次访问共享数据的功能。它是并发容器实现的基础。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>sychronized使用场景</p><ul><li><p>方法</p><blockquote><p>可以作用于实例方法和静态方法</p><p>区别在于被锁对象一个是实例对象，一个是类对象</p></blockquote></li><li><p>代码块（锁住方法相当于锁住整个方法的代码块）</p><blockquote><p>可以使用各种对象作为锁</p><p>this：使用类的实例对象作为锁</p><p>.class：使用类对象作为锁</p><p>Object：使用任意实例对象作为锁</p></blockquote></li></ul><h3 id="对象锁（moniter）机制"><a href="#对象锁（moniter）机制" class="headerlink" title="对象锁（moniter）机制"></a>对象锁（moniter）机制</h3><h4 id="获取与释放对象锁："><a href="#获取与释放对象锁：" class="headerlink" title="获取与释放对象锁："></a>获取与释放对象锁：</h4><p>在编译后的字节码中使用monitorenter指令获取到monitor（对象锁）后才能继续执行代码块中的指令，最后通过monitorexit指令释放所持有的monitor。</p><p>正常执行return退出代码块或者抛出异常退出代码块都能够执行monitorexit释放持有的对象锁</p><h4 id="对象锁（monitor）"><a href="#对象锁（monitor）" class="headerlink" title="对象锁（monitor）"></a>对象锁（monitor）</h4><p>每个对象都存在一个与之关联的monitor，线程对monitor持有的方式以及持有时机决定了synchronized的锁状态以及synchronized的状态升级方式</p><p>monitor是通过C++中的ObjectMonitor实现的：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/%E5%AF%B9%E8%B1%A1%E9%94%81.drawio.png" alt="对象锁.drawio"></p><ul><li>ObjectMonitor维护WaitSet和EntryList两个队列来保存ObjectWaiter对象</li><li>EntryList：阻塞等待获取锁的线程会被封装成ObjectWaiter进入EntryList队列，等待锁释放后竞争锁，获取锁后线程执行完成后退出并释放锁。</li><li>WaitSet：获取锁的线程若调用wait方法后会进入WaitSet中等待被唤醒，若被唤醒，则线程会进入EntryList中</li></ul><h3 id="synchronized与happens-before的关系"><a href="#synchronized与happens-before的关系" class="headerlink" title="synchronized与happens-before的关系"></a>synchronized与happens-before的关系</h3><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/5c09eea06aa64329bdae63dc31aa9622tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p><p>箭头表示happens-before</p><ul><li>程序顺序规则：黑色箭头顺序</li><li>监视器锁队则：红色箭头顺序</li><li>传递性规则：由上面两个推导出来的蓝色箭头顺序</li></ul><h3 id="获取锁和释放锁的内存语义"><a href="#获取锁和释放锁的内存语义" class="headerlink" title="获取锁和释放锁的内存语义"></a>获取锁和释放锁的内存语义</h3><p>释放锁：释放锁的时候会将线程对共享变量的修改写回主内存</p><p>获取锁：会强制从主内存中获取共享变量的新值</p><p>所以从横向看，线程之间基于主内存中的共享变量互相感知对方的数据操作，基于共享变量完成并发实体中的协作工作，整个过程就像是线程发送数据变更的“通知”，这种通知机制就是基于共享内存的并发模型导致的。</p><h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>synchronized最大特征就是同一时刻只能有一个线程能够获取对象的monitor，从何确保线程同步，对于线程之间表现为<strong>互斥性（排他性）</strong></p><p>优化的方向：</p><ul><li>让获取锁的速度变快</li><li>降低阻塞等待的概率</li></ul><p>对于优化需要先了解：</p><ul><li>CAS</li><li>Java对象头</li></ul><p>具体的优化：（锁升级）</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><h4 id="CAS概念"><a href="#CAS概念" class="headerlink" title="CAS概念"></a>CAS概念</h4><p>悲观锁：线程获取锁是一种悲观锁策略，即假设每次执行临界区代码都会产生冲突，所以当前线程获取锁的同时会阻塞其他线程获取该锁</p><p>乐观锁：CAS操作（又称无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，那么线程之间就不会出现阻塞。CAS操作会检测是否发生了冲突，则发生冲突，CAS会重试直到没有冲突</p><h4 id="CAS操作过程"><a href="#CAS操作过程" class="headerlink" title="CAS操作过程"></a>CAS操作过程</h4><p>CAS比较交换的过程可以大概理解为CAS(V, O, N)</p><ul><li>V（vary）：变量</li><li>O（old）：旧值</li><li>N（new）：新值</li></ul><p>过程：（整个过程是基于硬件指令级实现，具有原子性）</p><blockquote><p>读取V的值，若V &#x3D;&#x3D; O，那么说明内存中的值没有别其他线程修改过，就没有线程冲突，那么即可将N写入V。若V !&#x3D; O，说明该值已经被修改过了，CAS失败。</p></blockquote><p>Synchronized VS CAS:</p><blockquote><p>synchronized在存在线程竞争的情况下，会出现线程阻塞和唤醒带来的性能问题，这是一种<strong>阻塞同步</strong></p><p>CAS会在CAS操作失败后进行一定的尝试，而不是进行耗时的挂起唤醒操作，因此也叫做<strong>非阻塞同步</strong></p></blockquote><h4 id="CAS的应用场景"><a href="#CAS的应用场景" class="headerlink" title="CAS的应用场景"></a>CAS的应用场景</h4><ul><li><p>concurrency包的实现</p></li><li><p>Lock实现中CAS该百年state变量</p></li><li><p>atomic包的实现</p></li></ul><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><ul><li><p>ABA问题</p><blockquote><p>问题：</p><p>CAS通过检查旧值是否变化来检测变量是否改变，若变量变化如下A-&gt;B-&gt;A，那么CAS则无法检测到变量的变化</p><p>解决方法：</p><p>加上版本号1A-&gt;2B-&gt;3A</p><p>Java在atomic包中提供了AtomicStampedReference来解决ABA问题</p></blockquote></li><li><p>自旋对CPU的占用带来的性能消耗</p><blockquote><p>CAS若失败不会将线程挂起释放CPU资源，会进行自旋（死循环）进行重试直到CAS成功，自旋时间过程的话会对性能造成很大消耗</p><p>若JVM支持处理器提供的pause指令，可以在效率上有一定提升</p></blockquote></li><li><p>只能保证一个共享变量的原子操作</p><blockquote><p>问题：</p><p>对一个变量执行CAS操作可以保证器原子性，若对多个共享便变量进行操作，CAS就不能保证这个操作的原子性</p><p>解决办法：</p><p>利用对象整合多个共享变量，对对象执行CAS操作。</p><p>atomic包中提供了AtomicReference来保证引用对象之间的原子性</p></blockquote></li></ul><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>如何理解对象锁：</p><p>对象锁是对象的一个标志，这个标志存放在Java对象的对象头的Mark Word中。</p><p>Mark Word：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315cff10307a29tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315d056598e4c2tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>锁在大多数情况下不存在多线程竞争，并且总是由同一线程多次获得，为减少同一线程获取锁的代价而引入偏向锁</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxODMyMjU1,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="偏向锁逻辑"><a href="#偏向锁逻辑" class="headerlink" title="偏向锁逻辑"></a>偏向锁逻辑</h4><p>通用逻辑：</p><ol><li>检测锁标志位。若为01，说明处于无锁或偏向锁状态，才能进行偏向锁逻辑判断。</li><li>检测偏向锁标志位。若为0，说明是无锁（无锁不可偏向），进入轻量级锁逻辑（CAS竞争锁），若是1说明是偏向锁，进入偏向锁逻辑。</li></ol><p>偏向锁逻辑：</p><ol start="3"><li>检查Mark Word中的Thread Id。若为当前线程ID说明当前线程已经获取锁，不需要再获取锁，而是往自己的线程栈中添加一条Displaced Mark Word为空的Lock Record，用于重入统计。</li></ol><blockquote><p>偏向锁的释放与偏向锁的撤销：</p><p>偏向锁的释放：</p><ul><li>时机：退出同步代码块</li><li>操作：删除线程栈中的Lock Word（不会修改对象头中的锁状态）</li></ul><p>偏向锁的撤销：</p><ul><li>时机：发生锁竞争</li><li>操作：锁升级或者重偏向</li></ul></blockquote><ol start="4"><li>若Mark Word中的Thread Id不是当前线程ID，则进行CAS操作替换Thread Id。若当前对象锁处于匿名偏向状态（Thread Id为0，无锁可偏向）CAS会成功，则获取锁，并插入Lock Word到当前线程栈，执行同步代码块</li></ol><p>锁撤销逻辑：</p><ol start="5"><li>若CAS失败，说明对象锁已经被其他线程占用，进入偏向锁撤销逻辑。</li><li>等到全局安全点，暂停持有对象锁的线程，检测其状态，若其存活且在执行同步块代码，则将锁升级为轻量级锁。</li><li>若线线程未存活或者存活但未执行同步块代码。若开启重偏向，则将锁置为匿名偏向状态然后CAS获取偏向锁，若没开启重偏向，将锁置为无锁状态，然后升级为轻量级锁。</li><li>最后唤醒暂停的线程，从安全点继续执行代码</li></ol><h4 id="批量重偏向与批量撤销"><a href="#批量重偏向与批量撤销" class="headerlink" title="批量重偏向与批量撤销"></a>批量重偏向与批量撤销</h4><p>为什么有该机制：</p><blockquote><p>在出现锁竞争，即执行锁撤销逻辑的时候，需要暂停线程，并等到safe point，再撤销锁或升级锁，会消耗一定性能。若多线程竞争频繁，那么偏向锁不会提高性能，反而导致性能下降。</p></blockquote><p>解决的场景：</p><blockquote><p> 批量重偏向机制：一个线程创建大量对象，并执行了初始的同步操作，后面另一个线程也将这些对象作为锁对象进行操作，这样就会导致大量的锁撤销操作</p><p>批量撤销机制：再多线程竞争激烈的场景下竞争使用偏向锁</p></blockquote><p>原理：</p><blockquote><p>偏向锁撤销计数器：以class为单位，为每个class维护一个偏向锁撤销计数器，每次次该class的对象发生偏向撤销操作，该计数器+1</p><p>当计数器达到批量重偏向阈值（20）：</p><blockquote><p>epoch字段：</p><p>每个class对象会有一个epoch字段（可以理解为第几代偏向锁），处于偏向锁状态的对象的Mark Word中也有该字段，初始值为创建该对象时class中的epoch值。</p><p>批量重偏向操作：</p><p>将class中的epoch值+1（表示之前那一代的偏向锁失效）</p><p>被线程持有的该class类的锁对象，将其epoch值+1（保证已加锁的线程继续持有锁）（该操作需要等到全局安全点）</p><p>已经被线程释放的锁对象，其epoch值没有更新，其他线程去申请锁时，发现对象锁的epoch值与class中的epoch值不一致，则会进行自动重偏向（即不会进行锁撤销，而是直接通过CAS将其MarkWord中的Thread Id改为当前线程）</p></blockquote><p>当计数器达到批量撤销阈值（40）：</p><blockquote><p>直接标记该class为不可偏向，之后该class的锁直接走轻量级锁的逻辑</p></blockquote></blockquote><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><ol><li><p>复制Mark Word。</p><blockquote><p>线程再执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称之为<strong>Displaced Mark Word</strong>。</p></blockquote></li><li><p>CAS替换Mark Word。</p><blockquote><p>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获取锁。</p></blockquote></li><li><p>自旋获取锁。</p><blockquote><p>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</p></blockquote></li></ol><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>使用CAS操作将Displaced Mark Word替换回对象头</p><ul><li>成功：说明没有竞争发生</li><li>失败：说明当前锁存在竞争，锁回膨胀为重量级锁</li></ul><h3 id="锁比较"><a href="#锁比较" class="headerlink" title="锁比较"></a>锁比较</h3><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315cb91da523d9tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="各种锁的对比"></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="volatile简介"><a href="#volatile简介" class="headerlink" title="volatile简介"></a>volatile简介</h2><blockquote><p>被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p></blockquote><p>synchronized是阻塞式同步，在线程竞争激烈的情况下回升级成重量级锁，会执行线程的挂起和唤醒操作。而volatile就可以说是JVM提供的<strong>最轻量级</strong>的同步机制。</p><h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><blockquote><p>在生成汇编代码的时候会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀指令</strong></p></blockquote><h3 id="Lock前缀指令对多核处理器产生的影响"><a href="#Lock前缀指令对多核处理器产生的影响" class="headerlink" title="Lock前缀指令对多核处理器产生的影响"></a>Lock前缀指令对多核处理器产生的影响</h3><ul><li>将当前CPU核心缓存行的数据写回系统内存</li><li>使其他CPU核心内缓存了该内存地址的数据无效</li></ul><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>缓存一致性协议的意义：</p><blockquote><p>一个CPU核心将更新后的数据写回系统内存，但是其他核心中的数据还是旧的，若使用旧值执行计算就会有问题，缓存一致性协议能够保证个个CPU核心中的缓存是一致的。</p></blockquote><p>缓存一致性协议的实现：</p><blockquote><p> 每个核心通过嗅探总线上传播的数据来检查自己缓存的数据是否已经过期。若核心发现缓存行对应的内存地址上数据发生修改，就会将对应缓存行设置为无效状态，当核心需要该数据时，会重新从系统内存中加载数据。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Lock前缀指令会引起处理器缓存写回内存</li><li>一个处理器的缓存写回内存会导致其他处理器中的缓存失效</li><li>处理器读取变量数据，发现本地缓存失效，会从内存中读取最新值</li></ul><h2 id="volatile的happens-before关系"><a href="#volatile的happens-before关系" class="headerlink" title="volatile的happens-before关系"></a>volatile的happens-before关系</h2><h3 id="并发分析的切入点"><a href="#并发分析的切入点" class="headerlink" title="并发分析的切入点"></a>并发分析的切入点</h3><h4 id="两个核心："><a href="#两个核心：" class="headerlink" title="两个核心："></a>两个核心：</h4><ul><li>JMM内存模型</li><li>happens-before</li></ul><h4 id="三大性质："><a href="#三大性质：" class="headerlink" title="三大性质："></a>三大性质：</h4><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="volatile的happens-befores规则"><a href="#volatile的happens-befores规则" class="headerlink" title="volatile的happens-befores规则"></a>volatile的happens-befores规则</h3><blockquote><p>对一个volatile域的写，happens-befors于任意后续对这个volatile域的读</p></blockquote><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span>&#123;<br>        a = <span class="hljs-number">1</span>;          <span class="hljs-comment">//1</span><br>        flag = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//2</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(flag)&#123;      <span class="hljs-comment">//3</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">//4</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码实例的happens-before关系图：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796b904658tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="VolatileExample的happens-before关系推导"></p><p>happens-before分析：</p><p>加锁线程A先执行writer方法，然后线程B执行reader方法。</p><p>黑色箭头：程序顺序规则</p><p>红色箭头：volatile读写顺序规则</p><p>蓝色箭头：传递性规则</p><p>线程A happen-before 线程B，操作2 happensbefore 操作3，所以在线程A中的操作flag &#x3D; true可以马上被线程B感知，并且根据传递性规则，操作1 happens-before操作4，保证线程A对a的修改可以被线程B感知。</p><h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>还是针对上述代码进行分析，假设线程A执行writer方法，线程B随后执行reader方法，初始线程flag和a为初始状态。</p><p>线程A执行volatile写后的状态图：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796b8acbd7tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="线程A执行volatile写后的内存状态图"></p><p>线程B读取volatile变量的内存变化：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796bd467fbtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="线程B读volatile后的内存状态图"></p><p>从横向看，线程A和线程B之间进行了依次通信，线程A在写volatile变量时，就像是给线程B发送了一个消息，告诉线程B它对应的变量过期了，线程B得知自己的变量过期了，那么线程B需要读取变量的时候就去主存中加载最新值。</p><h2 id="volatile的内存语义实现"><a href="#volatile的内存语义实现" class="headerlink" title="volatile的内存语义实现"></a>volatile的内存语义实现</h2><blockquote><p>为了性能优化，在不改变正确语义的前提下，允许编译器和处理器的指令重排序，为了实现volatile的内存语义，就需要禁止一些重排序。通过添加<strong>内存屏障</strong>实现</p></blockquote><p>内存屏障分类：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e1471c0tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="内存屏障分类表"></p><p>JMM针对编译器制定的volatile重排序规则表：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e2f06datplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="volatile重排序规则表"></p><p>对于上述规则的简述：</p><ul><li>禁止volatile读后的任何操作与之重排序</li><li>禁止volatile写前的任何操作与之重排序</li><li>禁止volatile写于volatile读重排序</li></ul><p>JMM实现上述规则采用的内存屏障策略：</p><ul><li>对于volatile写<ul><li>写前插入StoreSore屏障</li><li>写后插入StoreLoad屏障</li></ul></li><li>对于volatile读<ul><li>读后插入LoadLoad屏障</li><li>读后插入LoadLoad屏障</li></ul></li></ul><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e03b351tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e799b76d34ctplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="final的具体使用场景"><a href="#final的具体使用场景" class="headerlink" title="final的具体使用场景"></a>final的具体使用场景</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h4><p>每个类的成员变量可以分为<strong>类变量、实例变量</strong>。</p><p>final变量必须初始化，系统不会进行隐式初始化。</p><p>成员变量的赋初值时机：</p><ul><li>类变量：<ul><li>在声明的时候直接赋初值</li><li>在静态代码块中给类变量赋初值</li></ul></li><li>实例变量：<ul><li>声明变量的时候给实例变量赋初值</li><li>在非静态代码块中赋初值</li><li>在构造器中赋初值</li></ul></li></ul><h4 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h4><p>final局部变量在方法中定义，<strong>形参或者方法体内</strong></p><p>若final变量未在定义的时候初始化，可以在方法体内有一次赋值机会，赋值之后再次赋值就会出错。</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320f7dbcfd83a2tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h4 id="final基本数据类型-VS-final引用数据类型"><a href="#final基本数据类型-VS-final引用数据类型" class="headerlink" title="final基本数据类型 VS final引用数据类型"></a>final基本数据类型 VS final引用数据类型</h4><p>final保证其修饰的变量有且只有一次赋值机会，赋值过后不会再该改变。</p><p>基本数据类型：</p><p>变量保存的是数据本身，所以数据不能修改。</p><p>引用数据类型：</p><p>变量保存的是对象的引用，就是说这个变量保存的应用不能变，即变量只能指向该对象，不能指向其他对象。但是对象本身的属性是可以改变的。</p><h4 id="宏变量"><a href="#宏变量" class="headerlink" title="宏变量"></a>宏变量</h4><blockquote><p>宏变量即常量，在程序中使用到宏变量的地方，编译器会直接将宏变量替换未该变量的字面值</p></blockquote><p>成为宏变量需要满足的三个条件：</p><ul><li>使用final修饰符修饰</li><li>在定义变量的时候就指定了初始值</li><li>该初始值在编译时就能唯一确定</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>被final修饰的方法不能够被子类重写</p></li><li><p>被final修饰的方可以重载</p></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>当一个类被final修饰的时候，表示该类时不能被子类继承的。</p><p>子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此当一个类希望不被继承的时候就可以使用final修饰。</p><h3 id="final使用的例子"><a href="#final使用的例子" class="headerlink" title="final使用的例子"></a>final使用的例子</h3><h4 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h4><p>定义：</p><p>不变类的意思时创建该类的实例后，该实例的实例变量时不可改变的。</p><p>成为不变类需要满足的条件：</p><ul><li>使用private和final修饰符修饰该类的成员变量</li><li>提供带参的构造器用于初始化类的成员变量</li><li>仅为该类的成员变量提供getter方法，不提供setter方法</li><li>有必要的话重写hashCode()和equals()方法，保证用equals判断相同的两个对象其Hashcode值也是相等的</li></ul><h4 id="JDK中提供的不变类"><a href="#JDK中提供的不变类" class="headerlink" title="JDK中提供的不变类"></a>JDK中提供的不变类</h4><p>String类、八个包装类 </p><h2 id="多线程中的final域重排序"><a href="#多线程中的final域重排序" class="headerlink" title="多线程中的final域重排序"></a>多线程中的final域重排序</h2><h3 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h3><h4 id="写final域重排序规则"><a href="#写final域重排序规则" class="headerlink" title="写final域重排序规则"></a>写final域重排序规则</h4><blockquote><p> 禁止对final域的写重排序到构造函数之外。</p></blockquote><p>实现：</p><ul><li>对于编译器：JMM禁止编译器把final域的写重排序到构造函数之外</li><li>对于处理器：编译器在final域写之后，构造函数return之前，插入一个storestore屏障。该屏障可以禁止处理器把final域的写重排序到构造函数之外</li></ul><p>该规则确保：</p><p>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具备这个保证。</p><h4 id="读final域重排序规则"><a href="#读final域重排序规则" class="headerlink" title="读final域重排序规则"></a>读final域重排序规则</h4><blockquote><p> 在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。（这个规则针对处理器）</p></blockquote><p>实现：</p><p>编译器在读final域操作前插入LoadLoad屏障。（实际上，读对象的引用和对该对象的final域存在简介依赖性，一般处理不会重排序这两个操作，但是有些处理器会，这个禁止重排序规则就是针对这些处理器而设定的）</p><p>该规则确保：</p><p>在读一个对象的final域之前，一定会先读这个包含final域的对象的引用</p><h3 id="final域为引用类"><a href="#final域为引用类" class="headerlink" title="final域为引用类"></a>final域为引用类</h3><h4 id="对final修饰的成员域写操作"><a href="#对final修饰的成员域写操作" class="headerlink" title="对final修饰的成员域写操作"></a>对final修饰的成员域写操作</h4><blockquote><p>在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作不能重排序</p></blockquote><h4 id="对final修饰的对象的成员域读操作"><a href="#对final修饰的对象的成员域读操作" class="headerlink" title="对final修饰的对象的成员域读操作"></a>对final修饰的对象的成员域读操作</h4><p>JMM不保证单独对final修饰对象的成员域的修改，与读取final修饰对象的成员域之间的重排序</p><h2 id="final的实现原理"><a href="#final的实现原理" class="headerlink" title="final的实现原理"></a>final的实现原理</h2><ul><li>final域写后插入StoreStore屏障</li><li>final域读前插入LoadLoad屏障</li></ul><h2 id="为什么final引用不能从构造函数中“逸出”"><a href="#为什么final引用不能从构造函数中“逸出”" class="headerlink" title="为什么final引用不能从构造函数中“逸出”"></a>为什么final引用不能从构造函数中“逸出”</h2><p>final域写重排序规则确保在使用一个对象引用的时候该对象的final域已经在构造函数中被初始化过了。</p><p>但是这儿其实有一个前提条件：</p><p>在构造函数结束之前，不能让这个被构造的对象被其他线程可件，也就是说该对象引用不能再构造函数中“逸出”</p><p>逸出的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalReferenceEscapeDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> FinalReferenceEscapeDemo referenceDemo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalReferenceEscapeDemo</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>;  <span class="hljs-comment">//1</span><br>        referenceDemo = <span class="hljs-built_in">this</span>; <span class="hljs-comment">//2</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalReferenceEscapeDemo</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (referenceDemo != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//3</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> referenceDemo.a; <span class="hljs-comment">//4</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程A执行writer方法，线程B执行reader方法</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320f7de16b0ec0tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="final域引用可能的执行时序"></p><p>在线程A中操作1和操作2没有依赖关系，所以操作2可以排在操作1前（操作2是让自己引用自己），这样在构造函数还没结束的时候，线程B已经拿到了构造的对象，但是这个对象还没有构造完成（构造函数还没有结束），此时线程B读final域会读到还未初始化的final域值。</p><h1 id="三大性质"><a href="#三大性质" class="headerlink" title="三大性质"></a>三大性质</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote><p>一个操作时不可中断的，要么全部执行成功，要么全部执行失败，有着“同生共死”的感觉</p></blockquote><h3 id="JMM中的8个原子操作"><a href="#JMM中的8个原子操作" class="headerlink" title="JMM中的8个原子操作"></a>JMM中的8个原子操作</h3><ul><li>lock</li><li>unlock</li><li>read</li><li>load</li><li>use</li><li>assign</li><li>store</li><li>write</li></ul><h3 id="JVM提供的原子性保证："><a href="#JVM提供的原子性保证：" class="headerlink" title="JVM提供的原子性保证："></a>JVM提供的原子性保证：</h3><ul><li><p>基本数据类型的访问读写具有原子性（除了long和double）</p><blockquote><p>原子性变量操作 read、load、use、assign、store、write</p></blockquote></li><li><p>synchronized满足原子性</p><blockquote><p>lock和unlock虽然没有开放使用，但是反映到JVM则是以monitorenter和monitorexit指令开放使用，反映到Java代码中则是synchronized关键字</p></blockquote></li><li><p>volatile不能保证原子性</p><blockquote><p>若要让volatile保证原子性需要符合两条规则</p><ul><li>运算结果不依赖于变量的当前值，或者确保只有一个线程修改便变量的值</li><li>变量不需要域其他的状态变量共同参与不变约束</li></ul></blockquote></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>锁被占用后其他线程只能等待，所以synchronized具有有序性</p></blockquote><h3 id="volatile-1"><a href="#volatile-1" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>volatile包含禁止指令重排序的语义，器具有有序性</p></blockquote><h4 id="Java程序的天然有序性可以总结为："><a href="#Java程序的天然有序性可以总结为：" class="headerlink" title="Java程序的天然有序性可以总结为："></a>Java程序的天然有序性可以总结为：</h4><p>如过在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。即as-if-serial语义。</p><h4 id="DCL（双重检查锁定-Double-Checked-Locking）例子："><a href="#DCL（双重检查锁定-Double-Checked-Locking）例子：" class="headerlink" title="DCL（双重检查锁定 Double-Checked Locking）例子："></a>DCL（双重检查锁定 Double-Checked Locking）例子：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-keyword">public</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重点在于为什么对instance加volatile</strong></p><blockquote><p>instance &#x3D; new Singleton();</p><p>该语句实际包含三个操作：</p><ol><li><p>分配对象的内存空间</p></li><li><p>初始化对象</p></li><li><p>设置instance指向刚分配的内存地址</p></li></ol></blockquote><p>重排序带来的问题：</p><p>重排序可能会导致操作3发生在操作2之前，即对象还没有初始化，instance对象的引用已经可以获取。相当于其他线程可能会拿到还没有初始化完成的instance对象的引用。</p><p>volatile解决：</p><p>使用volatile修饰instance对象，可以禁止2和3的重排序，避免上述问题。</p><ul><li><p>1、2、3操作在单线程中要满足as-if-serial语义</p></li><li><p>为volatile变量instance赋值happens-before读instance变量</p></li><li><p>传递性原则可以推导出，在对instance的初始化发生于对instance对象的访问前</p></li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>synchronized锁释放会将共享变量写回主内存，锁获取会从主内存获取共享变量的最新值。</p><p>volatile变量的读写都会立即更新</p><p>所以说synchronized和volatile都具有见性</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>synchronized：具有原子性、有序性和可见性</li><li>volatile：具有有序性和可见性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Java内存模型</title>
    <link href="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>线程不安全：</p><blockquote><p>在多线程中代码执行的结果与预期正确的结果不一致，那么这个线程就是线程不安全的</p></blockquote><p>线程安全：</p><blockquote><p>当多个线程访问同一个对象时，如果：</p><ul><li><p>不用考虑这些线程在运行时环境下的调度和交替运行</p></li><li><p>不需要进行额外的同步</p></li><li><p>不需要在调用方进行任何其他的协调操作</p></li></ul><p>调用这个对象的行为都可以获取正确的结果，那么这个对象是线程安全的</p></blockquote><h2 id="出现线程不安全的原因"><a href="#出现线程不安全的原因" class="headerlink" title="出现线程不安全的原因"></a>出现线程不安全的原因</h2><ul><li><p>主内存和工作内存数据不一致</p><blockquote><p>多线程通信</p></blockquote></li><li><p>重排序</p><blockquote><p>性能优化：编译器和处理器指令重排序</p></blockquote></li></ul><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="关于并发编程"><a href="#关于并发编程" class="headerlink" title="关于并发编程"></a>关于并发编程</h2><h3 id="并发编程需要解决的两个问题："><a href="#并发编程需要解决的两个问题：" class="headerlink" title="并发编程需要解决的两个问题："></a>并发编程需要解决的两个问题：</h3><ol><li><p>线程之间如何通信</p><ul><li><p>消息传递</p></li><li><p>共享内存</p></li></ul></li><li><p>线程之间如何同步</p></li></ol><h3 id="Java内存模型是共享内存的并发模型"><a href="#Java内存模型是共享内存的并发模型" class="headerlink" title="Java内存模型是共享内存的并发模型"></a>Java内存模型是<strong>共享内存</strong>的并发模型</h3><blockquote><p>线程之间主要通过读-写共享变量来完成隐式通信</p><p>共享变量：（堆内存数据）</p><ul><li>实例域</li><li>静态域</li><li>数组元素</li></ul><p>局部变量：（栈内存数据）</p><ul><li>方法定义参数</li><li>异常处理参数</li></ul></blockquote><h2 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h2><p>为什么会有内存模型：</p><blockquote><p>CPU和主存的读写速度不在一个数量级别，所以CPU有多级缓存，用于平衡这种差距，内存模型用于抽象这种模式</p></blockquote><p>内存模型的工作方式：</p><blockquote><p>共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且把位于主存中的共享变量拷贝到自己的工作内存中，之后线程对共享变量的而读写均作用于该副本，并在某个时刻将修改过的副本写回主存</p></blockquote><p>内存模型的任务：</p><blockquote><p>JMM决定了一个线程对共享变量的写入何时对其他线程可见（何时将工作内存中修改的副本写回主内存）</p></blockquote><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b2410a9e3ebtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p>Java内存模型下的线程通信：</p><blockquote><p>A线程和B线程的通信过程：</p><ol><li>线程A从主内存中将共享变量读入线程A的工作内存，并对其进行修改，修改过后将数据重新写回主内存中覆盖旧数据</li><li>线程B从主内存中读取最新的共享变量</li></ol><p>可能遇见的问题:</p><ul><li>“脏读”现象：线程A修改数据后还没有写回主内存，此时线程B读到的是过期的数据</li></ul><p>如何解决脏读：</p><ul><li>同步机制：通过同步机制控制不同线程操作发生的相对顺序来保证读写的顺序</li><li>volatile关键字：使用volatile关键字强制刷新到主内存，使得每次对volatile变量的修改立即对每个线程可见</li></ul></blockquote><h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><h2 id="重排序简介"><a href="#重排序简介" class="headerlink" title="重排序简介"></a>重排序简介</h2><p>重排序的目的：</p><blockquote><p>一个好的内存模型要放松对处理器和编译器队则的束缚。</p><p>软件和硬件的共同目标：在不改变程序执行结果的前提下，尽可能提高并行度</p></blockquote><p>重排序分类：</p><ul><li><p>编译器重排序</p><blockquote><p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序</p></blockquote></li><li><p>处理器重排序</p><ul><li><p>指令级并行重排序</p><blockquote><p>现代处理器采用指令级并行技术将多条指令重叠执行。</p><p>如果<strong>不存在数据依赖性</strong>，处理器可以改变语句对应机器指令的执行顺序</p></blockquote></li><li><p>内存系统重排序</p><blockquote><p>由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去是乱序执行</p></blockquote></li></ul></li></ul><p>针对重排序JMM做了什么：</p><ul><li><p>针对编译器重排序</p><blockquote><p>禁止一些特定类型的编译器重排序：</p><p>JMM的编译器重排序规则会禁止一些特定类型的编译器重排序</p></blockquote></li><li><p>针对处理器重排序</p><blockquote><p>内存屏障指令：</p><p>编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序</p></blockquote></li></ul><h2 id="重排序规则"><a href="#重排序规则" class="headerlink" title="重排序规则"></a>重排序规则</h2><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p>as-if-serial语义：</p><blockquote><p>对于程序员来说单线程程序是按照顺序执行的</p></blockquote><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before语义：</p><blockquote><p>一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</p></blockquote><p>八项规则：</p><ol><li><p>程序顺序规则（as-if-serial）</p><blockquote><p>一个线程中的每个操作，happens-before于该线程中的任意后续操作</p></blockquote></li><li><p>监视器锁规则</p><blockquote><p>对一个锁的解锁，happens-before于随后对于这个锁的加锁</p></blockquote></li><li><p>volatile变量规则</p><blockquote><p>对于一个volatile域的写，happens-befors于任意后续对这个volatile域的读</p></blockquote></li><li><p>传递性</p><blockquote><p>若A happens-before B，B happens-before C，那么A happens-before C</p></blockquote></li><li><p>start()规则</p><blockquote><p>如果A线程启动线程B，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作</p></blockquote></li><li><p>join()规则</p><blockquote><p>如果线程A执行ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作返回</p></blockquote></li><li><p>程序中断规则</p><blockquote><p>对线程的interrupted()方法的调用先行于被中断函数的代码检测到中断时间的发生</p></blockquote></li><li><p>对象finalize规则</p><blockquote><p>一个对象的初始化完成（构造函数执行结束）先于发生它的finalize()方法的执行</p></blockquote></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h2><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b3505fe3170tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="JMM层级图"></p><p>JMM是语言级的内存模型，JMM处于中间层：</p><p>向上面向程序员：</p><ul><li>提供基于JMM的关键字和J.U.C包下的一些具体类方便程序员进行并发编程</li><li>happens-before语义为程序员提供易于理解、易于编程的内存模型</li></ul><p>向下面向编译器和处理器：</p><ul><li><p>禁止编译器特定重排序，处理器内存屏障指令，实现happens-before语义</p></li><li><p>允许不改变程序执行结果的优化</p><blockquote><ul><li>允许不改变happens-before语义的重排序</li><li>编译器分析一个锁只会被单个线程访问，可以消除锁</li><li>编译器分析一个volatile变量只会被单个线程访问，编译器将其作为普通变量处理</li></ul></blockquote></li></ul><h2 id="happens-before与JMM的关系"><a href="#happens-before与JMM的关系" class="headerlink" title="happens-before与JMM的关系"></a>happens-before与JMM的关系</h2><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b4732a0ed2ctplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="happens-before与JMM的关系"></p><ul><li><p>一个happens-before规则对应一个或多个编译器和处理器重排序规则。</p></li><li><p>对于Java程序员来说，只需要根据happens-before规则进行多线程编程即可</p></li><li><p>JMM为程序员提供内存可见性保证，以及实现复杂的重排序规则</p></li></ul><h2 id="后续可能需要关注的问题"><a href="#后续可能需要关注的问题" class="headerlink" title="后续可能需要关注的问题"></a>后续可能需要关注的问题</h2><ul><li>可见性问题：数据“脏读”现象</li><li>有序性问题：DCL（双重检查锁）问题，需要使用volatile禁止重排序</li><li>原子性问题：i++，可能跟出现线程安全问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发基础</title>
    <link href="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="并发缺点"><a href="#并发缺点" class="headerlink" title="并发缺点"></a>并发缺点</h2><h3 id="1-频繁的上下文切换"><a href="#1-频繁的上下文切换" class="headerlink" title="1. 频繁的上下文切换"></a>1. 频繁的上下文切换</h3><h4 id="为什么会有频繁的多线程切换："><a href="#为什么会有频繁的多线程切换：" class="headerlink" title="为什么会有频繁的多线程切换："></a>为什么会有频繁的多线程切换：</h4><ul><li><p>真多线程：多核CPU，每个线程在不同的CPU上执行</p></li><li><p>宏观多线程：CPU分配给每个线程一定的时间片，CPU通过不断切换线程，宏观上就是多个线程同时执行</p><blockquote><p>每次切换线程需要保存线程当前状态，加载下一个线程之前保存的状态，这就是上下文切换，每个线程执行的时间很短，所以说上下文切换就很频繁。</p></blockquote></li></ul><h4 id="减少上下文切换的方法："><a href="#减少上下文切换的方法：" class="headerlink" title="减少上下文切换的方法："></a>减少上下文切换的方法：</h4><ul><li><p>无锁并发编程</p><blockquote><p>参考concurrentHashMap锁分段思想，减少多线程竞争</p></blockquote></li><li><p>CAS算法</p><blockquote><p>使用乐观锁，减少锁竞争带来的上下文切换</p></blockquote></li><li><p>使用最少线程</p><blockquote><p>避免创建不必要的线程</p></blockquote></li><li><p>协程</p><blockquote><p>在单线程中实现多任务调度</p></blockquote></li></ul><h3 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2. 线程安全问题"></a>2. 线程安全问题</h3><h4 id="线程安全问题：死锁"><a href="#线程安全问题：死锁" class="headerlink" title="线程安全问题：死锁"></a>线程安全问题：死锁</h4><h5 id="如何避免死锁："><a href="#如何避免死锁：" class="headerlink" title="如何避免死锁："></a>如何避免死锁：</h5><ul><li>避免一个线程获得多个锁&#x2F;多个资源</li><li>使用定时锁</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则可能会解锁失败</li></ul><h4 id="JMM内存模型中的问题"><a href="#JMM内存模型中的问题" class="headerlink" title="JMM内存模型中的问题"></a>JMM内存模型中的问题</h4><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步和异步通常用来形容一次方法调用。</p><ul><li>同步方法：调用者必须等待同步方法结束后，才会执行后面的代码。</li><li>异步方法：调用者调用方法后会直接继续执行后续代码，被调用的代码执行完毕后会通知调用者</li></ul><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li>并发：一个CPU核心分时执行多个线程</li><li>并行：多个CPU核心同时分别执行一个线程</li></ul><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><ul><li>阻塞：若一个线程占有了临界区的资源，其他线程若要访问，那么就需要等待这个线程释放该资源，会导致等待的线程挂起，这就叫阻塞</li><li>非阻塞：强调没有线程可以阻塞其他线程，所有线程都会尝试地往前运行</li></ul><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用，但是同一时刻只能由一个线程占有</p><h2 id="线程状态转换及其基本操作"><a href="#线程状态转换及其基本操作" class="headerlink" title="线程状态转换及其基本操作"></a>线程状态转换及其基本操作</h2><h3 id="1-新建线程"><a href="#1-新建线程" class="headerlink" title="1. 新建线程"></a>1. 新建线程</h3><blockquote><p>Java程序天生就是多线程的，包含：</p><ol><li>分发处理发送个JVM信号的线程</li><li>调用对象finalize方法的线程</li><li>清除Reference的线程</li><li>main线程，用户线程的入口</li></ol></blockquote><ul><li><p>方法一、继承Thread类，重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        Sytem.out.println(<span class="hljs-string">&quot;通过继承Thread&quot;</span>)<br>        <span class="hljs-built_in">super</span>.run();<br>    &#125;<br>&#125;;<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p>方法二、实现runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;通过实现runnable接口&quot;</span>)<br>    &#125;<br>&#125;);<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p>方法三、实现callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecuterService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;String&gt; future = service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>()&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;通过实现Callable接口&quot;</span><br>    &#125;<br>&#125;);<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get();<br>    System.out.println(result);<br>&#125;<span class="hljs-keyword">catch</span>(Exception)&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意事项：</strong></p><ul><li><p>优先考虑通过实现接口创建线程（Java只能单一继承）</p></li><li><p>可以将callable包装成FutureTask</p><blockquote><p>FutureTask同时实现Future接口和Runnable接口，所以将FutureTask提交给ExecutorService执行后，可以直接从FutureTask获取异步结果</p><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159b250b111f7tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p></blockquote></li><li><p>可以将runnable包装成callable</p><blockquote><p>runnable执行不会返回结果，callable执行后会返回结果</p></blockquote></li></ul><h3 id="2-线程状态转换"><a href="#2-线程状态转换" class="headerlink" title="2. 线程状态转换"></a>2. 线程状态转换</h3><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159b8a740b329tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p>六个状态：</p><ul><li><p>NEW</p><blockquote><p>线程创建后即为NEW状态</p></blockquote></li><li><p>RUNNABLE</p><blockquote><p>线程执行start()过后进入RUNNABLE状态，此时线程由系统调度分配时间片，线程也可以使用yeild()主动放弃时间片</p><p>使用Object.notify()或Object.notifyAll()方法可以将WAITING和TIME_WAITING状态的线程切换至RUNNABLE状态</p></blockquote></li><li><p>BLOCKED</p><blockquote><p>当线程出现资源竞争，即进入synchronized方法或代码块时需要获取锁，若没有获取锁则进入阻塞状态</p></blockquote></li><li><p>WAITING</p><blockquote><ul><li><p>调用锁对象的wait()、join ()方法</p></li><li><p>LockSupport.lock()</p></li><li><p>调用juc包中的锁对象进行加锁（因为其底层调用的是LockSupport的方法）</p></li></ul></blockquote></li><li><p>TIME_WAITING</p><blockquote><ul><li>wait(long)</li><li>sleep(long)</li><li>join(long)</li><li>LockSupport.parkNanos()</li><li>LockSupport.parkUtil()</li></ul></blockquote></li><li><p>TERMINATID</p></li></ul><h3 id="3-线程的基本操作"><a href="#3-线程的基本操作" class="headerlink" title="3. 线程的基本操作"></a>3. 线程的基本操作</h3><ol><li><p>interrupted</p><blockquote><p>中断可以理解为线程的一个标志位，它表示一个运行中的线程是否被其他线程执行了中断操作。</p><ul><li><p>其他线程可以通过interrupt()方法打断某线程</p></li><li><p>线程可以在线程内部调用isInterrupted()来感知是否被其他线程中断</p></li><li><p>Thread的静态方法可以对档期那线程进行中断操作，同时该操作会清除中断标志位</p></li></ul></blockquote><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159c1a4cc499dtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><blockquote><p>中断可以看作是线程间的一种简便的交互方式。在结束线程时通过中断标志位，使线程由机会清理资源，相较于直接结束线程，这种方式更加优雅和安全。</p></blockquote></li><li><p>join</p><blockquote><p>join方法可以看作是线程间协作的一种方式。</p><p>A执行threadB.join()语义：表示线程A需要等待另线程B执行完毕后才能继续执行</p></blockquote></li><li><p>sleep</p><blockquote><p>方法签名：public static native void sleep(long millis)</p><p>由上可看出sleep时Thread的静态方法，本地实现，让当前线程睡眠指定时间</p></blockquote><p>sleep()与wait()区别：</p><ul><li>sleep()是Thread的静态方法，而wait()是Object的实例方法</li><li>wait必须要在同步方法或同步方法块中调用，即调用前该线程必须已经获得对象锁。sleep没有限制</li><li>wait会释放CPU资源和线程占有的对象锁，使得该线程进入该对象锁的等待队列。sleep只会释放CPU资源，不会释放对象锁</li><li>sleep休眠固定时间后唤醒，等待CPU时间片。wait等待对象锁notify唤醒后离开等待队列，等待CPU时间片</li></ul></li><li><p>yield</p><blockquote><p>方法签名：public static native void yield()</p><p>yield是Thread的静态方法</p><ul><li>当前线程主动让出CPU时间片</li><li>让出的时间片只会分配给与当前线程优先级相同的线程</li><li>当前线程让出CPU时间片后还会参与CPU时间片的竞争</li></ul></blockquote></li></ol><h3 id="4-守护线程Daemon"><a href="#4-守护线程Daemon" class="headerlink" title="4. 守护线程Daemon"></a>4. 守护线程Daemon</h3><blockquote><p>守护线程：守护线程是在后台默默守护一些系统服务，比如垃圾回收线程、JIT线程</p><p>用户线程：用户线程就是系统的工作线程，完成整个系统的业务操作</p></blockquote><ul><li><p>用户线程代表整个系统的业务任务全部完成，因此系统没有对象需要守护，守护线程自然也就结束。</p></li><li><p>当一个Java应用中只剩下守护线程的时候，虚拟机就会退出。</p></li><li><p>守护线程不会执行finnaly块中的代码</p></li><li><p>在线程调用start()前对调用setDaemon (true)将线程设置为守护线程</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鼎桥面试预习</title>
    <link href="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/"/>
    <url>/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>A</p><ol><li><p>TCP和UDP的区别 </p><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>可靠性</td><td>不可靠传输</td><td>可靠传输，流量控制和拥塞控制</td></tr><tr><td>连接对象数量</td><td>一对N，N对一，多对多</td><td>只能一对一</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>小，8字节</td><td>大，20-60字节</td></tr><tr><td>使用场景</td><td>实时应用：IP电话、视频会议、直播</td><td>要求可靠传输的应用：文件传输</td></tr></tbody></table><ul><li>TCP（可靠性：文件下载，查看网页，邮件）<ul><li>面向连接：三次握手，四次挥手</li><li>仅支持单播传输</li><li>面向字节流：TCP对于来自应用层的报文可能会拆分后分别加上TCP头传输</li><li>可靠传输：TCP段编码和确认号可以进行<strong>丢包判断</strong>，和保证包的<strong>按序接收</strong></li><li>拥塞控制</li><li>全双工通信：TCP允许通信双方的应用程序在任何时候都能发数据，且双方都有缓存，TCP可以立即发送报文，也可以缓存后一次发送多个报文。</li></ul></li><li>UDP（实时性：电话会议）<ul><li>面向<strong>无连接</strong>：UDP只会在收发数据的时候增加或去除一个协议头</li><li><strong>面向报文</strong>：UDP对应用层发送来的报文不做处理，保留边界（不合并，不拆分）。所以应用程序必须自己选择合适大小的报文。</li><li><strong>单播、多播和广播</strong>功能</li><li><strong>不可靠</strong>性：UDP不管发送的数据是否被接收到；UDP没有拥塞控制，发送速度取决于上层，在网络拥堵的时候会丢包，但是在实时性要求高的场景需要使用UDP</li><li>头部小，效率高</li></ul></li></ul></li><li><p>UDP不可靠，为什么还要用UDP</p><ul><li>UDP头部开销小，无连接的特性使其传输效率高</li><li>实时性应用更关心数据的实时性，可以牺牲一定的可靠性</li></ul></li><li><p>UDP采取什么措施来提高正确率</p><ul><li>有两字节的检验和，用于判断数据在传输中是否出错，有错就丢弃</li></ul></li></ol><p>B</p><ol><li><p>Zoo<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>er的原理有了解吗？为什么要用Zoo<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>er做服务注册</p></li><li><p>Http和Https的区别，证书有什么用？</p><ul><li><p>HTTPS可以理解位HTTP + SSL&#x2F;TLS</p></li><li><p>TLS的前身是SSL：SSl协议位于TCP和各种应用层协议之间，为数据传输提供安全支持</p></li><li><p>数字证书：CA使用自己的私钥将服务器公钥进行加密生成数字签名，然后将（公钥信息+公钥+数字签名）打包成数字证书。服务器在发送内容时，使用私钥对内容进行签名，连同证书一起发给客户端，客户端拿到（私钥加密的内容+数字证书）后，向CA请求数字证书真伪，然后CA使用私钥解密，将公钥发送给客户端。</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程"></p></li></ul></li><li><p>Http的传输协议是什么？</p><ul><li>TCP</li></ul></li><li><p>MySQL 插入一条<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>，会直接更新到磁盘中吗？（change pool）</p><p>不会，WAL技术（Write-Ahead Logging）先写日志（redo log），再写磁盘（服务器空闲的时候）</p></li><li><p>MySQL宕机了怎么保证事务？（redo log）</p><p>redo log两阶段提交：（保证两个log的一致性）</p><ol><li>redo log写入日志处于prepare状态</li><li>binlog写入日志后redo log处于commit状态</li><li>后面服务器会根据redolog将数据真正写入数据库中</li></ol><p>宕机：</p><ol><li>在redolog写入前宕机，没有日志，且没有提交事务，不需要处理</li><li>在redolog的prepare状态后宕机，可以根据redolog来继续提交或者回滚</li><li>在redolog的commit状态后宕机，根据redolog把数据写入磁盘</li></ol></li><li><p>TCP和UDP的区别</p></li><li><p>TCP的<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>-live是什么？</p><ul><li><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p></li><li><p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p></li></ul></li><li><p>索引失效的例子？</p><ul><li><p>联合索引不满足左前缀法则</p><blockquote><p>联合索引:（a，b）先根据a排序，在a相同的情况下，使用b排序</p><p>最左前缀原则：若索引有多列，查询要从最左前列开始并且不跳过索引中的列</p></blockquote><ul><li>直接查找where b &#x3D; xxx；</li><li>like索引失效</li><li>范围查询右边失效原理。where a &gt; xxx and b &#x3D; xxx;</li></ul></li><li><p>在索引列参与运算，或使用了函数</p></li><li><p>使用select *</p></li><li><p>类型隐式转换</p></li><li><p>使用or操作：or左右是不同的列，且其中一个是全表扫描；或者or左右是相同列，同时使用&gt;和&lt;</p></li><li><p>两列做比较</p></li><li><p>is not null，not in，not exists</p></li><li><p>order by</p></li><li><p>DBMS针对不同参数优化：若全表扫描比索引快，则使用全表扫描</p></li></ul></li><li><p>遇到慢查询，你怎么解决？</p><ul><li>升级硬件。CPU和IO</li><li>软件排查<ul><li>使用EXPLAIN查看执行计划关注key和extra</li><li>查询没有命中任何索引，优化表索引结构</li><li>查询、排序没有命中覆盖索引，考虑添加联合索引</li></ul></li><li>优化建议<ul><li>select数据太多（分页控制、分批查询、精简查询列）</li><li>索引失效的解决</li><li>可能未定义索引</li><li>查询语句过于复杂（拆分为多个简单查询，放于同一事务）</li></ul></li></ul></li><li><p>索引为什么用B+树不用B树</p><ul><li>单一节点存储更多元素，查询IO次数会更少</li><li>所有查询都要查找叶子节点，查找性能稳定</li><li>所有子节点形成有序链表，便于范围查询</li></ul></li><li><p>聚集索引和非聚集索引的区别是啥？</p><ul><li>聚集索引和非聚集索引的<strong>根本区别</strong>是表记录的排列顺序和与索引的排列顺序是否一致。</li></ul></li></ol><p>C</p><ol><li><p>重载和重写区别</p><ul><li>重载：一个类的多态性的表现，在一个类中定义了多个方法名相同，参数数量或种类和次序不同的方法。</li><li>重写：子类与父类的以一种多态性表现，子类中存在和父类方法名、参数、返回值均相同的方法。</li></ul></li><li><p>GC算法有那些</p><ul><li><p>复制算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916203852553.png" alt="img"></p></li><li><p>标记 - 清除算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204202965.png" alt="img"></p></li><li><p>标记 - 整理算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204205977.png" alt="img"></p></li><li><p>分代回收算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204228959.png" alt="img"></p></li></ul></li></ol><p>D</p><ol><li><p>springBoot启动流程</p><ol><li>new SpringApplication对象。从main中找到run()方法前new一个SpringApplication对象</li><li>创建应用监听器。进入run()方法，创建SpringApplicationRunListeners开始监听</li><li>加载配置环境。加载ConfigurableEnvironment，然后把配置Environment加入监听对象</li><li>加载应用上下文。加载ConfigurableApplicationContext，作为run方法的返回对象</li><li>创建Spring容器、refreshContext（context），实现starter自动化配置和bean的实例化等工作</li></ol></li><li><p>springAOP（Aspect-oriented Programming）</p><p>为什么引入AOP</p><ul><li><p>OOP的局限性</p><blockquote><p>静态化语言：类结构一旦定义，不容易被修改</p><p>侵入式扩展：通过继承或组合组织新的类结构</p></blockquote></li><li><p>通过AOP抽离非业务逻辑代码</p><blockquote><p> 通过AOP可以将一些非业务逻辑的代码从业务中抽离出来，以非入侵的方式与原方法进行协同。这样可以使原方法更专注于业务逻辑，代码接口更加清晰，便于维护</p></blockquote></li></ul><p>AOP使用场景</p><ul><li>日志</li><li>统计</li><li>安防</li><li>性能</li></ul><p>AOP中的重要概念</p><ul><li><p>AspectJ：切面。</p><blockquote><p>（Join point + Advice + Pointcut）三者的统称。只是一个概念，没有具体的接口或类与之对应。</p></blockquote></li><li><p>Join point：连接点。</p><blockquote><p>指程序执行过程中的一个点，例如方法调用、异常处理等。在Spring AOP中，仅支持方法级别的连接点。</p></blockquote></li><li><p>Advice：通知。</p><blockquote><p>我们定义的一个切面中的横切逻辑，有”around“，”before“和”after“三种类型。在很多的AOP实现框架中，Advice通常作为一个拦截器，也可以包含多个拦截器作为一个链路围绕着Join point进行处理。</p></blockquote></li><li><p>Pointcut：切点。</p><blockquote><p>用于匹配连接点,一个AspectJ中包含哪些Join point需要由Pointcut进行筛选 。</p></blockquote></li><li><p>Introduction：引介。</p><blockquote><p>让一个切面可以被声明被通知的对象实现任何他们没有真正实现的额外接口。例如让一个代理对象代理两个目标类</p></blockquote></li><li><p>Weaving：织入。</p><blockquote><p>在有了连接点、切点、通知以及切面，如何将让门应用到程序中呢？就是使用织入，在切点的引导下，将通知逻辑插入到目标方法上，使得我们的通知逻辑在方法调用时得以执行。</p></blockquote></li><li><p>AOP proxy：AOP代理。</p><blockquote><p>指在AOP实现框架中实现切面协议的对象。在Spring AOP中有两种代理，JDK动态代理和CGLIB动态代理。</p></blockquote></li><li><p>Target object：目标对象。</p><blockquote><p>被代理的对象。</p></blockquote></li></ul></li><li><p>springAop是基于哪两种动态代理</p><ul><li>JDK动态代理</li><li>CGLIB动态代理</li></ul></li><li><p>SpringMVC一次请求的过程</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/5220087-3c0f59d3c39a12dd.png" alt="img"></p></li><li><p>springBean默认是什么模式（单例）</p></li><li><p>如何将其改为非单例</p></li><li><p>mybatis如何防止sql注入</p><ul><li><p>SQL注入发生在SQL预编译阶段</p></li><li><p>PreparedStatement预编译对象</p></li><li><p>预编译，替换占位符</p></li></ul></li><li><p>mysql隔离级别、事务特性</p><p>事务特性：</p><ul><li>原子性</li><li>一致性</li><li>隔离性<ul><li>读未提交</li><li>读提交</li><li>可重复度</li><li>串行化</li></ul></li><li>持久性</li></ul></li><li><p>可重复读是怎么解决不可重复读问题的（间隙锁）</p><p>在事务开始的时候创建快照，并对更新的行加上行锁</p></li><li><p>Java集合类</p></li><li><p>JVM内存模型</p><p>线程共享：</p><ul><li><p>方法区</p><blockquote><p>类信息、常量、静态变量、JIT编译后的代码</p><p>运行时常量池：编译期间生成的各种字面常量和符号引用</p></blockquote></li><li><p>堆</p><blockquote><p>实例对象</p></blockquote></li></ul><p>线程私有：</p><ul><li><p>虚拟机栈、本地方法栈</p><blockquote><p>栈帧：局部变量表、操作数表</p></blockquote></li><li><p>程序计数器</p></li></ul></li><li><p>垃圾回收过程</p></li><li><p>redis基本类型</p></li><li><p>redis的持久化</p></li><li><p>redis的发布订阅</p></li><li><p>kafka如何保证数据不丢失</p></li><li><p>kafka消费者采用的是哪种模式</p></li></ol><p>E</p><ol><li><p>&#x3D;&#x3D;和equals的区别</p></li><li><p>GC如何判断一个对象可回收</p><ul><li>引用计数法</li><li>可达性分析</li></ul></li><li><p>常用的GC roots对象</p><ul><li>虚拟机栈中的引用对象</li><li>本地方法栈中JNI的引用对象</li><li>方法区中的<strong>类静态属性</strong>引用对象</li><li>方法区中<strong>常量</strong>引用的对象</li></ul></li><li><p>volatile关键字</p><ul><li>变量可见性问题</li><li>指令重排序，Happens-Before</li></ul></li><li><p>为什么会有线程可见性问题</p><ul><li>工作内存中的是主内存的副本，线程之间的工作内存不共享</li><li>A修改后作用在A的工作内存，B看不到</li></ul></li><li><p>线程安全的方式</p><ul><li>synchronized关键字（互斥锁，悲观锁）</li><li>使用Lock接口下的实现类（悲观锁）</li><li>使用线程本地存储ThreadLocal</li><li>使用乐观锁机制，使用版本控制判断实现</li></ul></li><li><p>synchronized在普通方法和静态方法的区别</p></li><li><p>数据库的隔离级别</p></li><li><p>可重复读和读提交哪个性能更好</p></li><li><p>select for update和select区别</p><ul><li>select for update会对查询的行添加排他锁</li></ul></li><li><p>Spring中事务传播属性</p></li><li><p>线程死锁的例子</p></li><li><p>left jon和inner join区别</p><ul><li><p>left join以左表为基础，右表中有不匹配的行直接置为null</p></li><li><p>innerjoin，若有左右表不匹配的行，直接去除</p></li></ul></li><li><p>数据库结果集去重</p><ul><li>DISTINCT（多条记录的每一个字段值完全相同）</li><li>GROUP BY（只有部分字段值重复，但是表存在主键）</li><li>复制到临时表，再查询（只有部分字段重复，但是表没有主键，复制到临时表中就是为了给记录添加自增增长的id）</li></ul></li><li><p>客户端如何实现认证已登录</p><ul><li>cookie+session</li><li>Token</li></ul></li><li><p>同一条url,已登录和未登录为什么不同</p></li><li><p>IOC原理</p><ul><li>Java反射机制</li><li>被调用者实例本来由调用者创建</li><li>IOC使得将对象全部交给Spring管理</li></ul></li><li><p>java异常</p><ul><li>Error<ul><li>OutOfMemoryError</li><li>IOError</li></ul></li><li>Exception<ul><li>IOException</li><li>RuntimeException</li></ul></li></ul></li><li><p>常用的线程安全类</p></li><li><p>设计一个线程安全的HashSet</p></li><li><p>设计模式及其作用</p></li><li><p>SQL注入问题,解决</p></li><li><p>两台tomcat服务器,你已经登录上一台,但是随机访问到另一台要重新登录,如何解决这个问题</p></li></ol><p>F</p><ol><li>JVM新生代和老年代</li><li>线程池的建立</li><li>用过那些数据库</li><li>http和https的区别</li><li>抽象类和接口的区别</li><li>集合类相关</li><li>java中栈和链表是如何实现</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务隔离级别及其实现原理</title>
    <link href="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><ol><li><p>是什么</p><p>数据库事务指的是一组数据操作，事务内的操作要么全部成功，要么全部失败，什么都不做。（实际上事务中可能部分操作已经完成，但是有一部分失败，事务的作用就是回滚已经成功的所有操作）</p></li><li><p>作用</p><p>每一次操作由一系列动作组成，若其中某一个环节异常，那么整个操作都要撤回。</p><p>例如：网购付款，付款后的两个操作，订单更新、库存更新，这两个操作要么都完成，要么都不完成，如果只有一个操作执行，那么订单的数据和库存的数据就不一致。</p></li><li><p>事务特性（<strong>ACID</strong>）</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li><strong>隔离性（Isolation）</strong></li><li>持久性（Durability）</li></ul></li></ol><h2 id="事务隔离要解决的问题"><a href="#事务隔离要解决的问题" class="headerlink" title="事务隔离要解决的问题"></a>事务隔离要解决的问题</h2><ul><li><p><strong>脏读</strong>（未提交的数据（可能会回滚而失效）被其他事务读取）</p><blockquote><p>脏读指读到其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。</p><p>读到了并不一定存在的数据，这就是脏读。</p></blockquote></li><li><p><strong>不可重复读</strong>（同一事务不同时刻同样的查询条件，查出来的数据不同）</p><blockquote><p>通常针对数据<strong>更新（UPDATE）</strong>操作。</p><p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。</p><p>对比可重复读，不可重复读指的是在同一事务内，不同时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。</p></blockquote></li><li><p><strong>幻读</strong>（更新了数据但是好像未生效）</p><blockquote><p>幻读针对数据<strong>插入（INSERT）</strong>操作来说。</p><p>例如：</p><p>事务A对某行内容做了更改，未提交，</p><p>此时事务B插入了与A修改前记录相同的行，并在A事务提交之前提交了，</p><p>此时在A事务中查询，发现刚才做的更改好像未生效（其实是事务B刚插入的），</p><p>这就叫幻读。</p></blockquote></li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>读未提交（READ UNCOMMITTED）</li><li>读提交（READ COMMITTED）解决脏读</li><li>可重复读（REPEATABLE READ）解决不可重复读 <strong>默认</strong></li><li>串行化（SERIALIZABEL）解决幻读</li></ul><h3 id="查看与设置隔离级别"><a href="#查看与设置隔离级别" class="headerlink" title="查看与设置隔离级别"></a>查看与设置隔离级别</h3><ul><li>查看隔离级别</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW variables LIKE &#x27;transaction_isolation&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20220913223306947.png" alt="image-20220913223306947"></p><ul><li>修改隔离级别</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET 作用域 TRANSACTION ISOLATION LEVEL 事务隔离级别;<br></code></pre></td></tr></table></figure><blockquote><p>作用域：</p><ul><li>SESSION：指针对当前会话窗口</li><li>GLOBAL：全局</li></ul><p>事务隔离级别</p><ul><li>READ UNCOMMITTED</li><li>READ COMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li></ul></blockquote><h3 id="在MySQL中执行事务"><a href="#在MySQL中执行事务" class="headerlink" title="在MySQL中执行事务"></a>在MySQL中执行事务</h3><p>事务流程：开始事务–》执行操作–》结束事务（提交&#x2F;回滚）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">BEGIN;/START TANSACTION;#事务开始于BEGIN命令后的第一条语句<br>#执行操作<br>COMMIT;<br></code></pre></td></tr></table></figure><p>查看正在运行的事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.innodb_trx;<br></code></pre></td></tr></table></figure><h3 id="隔离级别分析"><a href="#隔离级别分析" class="headerlink" title="隔离级别分析"></a>隔离级别分析</h3><h4 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h4><p>脏读问题：</p><blockquote><p>A更新的数据还未提交，B直接读取，若A进行回滚，那么A刚才更新的数据就是无效的，B获取到了无效的数据，即脏读。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-77225da0805e43183c076c24f270e75b_720w.jpg" alt="img"></p><h4 id="读提交（READ-COMMITTED）"><a href="#读提交（READ-COMMITTED）" class="headerlink" title="读提交（READ COMMITTED）"></a>读提交（READ COMMITTED）</h4><p>解决脏读问题：</p><blockquote><p>一个事务只能读取到其他事务已经提交过的数据。这样脏读问题就解决了。</p></blockquote><p>不可重复读问题：</p><blockquote><p>B某一时刻读取了数据之后，A对其作了更新，B在同一事务中再去读同一数据，读取到的和第一次读取到的不一样，即为不可重复读。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-90289243339a900aaf3f87d9c9930258_720w.jpg" alt="img"></p><h4 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h4><p>解决不可重复读问题：</p><blockquote><p>事务不会读到其他事务对已有的数据的<strong>修改</strong>，即使其他事务已提交。也就是说事务开始读到的已有数据到事务提交之前都是不会变的。</p><p>但是，对于其他事务插入的数据是可以读到的。这也就引发了幻读问题。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-85fd2da20ae7cf219bf55d8b81f8bd94_720w.jpg" alt="img"></p><p>幻读问题：</p><blockquote><p>事务B对某行做了修改，事务A插入了一行，并且这行与B进行修改的行的原始数据一致，然后B再进行查询，发现读取到和未修改行一样的数据，就好像B做的修改没有生效一样，即幻读。</p><p>MySQL中的可重复度隔离解决了幻读问题。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-457f695ba253674e7a998297660c1a01_720w.jpg" alt="img"></p><h4 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h4><p>串行化相当于单线程，事务逐一执行，自然就不会存在因为并发而引起的脏读、不可重复读、幻读的问题。</p><h2 id="MySQL中事务隔离的实现"><a href="#MySQL中事务隔离的实现" class="headerlink" title="MySQL中事务隔离的实现"></a>MySQL中事务隔离的实现</h2><p>读未提交：性能最好，相当于没加锁。</p><p>串行化：读时加共享锁，可并发读，写时加排他锁，其他事务不能进行读写。</p><h3 id="读提交和可重复读的实现"><a href="#读提交和可重复读的实现" class="headerlink" title="读提交和可重复读的实现"></a>读提交和可重复读的实现</h3><p>采用MVVC（多版本并发控制）的方法</p><h4 id="行记录版本和事务id"><a href="#行记录版本和事务id" class="headerlink" title="行记录版本和事务id"></a>行记录版本和事务id</h4><p>概述：</p><blockquote><p>我们在数据库中看到的一条行记录可能实际上有多个版本，每个版本除了记录数据外，还有一个表示版本的字段，记未row trx_id，而整个字段就是使其产生的事务的id，事务id记为transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p></blockquote><p>图解：</p><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-114dd6691636883a92e7c1060210a014_720w.jpg" alt="img"></p><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>读提交和可重复读实现的关键就是快照，学名叫做一致性视图。</p><blockquote><ul><li><p>可重复读是在事务开始的时候生成一个当前事务全局性的快照。</p></li><li><p>而读提交是每次执行语句的时候都重新生成一次快照。</p></li></ul></blockquote><p>快照能够读取到的版本：</p><blockquote><ul><li>当前事务内的更新，可以读到；</li><li>快照创建前未提交的版本不可读；</li><li>快照创建后的提交的版本不可读</li></ul></blockquote><p>综上：可重复读和读提交二者<strong>唯一的区别就是快照的创建</strong></p><h3 id="并发写的问题"><a href="#并发写的问题" class="headerlink" title="并发写的问题"></a>并发写的问题</h3><p>问题：</p><blockquote><p>两个事务对同一数据做修改。最终的结果应该时间靠后的哪个事务。</p><p>并且在更新之前要先读数据，这里所说的读和上面说到的读不一样，更新之前的读叫做“当前读”，总是当前版本的数据，也就是多版本中最新一次提交的那版。</p></blockquote><p>例子：</p><blockquote><p>若A执行UPDATE操作，在UPDATE执行期间，要对所修改的行加<strong>行锁</strong>，这个行锁在提交过后才释放。在A提交之前，B若想UPDATE这行数据，需要先申请锁，但是锁已经被A占有，所以B需要等到A提交并释放锁过后才能获取锁继续执行。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-da32a0f82e9585e39c655ac490c6f3d8_720w.jpg" alt="img"></p><p>两种加锁过程：</p><ol><li><p>有索引（只锁对应行）</p><blockquote><p>例如：<code>UPDATE user SET age=11 WHERE id = 1;</code></p><p>id是这张表的主键，是有索引的情况，那么MySQL直接就在索引数中找到这行数据，让后将该行上行锁。</p></blockquote></li><li><p>无索引（全锁，在解锁留下对应行）</p><blockquote><p>例如：&#96;UPDATE user SET age&#x3D;11 WHERE age&#x3D;10;</p><p>age并非索引，所以MySQL无法直接定位该行（或者多行）数据。然后MySQL就对表中的所有行加行锁（并非表锁），然后分局条件过滤，释放掉不满足条件的行的行锁。</p><p>这个加锁和解锁的过程非常影响性能，所以对于大表需要合理的设计索引来避免这种情况。</p></blockquote></li></ol><h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><p> 并发写问题 的解决方式是行锁，而解决幻读的方式则是间隙锁。MySQL将行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做Next-Key锁</p><p>间隙锁：</p><ul><li>表：</li></ul><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-6a7c4b03297309813d57213a2a2d7366_720w.jpg" alt="img"></p><ul><li>间隙锁：</li></ul><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-f07516da40274690e8ece9bc415eab88_720w.jpg" alt="img"></p><blockquote><p>MySQL会在筛选的索引列和其两端的索引列之间加上间隙锁。</p><p>例如执行：<code>UPDATE user SET name = ‘风筝2号’ WHERE age = 10; </code></p><p>（其中age是索引列，唯一）那么MySQL就会在age为[负无穷，10）、（10，30）这两个区间加上间隙锁，那么所有age在这两个区间的数据在此期间就无法插入。（30之后的区间插入数据不会有幻读问题，所以不需要加间隙锁）</p></blockquote><ul><li><p>加锁过程</p><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-3ce9ac24fb6fdf3ff60d03e070136175_720w.jpg" alt="img"></p><blockquote><p>在A提交之前，因为事务B插入的数据age&#x3D;10，由于age&#x3D;10的行添加了行锁，两边有间隙锁，所以插入操作无法完成，需要等到A提交后才能插入。这样就不存在幻读问题了。（age  &gt; 30的行插入不受影响）</p></blockquote><blockquote><p>若age不是索引列，那么数据库将为整个表加上间隙锁，那么不管age为何值均要等到事务A提交才能成功插入。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法</title>
    <link href="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h2><h3 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h3><ul><li>平方阶：冒泡排序、插入排序、选择排序</li><li>n^(1.3-2)阶：希尔排序</li><li>线性对数阶：快速排序、归并排序、堆排序</li><li>线性阶：计数排序、桶排序、基数排序、</li></ul><h3 id="稳定度："><a href="#稳定度：" class="headerlink" title="稳定度："></a>稳定度：</h3><blockquote><p>算法稳定指的是两个相等键值的顺序和排序之前它们的顺序相同</p></blockquote><ul><li>稳定排序：冒泡排序、插入排序、归并排序、计数排序、桶排序、基数排序</li><li>不稳定排序：选择排序、希尔排序、快速排序、堆排序</li></ul><p><strong>注意：算法稳定与否和具体的实现有关！！！</strong></p><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><blockquote><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个。每一次将最大的元素放到合适的位置。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" alt="img"></p><h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><blockquote><p>每次遍历寻找最小&#x2F;大元素放到首&#x2F;尾</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" alt="img"></p><h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><blockquote><p>将未排序元素依次插入到已排序序列合适位置（初始化第一个元素未已排序序列）</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertionSort.gif" alt="img"></p><h2 id="四、希尔排序（插入排序-缩小增量）"><a href="#四、希尔排序（插入排序-缩小增量）" class="headerlink" title="四、希尔排序（插入排序|缩小增量）"></a>四、希尔排序（插入排序|缩小增量）</h2><p>又叫（缩小增量排序），是插入排序改进版</p><p>基于插入排序特性进行优化:</p><blockquote><ul><li>插入排序在对几乎已经拍好序的数据操作时，效率高。</li><li>但是一般来说插入排序是低效的，因为每次插入只能将数据移动一位。</li></ul></blockquote><p>希尔排序的基本思想：</p><blockquote><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1024555-20161128110416068-1421707828.png" alt="img"></p><h2 id="五、归并排序（分治法）"><a href="#五、归并排序（分治法）" class="headerlink" title="五、归并排序（分治法）"></a>五、归并排序（分治法）</h2><ul><li><p><strong>分治法</strong>的典型应用。</p></li><li><p>问题分解：要将数组排序，先将数组分解成两份，将两份分别排好序后，再将两份数组合并，合并后的数组就排好序了。</p></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1024555-20161218163120151-452283750.png" alt="img"></p><h2 id="六、快速排序（分治法-冒泡排序）"><a href="#六、快速排序（分治法-冒泡排序）" class="headerlink" title="六、快速排序（分治法|冒泡排序）"></a>六、快速排序（分治法|冒泡排序）</h2><ul><li><p><strong>分治法</strong>的典型应用。</p></li><li><p>从本质上看，快速排序算是<strong>在冒泡排序基础上的递归分治法</strong></p></li><li><p>算法思想：</p><blockquote><p>选择一个基准元素，然后以它为基准将数组分为两个区。然后将比基准值小的都放到基准值左边，大的放到基准值右边，然后对两个区域分别递归排序排序。</p><p>划区的操作就相当于是冒泡操作，每一层递归，一个元素就放置到了它该在的位置。</p></blockquote></li><li><p>算法实现：</p><blockquote><p>在单独的一层递归中，选择首元素作为基准元素，然后使用双指针，从第二个元素和末尾元素向中间遍历，左指针找比基准元素小的元素，右指针找比基准元素大的值，然后交换，最后将基准元素与左指针指向元素互换，这样基准元素左边都比它小，右边都比他大，此时他已经到了该在的位置。</p></blockquote></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" alt="img"></p><h2 id="七、堆排序（选择排序-堆）"><a href="#七、堆排序（选择排序-堆）" class="headerlink" title="七、堆排序（选择排序|堆）"></a>七、堆排序（选择排序|堆）</h2><ul><li><p>基于堆这种数据结构而设计</p><blockquote><p>堆是具有一下性质的<strong>完全二叉树</strong>：每个节点的值都大于或等于其左右子节点的值，称为大顶堆。反之为小顶堆。</p></blockquote></li><li><p>堆排序是一种<strong>选择排序</strong></p></li><li><p>堆排序的基本思想：</p><blockquote><p>1、将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。</p><p>2、将其与末尾元素进行交换，此时末尾就为最大值，然后将剩余的n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。</p><p>如此反复执行，就能得到一个有序序列。</p></blockquote></li></ul><h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><ul><li><p>计数排序的思想：</p><blockquote><p>将输入的数值转换为键存储在额外开辟的数组空间中。要求输入的数据是有确定范围的整数</p></blockquote></li><li><p>计数排序不是比较排序。用于计数的数组大小取决于数据的范围，所以说计数排序只适合于数据范围较小的数组。</p></li><li><p>但是计数排序可以用在基数排序中，用来排序数据范围很大的数组。</p></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/countingSort.gif" alt="img"></p><h2 id="九、桶排序（计数排序-桶）"><a href="#九、桶排序（计数排序-桶）" class="headerlink" title="九、桶排序（计数排序|桶）"></a>九、桶排序（计数排序|桶）</h2><ul><li><p>桶排序是计数排序的升级版。</p><blockquote><ul><li><p>计数排序是将每个值占用一个数组位置（相当于桶大小为1），然后直接顺序取值后全部元素就已拍好序列。</p></li><li><p>而桶排序则是将一定范围内的值放入一个桶中，然后对每个桶中元素单独排序（可以使用各种算法，一般采用插入排序，若桶内已经有元素，则新来的元素使用插入排序放入桶中），最后依次从桶中取出拍好序的元素归位。</p></li></ul></blockquote><ol><li>将元素分配到桶中</li></ol><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Bucket_sort_1.svg_.png" alt="img"></p><ol start="2"><li>将每个桶中元素进行排序</li><li>然后依次将每个桶中的元素取出归位</li></ol><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Bucket_sort_2.svg_.png" alt="img"></p></li></ul><h2 id="十、基数排序（桶排序-按位分配桶）"><a href="#十、基数排序（桶排序-按位分配桶）" class="headerlink" title="十、基数排序（桶排序|按位分配桶）"></a>十、基数排序（桶排序|按位分配桶）</h2><blockquote><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位切割成不同的数字，然后根据每个位上数字来分配桶（1-9共十个桶）。</p><p>基数排序还可以用于字符串和浮点数的排序。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/radixSort.gif" alt="img"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/09/04/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/04/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="1-Java语言特点"><a href="#1-Java语言特点" class="headerlink" title="1. Java语言特点"></a>1. Java语言特点</h3><ul><li>面向对象（封装、继承、多态）</li><li>平台无关性（Java虚拟机）</li><li>多线程（语言级支持）</li><li>网络编程（Java诞生就是为了简化网络编程设计）</li><li>编译与解释并存</li><li>简单易学、可靠性、安全性</li></ul><h3 id="2-JVM、JRE、JDK"><a href="#2-JVM、JRE、JDK" class="headerlink" title="2. JVM、JRE、JDK"></a>2. JVM、JRE、JDK</h3><ul><li><p>JVM</p><blockquote><p>JVM是运行Java字节码的虚拟机，JVM针对不同的系统的特定实现，目的是使用相同的字节码，在不同平台的JVM上运行都能产生相同结果。</p></blockquote><ul><li><p>什么是字节码？采用字节码的好处？</p><blockquote><p>在Java中，JVM可以理解的代码就是字节码（.class文件）、它不面向特定处理器，只面向虚拟机。Java通过字节码的方式，一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释性语言可移植的特点。所以因为采用字节码，Java程序运行比较高效，而且由于字节码不针对特定机器，所以Java程序无需重新编译即可在不同操作系统上运行。</p></blockquote></li><li><p>Java程序从源代码到运行的流程</p><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/image-20220904193326678.png" alt="image-20220904193326678"></p><blockquote><p>.class -&gt; 机器码，由JVM进行转换。有两种转换方式：</p><ul><li>一是解释执行，先加载字节码文件，经过解释器解释执行；</li><li>二是编译执行，对于热点代码，由编译器完成一次编译过后将字节码对应的机器码保存下来，下次直接使用。</li></ul></blockquote></li></ul></li><li><p>JRE</p><blockquote><p>JRE是Java与模型时环境，它时运行已编译Java程序所需的所有内容的集合，包括JVM、Java类库、java命令和一些其他的基础构件。但是，它不能用于创建新程序。</p></blockquote></li><li><p>JDK</p><blockquote><p>JRE + 编译器（javac）+ 工具（如javadoc和jdb）。它能创建和编译程序。</p></blockquote></li></ul><p>   总结：</p><ul><li>JVM：（执行java字节码文件）</li><li>JRE：JVM + java类库 + java命令 + 基础构件（运行java程序）</li><li>JDK：JRE + 编译器 + 工具（创建和编译程序）</li></ul><h3 id="3-Oracle-JDK-和-OpenJDK"><a href="#3-Oracle-JDK-和-OpenJDK" class="headerlink" title="3. Oracle JDK 和 OpenJDK"></a>3. Oracle JDK 和 OpenJDK</h3><ul><li>OpenJDK完全开源，作为一个参考模型。Oracle JDK是OpenJDK的一个实现，包含自己的商业内容，不完全开源。</li><li>Oracle更稳定，有更多的类和一些错误修复。性能更好。</li></ul><h3 id="4-Java和C-的区别"><a href="#4-Java和C-的区别" class="headerlink" title="4. Java和C++的区别"></a>4. Java和C++的区别</h3><ul><li><p>都是面向对象的语言，都支持封装、继承和多态</p></li><li><p><strong>指针</strong>，Java不提供指针用来直接访问内存，程序内存更安全</p></li><li><p><strong>继承</strong>，Java的类是单继承的，C++支持多继承。虽然Java的类不能多继承，但是接口可以多继承（实现）</p></li><li><p><strong>内存管理</strong>，Java通过JVM自动管理内存，不需要程序员手动释放无用内存</p></li><li><p><strong>字符串结束符</strong>，C语言中字符串和字符数组随后都有额外字符 ‘\0’ 来表示结束。Java语言中没有结束符这一概念。</p><blockquote><p>Java是面向对象的，字符串和数组均是对象，对象有属性length来记录长度，所以说再额外使用结束符来标识末尾。</p></blockquote></li></ul><h3 id="5-什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#5-什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="5. 什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>5. 什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><blockquote><p>一个程序可以有很多个类，但是只能由一个类是主类。再Java应用程序中，这个主类是指包含main方法的类。</p></blockquote><blockquote><p>在小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是pulic类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p></blockquote><h3 id="6-Java应用程序（Application）和小程序（Applet）之间的差别"><a href="#6-Java应用程序（Application）和小程序（Applet）之间的差别" class="headerlink" title="6. Java应用程序（Application）和小程序（Applet）之间的差别"></a>6. Java应用程序（Application）和小程序（Applet）之间的差别</h3><ul><li>（1）运行方式不同。Java Application是完整的程序，可以独立运行；Java Applet程序不能单独运行，<br>它必须嵌入到用HTML语言编写的Web页面中，通过与Java兼容的浏览器来控制执行。</li><li>（2）运行工具不同。Java Application程序被编译以后，用普通的Java解释器就可以使其边解释边执行，<br>而Java Applet必须通过网络浏览器或者Applet观察器才能执行。</li><li>（3）程序结构不同。每个Java Application程序必定含有一个并且只有一个main方法，程序执行时<br>首先寻找main方法，并以此为入口点开始运行。含有main方法的那个类，常被称为主类，也就是说<br>Java Application程序都含有一个主类。而Applet程序则没有含main方法的主类，这也正是Applet程序不能独立运行的原因。<br>尽管Applet没有含main方法的主类，但Applet一定有一个从 java.applet.Applet派生的类，它是由Java系统提供的。</li><li>（4）受到的限制不同Java Application程序可以设计成能进行各种操作的程序，包括读／写文件的操作<br>但是 Java Applet 对站点的磁盘文件既不能进行读操作，也不能进行写 操作。然而，由于Applet的引入<br>使Web页面具有动态多媒体效果和可交互性能，这使由名为超文本、实为纯文本的HTML语言编写成的Web页面真正具有了超文本功能</li></ul><h3 id="7-import-java-x2F-javax有啥区别"><a href="#7-import-java-x2F-javax有啥区别" class="headerlink" title="7. import java&#x2F;javax有啥区别"></a>7. import java&#x2F;javax有啥区别</h3><blockquote><p>刚开始的时候JavaAPI所需的包均以是以java开头的包，javax作为扩展API包使用。随着时间的推移，javax逐渐成为JavaAPI的一部分，但是将javax包移动到java包中太麻烦，且会破坏一堆现有代码，所以直接将javax纳入为JavaAPI的一部分</p></blockquote><h3 id="8-为什么说Java语言“编译与解释并存”？"><a href="#8-为什么说Java语言“编译与解释并存”？" class="headerlink" title="8. 为什么说Java语言“编译与解释并存”？"></a>8. 为什么说Java语言“编译与解释并存”？</h3><blockquote><p>高级程序语言按照程序的执行方式分为编译型和解释型。</p><ul><li>编译型语言指编译器针对特定操作系统将源代码一次性翻译成可被该平台执行的机器码</li><li>解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</li></ul></blockquote><blockquote><p>Java语言既有编译型语言特征，也有解释型语言特征。java源码先编译成字节码，字节码再由解释器解释执行（同时也有编译器对热点代码进行编译）</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="1-字符型常量和字符串常量的区别？"><a href="#1-字符型常量和字符串常量的区别？" class="headerlink" title="1. 字符型常量和字符串常量的区别？"></a>1. 字符型常量和字符串常量的区别？</h3><ul><li>形式：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干字符</li><li>含义：字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串再内存中的存放地址）</li><li>占用内存：字符常量只占2个字节；字符串常量占若干字节</li></ul><h3 id="2-关于注释？"><a href="#2-关于注释？" class="headerlink" title="2. 关于注释？"></a>2. 关于注释？</h3><blockquote><p>注释并非越详细越好，好的代码本身就是注释，尽量通过规范和美化代码来减少不必要的注释。</p></blockquote><ul><li><p>注释种类</p><ul><li><p>单行注释</p><blockquote><p>&#x2F;&#x2F;注释</p></blockquote></li><li><p>多行注释</p><blockquote><p> &#x2F;*</p><p>注释</p><p>注释</p><p>*&#x2F;</p></blockquote></li><li><p>文档注释</p><blockquote><p>&#x2F;**</p><p>*文档注释</p><p>*&#x2F;</p></blockquote></li></ul></li></ul><h3 id="3-标识符和关键字的区别？"><a href="#3-标识符和关键字的区别？" class="headerlink" title="3. 标识符和关键字的区别？"></a>3. 标识符和关键字的区别？</h3><blockquote><p>在编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符。简单来说标识符就是一个名字。</p></blockquote><blockquote><p>但是有一些标识符，Java语言已经赋予其特殊含义，只能又在特定地地方，这种特殊的标识符就是关键字。因此关键字是被赋予特殊含义的标识符。</p></blockquote><h3 id="4-常见关键字"><a href="#4-常见关键字" class="headerlink" title="4. 常见关键字"></a>4. 常见关键字</h3><ul><li><p>访问控制：private、protected、public</p></li><li><p>类、方法和变量的修饰符：abstract、static、interface、final、extends、implments、new、native、strictfp、synchronized、transient、volatile、class</p></li><li><p>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</p></li><li><p>错误处理：try、catch、throw、throws、finally</p></li><li><p>包相关：import、package</p></li><li><p>基本类型：boolean、byte、char、double、float、int、long、short、null、true、false</p></li><li><p>变量引用：super、this、void</p></li><li><p>保留字：goto、const</p></li></ul><h3 id="5-continue、break和return区别"><a href="#5-continue、break和return区别" class="headerlink" title="5. continue、break和return区别"></a>5. continue、break和return区别</h3><ul><li>提前终止循环<ul><li>continue：跳出当前这一次循环（此次循环中continue后的语句不执行，直接跳到循环的开头进行循环的条件判断，执行下一次循环）</li><li>break：跳出当前所在的整个循环体，执形循环后的语句</li></ul></li><li>结束方法的运行<ul><li>return：直接结束方法的执行，用于没有返回值的方法</li><li>return value：返回一个特定值，并结束方法的执行</li></ul></li></ul><h3 id="6-泛型、类型擦除、通配符？"><a href="#6-泛型、类型擦除、通配符？" class="headerlink" title="6. 泛型、类型擦除、通配符？"></a>6. 泛型、类型擦除、通配符？</h3><ul><li><p>泛型：泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数</p><blockquote><p>泛型的三种使用方法：</p><ul><li><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> T key;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span>&#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实例化泛型类</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure></li><li><p>泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//实现泛型接口，不指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实现泛型接口，指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(E[] inputArray)</span>&#123;<br>    <span class="hljs-keyword">for</span>(E element : inputArray)&#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s&quot;</span>, element);<br>    &#125;<br>    System.out.println();<br>&#125;<br><span class="hljs-comment">//创建不同类型的数组，使用同一泛型方法打印</span><br>Integer[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>String[] stringArray = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br>printArray(intArray);<br>printArray(stringArray);<br></code></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>常用通配符：T、E、K、V、？</p><ul><li>？标识不确定的java类型</li><li>T（type）标识具体的一个java类型</li><li>K V（key value）分别标识java键值中的Key Value</li><li>E（element）标识数组中的元素类型</li></ul></blockquote></li><li><p>类型擦除：Java的泛型是<strong>伪泛型</strong>，因为Java在编译期间，所有的泛型信息都会被擦除，这就是通常所说的类型擦除。 所有的泛型在编译过后均为Object，所以说，在运行期间通过反射可以向Integer泛型的List中添加String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>list.add(<span class="hljs-number">12</span>);<br><span class="hljs-comment">//直接往Integer的list中添加string会在编译器报错</span><br>list.add(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-comment">//通过反射获取运行期，list的add方法</span><br>Class&lt;? extend List&gt; clazz = list.getClass();<br><span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br><span class="hljs-comment">//通过反射获取的add方法可以往Integer的list中添加string</span><br>add.invoke(list, <span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-x3D-x3D-和equals-的区别"><a href="#7-x3D-x3D-和equals-的区别" class="headerlink" title="7. &#x3D;&#x3D;和equals()的区别"></a>7. &#x3D;&#x3D;和equals()的区别</h3><ul><li><p>&#x3D;&#x3D;：比较的是值，若是基本数据类型，即直接比较它们的值是否相等；若是比较对象，因为引用变量的值是对象的地址，即比较的是对象的地址是否相同。</p></li><li><p>equals：它的作用是比较两个对象是否相等，不能用于比较基本数据类型变量。equals方法存在于Object类中，而Object类是所有类的父类，所有说所有的类都有equals方法。</p><blockquote><p>类的equals方法可以重写，重写即是定义规则使用&#x3D;&#x3D;比较对象的属性，来判断两个对象是否相等。</p><p>若没有重写则使用Object的默认equals方法，比较两个对象的地址，即和&#x3D;&#x3D;一样。</p></blockquote></li></ul><h3 id="8-hashCode-与equals"><a href="#8-hashCode-与equals" class="headerlink" title="8. hashCode()与equals()"></a>8. hashCode()与equals()</h3><ol><li><p>hashCode()介绍：</p><blockquote><p>hashCode()的作用是获取哈希码，也称为散列码；它返回一个int整数，用于确定对象在哈希表中的索引位置。</p></blockquote></li><li><p>为什么要有hashCode？</p><blockquote><p> 减少equals的使用次数。若要将对象加入HashSet，首先会计算对象的hashcode，与其他已加入的对象的hashcode值比较，若没有重复的hashcode，则没有重复的对象。若有重复的hashcode，则使用equals方法来确定对象是否真的相同。若是hashcode相同的不同对象，则会将后加入的对象散列到其他位置</p></blockquote></li><li><p>为什么重写equals时必须重写hashCode方法？</p><blockquote><p>hashCode方法要实现equals方法认定相等的对象返回相同的hashcode值。若是默认的hashCode方法，使用的是对象地址转换的hashcode值，但是两个不同的对象地址不同，但是它们可以是相等的。若使用默认的Object类的hashCode方法则相等的对象有不同的hashcode值</p></blockquote></li><li><p>为什么hashcode值相等的对象不一定相等？</p><blockquote><p>hash碰撞</p></blockquote></li></ol><h3 id="9-获取键盘输入"><a href="#9-获取键盘输入" class="headerlink" title="9. 获取键盘输入"></a>9. 获取键盘输入</h3><ol><li><p>通过Scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> input.nextLine();<br>input.close();<br></code></pre></td></tr></table></figure></li><li><p>通过BufferedReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferReader</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> input.readLine();<br></code></pre></td></tr></table></figure></li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="1-Java中有几种基本数据类型-以及其对应的包装类是什么-各自占用多少字节"><a href="#1-Java中有几种基本数据类型-以及其对应的包装类是什么-各自占用多少字节" class="headerlink" title="1. Java中有几种基本数据类型?以及其对应的包装类是什么?各自占用多少字节?"></a>1. Java中有几种基本数据类型?以及其对应的包装类是什么?各自占用多少字节?</h3><table><thead><tr><th>基本类型</th><th>包装类</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>short</td><td>Short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>int</td><td>Integer</td><td>32</td><td>4</td><td>0</td></tr><tr><td>long</td><td>Long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>float</td><td>Float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>Double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>char</td><td>Character</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>boolean</td><td>Boolean</td><td>1</td><td></td><td>false</td></tr></tbody></table><blockquote><p>long类型的数值一定要在数值后加上<strong>L</strong>，否则作为整型解析；</p><p>对于boolean，不同JVM不同实现，逻辑上是占一位，但实际中会考虑在计算机中的高效存储。</p></blockquote><h3 id="2-自动拆装箱"><a href="#2-自动拆装箱" class="headerlink" title="2.自动拆装箱"></a>2.自动拆装箱</h3><ul><li><p>是什么</p><blockquote><p>装箱：Integer i &#x3D; 10;</p><p>拆箱：int n &#x3D; i;</p></blockquote></li><li><p>原理</p><blockquote><p>在编译的时候自动调用包装类对应的方法来进行拆装箱</p><p>装箱：Integer.valueOf(int)</p><p>拆箱：Integer.intValue()</p></blockquote></li></ul><h3 id="3-包装类的常量池"><a href="#3-包装类的常量池" class="headerlink" title="3.包装类的常量池"></a>3.包装类的常量池</h3><p>常量池技术的意义：</p><blockquote><p>在缓存数据范围内的包装类，新建的多个相同数值的包装类会指向同一个地址</p><p>浮点数类型包装类并没有实现常量池技术</p></blockquote><ul><li><p>整型：Byte、Short、Integer、Long</p><blockquote><p>这四种包装类拆创建了数值[-128, 127]的相应类型的缓存数据</p></blockquote></li><li><p>Character</p><blockquote><p>创建了[0, 127]范围的缓存数据</p></blockquote></li><li><p>Boolean</p><blockquote><p>直接返回True Or False</p></blockquote></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-为什么Java中只有值传递？"><a href="#1-为什么Java中只有值传递？" class="headerlink" title="1.为什么Java中只有值传递？"></a>1.为什么Java中只有值传递？</h3><p>程序设计语言中的一些术语：</p><blockquote><ul><li><p>按值调用（call by value）：表示方法接收的是调用者提供的值</p></li><li><p>按引用调用（call by reference）：表示方法接收的是调用者提供的变量地址</p></li></ul></blockquote><p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p>Java中方法参数的使用情况：</p><blockquote><ul><li>一个方法不能修改一个基本数据类型的参数（数值型或布尔型）</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用另一个新的对象</li></ul></blockquote><h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h3><blockquote><p>重载：同一个方法名，根据不同的输入数据，做出不同的处理</p><p>重写：子类继承父类的方法，若子类要对于相同的数据，做出与父类不同的响应的时候，要重写父类方法</p></blockquote><h4 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h4><ul><li><strong>方法的签名</strong>包括方法名和参数类型</li><li>重载发生在同一个类中，方法名相同，参数不同（类型、个数、顺序），重载的方法可以有不同的返回值和访问修饰符</li><li>方法签名不包括方法的返回类型，所以说不能存在方法签名相同，但是返回类型不同的方法。</li></ul><h4 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h4><ul><li>重写发生在运行期</li><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围不超过父类，访问修饰符范围不低于父类。</li><li>若父类方法范文修饰符为 private&#x2F;final&#x2F;static 则子类不能重写该方法，但是被static修饰的方法能够被再次声明</li><li>构造方法无法被重写</li></ul><table><thead><tr><th>区别点</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类中</td><td>子类中</td></tr><tr><td>参数</td><td>必须修改</td><td>一定不能改</td></tr><tr><td>返回类型</td><td>可修改</td><td>一定不能改</td></tr><tr><td>异常</td><td>可修改</td><td>可以减少或删除，一定不能抛出更广的异常</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>可以扩大范围吧范围，一定不能缩小</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table><h3 id="3-深拷贝VS浅拷贝"><a href="#3-深拷贝VS浅拷贝" class="headerlink" title="3.深拷贝VS浅拷贝"></a>3.深拷贝VS浅拷贝</h3><p>对于基本数据类型都一样进行值传递</p><p>对与引用数据类型：</p><ul><li>浅拷贝：拷贝原对象的引用</li><li>深拷贝：创建一个新的对象，并对原引用对象的数据进行复制，将新对象的引用拷贝</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h3><blockquote><p>面向过程就是分析出解决问题所需的步骤，然后使用函数把这些步骤一步一步实现，使用的时候依次调用。</p><p>面向对象就是把问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</p></blockquote><h3 id="2-构造器能够被重写"><a href="#2-构造器能够被重写" class="headerlink" title="2. 构造器能够被重写"></a>2. 构造器能够被重写</h3><blockquote><p>构造器不能被重写，但是可以被重载，所以说一个类中可以有多个构造器</p></blockquote><h3 id="3-关于构造方法"><a href="#3-关于构造方法" class="headerlink" title="3. 关于构造方法"></a>3. 关于构造方法</h3><h4 id="3-1-构造方法的作用？若类没有声明构造方法会怎样？"><a href="#3-1-构造方法的作用？若类没有声明构造方法会怎样？" class="headerlink" title="3.1 构造方法的作用？若类没有声明构造方法会怎样？"></a>3.1 构造方法的作用？若类没有声明构造方法会怎样？</h4><blockquote><p>构造方法的主要作用是完成类对象的初始化工作</p></blockquote><blockquote><p>若一个类没有声明构造方法，也就生成一个默认得无参构造方法，我们在创建对象得时候加一个空括号就是在调用这个无参构造方法。若我们添加了类的构造方法，那么就不会生成默认得无参构造方法。</p></blockquote><h4 id="3-2在调用子类构造方法之前会先调用父类的构造方法，其目的是？"><a href="#3-2在调用子类构造方法之前会先调用父类的构造方法，其目的是？" class="headerlink" title="3.2在调用子类构造方法之前会先调用父类的构造方法，其目的是？"></a>3.2在调用子类构造方法之前会先调用父类的构造方法，其目的是？</h4><blockquote><p>帮助子类完成初始化工作</p></blockquote><h4 id="3-3-在Java中定义一个无参构造方法的意义"><a href="#3-3-在Java中定义一个无参构造方法的意义" class="headerlink" title="3.3 在Java中定义一个无参构造方法的意义"></a>3.3 在Java中定义一个无参构造方法的意义</h4><blockquote><p>Java程序在执行子类的构造方法之前，若没有使用super显式地调用父类地构造方法，就会调用父类中地无参构造方法。若父类中没有无参构造方法，而且子类没有用super调用父类中特定的构造方法，则编译的时候就会出错。</p></blockquote><h4 id="3-4-构造方法的特性"><a href="#3-4-构造方法的特性" class="headerlink" title="3.4 构造方法的特性"></a>3.4 构造方法的特性</h4><ul><li>名字与类名相同</li><li>没有返回值，但是不能用void声明构造函数</li><li>构造方法子啊生成类时自动执行，无需调用</li></ul><h3 id="4-成员变量和局部变量的区别"><a href="#4-成员变量和局部变量的区别" class="headerlink" title="4. 成员变量和局部变量的区别"></a>4. 成员变量和局部变量的区别</h3><ul><li>语法形式：<ul><li>成员变量属于类，局部变量属于方法；</li><li>成员变量可以被public、private、static等修饰符修饰，局部变量不能。但是二者都可以被final修饰</li></ul></li><li>存储形式：<ul><li>若成员变量被static修饰，那么这个成员变量属于类，若没有，那么这个成员变量属于实例。</li><li>对象存储在堆内存，局部变量存储在栈内存</li></ul></li><li>生存时间：<ul><li>成员变量属于对象，随着对象的创建而存在</li><li>局部变量随着方法的调用而消失</li></ul></li><li>默认值：<ul><li>成员变量若没有被初值，则会以类型的默认值赋值（被final修饰的成员变量必须显式的赋值）</li><li>局部变量不会自动赋值</li></ul></li></ul><h3 id="5-对象实体与对象引用有何不同？"><a href="#5-对象实体与对象引用有何不同？" class="headerlink" title="5. 对象实体与对象引用有何不同？"></a>5. 对象实体与对象引用有何不同？</h3><ul><li>使用new运算符创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用在栈内存中）</li><li>一个对象引用可以指向0或1个对象；一个对象可以有n个引用指向它</li></ul><h3 id="6-对象相等与指向它们的引用相等的区别"><a href="#6-对象相等与指向它们的引用相等的区别" class="headerlink" title="6. 对象相等与指向它们的引用相等的区别"></a>6. 对象相等与指向它们的引用相等的区别</h3><p>对象相等比较的是对象的内容是否相等。而引用相等比较的是它们指向的内存地址时候相等。</p><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><p>封装就是把一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。可以提供一些可以被外界访问的方法来操作属性。</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h3><p>不同类型的对象，相互之间经常有一定数量的共同点，与此同时每个对象还拥有自己的额外特性。例如小红同学和小明同学，它们都是学生拥有学生的特征（学号，班级等），但是每个同学由有各自不同的优点，比如小红数学好，小明力气大。</p><p>继承是使用已经存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，但是不能选择性地继承父类。</p><p>通过使用继承，可以快速地创建新地类，可以提高代码地重用，程序的可维护性，节省大量创建新类的时间，提高开发效率。</p><p>关于继承：</p><ul><li><strong>继承</strong>，子类拥有父类对象的所有属性和方法（包括私有的属性和方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。</li><li><strong>拓展</strong>，子类可以拥有自己的属性和方法，即子类可以对父类进行拓展。</li><li><strong>重写</strong>，子类可以用自己的方式实现父类的方法。</li></ul><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h3><p>多态表示一个对象具有多种状态。具体表现为父类的引用指向子类的实例。</p><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有 <strong>继承&#x2F;实现</strong> 的关系；</li><li>对象类型不可变，引用类型可变；</li><li>方法具有多态性，属性不具有多态性；</li><li>引用类型不能调用 ”只在子类存在但是在父类不存在的“ 方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆写的方法。</li></ul><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h4 id="1-为什么在静态方法内调用一个非静态成员是非法的？"><a href="#1-为什么在静态方法内调用一个非静态成员是非法的？" class="headerlink" title="1. 为什么在静态方法内调用一个非静态成员是非法的？"></a>1. 为什么在静态方法内调用一个非静态成员是非法的？</h4><p>因为静态方法可以不通过类调用，不通过对象调用，而非静态成员存在与对象中，所以说在静态方法中，不能访问&#x2F;调用其他非静态成员。</p><h4 id="2-静态方法和实例方法的区别"><a href="#2-静态方法和实例方法的区别" class="headerlink" title="2. 静态方法和实例方法的区别"></a>2. 静态方法和实例方法的区别</h4><ul><li>调用，在外部调用静态方法时，可以使用 ”类名.方法名“ 和 ”对象名.方法名” 的方式访问。也就是说，静态方法的调用无需创建对象。</li><li>类成员访问范围，静态方法只能访问本类的静态成员，即（静态成员变量和静态方法）。</li></ul><h4 id="3-常见修饰符总结"><a href="#3-常见修饰符总结" class="headerlink" title="3.常见修饰符总结"></a>3.常见修饰符总结</h4><p><strong>3.1 修饰类：</strong></p><ul><li><p>访问权限修饰符</p><ul><li><p>public：完全开放</p></li><li><p>protected：同包及子类访问</p></li><li><p>default：同包访问</p></li><li><p>private：只能本类访问</p></li></ul></li><li><p>限定符</p><ul><li>abstract：指定为抽象类</li><li>final：指定为最终类，不可被继承</li></ul></li></ul><p><strong>3.2 修饰成员变量：</strong></p><ul><li><p>限定符</p><ul><li><p>static：类属性，可直接通过类名调用</p><blockquote><p>static 不能修饰普通类，但是可以用来<strong>修饰内部类</strong>，因为内部类时类的成员变量。若用static修饰内部类，可以直接使用new OuterClass.InnerClass()直接创建出来。</p></blockquote></li><li><p>final：该成员不能不重写，即定义常量</p><blockquote><p>final修饰的<strong>属性变量</strong>必须在定义或者构造函数中初始化</p><p>final修饰的<strong>局部变量</strong>在使用前赋值即可</p><p>通常与static一起使用以创建<strong>类常量</strong>，此时该变量必须在定义的时候进行初始化</p></blockquote></li><li><p><del>transient</del>：不许列化</p></li><li><p><del>volatile</del>：同步变量</p></li></ul></li></ul><p><strong>3.3修饰成员方法：</strong></p><ul><li><p>限定符</p><ul><li><p>static：类方法，可通过类名直接调用</p></li><li><p>final：方法不能被重写</p></li><li><p>abstract：抽象方法，没有方法体</p><blockquote><p>抽象方法不能被声明为final和static</p></blockquote></li><li><p><del>synchronized</del>：同步方法</p></li><li><p><del>native</del>：本地方法（集成其他语言的代码）</p></li></ul></li></ul><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范。</p><ul><li>接口的方法默认是public，抽象类可以有非抽象方法，抽象方法可以有的访问修饰符不能是privat，因为抽象方法就是为了被重写的，而private修饰的方法是无法被子类访问的，更不用说重写了。</li><li>接口中只能有static、final变量，不能有其他变量，抽象类中不一定。</li><li>一个类可以实现多个接口，但是只能继承一个类。接口本身可以实现多个接口。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-String、StringBuffer、StringBuilder区别？String为什么不可变？"><a href="#1-String、StringBuffer、StringBuilder区别？String为什么不可变？" class="headerlink" title="1. String、StringBuffer、StringBuilder区别？String为什么不可变？"></a>1. String、StringBuffer、StringBuilder区别？String为什么不可变？</h3><p>存储：</p><ul><li>String：使用final修饰的字符数组来保存字符串，因此String不可变。</li><li>StringBuilder和StringBuffer都继承自AbstractStringBuilder，使用字符串数组保存字符串，但是没有使用final修饰，所有保存的字符串可变</li></ul><p>线程安全：</p><ul><li><p>String不可变，可以理解为常量，所以说线程安全</p></li><li><p>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以说线程安全</p></li><li><p>StringBuilder没有对方法加锁，是非线程安全的</p><blockquote><p>String类型改变时会生成新的String对象，然后将指针指向新的String对象。</p><p>StringBuilder直接对对象本身修改。用多线程不安全的风险换10%左右的性能提升。</p></blockquote></li></ul><h3 id="2-Object类的常见方法"><a href="#2-Object类的常见方法" class="headerlink" title="2. Object类的常见方法"></a>2. Object类的常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于返回当前运行时对象的Class对象，使用final关键词修饰，故不允许子类重写</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br><br><span class="hljs-comment">//返回对象的哈希码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//默认比较两个对象地址是否相等，可重写自定义对象相等比较</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br><span class="hljs-comment">//用于创建并返回当前对象的一份拷贝。使用必须重写，Object类没有实现Cloneable接口，直接使用会抛错。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br><br><span class="hljs-comment">//默认返回类名@实例的哈希码的16进制的字符串</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//---------------------------线程相关-------------------------------------</span><br><br><span class="hljs-comment">//唤醒一个在此对象监视器上等待的线程</span><br>notify();<br><br><span class="hljs-comment">//唤醒所有在此对象监视器上等待的线程</span><br>notifyAll();<br><br><span class="hljs-comment">//暂停线程的执行。sleep方法没有释放锁，wait方法在暂停期间释放锁。</span><br>wait();<br><br><span class="hljs-comment">//实例被垃圾回收期回收的时候触发的操作</span><br>finalize();<br></code></pre></td></tr></table></figure><h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/gailan-01.png" alt="img"></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/npe-1.jpg" alt="img"></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-程序、线程、进程的基本概念和它们之间的关系"><a href="#1-程序、线程、进程的基本概念和它们之间的关系" class="headerlink" title="1. 程序、线程、进程的基本概念和它们之间的关系"></a>1. 程序、线程、进程的基本概念和它们之间的关系</h3><ul><li><p>程序：</p><blockquote><p>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中,也就是说程序是静态的代码。</p></blockquote></li><li><p>进程：（资源分配的最小单位）</p><blockquote><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此<strong>进程是动态的</strong>。</p><p>系统运行一个程序即是一个进程从创建、运行到消亡的过程。简单来看，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行，同时每个进程还占有某些系统资源，比如说CPU时间，内存空间，文件，输入输出设备的使用权等。</p></blockquote></li><li><p>线程：（系统调度的最小单位）</p><blockquote><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小很多，也正因为如此，线程也被称为轻量级进程。</p></blockquote></li></ul><p>关系：</p><p>当程序被执行时，将会被操作系统载入内存中。线程时进程划分成的更小的运行单位。线程和进程的最大不同在于基本各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一个角度来说进程属于操作系统的范畴，主要是同段时间内，可以同时执行一个以上的程序，而线程则是在一个同一程序内几乎同时执行一个以上的程序段</p><h3 id="2-线程的基本状态"><a href="#2-线程的基本状态" class="headerlink" title="2. 线程的基本状态"></a>2. 线程的基本状态</h3><blockquote><ul><li><p>NEW：初始状态</p><blockquote><p>线程被构建，但是还没调用start()方法</p></blockquote></li><li><p>RUNNABLE：运行状态</p><blockquote><p>Java线程将操作系统中的就绪和运行两种状态笼统地称为“运行中”</p></blockquote></li><li><p>BLOCKED：阻塞状态</p><blockquote><p>表示线程阻塞与锁</p></blockquote></li><li><p>WAITING：等待状态</p><blockquote><p>表示线程进入等待状态，进入该状态表示档期那线程需要等待其他线程做出一些特定动作（通知或中断）</p></blockquote></li><li><p>TIME_WAITING：超时等待状态</p><blockquote><p>该状态不同于WAITING，它是可以在指定地时间自行返回地</p></blockquote></li><li><p>TERMINATED：终止状态</p><blockquote><p>表示当前线程已经执行完毕</p></blockquote></li></ul></blockquote><h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="1-Java中的IO流分为几种"><a href="#1-Java中的IO流分为几种" class="headerlink" title="1. Java中的IO流分为几种"></a>1. Java中的IO流分为几种</h3><p>划分方式：</p><blockquote><p><strong>流的流向分</strong>：输入流和输出流</p><p><strong>操作单元</strong>：字节流和字符流</p><p><strong>流的角色</strong>：节点流和处理流</p></blockquote><p>IO流的派生抽象基类</p><blockquote><p>InputStream&#x2F;Reader：输入流 + 字节流&#x2F;字符流</p><p>OutputStream&#x2F;Writer：输出流 + 字节流&#x2F;字符流</p></blockquote><h3 id="2-有了字节流为什么还要有字符流"><a href="#2-有了字节流为什么还要有字符流" class="headerlink" title="2. 有了字节流为什么还要有字符流"></a>2. 有了字节流为什么还要有字符流</h3><p>问题本质：</p><blockquote><p>不管是文件读写还是网络发送接收，信息的最小存储单位都是字节，那为什么I&#x2F;O流操作要分为字节流操作和字符流操作？</p></blockquote><p>回答：</p><blockquote><p>字符流是由Java虚拟机将字节转换得到的，问题就出在这个过程非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以，I&#x2F;O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果有音频、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p></blockquote><h3 id="3-BIO，BIO，AIO有什么区别"><a href="#3-BIO，BIO，AIO有什么区别" class="headerlink" title="3. BIO，BIO，AIO有什么区别"></a>3. BIO，BIO，AIO有什么区别</h3><ul><li><p>BIO（Blocking I&#x2F;O）：同步阻塞IO</p><blockquote><p>数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每个连接专注于自己的I&#x2F;O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的来连接或请求。但是，当面对十万甚至是百万级连接的时候，传统的BIO模型无能为力。因此需要一种更高效的I&#x2F;O处理模型来应对更高的并发量。</p></blockquote></li><li><p>NIO（Non-blocking&#x2F;New I&#x2F;O）：同步非阻塞IO</p><blockquote><p>在Java1.4引入NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持<strong>面向缓冲</strong>的，<strong>基于通道</strong>的I&#x2F;O操作方法。NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。</p></blockquote></li><li><p>AIO（Asynchronous I&#x2F;O）：异步非阻塞IO</p><blockquote><p>在Java7中引入了NIO的改进版NIO2，它是异步非阻塞的IO模型。异步IO是<strong>基于事件和回调机制实现</strong>的也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成、操作系统会通知相应的线程进行后续的操作。AIO是异步IO的许哦谢，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。</p><p><strong>AIO应用还不广泛。</strong></p></blockquote></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题 - 蜗牛大师 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://juejin.cn/post/6844903917835419661">聊一聊-JAVA 泛型中的通配符 T，E，K，V，？ - 掘金 (juejin.cn)</a></p></li><li><p><a href="https://developer.aliyun.com/article/799160#:~:text=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87,%E6%93%8D%E4%BD%9C%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E3%80%82">怎么理解面向对象和面向过程到底的本质区别？ .-阿里云开发者社区 (aliyun.com)</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL进阶</title>
    <link href="/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>在安装MySQL时已经指定了默认编码为UTF8，所以在创建数据库、创建表的时候都无需指定编码。</p><ul><li><p>几个关于编码的参数：</p><ul><li><p>character_set_client</p><blockquote><p>服务器用来解读用户发来数据所使用的编码</p></blockquote></li><li><p>character_set_results</p><blockquote><p>服务器发送给客户数据的编码</p></blockquote></li><li><p>character_set_connection</p></li><li><p>character_set_database</p></li><li><p>character_set_server</p></li><li><p>character_set_system</p></li></ul></li><li><p>查看数据库当前编码设置：<code>SHOW VARIABLES LIKE &#39;char%&#39;</code>;<img src="/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/image-20220903103244158.png" alt="image-20220903103244158"></p></li><li><p>编码的修改：</p><ol><li><p>命令行临时修改</p><blockquote><p><code>set character_set_client=gbk;</code></p></blockquote></li><li><p>配置文件永久修改</p><blockquote><p>可以在my.ini配置文件中修改</p><p>default-character-set&#x3D;gbk</p><p>该项目会同时修改三个变量的编码：client、results、connection</p></blockquote></li></ol><p>注意：修改后要重启MySQL服务</p><ul><li><code>net stop mysql</code></li><li><code>net start mysql</code></li></ul></li></ul><h1 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h1><blockquote><p>备份：数据库 –&gt; SQL脚本</p><p>恢复：SQL脚本 –&gt; 数据库</p></blockquote><ol><li><p>数据库导出SQL脚本（备份数据库内容）</p><ul><li>命令：<code>mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本文件路径</code></li><li>注意:<ul><li>不要打分号，不要登录mysql，直接在cmd下运行</li><li>生成的脚本文件中不包含create database语句</li></ul></li></ul></li><li><p>从SQL脚本恢复至数据库</p><blockquote><p>方法一、不用登录数据库</p><p>命令：<code>mysql -u用户名 -p密码 数据库名&lt;用于恢复的脚本文件路径</code></p></blockquote><blockquote><p>方法二、登录数据库，并在选择对应数据库</p><p>命令：<code>source 用于恢复的脚本文件路径</code></p></blockquote></li></ol><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>  约束是添加到列上的，用来约束列</p><h2 id="一、主键约束：PRIMARY-KEY"><a href="#一、主键约束：PRIMARY-KEY" class="headerlink" title="一、主键约束：PRIMARY KEY"></a>一、主键约束：PRIMARY KEY</h2><ul><li>主键特点：<strong>非空、唯一、被引用</strong></li></ul><blockquote><p>当表的某一列被指定为主键后，该列就不能为空，不能有重复着值出现。</p></blockquote><ul><li><p>主键的创建与删除</p><ul><li><p>创建表时指定主键：(指定sid为主键列，即为sid列添加主键约束)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE stu(<br>sidCHAR(6) PRIMARY KEY,<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE stu(<br>sidCHAR(6),<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>PRIMARY KEY(sid)<br>);<br></code></pre></td></tr></table></figure></li><li><p>修改表时指定主键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE stu ADD PRIMARY KEY(sid);<br></code></pre></td></tr></table></figure></li><li><p>删除主键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE stu DROP PRIMARY KEY;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>主键自增长</p><ul><li><p>设置主键自增长</p><ol><li><p>在创建表时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE stu(<br>sidINT PRIMARY KEY AUTO_INCREMENT,<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>);<br></code></pre></td></tr></table></figure></li><li><p>在修改表时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE stu MODIFY sid INT AUTO_INCREMENT;<br></code></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h2 id="二、非空约束：NOT-NULL"><a href="#二、非空约束：NOT-NULL" class="headerlink" title="二、非空约束：NOT NULL"></a>二、非空约束：NOT NULL</h2><h2 id="三、唯一约束：UNIQUE"><a href="#三、唯一约束：UNIQUE" class="headerlink" title="三、唯一约束：UNIQUE"></a>三、唯一约束：UNIQUE</h2><h2 id="四、外键约束：CONSTRAINT-FOREIGN-KEY-REFERENCES"><a href="#四、外键约束：CONSTRAINT-FOREIGN-KEY-REFERENCES" class="headerlink" title="四、外键约束：CONSTRAINT | FOREIGN KEY | REFERENCES"></a>四、外键约束：CONSTRAINT | FOREIGN KEY | REFERENCES</h2><ul><li><p>添加外键约束：</p><ul><li><p>创建时添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE 表名(<br>    主键列名 INT PRIMARY KEY AUTO_INCREMENT,<br>    列名1 VARCHAR(50),<br>    外键列名 INT,<br>    CONSTRAINT 外键约束名 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表中的关联列)<br>);<br></code></pre></td></tr></table></figure></li><li><p>更新时添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE 表名 ADD CONSTRAINT 外键约束名 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表中的关联列);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>外键特点：</p><ul><li>可为NULL</li><li>可重复</li><li>必须在关联表中关联列中存在。</li></ul></li></ul><h1 id="模型与关系"><a href="#模型与关系" class="headerlink" title="模型与关系"></a>模型与关系</h1><h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><ul><li><p>对象模型：</p><ul><li>在java中是domain</li><li>可以双向关联，而且引用的是对象，而不是一个主键</li></ul></li><li><p>关系模型：</p><ul><li>在数据库中是表</li><li>只能多方引用一方，而且引用的只是主键，而不是一整行记录</li></ul></li></ul><p>当我们要完成一个软件系统时，需要把系统中的实体抽取出来，形成概念模型。例如部门、员工都是系统中的实体。</p><ul><li><p><strong>实体之间的关系：</strong></p><ul><li><p>一对多（最常见）</p><blockquote><p>部门与员工，一个部门中有多个员工，而每个员工只属于一个部门。其中员工是多方，部门是一方。</p></blockquote></li><li><p>一对一</p><blockquote><p>夫妻，老公、老婆之间就是一对一的关系。</p></blockquote></li><li><p>多对多</p><blockquote><p>老师与学生，一个老师对应对个学生，一个学生也有多个老师</p></blockquote></li></ul></li></ul><p>概念模型中的实体最终会成为Java中的类、数据库中的表。类使用成员变量来完成关系，一般都是<strong>双向关联</strong>。</p><ul><li><p>一对多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> Department department;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span> &#123;<br><span class="hljs-keyword">private</span> List&lt;Employee&gt; employee;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>一对一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br>    <span class="hljs-keyword">private</span> Wife wife;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wife</span> &#123;<br>    <span class="hljs-keyword">private</span> Husband husband;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多对多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Teacher&gt; teacher;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Student&gt; student;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul><li><p>一对一关系：</p><blockquote><p>从表的主键作为外键关联主表的主键</p></blockquote><p>husband不做处理，将wife中的主键作为外键关联到husband的主键。从而实现一对一的关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE husband(<br>hid INT PRIMARY AUTO_INCREMENT,<br>    hname VARCHAR(50)<br>);<br><br>CREATE TABLE wife(<br>wid INT PRIMARY KEY AUTO_INCREMENT,<br>    wname VARCHAR(50),<br>    CONSTRAINT fk_wife_husband FOREIGN KEY(wid) REFERENCES husband(hid);<br>);<br></code></pre></td></tr></table></figure></li><li><p>多对多关系</p><blockquote><p>使用中间表 (关联表)</p></blockquote><p>师生关系，创建一个学生表，一个老师表，在创建一个师生关系表，其中一个键为学生，一个键为老师，分别使用外键关联到学生表，老师表。相当与将师生关系抽离出来单独使用一张表来存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE student(<br>sid INT PRIMARY KEY,<br>    ...<br>);<br>CREATE TABLE teacher(<br>tid INT PRIMARY KEY,<br>    ...<br>);<br><br>CREATE TABLE stu_tea(<br>sid INT,<br>    tid INT,<br>    ADD CONSTRAINT fk_stu_tea_sid FOREIGN KEY(sid) REFERENCES student(sid),<br>    ADD CONSTRAINT fk_stu_tea_tid FOREIGN KEY(tid) REFERENCES teacher(tid)<br>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="一、合并结果集"><a href="#一、合并结果集" class="headerlink" title="一、合并结果集"></a>一、合并结果集</h2><blockquote><ul><li>要求被合并的表，列的类型和列数相同（即两张表结构完全相同）</li><li>合并结果集语法<ul><li>UNION，在合并的时候去除重复行</li><li>UNION，不去除重复行</li></ul></li></ul></blockquote><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM a<br>UNION ALL<br>SELECT * FROM b;<br></code></pre></td></tr></table></figure><h2 id="二、连接查询"><a href="#二、连接查询" class="headerlink" title="二、连接查询"></a>二、连接查询</h2><ul><li><p><strong>内连接</strong></p><ul><li><p>方言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * <br>FROM 表1 别名一，表2 别名2 <br>WHERE 别名1.xx=别名2.xx;<br></code></pre></td></tr></table></figure><blockquote><ul><li>若没有WHERE子句，那么查询出来的结果个数成为笛卡尔积，即表一中的每一项分别与表二中的每一项匹配生成表，即最终共的结果数目为：表一数据个数*表二数据个数</li><li>WHERE子句的作用就是去笛卡尔积，一般使用表一中对应的连接的内键和外键来去笛卡尔积</li></ul></blockquote></li><li><p>标准：<strong>INNER JOIN | ON</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * <br>FROM 表1 别名一 INNER JOIN 表2 别名2 <br>ON 别名1.xx=别名2.xx;<br></code></pre></td></tr></table></figure></li><li><p>自然：<strong>NATRURAL JOIN</strong></p><blockquote><p>自然连接会在两张表中寻找名字相同的列自动进行匹配，相当于自动完成<code>ON 别名1.xx=别名2.xx</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * <br>FROM 表1 别名一 NATURAL JOIN 表2 别名2;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>外连接</strong></p><blockquote><p>外连接有一主一次，主表中的所有记录不论是否满足条件，都会打印出来，主表中没有对应的次表项，那么对应的次表条目使用NULL填充</p></blockquote><ul><li>左外连接：<strong>LEFT OUTER JOIN</strong></li><li>右外连接：<strong>RIGHT OUTER JOIN</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT e.ename, e.sal IFNULL(d.dname, &#x27;无部门&#x27;) AS dname<br>FROM emp e LEFT OUTER JOIN dept d<br>ON e.deptno=d.depton;<br></code></pre></td></tr></table></figure></li></ul><h2 id="三、子查询"><a href="#三、子查询" class="headerlink" title="三、子查询"></a>三、子查询</h2><ul><li><p>不同子查询结果的应用：</p><ul><li><p>多行多列</p><blockquote><p>FROM后，子查询的结果作为用于查询的表</p></blockquote></li><li><p>单行单列</p><blockquote><p>WHERE后，子查询的结果作为过滤条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT *<br>FROM emp<br>WHERE sal=(SELECT MAX(SAL) FROM emp);<br></code></pre></td></tr></table></figure><p>查询本公司工资最高的员工的详细信息，条件为工资最高，最高工资要使用MAX()查询</p></blockquote></li><li><p>多行单列：<strong>IN | ALL | ANY</strong></p><blockquote><p>WHERE后，与IN\ALL\ANY一起，作为搜索条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">    &gt;SELECT *<br>FROM emp<br>WHERE sal &gt; ALL (SELECT sal FROM emp WHERE deptno=30);<br></code></pre></td></tr></table></figure><p>搜索工资大于30部门所有员工工资的员工</p></blockquote></li><li><p>单行多列</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT *<br>FROM emp<br>WHERE (job, depno) IN (SELECT job, depno FROM emp WHERE ename=&#x27;殷天正&#x27;)；<br></code></pre></td></tr></table></figure><p>查询工资和部门与殷天正完全相同的员工</p></blockquote></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>MySQL使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL入门笔记</title>
    <link href="/2022/09/02/MySQL%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/02/MySQL%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><ol><li><p>什么是 SQL</p><blockquote><p>结构化查询语言（Structured Query Language）</p></blockquote></li><li><p>SQL 的作用</p><blockquote><p>客户端使用SQL来操作服务器</p></blockquote></li><li><p>语法规范</p><blockquote><ul><li>SQL语句可以在单行或多行书写, 以<strong>分号结尾</strong></li><li>可以使用空格和缩进来增强语句的<strong>可读性</strong></li><li>MySQL不区分大小写, 但是<strong>建议使用大写</strong></li></ul></blockquote></li><li><p>SQL语句分类</p><blockquote><ul><li><p>DDL(Data Definition Language): 数据定义语言</p><blockquote><p>创建、删除、修改：库、表结构</p></blockquote></li><li><p>DML(Data Manipulation Language): 数据操作语言</p><blockquote><p>增、删、改：表记录</p></blockquote></li><li><p>DQL(Data Query Language):  数据查询语言</p><blockquote><p>用来查询记录（数据）</p></blockquote></li><li><p>DCL(Data Control Language): 数据控制语言</p><blockquote><p>用来定义访问权限和安全级别（用户创建，以及用户的权限管理）</p></blockquote></li></ul></blockquote></li></ol><h1 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h1><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><ul><li>查看所有数据库：<code>SHOW DATABASES</code></li><li>切换（选择要操作的）数据库：<code>USE 数据库名</code></li><li>创建数据库：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名</code> </li><li>删除数据库：<code>DROP DATABASE [IF EXISTS] 数据库名</code></li><li>修改数据库编码：<code>ALTER DATABASE 数据库名CHARACTER SET 编码名</code></li></ul><h2 id="数据类型（列数据类型）"><a href="#数据类型（列数据类型）" class="headerlink" title="数据类型（列数据类型）"></a>数据类型（列数据类型）</h2><ul><li><p>int：整型</p></li><li><p>double：浮点型</p><blockquote><p>double(5, 2)表示最多5位，其中必须有两位小数</p></blockquote></li><li><p>decimal：浮点型</p><blockquote><p>十进制浮点类型，不会出现浮点数精度丢失问题，在跟钱相关的方面使用该类</p></blockquote></li><li><p>char：固定长度字符串</p><blockquote><p>char(255)，数据长度不足，则会补足到指定长度</p></blockquote></li><li><p>varchar：可变长字符串类型</p><blockquote><ul><li><p>varchar(65535)，最大指定长度为65535，当数据长度不足指定长度的时候，不用补足到指定长度。</p></li><li><p>需要使用额外的一个字节来记录数据长度</p></li></ul></blockquote></li><li><p>text：字符串类型</p><blockquote><p>MySQL的方言，在标准SQL中为clob</p></blockquote><ul><li>tinytext：256B</li><li>text：64K</li><li>mediumtext：16M</li><li>longtext：4G</li></ul></li><li><p>blob：字节类型</p><ul><li>varblob</li><li>tinyblob</li><li>blob</li><li>mediumblob</li><li>longblob</li></ul></li><li><p>时间相关</p><ul><li>date：日期类型，格式：yyyy- MM-dd;</li><li>time：时间类型， 格式：hh:mm:ss；</li><li>timestamp：时间戳类型：</li></ul></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><p><strong>注意：所有对表的操作都要在选定数据库之后</strong></p><ol><li><p>创建表</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE [IF NOT EXISTS] 表名(<br>列名 列类型,<br>    ...<br>    列名 列类型,<br>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>查看表</p><blockquote><ul><li><p>查看当前数据库中左右表名称：<code>SHOW TABLES;</code></p></li><li><p>查看指定表的创建语句：<code>SHOW CREATE TABLE 表名;</code>(了解)</p></li><li><p>查看表结构： <code>DESC 表名;</code></p></li></ul></blockquote></li><li><p>删除表：<code>DROP TABLE 表名;</code></p></li><li><p>修改表：<strong>ALTER</strong></p><ul><li><p>添加列：<strong>ADD</strong></p><blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD(<br>列名 列类型,<br>    ...<br>    列名 列类型,<br>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>删除列：<strong>DROP</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 DROP 列名;<br><br>  - 修改列类型：**MODIFY**<br><br>```mysql<br>ALTER TABLE 表名 MODIFY 列名 列类型;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>修改列名：<strong>CHANGE</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 CHANGE  原列名 新列名 列类型；<br></code></pre></td></tr></table></figure></blockquote></li><li><p>修改表名称：<strong>RENAME</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 原表名 RENAME TO 新表名<br></code></pre></td></tr></table></figure></blockquote></li></ul></li></ol><h1 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h1><blockquote><p>先了解一个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SLEECT * FROM 表名<br></code></pre></td></tr></table></figure><ul><li>显示所有数据库：<code>SHOW DATABASES;</code></li><li>选择数据库：<code>USE 数据库名;</code></li><li>显示数据库中所有表：<code>SHOW TABLES;</code></li></ul></blockquote><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><ol><li>给出插入列</li></ol><blockquote><ul><li>列名与列值对应，不一定要按照表中列顺序，若插入的是部分列，那么未填写的列为null值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 表名(<br>列名1,列名2，列名3<br>)<br>VALUES(<br> 列对应值1，列对应值2，对应列值3<br>);<br></code></pre></td></tr></table></figure></blockquote><ol start="2"><li>不给出插入列</li></ol><blockquote><ul><li>默认插入所有列，必须根据表中列的排序给出所有列值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INT 表名 VALUES(<br>列值1，列值2，列值3<br>);<br></code></pre></td></tr></table></figure></blockquote><p><strong>注意：</strong>MySQL中的字符串<strong>必须使用单引号</strong></p><h2 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h2><p>基本语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UPDATE</span> 表名 SET 列名<span class="hljs-number">1</span>=列值<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span>=列值<span class="hljs-number">2</span><span class="hljs-meta"> [WHERE 条件]</span><br></code></pre></td></tr></table></figure><p>注意：若没有WHERE条件，那么这个表中的所有行都会被修改。WHERE 条件用于选择需要修改的行。</p><p>条件：</p><blockquote><p>运算符</p><ul><li>**&#x3D;**、!&#x3D;(&lt;&gt;等价)&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;</li><li>区间：BETWEEN…AND…</li><li>枚举：IN(…)</li><li>IS NULL</li><li>连接多个条件：NOT、OR、AND</li></ul></blockquote><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>基本语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM 表名 [WHERE 条件]<br></code></pre></td></tr></table></figure><p>注意：不加WHERE整个表中数据都会被删除（表还在）</p><h1 id="DCL（数据控制语言）"><a href="#DCL（数据控制语言）" class="headerlink" title="DCL（数据控制语言）"></a>DCL（数据控制语言）</h1><p>对于DCL的理解：</p><blockquote><ul><li>一个项目创建一个用户，一个项目对应的数据库只有一个</li><li>这个用户只拥有该数据库的权限，无法操作其他数据库</li></ul></blockquote><h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1. 创建用户"></a>1. 创建用户</h2><p>用户只能在指定IP登录</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 用户名@IP地址 IDENTIFIED BY &#x27;密码&#x27;;<br></code></pre></td></tr></table></figure></blockquote><p>用户可以在任意IP登录</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 用户名@IP&#x27;*&#x27; IDENTIFIED BY &#x27;密码&#x27;;<br></code></pre></td></tr></table></figure></blockquote><h2 id="2-给用户授权"><a href="#2-给用户授权" class="headerlink" title="2. 给用户授权"></a>2. 给用户授权</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">GRANT 权限1,...,权限n ON 数据库.* TO 用户名@IP地址;<br></code></pre></td></tr></table></figure><ul><li><p>将<strong>指定数据库</strong>的<strong>指定权限</strong>赋予<strong>指定用户</strong></p></li><li><p>要素：权限、数据库、用户</p><blockquote><p>权限：</p><ul><li><p>CREATE、ALTER、DROP、INSERT、UPDATE、DELETE、SELECT</p></li><li><p>ALL表示所有权限</p></li></ul></blockquote></li></ul><h2 id="3-撤销授权"><a href="#3-撤销授权" class="headerlink" title="3. 撤销授权"></a>3. 撤销授权</h2><p>操作基本同授权一样，使用REVOKE替换GRANT即可</p><h2 id="4-查看权限"><a href="#4-查看权限" class="headerlink" title="4. 查看权限"></a>4. 查看权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GRANTS FOR 用户名@IP地址;<br></code></pre></td></tr></table></figure><h2 id="5-删除用户"><a href="#5-删除用户" class="headerlink" title="5. 删除用户"></a>5. 删除用户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP USER 用户名@IP地址<br></code></pre></td></tr></table></figure><h1 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h1><h2 id="一、基础查询"><a href="#一、基础查询" class="headerlink" title="一、基础查询"></a>一、基础查询</h2><ul><li><strong>查询所有列（整张表）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名;<br></code></pre></td></tr></table></figure><h3 id="1-列控制"><a href="#1-列控制" class="headerlink" title="1. 列控制"></a>1. 列控制</h3><ol><li>查询指定列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT 列名1,列名2 FROM 表名;<br></code></pre></td></tr></table></figure><ol start="2"><li>完全重复的记录只有一次</li></ol><blockquote><p>当查询结果中多行记录一摸一样时，只显示一行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT DISTINCT 列名 FROM 表名;<br></code></pre></td></tr></table></figure><ol start="3"><li>列运算</li></ol><ul><li><p>数量类型的列可以做加减乘除运算</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名*1.5 FROM 表名;<br>SELECT 列名1+列名2 FROM 表名;<br></code></pre></td></tr></table></figure></li><li><p>字符串类型的列可以做连续运算</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT CONCAT(&#x27;S&#x27;, 列名) FROM 表名;<br></code></pre></td></tr></table></figure></li></ul><blockquote><ul><li>转换NULL值</li></ul>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT IFNULL (列名1,0)+1000 FROM 表名;<br></code></pre></td></tr></table></figure><blockquote><p>IFNULL(列名1，0) 表示，如果列1中的值为NULL，则当为0计算</p></blockquote><ul><li>给列起别名</li></ul><blockquote><p>在使用列运算后自动生成的列名称不直观，可以给列名起个别名(<strong>AS可省略</strong>)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT IFNULL (列名1,0)+1000 AS 奖学金 FROM 表名;<br></code></pre></td></tr></table></figure></blockquote><h3 id="2-行控制"><a href="#2-行控制" class="headerlink" title="2. 行控制"></a>2. 行控制</h3><ol><li><p>条件查询: <strong>WHERE</strong></p><blockquote><p>同前面的UPDATE和DELETE语句一样，使用WHERE子句来控制记录</p></blockquote></li><li><p>模糊查询: <strong>LIKE</strong></p><blockquote><p>用来对<strong>字符串列</strong>进行模糊查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WHERE 列名 LIKE &#x27;李_&#x27;;<br></code></pre></td></tr></table></figure><ul><li>_下划线，用来匹配一个字符</li><li>%百分号，用来匹配0-n个字符</li></ul></blockquote></li></ol><h3 id="二、排序：ORDER-BY"><a href="#二、排序：ORDER-BY" class="headerlink" title="二、排序：ORDER BY"></a>二、排序：ORDER BY</h3><ol><li><p>默认升序: <strong>ASC</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名；<br></code></pre></td></tr></table></figure></li><li><p>降序排序: <strong>DESC</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名 DESC;<br></code></pre></td></tr></table></figure></li><li><p>多条件排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名1 DESC, 列名2 ASC;<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、聚合函数"><a href="#三、聚合函数" class="headerlink" title="三、聚合函数"></a>三、聚合函数</h2><ol><li><p>查询有效行数：<strong>COUNT()</strong></p><blockquote><p>括号中可以是列名、*、数字，其中*和数字等效</p></blockquote></li><li><p>计算</p><blockquote><p> 计算中的括号中只能填写数字列</p></blockquote><ul><li>总和：<strong>SUM()</strong></li><li>最大值：<strong>MAX()</strong></li><li>平均值：<strong>AVG()</strong></li></ul></li><li><p>综合计算</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT COUNT(*),SUM(列名1)，MAX(列名2) FROM 表名;<br></code></pre></td></tr></table></figure></li></ol><h2 id="四、分组查询：GROUP-BY-HAVING"><a href="#四、分组查询：GROUP-BY-HAVING" class="headerlink" title="四、分组查询：GROUP BY|HAVING"></a>四、分组查询：GROUP BY|HAVING</h2><blockquote><ul><li>分组</li></ul><blockquote><p>将一列中值相同的行分为一组</p></blockquote><ul><li>查询</li></ul><blockquote><p>分组查询不能使用个人信息查询，都是使用聚合信息进行查询</p></blockquote></blockquote><p>分组查询过滤</p><ul><li><p>分组前过滤条件（对整张表进行过滤）</p><blockquote><p>WHERE</p><p>在GROUP BY之前</p></blockquote></li><li><p>分组后过滤条件（对分组查询的结果过滤）</p><blockquote><p>HAVING</p><p>在GROUP BY之后</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名1(展示列), 聚合函数 FROM 表名 WHERE 分组前条件 GROUP BY 列名2(分组列) HAVING 分组后条件 ORDER BY 列名3(排序列)<br></code></pre></td></tr></table></figure><blockquote><p>同一SQL语句中，关键字使用顺序(执行顺序也是如此)：</p><ol><li>SELECT</li><li>FROM</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>ORDER BY</li></ol></blockquote><h2 id="五、LIMIT方言"><a href="#五、LIMIT方言" class="headerlink" title="五、LIMIT方言"></a>五、LIMIT方言</h2><p>LIMIT作用：</p><blockquote><ul><li>用来限定查询结果的起始行，以及总行数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM 表名 LIMIT a,b;<br></code></pre></td></tr></table></figure><p>从第a行开始查b行数据</p></blockquote><p>LIMIT应用：</p><blockquote><ul><li>用于分页查询</li></ul><p>若每页十行数据，那么如果要查第三页，语句如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 LIMIT 20,10;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>MySQL使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown入门</title>
    <link href="/2022/09/01/MarkDownBase/"/>
    <url>/2022/09/01/MarkDownBase/</url>
    
    <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. <strong>标题</strong></h3><blockquote><p># H1 </p><p>## H2</p><p>### H3</p><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3></blockquote><h3 id="2-粗体"><a href="#2-粗体" class="headerlink" title="2. 粗体"></a>2. <strong>粗体</strong></h3><blockquote><p>*<em>bold text</em>*</p><p><strong>bold text</strong></p></blockquote><h3 id="3-斜体"><a href="#3-斜体" class="headerlink" title="3. 斜体"></a>3. <strong>斜体</strong></h3><blockquote><p>*italicized text*</p><p><em>italicized text</em></p></blockquote><h3 id="4-引用块"><a href="#4-引用块" class="headerlink" title="4. 引用块"></a>4. <strong>引用块</strong></h3><blockquote><p>&gt; blockquote</p><blockquote><p>blockquote</p></blockquote></blockquote><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. <strong>有序列表</strong></h3><blockquote><ol><li>First item</li><li>Second item</li><li>Third item</li></ol></blockquote><h3 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6. 无序列表"></a>6. <strong>无序列表</strong></h3><blockquote><p>- First item</p><p>- Second item</p><p>- Third item</p><ul><li>First item</li><li>Second item</li><li>Third item</li></ul></blockquote><h3 id="7-代码"><a href="#7-代码" class="headerlink" title="7. 代码"></a>7. <strong>代码</strong></h3><blockquote><p>`code&#96;</p><p><code>code</code></p></blockquote><h3 id="8-分隔线"><a href="#8-分隔线" class="headerlink" title="8. 分隔线"></a>8. <strong>分隔线</strong></h3><blockquote><p>-–</p><hr></blockquote><h3 id="9-链接"><a href="#9-链接" class="headerlink" title="9. 链接"></a>9. <strong>链接</strong></h3><blockquote><p>[title](<a href="http://www.example.com/">http://www.example.com</a>)</p><p><a href="http://www.example.com/">title</a></p></blockquote><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10. 图片"></a>10. <strong>图片</strong></h3><blockquote><p>![alt text](<a href="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot;picture">https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot;picture</a> title”)</p><p><img src="/2022/09/01/MarkDownBase/googlelogo_color_272x92dp.png" alt="alt text" title="picture title"></p></blockquote><h2 id="二、扩展语法"><a href="#二、扩展语法" class="headerlink" title="二、扩展语法"></a>二、扩展语法</h2><h3 id="1-表格"><a href="#1-表格" class="headerlink" title="1. 表格"></a>1. <strong>表格</strong></h3><blockquote><p>| Syntax    | Description |<br>| ——— | ———– |<br>| Header    | Title       |<br>| Paragraph | Text        |</p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></blockquote><h3 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2. 代码块"></a>2. <strong>代码块</strong></h3><blockquote><p>`&#96;&#96;json<br>{<br>“firstname”: “John”,<br>“lastname”: “Smith”,<br>“age”: 25<br>}<br>`&#96;&#96;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;firstname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;lastname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="3-脚注"><a href="#3-脚注" class="headerlink" title="3. 脚注"></a>3. <strong>脚注</strong></h3><blockquote><p>Here’ s a sentence with a footnote.[^1]</p><p>[^1]:This is the footnote.</p></blockquote><p>Here’ s a sentence with a footnote.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="This is the footnote.">[1]</span></a></sup></p><h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4. 删除线"></a>4. <strong>删除线</strong></h3><blockquote><p>~~The world is flat.~~</p><p><del>The world is flat.</del></p></blockquote><h3 id="5-任务列表"><a href="#5-任务列表" class="headerlink" title="5. 任务列表"></a>5. <strong>任务列表</strong></h3><blockquote><p>- [x] Write the press release</p><p>- [ ] Update the website</p><p>- [ ] Contact the media</p><ul><li><input checked disabled type="checkbox"> Write the press release</li><li><input disabled type="checkbox"> Update the website</li><li><input disabled type="checkbox"> Contact the media</li></ul></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>This is the footnote.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="/2022/09/01/HexoBlogBuild/"/>
    <url>/2022/09/01/HexoBlogBuild/</url>
    
    <content type="html"><![CDATA[<ol><li><h1 id="Hexo博客-搭建-美化-使用"><a href="#Hexo博客-搭建-美化-使用" class="headerlink" title="Hexo博客 搭建+美化+使用"></a>Hexo博客 搭建+美化+使用</h1><h2 id="一、搭建"><a href="#一、搭建" class="headerlink" title="一、搭建"></a>一、搭建</h2><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h3><h4 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a>1.1 注意事项</h4><ul><li>命令可以使用Windows的<strong>cmd</strong>和<strong>git bash</strong>来完成，cmd可能会有一些问题，建议全部使用git bash执行</li><li>hexo版本差异大，网上一些配置信息基于2.x，注意区别</li><li>hexo中有两种_config.yml文件，一个hexo根目录下的,一个是各个theme目录下的</li></ul><h4 id="1-2-安装所需软件"><a href="#1-2-安装所需软件" class="headerlink" title="1.2 安装所需软件"></a>1.2 安装所需软件</h4><ul><li>node.js<ul><li>官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装后验证：<code>node -v</code></li></ul></li><li>git<ul><li>官网：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li><li>安装后验证：<code>git -v</code></li></ul></li><li>cnpm<ul><li>安装命令： <code>npm install -g cnpm –registry==https://registry.npm.taobao.org</code></li><li>安装后验证：<code>cnpm -v</code></li></ul></li><li>hexo<ul><li>安装命令：<code>cnpm install -g hexo-cli</code></li><li>安装后验证：<code>hexo -v</code></li></ul></li></ul><h3 id="2-配置GitHub"><a href="#2-配置GitHub" class="headerlink" title="2. 配置GitHub"></a>2. 配置GitHub</h3><h4 id="2-1-在GitHub上创建仓库"><a href="#2-1-在GitHub上创建仓库" class="headerlink" title="2.1 在GitHub上创建仓库"></a>2.1 在GitHub上创建仓库</h4><ol><li>创建一个以<strong>你的用户名.github.io</strong>的仓库</li><li>注意：我的用户名为xiang-4422，所以仓库为xiang-4422.githun.io，网站的访问地址就是<a href="http://xiang-4422.github.io/">http://xiang-4422.github.io</a>。由此可见，每个github账户只能创建一个这样可以直接使用域名访问的仓库。</li></ol><h4 id="2-2-绑定域名（可选）"><a href="#2-2-绑定域名（可选）" class="headerlink" title="2.2 绑定域名（可选）"></a>2.2 绑定域名（可选）</h4><ol><li>注册域名<ul><li>godaddy</li><li>阿里云</li></ul></li><li>绑定域名<ul><li>带www</li><li>不带www</li><li>无论域名是否带www，在访问的时候使用两种方式都能跳转</li></ul></li><li>域名配置<ul><li>方式一、CNAME<ul><li>CNAME填写域名，即<strong>用户名.github.io</strong></li></ul></li><li>方式二、A记录<ul><li>A记录填写IP</li><li>不带www的方式只能采用A记录，所以需要先ping一下网站的IP，然后到域名DNS设置页中，将A记录指向ping出来的IP</li></ul></li></ul></li></ol><h3 id="3-配置SSH免密登录"><a href="#3-配置SSH免密登录" class="headerlink" title="3. 配置SSH免密登录"></a>3. 配置SSH免密登录</h3><h4 id="3-1-获取本地的SSH公钥"><a href="#3-1-获取本地的SSH公钥" class="headerlink" title="3.1 获取本地的SSH公钥"></a>3.1 获取本地的SSH公钥</h4><ol><li>打开电脑文件夹，找到 C:\Users\用户名\.ssh 文件夹并删除</li><li>在 C:\Users\用户名 目录下右键打开Git Bash Here，输入命令<code>ssh-keygen -t rsa -C github邮件地址</code>生成.ssh密钥，输入后连敲三次回车</li><li>生成.ssh文件夹后，打开该文件夹，打开id_rsa.pub文件，复制其中内容</li></ol><h4 id="3-2-在GitHub中添加公钥"><a href="#3-2-在GitHub中添加公钥" class="headerlink" title="3.2 在GitHub中添加公钥"></a>3.2 在GitHub中添加公钥</h4><ol start="4"><li>GitHub主页 -&gt; SSH and GPG keys -&gt; New SSH key，将复制的内容粘贴进去，设置一个title，并保存</li></ol><h4 id="3-3-检查是否配置成功"><a href="#3-3-检查是否配置成功" class="headerlink" title="3.3 检查是否配置成功"></a>3.3 检查是否配置成功</h4><ul><li><p>命令：<code>$ ssh -T git@github.com</code></p></li><li><p>成功后的提示信息：Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.即配置成功</p></li></ul><h4 id="3-4-配置Git信息"><a href="#3-4-配置Git信息" class="headerlink" title="3.4 配置Git信息"></a>3.4 配置Git信息</h4><ul><li>命令：<code>$ git config –global user.name “GitHub用户名”</code></li><li>命令：<code>$ git config –global user.email “GitHub注册邮箱&quot;</code></li></ul><h3 id="4-使用hexo搭建博客"><a href="#4-使用hexo搭建博客" class="headerlink" title="4. 使用hexo搭建博客"></a>4. 使用hexo搭建博客</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><ol><li>在电脑中创建一个文件夹用于存放hexo的代码，作为hexo的根目录</li><li>在该文件夹中右键打开Git Bash Here，输入一下命令<ul><li><code>hexo init</code>: 初始化</li><li><code>hexo g</code>: 在public文件夹中生成相关html文件</li><li><code>hexo s</code>: 启动服务</li></ul></li><li>hexo g开启了本地预览服务，访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看。<ul><li>端口冲突问题解决：<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">https://www.runoob.com/w3cnote/windows-finds-port-usage.html</a></li></ul></li></ol><h4 id="4-2部署到GitHub个人主页"><a href="#4-2部署到GitHub个人主页" class="headerlink" title="4.2部署到GitHub个人主页"></a>4.2部署到GitHub个人主页</h4><ol><li>在hexo根目录下安装hexo-deployer-git插件<ul><li>安装命令：<code>npm install hexo-deployer-git -save</code></li></ul></li><li>编辑hexo根目录下的_config.yml文件，在文件末尾添加如下内容</li></ol><p><img src="/2022/09/01/HexoBlogBuild/8.png" alt="img"></p><ul><li>注意：其中repo中的内容为GitHub个人主页链接地址，如图：</li></ul><p><img src="/2022/09/01/HexoBlogBuild/9.png" alt="img"></p><ol start="3"><li>在根目录下使用命令：<code>hexo d</code>将本地blog推动到GitHub仓库<ul><li>可能需要username &amp; pwd</li><li>推送成功后，即可在浏览器中通过域名访问 <a href="https://xiang-4422.github.io/">https://xiang-4422.github.io/</a></li></ul></li></ol><h2 id="二、美化"><a href="#二、美化" class="headerlink" title="二、美化"></a>二、美化</h2><h3 id="1-更换主题"><a href="#1-更换主题" class="headerlink" title="1. 更换主题"></a>1. 更换主题</h3><ol><li><p>主题下载：</p><ul><li><p><a href="https://hexo.io/themes/">hexo官网</a>上有很多主题，我使用的是 fluid：<a href="https://github.com/fluid-dev/hexo-theme-fluid">GitHub仓库地址</a> | <a href="https://github.com/fluid-dev/hexo-theme-fluid">用户手册</a></p></li><li><p>到hexo根目录下使用Git Bash Here，输入命令<code>$ git clone 主题http链接 themes/主题名称</code>下载主题</p><p><img src="/2022/09/01/HexoBlogBuild/10.png" alt="img"></p></li><li><p>根目录中theme文件下就是博客的主题，可以下载多个，具体选择哪一个可以在hexo配置文件中配置</p></li></ul></li></ol><h3 id="2-使用主题"><a href="#2-使用主题" class="headerlink" title="2. 使用主题"></a>2. 使用主题</h3><ol><li>修改hexo配置文件<ul><li>打开hexo根目录下的_config.yml文件</li><li>找到theme: landscape项目，改为theme: 对应主题名</li><li>执行<code>hexo g</code>重新生成</li></ul></li><li>若出现问题依次执行下面命令<ul><li><code>hexo clean</code>清理public内容</li><li><code>hexo g</code>重新生成</li><li><code>hexo s</code>重新部署</li></ul></li></ol><h3 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h3><ul><li>根据使用主题对对应的配置文档进行主题配置</li><li>我使用过的是fluid：<a href="https://github.com/fluid-dev/hexo-theme-fluid">GitHub仓库地址</a> | <a href="https://github.com/fluid-dev/hexo-theme-fluid">用户手册</a></li></ul><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="1-写博客的步骤"><a href="#1-写博客的步骤" class="headerlink" title="1. 写博客的步骤"></a>1. 写博客的步骤</h3><h4 id="1-1-创建-md文件"><a href="#1-1-创建-md文件" class="headerlink" title="1.1 创建.md文件"></a>1.1 创建.md文件</h4><ul><li><p>方法一、使用hexo命令创建</p><ul><li><p>在hexo根目录，在Git Bash Here中执行命令：<code>hexo new &#39;文章名称&#39;</code></p></li><li><p>hexo会自动在对应位置生成.md文件，且自动在 新建的.md文件中生成如下内容</p><p><img src="/2022/09/01/HexoBlogBuild/16.png" alt="img"></p></li></ul></li><li><p>方法二、直接在hexo根目录\source\_posts文件夹下直接创建.md文件</p></li></ul><h4 id="1-2-编写并保存"><a href="#1-2-编写并保存" class="headerlink" title="1.2 编写并保存"></a>1.2 编写并保存</h4><ul><li>使用typora打开该文件，编写博客，写完后Ctrl+S保存关闭即可</li></ul><h4 id="1-3-推送博客"><a href="#1-3-推送博客" class="headerlink" title="1.3  推送博客"></a>1.3  推送博客</h4><ul><li>在hexo根目录下，在Git Bash Here中依次执行以下命令<ul><li><code>hexo clean</code>清理</li><li><code>hexo g</code>生成</li><li><code>hexo d</code>部署</li></ul></li></ul><h3 id="2-注意使用的文章-Front-matter-语法"><a href="#2-注意使用的文章-Front-matter-语法" class="headerlink" title="2. 注意使用的文章 Front-matter 语法"></a>2. 注意使用的文章 Front-matter 语法</h3><ul><li>不同主题有所不同，在主题的使用文档中查找。<a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5">hexo中的说明</a></li><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5">fluid主题对应文档</a></li></ul><h3 id="3-向hexo博客中插入图片"><a href="#3-向hexo博客中插入图片" class="headerlink" title="3. 向hexo博客中插入图片"></a>3. 向hexo博客中插入图片</h3><h4 id="3-1-常规路径设置，及其问题"><a href="#3-1-常规路径设置，及其问题" class="headerlink" title="3.1 常规路径设置，及其问题"></a>3.1 常规路径设置，及其问题</h4><ul><li><p>md中插入图片的语法为：![]()</p><ul><li><p>[]为图片描述 | ()为图片路径:  路径分为三种</p><ul><li><p>相对路径</p><blockquote><p>在hexo配置文件中启用 post_asset_folder: true</p><p>使用hexo new命令创建文章的时候会生成同名的文件夹用于存放文件资源</p><p>引入图片：![](image.jpg)</p><p>问题：</p><ol><li><p>在Typora中无法显示</p><ul><li><p>在Typora引入相对路径图片：![](文章名&#x2F;image.jpg)</p></li><li><p>在Hexo中引入相对路径图片：![](image.jpg)</p></li></ul></li><li><p>在首页显示</p><ul><li>解决办法：使用标签插件语法 </li></ul></li></ol></blockquote></li><li><p>绝对路径</p><blockquote><p>将图片文件放在：hexo根目录&#x2F;source&#x2F;images&#x2F;image.jpg</p><p>引入图片：![图片描述](&#x2F;images&#x2F;image.jpg)</p><p>问题：</p><ul><li>所有文章的图片都在 source&#x2F;images 目录下，图片资源杂乱</li></ul></blockquote></li><li><p>网络路径</p><blockquote><p>问题：图片链接可能失效</p></blockquote></li></ul></li></ul></li></ul><h4 id="3-2-图片插入的解决办法"><a href="#3-2-图片插入的解决办法" class="headerlink" title="3.2 图片插入的解决办法"></a>3.2 图片插入的解决办法</h4><ol><li><p>asset-image插件</p><ul><li><p>安装: <code>npm install https://github.com/CodeFalling/hexo-asset-image</code></p></li><li><p>修改Hexo配置文件</p><blockquote><p>post_asset_folder: true</p></blockquote></li><li><p>设置好后在Hexo中就可以使用 ![](文章名&#x2F;image.jpg) 插入图片</p></li></ul></li><li><p>asset-image插件+Typora结合</p><ul><li><p>在Typora中， 文件-&gt;偏好设置-&gt;图像中设置<img src="/2022/09/01/HexoBlogBuild/21.png" alt="img"></p></li><li><p>复制网络图片</p><blockquote><p>在网页中复制图片后，粘贴到Typora中，会直接复制该图片到文章资源文件夹中，同时自动更改路径</p><p>如：图片 https:&#x2F;&#x2F;…&#x2F;image.jpg 粘贴到Typora中叫文章名的文章中后，图片的路径自动变为(文章名&#x2F;image.jpg)，同时图片资源自动存入对应文章资源文件夹中</p></blockquote></li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://reclusew.github.io/2021/08/12/blog-setup/">2021年最全搭建+美化+使用博客教程</a></li><li><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li><li><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册 (fluid-dev.com)</a></li><li><a href="http://codecook.site/2020/12/05/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/">hexo图片路径设置</a></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
