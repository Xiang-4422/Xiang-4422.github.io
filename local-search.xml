<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java多线程-生产者与消费者问题</title>
    <link href="/2022/10/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者模式可以让我们加深对并发编程的理解。</p><p>所谓的生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一类是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据后直接放置在共享数据区中，不需要关心消费者的行为，而消费者只需要从共享数据区中去获取数据，就不再需要去关心生产者的行为。</p><p>这个共享数据区中应该具备这样的线程间并发协作的功能：</p><ul><li>如果共享数据区已满的话，阻塞生产者继续生产数据放置入内</li><li>如果共享数据区为空的话，阻塞消费者继续消费数据</li></ul><p>生产者-消费者的实现有下面三种方式：</p><ul><li>使用Object的wait&#x2F;notify的消息通知机制</li><li>使用Lock的Condition的await&#x2F;signal的消息通知机制</li><li>使用BlockingQueue实现</li></ul><h1 id="wait-x2F-notify的消息通知机制"><a href="#wait-x2F-notify的消息通知机制" class="headerlink" title="wait&#x2F;notify的消息通知机制"></a>wait&#x2F;notify的消息通知机制</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li><p>wait ()</p><blockquote><ul><li><p>该方法用来将当前线程置入休眠状态，直到接收到通知或被中断为止</p></li><li><p>只能在同步方法或同步块中调用wait()方法。</p><blockquote><p>在调用wait()方法之前，线程必须要获得该对象的对象监视器锁，若调用前没有获取锁，则会抛出IllegalMonitorStateException异常，这是个Runtime异常。</p></blockquote></li><li><p>调用wait ()方法之后，当前线程会释放锁。</p></li><li><p>如果再次获取到锁的话，当前线程才能从wait()方法处成功返回</p></li></ul></blockquote></li><li><p>notify()</p><blockquote><ul><li>该方法也需要在同步方法或同步块中调用。</li><li>该方法从等待队列中随机挑选一个处于WAITING状态的线程发出通知，使得被通知的线程由随机队列移入同步队列中，等待有机会再一次获取锁，从而使得调用wait()方法的线程能够从wait()方法处退出。</li><li>调用notify后，当前线程不会马上释放该对象锁，而是要等到程序退出同步块后，当前线程才会释放锁</li></ul></blockquote></li><li><p>notifyAll()</p><blockquote><p>与notify()方法不同的一点在于，notifyAll会通知所有等待线程。</p></blockquote></li></ul><h2 id="wait-x2F-notify潜在的一些问题"><a href="#wait-x2F-notify潜在的一些问题" class="headerlink" title="wait&#x2F;notify潜在的一些问题"></a>wait&#x2F;notify潜在的一些问题</h2><h3 id="问题一、notify早期通知（通知遗漏）"><a href="#问题一、notify早期通知（通知遗漏）" class="headerlink" title="问题一、notify早期通知（通知遗漏）"></a>问题一、notify早期通知（通知遗漏）</h3><p>notify通知遗漏很容易理解，即当threadA还没开始wait的时候，threadB已经notify了。这样，threadB的通知是没有任何响应的，而threadA在notify后wait，便会一直阻塞等待，直到被其他线程打断。</p><p>解决方案：</p><p>添加一个状态标志，让waitThread在调用wait方法前判断通知是否已经发出，如果通知已经发出，则waitThread就不再wait。</p><h3 id="问题二、等待wait的条件发生变化"><a href="#问题二、等待wait的条件发生变化" class="headerlink" title="问题二、等待wait的条件发生变化"></a>问题二、等待wait的条件发生变化</h3><p>如果线程在等待时接收到了通知，但是之后等待的条件发生了变化，并没有对等待条件进行判断，也会导致程序出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionChange</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; lockObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(lockObject);<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(lockObject);<br>        <span class="hljs-type">Productor</span> <span class="hljs-variable">productor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(lockObject);<br>        <span class="hljs-comment">//两个消费者线程</span><br>        consumer1.start();<br>        consumer2.start();<br>        <span class="hljs-comment">//一个生产者线程</span><br>        productor.start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;String&gt; lock;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//这里使用if的话，就会存在wait条件变化造成程序错误的问题</span><br>                    <span class="hljs-keyword">if</span> (lock.isEmpty()) &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; list为空&quot;</span>);<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 调用wait方法&quot;</span>);<br>                        lock.wait();<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  wait方法结束&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> lock.remove(<span class="hljs-number">0</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 取出第一个元素为：&quot;</span> + element);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;String&gt; lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 开始添加元素&quot;</span>);<br>                lock.add(Thread.currentThread().getName());<br>                lock.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br>会报异常：<br>    <br>Exception in thread <span class="hljs-string">&quot;Thread-1&quot;</span> Thread-<span class="hljs-number">0</span> list为空<br>Thread-<span class="hljs-number">0</span> 调用wait方法<br>Thread-<span class="hljs-number">1</span> list为空<br>Thread-<span class="hljs-number">1</span> 调用wait方法<br>Thread-<span class="hljs-number">2</span> 开始添加元素<br>Thread-<span class="hljs-number">1</span>  wait方法结束<br>java.lang.IndexOutOfBoundsException: Index: <span class="hljs-number">0</span>, Size: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>异常原因分析：</p><p>两个消费者启动的时候，List为空。都被阻塞，等待被唤醒后消费List中的数据。</p><p>一个生产者，生产数据过后，notifyAll，两个消费者都被唤醒，第一个消费者正常消费数据，此时List为空，第二个消费者再消费数据的时候List为空，抛出异常。</p><p>即第二个消费者从wait方法退出过后wait条件已经发生变化，再执行程序就出错了</p><p>解决方案：在wait退出之后再对条件进行判断即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改Customer线程的run方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//如果lock为空的话，进入进入循环wait</span><br>            <span class="hljs-keyword">while</span> (lock.isEmpty()) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; list为空&quot;</span>);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 调用wait方法&quot;</span>);<br>                lock.wait();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  wait方法结束&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//出循环后此时lock不为空</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> lock.remove(<span class="hljs-number">0</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 取出第一个元素为：&quot;</span> + element);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题三、”假死“状态"><a href="#问题三、”假死“状态" class="headerlink" title="问题三、”假死“状态"></a>问题三、”假死“状态</h3><p>问题：</p><p>如果时多消费者和多生产者情况，如果使用notify方法可能会出现”假死“的情况，即唤醒的时同类线程。</p><p>原因分析：</p><p>假设当多个生产者线程调用wait阻塞，当其中一个生产者获取到对象锁之后使用notif通知处于等待状态的线程（有生产者和消费者）如果唤醒的仍是生产者线程，就会造成所有的生产者线程都处于等待状态</p><p>解决办法：</p><p>使用notify方法替换notifyAll方法如果使用的是Lock，就将signal替换为signalAll方法</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Object提供的消息通知机制应该遵循如下条件：</p><ul><li><p>永远在while循环中对条件进行判断</p><blockquote><p>在使用线程的等待&#x2F;通知机制时，一般要在while循环中调用wait()方法，因此需要配合使用一个Boolean变量（或其他wait条件），满足wait条件时，进入while循环，执行wait()方法，不满足wait条件时，跳出循环，执行后续代码</p></blockquote></li><li><p>使用notifyAll而不是notify</p></li></ul><p>使用范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The standard idiom for calling the wait method in Java</span><br><span class="hljs-keyword">synchronized</span> (sharedObject) &#123;<br>    <span class="hljs-keyword">while</span> (condition) &#123;<br>    sharedObject.wait();<br>        <span class="hljs-comment">// (Releases lock, and reacquires on wakeup)</span><br>    &#125;<br>    <span class="hljs-comment">// do action based upon condition e.g. take or put into queue</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wait-x2F-notifyAll实现生产者-消费者"><a href="#wait-x2F-notifyAll实现生产者-消费者" class="headerlink" title="wait&#x2F;notifyAll实现生产者-消费者"></a>wait&#x2F;notifyAll实现生产者-消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(linkedList, <span class="hljs-number">8</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(linkedList));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxLength;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List list, <span class="hljs-type">int</span> maxLength)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.maxLength = maxLength;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (list) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (list.size() == maxLength) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list以达到最大容量，进行wait&quot;</span>);<br>                            list.wait();<br>                            System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                        &#125;<br>                        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 生产数据&quot;</span> + i);<br>                        list.add(i);<br>                        list.notifyAll();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List list)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (list) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list为空，进行wait&quot;</span>);<br>                            list.wait();<br>                            System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                        &#125;<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  消费数据：&quot;</span> + element);<br>                        list.notifyAll();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Lock中Conditionn的await-x2F-signal"><a href="#Lock中Conditionn的await-x2F-signal" class="headerlink" title="Lock中Conditionn的await&#x2F;signal"></a>Lock中Conditionn的await&#x2F;signal</h1><p>使用Lock.lock()代替syncchronized(Objcet)</p><p>使用Condition的await()和signal()代替Object的wait()和notify()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(linkedList, <span class="hljs-number">8</span>, lock));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(linkedList, lock));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxLength;<br>        <span class="hljs-keyword">private</span> Lock lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List list, <span class="hljs-type">int</span> maxLength, Lock lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.maxLength = maxLength;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (list.size() == maxLength) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list以达到最大容量，进行wait&quot;</span>);<br>                        full.await();<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                    System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 生产数据&quot;</span> + i);<br>                    list.add(i);<br>                    empty.signalAll();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> Lock lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List list, Lock lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list为空，进行wait&quot;</span>);<br>                        empty.await();<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>                    System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  消费数据：&quot;</span> + element);<br>                    full.signalAll();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>BlockingQueue会自动阻塞生产者和消费者线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(queue));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(queue));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> BlockingQueue queue;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(BlockingQueue queue)</span> &#123;<br>            <span class="hljs-built_in">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                    System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;生产数据&quot;</span> + i);<br>                    queue.put(i);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> BlockingQueue queue;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(BlockingQueue queue)</span> &#123;<br>            <span class="hljs-built_in">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> (Integer) queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在消费数据&quot;</span> + element);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java多线程相关完结。完全参考：<a href="https://github.com/CL0610/Java-concurrency">https://github.com/CL0610/Java-concurrency</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发工具类</title>
    <link href="/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>业务场景：</strong></p><p>在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务后，主线程才能继续往下执行业务功能。</p><p>解决方案：</p><ul><li>使用Thread类的join方法，让主线程等待被join的线程执行完毕后，主线程才能继续往下执行。</li><li>也可以使用线程间消息通信机制（wait和notify）</li><li>Java并发工具类中为我们提供了类似“倒计时”这样的工具类，也就是CountDownLathch来完成这种业务场景</li></ul><p><strong>CountDownLatch的通俗解释：</strong></p><p>若有6个运动员参与比赛，一个裁判员在终点计时。每个运动员到达终点，裁判员就少一个计时任务，当所有运动员到达终点，裁判员任务完完成，才能继续执行其他操作。6个运动员可以类比为六个线程，裁判员类比为一个主线程，当运动员到达终点时，调用CountDownLatch.countDown()方法对计数器减一，直到计数器为0，裁判员主线程才能继续往下执行。</p><h2 id="CountDownLatch的主要方法"><a href="#CountDownLatch的主要方法" class="headerlink" title="CountDownLatch的主要方法"></a>CountDownLatch的主要方法</h2><p>构造方法：</p><ul><li><p>public CountDownLatch(int count)</p><blockquote><p>构造方法传入一个整数N，之后调用countdown方法会对N减一，当N捡到0时，之前因为调用await方法阻塞的线程会被唤醒会继续执行。</p></blockquote></li></ul><p>使用方法：</p><ul><li><p>await() throws InterruptedException</p><blockquote><p> 调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行</p></blockquote></li><li><p>await(long timeout, TimeUnit unit)</p><blockquote><p>在await方法的基础上，增加了超时等待机制</p></blockquote></li><li><p>countDown()</p><blockquote><p>使CountDownLatch计数值N减1</p></blockquote></li><li><p>long getCount()</p><blockquote><p>获取当前CountDownLatch中的计数值</p></blockquote></li></ul><h2 id="解释示例的代码实现"><a href="#解释示例的代码实现" class="headerlink" title="解释示例的代码实现"></a>解释示例的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br> <span class="hljs-comment">//运动员线程需要关注的起跑信号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//裁判员线程需要关注的六个运动员都到达终点的信号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">endSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//主线程裁判员线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">//创建六个运动员线程并提交给线程池执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 运动员等待裁判员响哨！！！&quot;</span>);<br>                    <span class="hljs-comment">//运动员等待起跑信号</span><br>                    startSignal.await();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在全力冲刺&quot;</span>);<br>                    endSignal.countDown();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  到达终点&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//起跑信号，六个运动员起跑</span><br>        System.out.println(<span class="hljs-string">&quot;裁判员发号施令啦！！！&quot;</span>);<br>        startSignal.countDown();<br>        <span class="hljs-comment">//结束信号，裁判员宣布比赛结束</span><br>        endSignal.await();<br>        System.out.println(<span class="hljs-string">&quot;所有运动员到达终点，比赛结束！&quot;</span>);<br>        executorService.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br>输出结果：<br>    <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span> 运动员等待裁判员响哨！！！<br>裁判员发号施令啦！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  到达终点<br>所有运动员到达终点，比赛结束！<br></code></pre></td></tr></table></figure><p>注意：代码中设置了两个CountDownLatch，一个startSignal用于让裁判员发送开始信号给运动员，一个endSignal用于让裁判员接收结束信号。</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>CyclicBarrier也是一种多线程并发控制的使用工具，和CountDownLatch一样具有等待计数的功能，但是更加强大。</p><p>通俗解释：</p><p>还是上面的运动会例子，模拟运动员入场的情况。假设有6条跑道，需要6个运动员都到达跑到起点后，才能吹哨开始跑步。跑道起点相当于一个barrier，是临界点，6个运动员类比成线程的话，到达临界点的线程会阻塞，需要等待到达临界点的线程到达六个，阻塞在临界点的线程才会解除阻塞继续执行。</p><p>CyclicBarrier在使用一次过后，仍然有效，可以继续当计数器使用，这是和CountDownLatch的区别之一。</p><p>示意图：</p><p><img src="/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/16334ad72bdd4ca3tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="CyclicBarrier执行示意图.jpg"></p><h2 id="CyclicBarrier的主要方法"><a href="#CyclicBarrier的主要方法" class="headerlink" title="CyclicBarrier的主要方法"></a>CyclicBarrier的主要方法</h2><p>构造方法：</p><p>public CyclicBarrier(int parties, Runnable barrierAction)</p><p>使用方法：</p><ul><li><p>await()</p><blockquote><p>等待所有的线程都到达指定的临界点</p></blockquote></li><li><p>awat(long timeout, TimeUnit unit)</p><blockquote><p>在await方法基础上增加超时等待机制</p></blockquote></li><li><p>int getNumberWaiting()</p><blockquote><p>获取当前有多少个线程阻塞等待在临界点上</p></blockquote></li><li><p>boolean isBroken()</p><blockquote><p>用于查询阻塞等待的线程是否被中断</p></blockquote></li><li><p>void reset()</p><blockquote><p>将屏障重置为初始状态，如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException</p></blockquote></li></ul><h2 id="解释示例的代码实现："><a href="#解释示例的代码实现：" class="headerlink" title="解释示例的代码实现："></a>解释示例的代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-comment">//创建计数为6的CyclicBarrier，并设置线程到齐后的执行函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">6</span>, () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;所有运动员入场，裁判员一声令下！！！！！&quot;</span>);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;运动员准备进场，全场欢呼............&quot;</span>);<br>        <br>        <span class="hljs-comment">//创建六个运动员线程并提交给线程池执行</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">6</span>; i++) &#123;<br>            service.execute(() -&amp;gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 运动员，进场&quot;</span>);<br>                    <span class="hljs-comment">//在barrier阻塞，等待其他线程到齐</span><br>                    barrier.await();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  运动员出发&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>&#125;<br>&#125;<br><br>输出结果：<br>运动员准备进场，全场欢呼............<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span> 运动员，进场<br>所有运动员入场，裁判员一声令下！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  运动员出发<br></code></pre></td></tr></table></figure><h2 id="CountDownLatch与CyclicBarrier比较"><a href="#CountDownLatch与CyclicBarrier比较" class="headerlink" title="CountDownLatch与CyclicBarrier比较"></a>CountDownLatch与CyclicBarrier比较</h2><p>二者都是用于控制并发的工具类，都可以理解成维护一个计数器，但是二者的侧重点不同：</p><ul><li>CountDownLatch一般用于某个线程A等待其他若干线程执行完任务后，它才执行（一个线程等多个线程）。而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行（多个线程互相等待）。</li><li>调用CountDownLatch的countDown方法不会阻塞当前线程；而调用CyclicBarrier的await方法会阻塞当前线程，直到CyclicBarrier指定的线程数量到达，才继续往下执行。</li><li>CountDownLatch方法较少，使用简单。而CyclicBarrier提供的方法更多，可以同通过getNumberWaiting()、isBroken()方法获取当前多个线程的状态，并且再构造方法中可以传入barrierAction，指定当所有线程都到达时执行的业务功能。</li><li>CountDownLatch是一次性的，不能复用，而CyclicBarrier可以复用。</li></ul><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Semaphore可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。</p><p>Semaphore就相当于一个许可证，线程需要先通过acquire方法获取该许可证，该线程才能继续执行下去，否则只能在该方法处阻塞等待。当执行完业务功能够，通过release()方法将许可证归还，以便其他线程能够获得许可证继续执行。</p><p>业务场景：</p><p>Semaphore可以用作流量控制，特别是公共资源有限的应用场景，比如数据库连接。加入有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有10个，这个时候就需要使用Semaphore来控制能够并发访问到数据库连接资源的线程数只有10个。在限制资源使用的应用场景下，Semaphore是特别合适的。</p><h2 id="Semaphore的主要方法"><a href="#Semaphore的主要方法" class="headerlink" title="Semaphore的主要方法"></a>Semaphore的主要方法</h2><p>构造方法：</p><ul><li><p>Semaphore(int permits)</p></li><li><p>Semaphore(int permits, boolean fair)</p></li></ul><p>获取与释放许可的方法：</p><ul><li>acquire()</li><li>acquire(int permits)</li><li>release()</li><li>release(int permits)</li><li>boolean tryAcquire()</li><li>boolean tryAcquire(int permits)</li><li>boolean tryAcquire(long timeout, TimeUnit unit)</li><li>Boolean try Acquire(int premits, long timeout, TimeUnit unit)</li></ul><p>获取许可证和阻塞线程信息的方法：</p><ul><li>int availablePermits()</li><li>int getQueueLength()</li><li>boolean hasQueuedThreads()</li><li>Collections<Thread> getQueueThreads()</Thread></li></ul><h2 id="使用示例代码实现"><a href="#使用示例代码实现" class="headerlink" title="使用示例代码实现"></a>使用示例代码实现</h2><p>模拟场景：</p><p>有一天，班主任需要班上10个同学到讲台上来填写一个表格，但是老师只准备了5只笔，因此只能保证同时只有5名同学能够拿到笔填写表格，没有拿到笔的同学需要等待前面拿到笔的同学用完笔放回，才能拿到笔填写表格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-comment">//表示老师只有5支笔</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//表示10个学生</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//创建10个学生线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  同学准备获取笔......&quot;</span>);<br>                    semaphore.acquire();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  同学获取到笔&quot;</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  填写表格ing.....&quot;</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                    semaphore.release();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  填写完表格，归还了笔！！！！！！&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        service.shutdown();<br>    &#125;<br>&#125;<br>输出结果<br>    <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  填写表格ing.....<br><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  同学准备获取笔......<br><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  填写完表格，归还了笔！！！！！！<br></code></pre></td></tr></table></figure><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。</p><p>具体交换数据是通过exchange() 方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程都到达同步点，两个线程就可以交换数据。</p><h2 id="Exchanger的主要方法"><a href="#Exchanger的主要方法" class="headerlink" title="Exchanger的主要方法"></a>Exchanger的主要方法</h2><p>构造方法：</p><p>只有一个简单的无参构造方法</p><p>主要方法：</p><ul><li>V exchange(V x)</li><li>V exchange(V x, long timeout, timeUnit unit)</li></ul><h2 id="使用示例代码实现-1"><a href="#使用示例代码实现-1" class="headerlink" title="使用示例代码实现"></a>使用示例代码实现</h2><p>模拟场景：</p><p>在青春洋溢的中学时代，下课期间，男生经常会给走廊里为自己喜欢的女孩送情书。男生会先到女孩教师门口，然后等女孩出来，教师门口就是一个同步点，然后彼此交换信物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//代表男生和女生</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//男生线程</span><br>        service.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//男生对女生说的话</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">girl</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;我其实暗恋你很久了......&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;女孩儿说：&quot;</span> + girl);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//女生线程</span><br>        service.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;女生慢慢的从教室你走出来......&quot;</span>);<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                <span class="hljs-comment">//女生说的话</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">boy</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;我也很喜欢你......&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;男孩儿说：&quot;</span> + boy);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br>输出结果：<br><br>女生慢慢的从教室你走出来......<br>男孩儿说：我其实暗恋你很久了......<br>女孩儿说：我也很喜欢你......<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-atomic包</title>
    <link href="/2022/10/21/Java%E5%B9%B6%E5%8F%91-atomic%E5%8C%85/"/>
    <url>/2022/10/21/Java%E5%B9%B6%E5%8F%91-atomic%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="原子操作类简介"><a href="#原子操作类简介" class="headerlink" title="原子操作类简介"></a>原子操作类简介</h1><p>并发问题：</p><p>并发编程中很容易出现并发安全的例子。比如说多线程执行i++，就可能无法获取正确的结果。常用的解决办法是使用Synchronized进行控制来达到线程安全的目的。但是synchronized采用的是悲观锁策略，并不是特别高效的一种解决方案。</p><p>高效的解决方案：</p><p>在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并且能保证线程安全的更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p><h1 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h1><p>原子更新基本类型的工具类：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>这几个类的用法基本一致，以AtomicInteger为例：</p><ul><li>getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值（a &#x3D; newValue）</li><li>addAndGet(int delta)：原值加上输入数值，返回最后结果（a +&#x3D; delta）</li><li>incrementAndGet()：原值加1，返回自增后的结果（a++）</li><li>getAndIncrement()：原值加1，返回自增前的旧值（++a）</li></ul><p>实现原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AtomicInteger的getAndIncrement方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//AtomicInteger的compareAndSet方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">boolean</span> expect, <span class="hljs-type">boolean</span> update)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> expect ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> update ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, e, u);<br>&#125;<br><span class="hljs-comment">//原子类中Unsafe实例的获取</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br></code></pre></td></tr></table></figure><p>由上面源码可见，这些原子类的方法都是通过调用Unsafe类的CAS操作来实现的。</p><h1 id="原子更新数组类型"><a href="#原子更新数组类型" class="headerlink" title="原子更新数组类型"></a>原子更新数组类型</h1><p>原子更新数组中元素的类：</p><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><p>几个类的用法一致，以AtomicIntegerArray为例：</p><ul><li>addAndGet(int i, int delta)：将数组中索引为i的元素加上delta，并返回相加后的值</li><li>getAndIncrement(int i)：将数组中索引为i的元素自增1，并返回自增前的值</li><li>compareAndSet(int i, int expect, int update)：CAS更新索引为i的元素的值</li></ul><h1 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h1><p>原子更新引用类型变量的类：</p><ul><li>AtomicReference：原子更新引用类型</li><li>AtomicReferenceFieldUpdater：原子更新引用类型中的字段</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型</li></ul><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicReference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>        reference.set(user1);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> reference.getAndSet(user2);<br>        <br>        System.out.println(user);<br>        System.out.println(reference.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String userName;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.userName = userName;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;userName=&#x27;&quot;</span> + userName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>&#125;<br>&#125;<br><br>输出结果：<br>User&#123;userName=<span class="hljs-string">&#x27;a&#x27;</span>, age=<span class="hljs-number">1</span>&#125;<br>User&#123;userName=<span class="hljs-string">&#x27;b&#x27;</span>, age=<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="原子更新字段类型"><a href="#原子更新字段类型" class="headerlink" title="原子更新字段类型"></a>原子更新字段类型</h1><p>原子更新对象字段的类：</p><ul><li>AtomicIntegeFieldUpdater：原子更新对象的整形字段</li><li>AtomicLongFieldUpdater</li><li>AtomicStampedReference：原子更新引用类型。这种更新方式带有版本号，解决了ABA的问题</li></ul><p>使用步骤：</p><ol><li>原子更新字段类都是抽象类，只能通过其静态方法newUpdater来创建一个更新器，并在创建的时候指定要更新的类和属性</li><li>更新类的属性必须使用public volatile进行修饰</li></ol><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicDemo</span> &#123;<br><span class="hljs-comment">//指定类和属性，创建更新器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> <br>        AtomicIntegerFieldUpdater.newUpdater(User.class,<span class="hljs-string">&quot;age&quot;</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//使用更新器更新指定类的指定属性</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> updater.getAndAdd(user, <span class="hljs-number">5</span>);<br>        <br>        System.out.println(oldValue);<br>        System.out.println(updater.get(user));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String userName;<br>     <span class="hljs-comment">//public volatile修饰的属性，可以使用原子更新字段类更新</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.userName = userName;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>    &#125;<br>&#125;<br><br>输出结果：<br><span class="hljs-number">1</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-FutureTask</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p> 在Executors框架体系中，FutureTask用来表示<strong>可获取结果的异步任务</strong>。</p></blockquote><p>FutureTask实现了Future接口，提供的方法：</p><ul><li>启动和取消异步任务</li><li>查询异步任务是否执行完毕</li><li>获取最终的异步任务结果</li></ul><p>FutureTask中定义的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>在《Java并发编程的艺术》一书中，作者根据FutureTask.run()方法的执行时机，将其分了3中状态：</p><ul><li><p>未启动</p><blockquote><p>当创建一个 FutureTask，但是FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态</p></blockquote></li><li><p>已启动</p><blockquote><p>FutureTask.run()方法正在被执行的过程中，FutureTask处于已启动状态</p></blockquote></li><li><p>已完成</p><blockquote><p>FutureTask变为已完成状态的几种情况</p><ul><li>FutureTasl.run()方法正常执行结束</li><li>FutureTask.cancel()方法取消任务</li><li>在执行过程中抛出异常</li></ul></blockquote></li></ul><p>状态变化过程图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/16334a72fd345345tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="FutureTask状态迁移图.jpg"></p><p>不同状态对get和cancel方法的影响：</p><ul><li><p>get方法</p><blockquote><p>未完成状态：会导致线程阻塞</p><p>已完成状态：立即返回结果或抛出异常</p></blockquote></li><li><p>cancel方法</p><blockquote><p>未启动：该任务永远不会再执行</p><p>已启动：</p><p>FutureTask.cancel(true)方法将以中断方式来阻止任务继续执行</p><p>FutureTask.cancel(false)将不会对正在执行任务的线程有影响</p><p>已完成：返回false</p></blockquote></li></ul><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/16334a72fd899d43tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="FutureTask的get和cancel的执行示意图.jpg"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>FutureTask对象的执行：</p><p>FutureTask除了实现了Future接口，还实现了Runnable接口。因此可以将FutureTask交给Executror执行，也可以由调用的线程直接执行FutureTask.run () 。</p><p>FutureTask对象的获取：</p><p>可以通过ExecutorService.submit ()方法返回一个FutureTask对象</p><p>应用场景：</p><ul><li>当一个线程需要等待另一个线程执行完成后它才能继续执行，此时可以使用FutureTask</li><li>若有多个线程执行多个任务，每个任务只能执行一次。当多个线程试图执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完成后才能继续执行。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ScheduledThreadPoolExecutor</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ScheduledThreadPoolExecutor用途：</p><ul><li>在给定延时后执行异步任务</li><li>周期性执行任务</li></ul><p>相对于任务调度Timer来说，其功能更加强大。Timer只能使用一个后台线程执行任务，而ScheduledThreadPoolExecutor则可以指定后台线程的个数。</p><p>ScheduledThreadPoolExecutor类的UML图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/16334a21947ee154tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>从UML中可以看出：</p><ul><li><p>继承自ThreadPoolExecutor类</p><blockquote><p>拥有execute()和submit()提交异步任务的基础功能</p></blockquote></li><li><p>实现了ScheduledExecutorService接口</p><blockquote><p>该接口定义了能够延迟执行任务和周期性执行任务的功能</p></blockquote></li><li><p>包含两个重要类：DelayedWorkQueue和ScheduledFutureTask</p></li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), handler);<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadPoolExecutor中可以设定的参数：</p><ul><li>maximumPoolSize：线程池能创建线程的最大个数</li><li>keepAliveTime：空闲线程存活时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列</li><li>corePoolSize：核心线程池大小</li><li>threadFactory：创建线程的工厂类</li><li>handler：饱和策略</li></ul><p>ScheduledThreadPoolExecutor是通过调用ThreadPoolExecutor的构造方法进行构造的。</p><p>可定制参数：</p><ul><li>corePoolSize</li><li>threadFactory</li><li>handler</li></ul><p>已指定参数：</p><ul><li>maximumPoolSize：Integer.MAX_VALUE</li><li>keepAliveTime：0</li><li>unit：NANOSECONDS</li><li>workQueue：DelayedWorkQueue</li></ul><h2 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h2><p>ScheduledThreadPoolExexecutor实现了ScheduledExecutorService接口，该接口定义了可延时执行异步任务和可周期性执行异步任务的特有功能。相应方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1 延时执行异步任务</span><br><br><span class="hljs-comment">//这里传入的是实现Runnable接口的任务，因此通过ScheduledFuture.get()获取结果为null</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                       <span class="hljs-type">long</span> delay, TimeUnit unit);<br><span class="hljs-comment">//这里传入的是实现Callable接口的任务，因此，返回的是任务的最终计算结果</span><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">                                           <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br><span class="hljs-comment">//2 周期性执行异步任务</span><br><br><span class="hljs-comment">//当达到延时时间initialDelay后，任务开始执行。</span><br><span class="hljs-comment">//以上一个任务开始的时间计时，period时间过去后，检测上一个任务是否执行完毕</span><br><span class="hljs-comment">//如果上一个任务执行完毕，则当前任务立即执行</span><br><span class="hljs-comment">//如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit);<br><span class="hljs-comment">//当达到延时时间initialDelay后，任务开始执行。</span><br><span class="hljs-comment">//上一个任务执行结束后到下一次任务执行，中间延时时间间隔为delay。</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                     <span class="hljs-type">long</span> initialDelay,<br>                                                     <span class="hljs-type">long</span> delay,<br>                                                     TimeUnit unit);<br></code></pre></td></tr></table></figure><h1 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h1><p>上面特有方法执行，实际上是将提交的任务转换为ScheduledFutureTask类。</p><p>例如schedule方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay,<br>                                   TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//Runable转换为ScheduledFutureTask</span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(<br>        command, <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay, unit))<br>    );<br>    <span class="hljs-comment">//提交执行ScheduledFutureTask</span><br>    delayedExecute(t);<br>    <span class="hljs-comment">//返回ScheduledFutureTask</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程池最大的作用是将任务和线程解耦。</p><p>线程是任务的执行者，任务是ScheduledFutureTask，任何线程执行任务都是通过调用run()方法。为了保证ScheduledThreadPoolExecutor能够延迟执行任务以及周期性执行任务，ScheduledFutureTask重写了run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<br>        cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//1 如果不是周期性执行任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>        <span class="hljs-comment">//直接调用run方法</span><br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();<br><span class="hljs-comment">//2 如果是周期性执行任务的话</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>        <span class="hljs-comment">//重设下一次执行任务的时间</span><br>        setNextRunTime();<br>        <span class="hljs-comment">//将下一次待执行的任务放置到DelayedWorkQueue中</span><br>        reExecutePeriodic(outerTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h1><p>DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。</p><p>在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列任务，执行时间越接近当前时间的任务在队列的前面。</p><p>为什么要使用DelayedWorkQueue？</p><ul><li><p>定时任务执行时需要取出最近要执行的任务，所以每次队列出队的一定钥匙执行时间最靠前的任务。</p></li><li><p>DelayedWorkQueue是一个优先级队列，它基于堆结构，插入和删除操作最坏的时间复杂度都是O(logN)。</p></li></ul><p>DelayedWorkQueue的数据结构（底层采用数组存储任务）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DelayedWorkQueue是由一个大小为16的数组组成</span><br><span class="hljs-comment">//数组元素为实现RunnableScheduleFuture接口的类，实际上为ScheduledFutureTask</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>以ScheduledThreadPoolExecutor的schedule方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay,<br>                                   TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-comment">//1 将提交的任务转换成ScheduledFutureTask</span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(<br>        command,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay, unit))<br>    );<br>    <span class="hljs-comment">//2 延时执行任务ScheduledFutureTask</span><br>delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-comment">//2.1 如果当前线程池已经关闭，拒绝任务</span><br>    <span class="hljs-keyword">if</span> (isShutdown())<br>        reject(task);<br>    <span class="hljs-comment">//2.2 若线程池没有关闭，将任务放入阻塞队列中</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.getQueue().add(task);<br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>            remove(task))<br>            task.cancel(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">else</span><br><span class="hljs-comment">//保证至少有一个线程启动，即使corePoolSize=0</span><br>            ensurePrestart();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取现在的线程数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());<br>    <span class="hljs-comment">//1 若核心线程池没满，新建线程</span><br>    <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//2 若corePoolSize为0，则会保证有一个线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>addWorker()方法就是新建线程：</p><ul><li><p>ensurePrestart()方法的关键在于addWorker()方法，该方法的主要功能：新建Worker类。</p></li><li><p>当执行任务时，会调用被Worker重写的run方法，进而执行runWorker方法。在runWorker方法中会调用getTask方法从阻塞队列中不断获取任务进行执行，直到从阻塞队列中获取的任务为null的时候，线程结束终止。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="ScheduledThreadPoolExecutor的异同"><a href="#ScheduledThreadPoolExecutor的异同" class="headerlink" title="ScheduledThreadPoolExecutor的异同"></a>ScheduledThreadPoolExecutor的异同</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor类，因此整体功能一致：</p><ul><li>线程池主要负责创建线程（Worker类）</li><li>线程从阻塞队列中不断获取新的异步任务，直到阻塞队列为空</li></ul><p>ScheduledThreadPoolExecutor相较于ThreadPoolExecutor类增加了延时执行任务和可周期性执行任务的特性：</p><ul><li>重新设计了任务类ScheduleFutureTash，重写其run方法使其具有上述特性</li><li>通过阻塞队列DelayedWorkQueue保证越靠近当前时间执行的任务先执行</li></ul><h2 id="线程池的解耦"><a href="#线程池的解耦" class="headerlink" title="线程池的解耦"></a>线程池的解耦</h2><p>线程池设计时的三个关键要素是：任务、执行者和任务结果。线程池的设计思想就是将这三个要素解耦：</p><ul><li><p>执行者</p><blockquote><p>任务的执行机制，完全交给Worker类，也就是进一步封装了Thread。</p><p>向线程池提交任务，无论是ThreadPoolExecutor的execute方法和submit方法，还是ScheduledThredPoolExecutor的schedule方法，其执行流程都如下：</p><ol><li>将任务移入阻塞队列</li><li>通过addWork方法新建Work类，并通过runWorker方法启动线程</li><li>不断从阻塞队列中共获取异步任务交给Worker执行，直到阻塞队列为空</li></ol></blockquote></li><li><p>任务</p><blockquote><p>任务是实现了Runnable接口和Callable接口的实现类。</p><p>ThreadPoolExecutor中将任务转换成FutureTask类</p><p>ScheduledThreadPoolExecutor中将任务转换成ScheduleFutureTask类，该类继承自FutureTask，并重写run方法</p></blockquote></li><li><p>任务结果</p><blockquote><p>任务提交过后，可以通过Future接口的类获取任务结果。</p><p>ThreadPoolExecutor中实际为FutureTask类</p><p>ScheduledThreadPoolExecutor中则是ScheduledFutureTask类</p></blockquote></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-线程池实现原理</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><p>在实际的使用中，线程池是很占用系统资源的，如果对线程管理不善很容易导致系统问题。所以在大多数并发框架中都会使用线程池来管理线程。</p><p>使用线程池的好处：</p><ul><li><p>降低资源消耗</p><blockquote><p>通过复用已存的线程，来减少线程的创建于销毁</p></blockquote></li><li><p>提高系统响应速度</p><blockquote><p>通过复用线程，省去了创建线程的过程，因此从整体上提升了系统的响应速度</p></blockquote></li><li><p>提高线程的可管理性</p><blockquote><p>线程是稀缺资源，如果无限制地创建线程，不仅会消耗系统资源，还会降低系统的稳定性。所以需要线程池来管理线程</p></blockquote></li></ul><h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><p>并发任务提交给线程池，线程池分配线程去执行任务的过程：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/163349e503061169tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>线程池执行所提交任务的几个阶段：</p><ol><li><p>核心线程池：</p><blockquote><p>先判断线程池中的核心线程池所有的线程是否都在执行任务。若不是，则创建一个核心线程执行刚提交的任务，否则进入第2步</p></blockquote></li><li><p>阻塞队列：</p><blockquote><p>若阻塞队列没有满，则将任务放置于阻塞队列中，否则进入第3步</p></blockquote></li><li><p>线程池：</p><blockquote><p>若线程池中所有线程都在执行任务，则交给饱和策略处理，否则创建一个新的线程来执行任务</p></blockquote></li></ol><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><h2 id="ThreadPoolExecutor的构造方法"><a href="#ThreadPoolExecutor的构造方法" class="headerlink" title="ThreadPoolExecutor的构造方法"></a>ThreadPoolExecutor的构造方法</h2><p>创建线程池主要是通过ThreadPoolExecutor类来完成，其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize,<br>                   <span class="hljs-type">int</span> maximumPoolSize,<br>                   <span class="hljs-type">long</span> keepAliveTime,<br>                   TimeUnit unit,<br>                   BlockingQueue&lt;Runnable&gt; workQueue,<br>                   ThreadFactory threadFactory,<br>                   RejectedExecutionHandler handler)<br></code></pre></td></tr></table></figure><p>参数解析：</p><ul><li><p>corePoolSize：核心线程池大小</p><blockquote><p>当提交一个任务时，如果当前核心线程池的线程个数没有达到corePoolSize，则会创建一个新的线程用于执行所提交的任务，即使核心线程池中有空闲线程。</p><p>如果调用prestartCoreThread()或者prestartAllCoreThreads()，线程池在创建的时候，会创建并启动所有的核心线程。</p></blockquote></li><li><p>maximumPoolSize：线程池能创建线程的最大个数</p><blockquote><p>如果阻塞队列已满（此时核心线程池肯定也已满），但是当前线程个数没有超过允许创建的最大线程数，则会创建一个新的线程用于执行任务。</p></blockquote></li><li><p>keepAliveTime：空闲线程存活时间</p><blockquote><p>当线程池的线程个数超过corePoolSize，并且线程空闲时间超过了keepAliveTime的话，将会销毁这些空闲线程以降低系统资源消耗。</p></blockquote></li><li><p>unit：时间单位</p><blockquote><p>为keepAliveTime指定时间单位</p></blockquote></li><li><p>workQueue：阻塞队列</p><blockquote><p>用于保存任务的阻塞队列。</p></blockquote></li><li><p>threadFactory：创建线程的工厂类</p><blockquote><p>可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字，如果出现并发问题，方便排查。</p></blockquote></li><li><p>handler：饱和策略</p><blockquote><p>当线程池已满，再提交任务需要策略来处理。有如下策略：</p><ul><li><p>AbortPolicy</p><blockquote><p>直接拒绝所提交的任务，并抛出RejectedExecutionException异常</p></blockquote></li><li><p>CallerRunsPlicy</p><blockquote><p>只用调用者所在得线程来执行任务</p></blockquote></li><li><p>DiscardPolicy</p><blockquote><p>不处理直接丢弃提交的任务</p></blockquote></li><li><p>DiscardOldestPolicy</p><blockquote><p>丢弃阻塞队列中存放最久的任务，执行当前任务</p></blockquote></li></ul></blockquote></li></ul><h2 id="线程池执行逻辑"><a href="#线程池执行逻辑" class="headerlink" title="线程池执行逻辑"></a>线程池执行逻辑</h2><p>通过ThreadPoolExecutor创建线程池后，通过其execute方法提交任务给线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-comment">//如果线程池的线程个数少于corePoolSize则创建新线程执行当前任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-comment">//如果线程个数大于corePoolSize或者创建线程失败，则将任务存放在阻塞队列workQueue中</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><span class="hljs-comment">//如果当前任务无法放进阻塞队列中，则创建新的线程来执行任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程示意图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/163349e50368064btplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="execute执行过程示意图.jpg"></p><p>执行逻辑：</p><ol><li>如果当前运行的线程少于corePoolSize，则创建新的线程来执行新的任务</li><li>如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中</li><li>如果workQueue队列已满的话，则会创建新的线程来执行任务</li><li>如果线程个数已经超过maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来处理</li></ol><h1 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h1><p>关闭线程池有两个方法：</p><ul><li><p>shutdown</p><blockquote><p>只是将线程池的状态设置未SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p></blockquote></li><li><p>shutdownNow</p><blockquote><p>首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表</p></blockquote></li></ul><p>二者的原理都是通过遍历线程池中所有的线程，然后依次中断线程。shutdown方法会将正在执行的任务执行完，而shutdownNow会直接中断正在执行的任务。</p><p>调用任意一个方法，isShutdown方法都会返回true，当所有的线程都关闭成功，才表示线程池成功关闭，这时调用isTerminated方法才会返回true。</p><h1 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h1><p>想要合理配置线程池，首先要分析任务特性，有以下几个角度：</p><ul><li><p>任务的性质：CPU密集型任务、IO密集型任务和混合型任务</p><blockquote><p>CPU密集型任务，因为CPU本身很少空闲，配置尽可能少地线程数量，如Ncpu+1个线程。</p><p>IO密集型任务，因为需要等待IO操作，线程并非一直执行任务，应该配置尽可能多，如2Ncpu。</p><p>混合型任务，如果可以拆分，则将其拆分未一个CPU密集型任务一个IO密集型任务。</p><p>cpu数量可以通过Runtime.getRuntime().availableProcessors()方法获取。</p></blockquote></li><li><p>任务的优先级</p><blockquote><p>优先级不同的任务，可以使用优先队列PriorityBlockingQueue来处理</p><p>它可以让优先级高的任务优先执行，但是优先级低的任务可能会出现“饥饿”永远无法执行</p></blockquote></li><li><p>任务的执行时间</p><blockquote><p>执行时间不同的任务可以交给不同规模的线程池处理。</p><p>或者使用优先队列，让执行时间短的任务先执行。</p></blockquote></li><li><p>任务的依赖性：是否依赖其他系统资源，如数据库连接</p><blockquote><p>依赖数据库连接的任务，因为线程提交SQL后需要等待数据库返回结果，等待中CPU空闲，那么线程数量根据CPU空闲时间越大，设置数量越多，这样更好地利用CPU资源。</p></blockquote></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-BlockingQueue</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/</url>
    
    <content type="html"><![CDATA[<h1 id="BlockingQueue简介"><a href="#BlockingQueue简介" class="headerlink" title="BlockingQueue简介"></a>BlockingQueue简介</h1><p>在JDK中的Collection集合框架中的各种容器类如实现List，Map，Queue接口的容器类，但是这些容器类都不是线程安全的，除了使用Collections可以将其转换位线程安全的容器，JDK中的Concurrent包中还提供了线程安全的容器。如实现List接口的CopyOnWriteArrayList，实现了Map接口的ConcurrentHashMap，实现了Queue接口的ConcurrentLinkedQueue。</p><p>阻塞队列的用途：</p><p>在最常见的“生产者-消费者”问题中，队列常常被作为线程间操作的容器，这样可以将生产和消费的业务功能解耦，生产者将生产出来的数据放置在数据容器中，而消费者仅仅需要从数据容器中获取数据即可。阻塞队列提供了可阻塞的插入的移除的方法，当队列容器已满，生产者线程会被阻塞，知道队列未满，当队列容器为空时，消费者线程会被阻塞，知道队列非空为止。</p><h1 id="阻塞队列的基本操作"><a href="#阻塞队列的基本操作" class="headerlink" title="阻塞队列的基本操作"></a>阻塞队列的基本操作</h1><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267ca3fc39tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>插入元素：</p><ul><li><p>add(E e)</p><blockquote><p>队列满时候，插入失败抛出IllegalStateException异常</p></blockquote></li><li><p>offer(E e)</p><blockquote><p>插入成功返回true，否则false</p></blockquote></li><li><p>put(E e)</p><blockquote><p>若阻塞队列已经满了，put线程会被阻塞，知道阻塞队列有空余容量可供使用</p></blockquote></li></ul><p>删除元素：</p><ul><li><p>remove(Object o)</p><blockquote><p>删除成功返回true，否则false</p></blockquote></li><li><p>poll()</p><blockquote><p>删除并返回队头元素，若为空，返回null</p></blockquote></li><li><p>take()</p><blockquote><p>删除并返回队头元素，若为空，take线程阻塞直到阻塞队列不为空</p></blockquote></li><li><p>poll(long timeout, TimeUnit unit)</p><blockquote><p>基本同take方法，增加了超时退出的功能（阻塞超过给定时长，该线程直接退出）</p></blockquote></li></ul><p>查看元素：</p><ul><li><p>element()</p><blockquote><p> 获取头元素，若队列为空，抛出异常NoSuchElementException</p></blockquote></li><li><p>peek()</p><blockquote><p> 获取头元素，若队列为空，抛出异常NoSuchElementException</p></blockquote></li></ul><h1 id="常用的BlockingQueue实现类"><a href="#常用的BlockingQueue实现类" class="headerlink" title="常用的BlockingQueue实现类"></a>常用的BlockingQueue实现类</h1><h2 id="常用实现类简介："><a href="#常用实现类简介：" class="headerlink" title="常用实现类简介："></a>常用实现类简介：</h2><ul><li><p>ArrayBlockingQueue</p><blockquote><p>ArrayBlockingQueue是由<strong>数组</strong>实现的<strong>有界阻塞队列</strong>。</p><p>该队列命令元素<strong>FIFO</strong>。因此，队列中元素按照进入队列时间排序。</p><p>ArrayBlockingQueue可作为“有界数据缓冲区”，一旦被创建，其<strong>容量不能改变</strong>。</p><p>线程访问队列的公平性：</p><ul><li><p>默认是非公平性访问，即一旦ArrauBlockingQueue可以被访问时，长时间阻塞的线程可能依然无法访问到ArrayBlockingQueue。</p></li><li><p>若要保证公平性，则在new ArrayBlockingQueue的时候加上true参数，获取公平性的Array BlockingQueue</p></li></ul></blockquote></li><li><p>LinkedBlockingQueue</p><blockquote><p>LinkedBlockingQueue使用链表实现的有界阻塞队列。</p><p>同样满足FIFO特性。比ArrayBlockingQueue相比具有更高的吞吐量。</p><p>为了防止LinkedBlockingQueue容量迅速增大，损耗大量内存，通常在创建LinkedBlockingQueue对象的时候会指定其大小，若未指定，其容量为Integer.MAX_VALUE</p></blockquote></li><li><p>PriorityBlockingQueue</p><blockquote><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。</p><p>排序方式：</p><ul><li>默认情况下元素采用自然顺序进行排序</li><li>也可以通过自定义类的compareTo()方法指定元素的排序规则</li><li>或则在初始化时通过构造器参数Comparator来指定排序规则</li></ul></blockquote></li><li><p>SynchronousQueue</p><blockquote><p>SynchronousQueue每个插入操作必须等待另一个线程进行相应的删除操作。</p><p>因此，SynchronousQueue实际上没有存储任何数据，删除和插入线程需要相互等待对方。</p><p>SynchronousQueue也可以通过构造器参数为其指定公平性</p></blockquote></li><li><p>LinkedTransferQueue</p><blockquote><p>LinkedTransferQueue是一个由链表数据结构构成的无界阻塞队列。</p><p>该队列实现了TransferQueue接口，与其他阻塞队列的不同方法：</p><ul><li><p>transfer(E e)</p><blockquote><p>如果当前有线程在执行take()方法或可延时的poll()方法进行消费数据，生产者线程可以调用transfer方法将数据直接传递给消费者线程。</p><p>若当前没有消费者线程消费数据，生产者线程会将数据插入队尾，直到有消费者进行消费才能退出</p></blockquote></li><li><p>tryTransfer(E e)</p><blockquote><p>与transfer相比，若当前没有线程在消费数据，则立即返回false。</p></blockquote></li><li><p>tryTransfer(E e, long timeout, timeUnit unit)</p><blockquote><p>与transfer相比，增加了超时特性，若超过规定时间没有消费者消费数据，则返回false</p></blockquote></li></ul></blockquote></li><li><p>LinkedBlockingDequeue</p><blockquote><p>LinkedBlockingDequeue是基于链表数据结构的有界阻塞双端队列。</p><p>LinkedBlockingDeque具有双端队列特性，其基本操作如下：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267d1586d2tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>LinkedBlockingDque实现的是BlockingDeque接口，而LinkedBlockingQueue实现的是BlockingQueue接口</p><p>两个接口区别如下：（两个接口的功能可以等价使用）</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267d5efe67tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p></blockquote></li><li><p>DelayQueue</p><blockquote><p>DelayQueue是一个存放实现Delayed接口数据的无界阻塞队列。</p><p>只有当数据对象的延时时间达到时才能插入到队列进行存储。</p><p>若当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过poll方法获取元素返回null。</p><p>所谓的数据延时期满时，是通过Delayed接口的getDelay()来进行判断的，若返回值小于等于0，说明数据元素的延时期已满。</p></blockquote></li></ul><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>阻塞队列最核心的功能是，可以阻塞式地插入和删除队列元素。当队列为空，会阻塞消费者线程，直至队列非空时，通知被阻塞地消费者线程；当队列满时，会阻塞插入数据地线程，直至队列未满时，通知被阻塞的生产者线程。</p><p>多线程中的消息通知最常用的是lock的condition机制。</p><h4 id="主要属性："><a href="#主要属性：" class="headerlink" title="主要属性："></a>主要属性：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存储数据相关的属性：</span><br><span class="hljs-comment">/** The queued items */</span><br><span class="hljs-keyword">final</span> Object[] items;<br><br><span class="hljs-comment">/** items index for next take, poll, peek or remove */</span><br><span class="hljs-type">int</span> takeIndex;<br><br><span class="hljs-comment">/** items index for next put, offer, or add */</span><br><span class="hljs-type">int</span> putIndex;<br><br><span class="hljs-comment">/** Number of elements in the queue */</span><br><span class="hljs-type">int</span> count;<br><br><span class="hljs-comment">//消息通知相关的属性：</span><br><span class="hljs-comment">/** Main lock guarding all access */</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><br><span class="hljs-comment">/** Condition for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-comment">/** Condition for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br><span class="hljs-comment">//构造方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    <span class="hljs-comment">//创建lock和condition</span><br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put方法："><a href="#put方法：" class="headerlink" title="put方法："></a>put方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//如果当前队列已满，将线程移入到notFull等待队列中</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br><span class="hljs-comment">//满足插入数据的要求，直接进行入队操作</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br><span class="hljs-comment">//1 插入数据</span><br>    items[putIndex] = x;<br>    <span class="hljs-comment">//更新putIndex和count属性</span><br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br><span class="hljs-comment">//2 通知消费者线程，当前队列中有数据可供消费</span><br>    notEmpty.signal();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="take方法："><a href="#take方法：" class="headerlink" title="take方法："></a>take方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//如果队列为空，没有数据，将消费者线程移入等待队列中</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br><span class="hljs-comment">//获取数据</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//1 获取数据</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    <span class="hljs-comment">//置为null，帮助GC</span><br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//更新takeInde和count属性</span><br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>        itrs.elementDequeued();<br>    <span class="hljs-comment">//2 通知被阻塞的生产者线程</span><br>notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><h4 id="主要属性：-1"><a href="#主要属性：-1" class="headerlink" title="主要属性："></a>主要属性：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Current number of elements */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">//头尾节点指针</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><span class="hljs-comment">//读锁与非空等待队列</span><br><span class="hljs-comment">/** Lock held by take, poll, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/** Wait queue for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<br><br><span class="hljs-comment">//写锁与未满等待队列</span><br><span class="hljs-comment">/** Lock held by put, offer, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/** Wait queue for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<br><br><span class="hljs-comment">//Node节点定义：</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>Node&lt;?&gt; next;<br><br>Node(E x) &#123; item = x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put方法：-1"><a href="#put方法：-1" class="headerlink" title="put方法："></a>put方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//封装数据为Node</span><br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    putLock.lockInterruptibly();<br>    <span class="hljs-comment">//插入Node</span><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//1 如果队列已满，则阻塞当前线程，将其移入等待队列</span><br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br>            notFull.await();<br>        &#125;<br><span class="hljs-comment">//2 入队操作，插入数据</span><br>        enqueue(node);<br>        <span class="hljs-comment">//3 如果入队过后队列还没有满，唤醒其他被阻塞的生产者线程</span><br>        c = count.getAndIncrement();<br>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>            notFull.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        putLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>        signalNotEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="take方法：-1"><a href="#take方法：-1" class="headerlink" title="take方法："></a>take方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    E x;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;<br>    takeLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件</span><br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>            notEmpty.await();<br>        &#125;<br><span class="hljs-comment">//移除队头元素，获取数据</span><br>        x = dequeue();<br>        c = count.getAndDecrement();<br>        <span class="hljs-comment">//如果当前满足移除元素的条件，则通知被阻塞的消费者线程</span><br><span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>            notEmpty.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        takeLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == capacity)<br>        signalNotFull();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ABQ和LBQ比较"><a href="#ABQ和LBQ比较" class="headerlink" title="ABQ和LBQ比较"></a>ABQ和LBQ比较</h3><p>相同点：</p><p>都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性。</p><p>不同点：</p><ul><li>底层实现：ABQ是数组，LBQ是链表</li><li>锁：ABQ插入和删除采用同一个锁，LBQ在插入和删除分别一个锁，降低阻塞，提高并发效率</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ThreadLocal</title>
    <link href="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/"/>
    <url>/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h1><p>加锁的弊端：</p><blockquote><p>多线程编程中通过synchronized或者lock控制对临界区资源的同步顺序从而解决线程安全的问题。</p><p>通过加锁的方式或让未获取锁的线程阻塞等待，这种方式时间效率并不是很好。</p></blockquote><p>空间换时间：</p><blockquote><p>线程安全问题的核心在于多个线程会对同一临界区共享资源进行操作，若让每个线程使用自己的“共享资源”，那么多个线程互相隔离，就不会出现线程安全的问题。这实际上是一种“空间换时间”的方案，每个线程拥有自己的“共享资源”会占用大量内存，但是不需要同步也就避免了阻塞等待的情况。</p></blockquote><p>虽然ThreadLocal并不是在java.util.concurrent包中而在Java.lang包中，但是我更倾向于将其作为一种并发容器（虽然真实存放的数据是ThreadLocalMap）进行归类。</p><p>从ThreadLocal这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量的副本，达到人手一份的效果，各自用各自的就可以避免共享资源的竞争。</p><h1 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h1><h2 id="void-set-T-value"><a href="#void-set-T-value" class="headerlink" title="void set (T value)"></a>void set (T value)</h2><blockquote><p>set方法设置在前线程中的threadLocal变量的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程实例对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//2. 通过当前线程实例获取到ThreadLocalMap对象</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//3. 如果Map不为null,则以当前threadLocl实例为key,值为value进行存入</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br><span class="hljs-comment">//4.map为null,则新建ThreadLocalMap并存入value</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ThreadLocalMap：</p><ul><li><p>数据真正存放在ThreadLocalMap中，key为当前threadLocal实例</p></li><li><p>ThreadLocalMap的引用作为Thread类的一个属性，被Thread维护</p><ul><li>getMap方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>createMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="T-get"><a href="#T-get" class="headerlink" title="T get()"></a>T get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程的实例对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//2. 获取当前线程的threadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//3. 获取map中当前threadLocal实例为key的值的entry</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//4. 当前entitiy不为null的话，就返回相应的值value</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>map为空时的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//若map已经创建</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-comment">//若map还没创建</span><br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-comment">//initialValue类为protected，表示继承ThreadLocal的类可以通过重写该方法设置默认值</span><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="void-remove"><a href="#void-remove" class="headerlink" title="void remove()"></a>void remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程的threadLocalMap</span><br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br> <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//2. 从map中删除以当前threadLocal实例为key的键值对</span><br>m.remove(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ThreadLocalMap详解"><a href="#ThreadLocalMap详解" class="headerlink" title="ThreadLocalMap详解"></a>ThreadLocalMap详解</h1><p>ThreadLocal类的get、set和remove都是通过调用其属性threadLocals（ThreadLocalMap）的getEntry、set和remove实现的。</p><h2 id="Entry数据结构"><a href="#Entry数据结构" class="headerlink" title="Entry数据结构"></a>Entry数据结构</h2><p>ThreadLocalMap是ThreadLocal的一个静态内部类。和大多数容器一样，其内部维护了一个数组，ThreadLocalMap内部维护了一个Entry类型的tabel数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>    <span class="hljs-comment">//数组会根据需要扩容</span><br>    <span class="hljs-comment">//数组的长度必须是2的幂次方</span><br>    <span class="hljs-keyword">private</span> Entry[] table;<br>    ...<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br>Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>    <span class="hljs-built_in">super</span>(k);<br>    value = v;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Entry是一个以ThreadLocal为key，Object为value的键值对。</p></li><li><p>ThreadLocal是弱引用，因为Entry继承了WeakReference。</p></li><li><p>Entry的构造方法中，调用了super(k)将ThreadLocal实例包装成一个WeakReference</p></li></ul><h2 id="Thread、ThreadLocal、ThreadLocalMap之间的关系"><a href="#Thread、ThreadLocal、ThreadLocalMap之间的关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap之间的关系"></a>Thread、ThreadLocal、ThreadLocalMap之间的关系</h2><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbmNlbnRfd2VuMDc2Ng==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>ThreadLocal数据实际的存放：</p><blockquote><p>每一个线程实例都有一个ThreadLoaclMap实例的属性，ThreadLocalMap中维护了一个Entry数组用于存放不同ThreadLocal实例存放的数据。</p></blockquote><p>通过ThreadLocal存取数据：</p><blockquote><p>ThreadLocal不存储数据，其提供一些方法，操作这些数据。</p><p>通过当前线程实例获取当前线程实例的ThreadLocalMap（在不同的方法中执行，获取的是不同的ThreadLocalMap），然后使用ThreadLocal本身作为key，从ThreadLocalMap中的Entry数组中获取ThreadLocal存放在当前线程中的value。</p></blockquote><p>ThreadLocal根据当前线程获取当前线程对应的ThreadLocalMap（每个线程对应一个ThreadLocalMap），该ThreadLocalMap可以存储多个不同ThreadLocal实例存储在当前线程中的数据（一个ThreadLocal实例可以分别在多个线程中存储一个value）</p><p>ThreadLocal内存泄漏问题：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/16334681776bb805tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="ThreadLocal各引用间的关系"></p><p>Entry中的key是弱引用，当ThreadLocal实例引用被置为null后，这个ThreadLocal实例不可达，会被GC回收，那么ThreadLocalMap中就会出现key为null的额Entry，这个Entry无法被访问，也无法被回收。若线程不结束，这个key为null的Entry会一直存在，无法回收，造成内存泄漏。虽然在线程结束后，线程相关的所有类都会被回收，但是在实际的开发中，会使用线程池，线程为了被复用不会主动结束，这样垃圾也就一直不能被回收。所以在使用完ThreadLocal后，主动的通过remove移除对应的Entry，避免内存泄漏。</p><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><p>ThreadLocalMap通过散列表进行实现。在了解set方法前，先回顾下散列表的相关知识。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。</p><p>理想散列表：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177649b66tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="理想散列表的一个示意图"></p><p>散列冲突：</p><p>在理想状态下，哈希函数可以将关键字均匀地分散到数组地不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称之为散列冲突。</p><p>散列冲突解决：</p><ul><li><p>分离链表法</p><blockquote><p>分离链表法使用链表解决冲突，将散列值相同的元素都保存在一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素。</p><p>典型实现为HashMap和ConcurrentHashMap的拉链法。</p><p>示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177fb894ctplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="分离链表法示意图"></p></blockquote></li><li><p>开放定址法</p><blockquote><p>开放定址法不会创建链表，当关键字散列到的数组单元已经被另一个关键字占用的时候，就会尝试在数组中寻找其他单元，直到找到空的单元。探测数组空单元的方法有很多，最简单的一种为线性探测法。线性探测法就是从发生冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。</p><p>示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177ede9abtplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="开放定址法示意图"></p></blockquote></li></ul><p>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用分离链表法。</p><p>因为ThreadLocalMap中打散列值分散十分均匀，很少发生冲突，并且ThreadLocalMap经常要清除无用对象，使用纯数组更方便。</p><h3 id="set方法源码"><a href="#set方法源码" class="headerlink" title="set方法源码"></a>set方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">//根据threadLocal的hashCode确定Entry应该存放的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp;amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//采用开放地址法，hash冲突的时候使用线性探测</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//覆盖旧Entry</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//当key为null时，说明threadLocal强引用已经被释放掉，那么就无法</span><br>        <span class="hljs-comment">//再通过这个key获取threadLocalMap中对应的entry，这里就存在内存泄漏的可能性</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//用当前插入的值替换掉这个key为null的“脏”entry</span><br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//新建entry并插入table中i处</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <br>    <span class="hljs-comment">//插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容</span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><p>set方法中需要注意的点：</p><ol><li><p>ThreadLocal的hashcode？</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the next hash code.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal实例的hashCode是通过nextHashCode()方法实现的，该方法通过一个AtomicInteger加上0x61c88647来实现。0x61c88647这个数可以保证hash表的每个散列桶能均匀分布。</p></blockquote></li><li><p>怎样确定新值插入到哈希表中的位置？</p><blockquote><p>该操作源码为： key.threadLocalHashCode &amp; (len - 1)，同HashMap和ConcurrentHashMap等容器的方式一样，利用当前key的hashCode与哈希表想与（因为哈希表大小总是2的幂次方，所以想与操作等同于一个取模操作），这样就可以通过key分配到具体的哈希桶中。</p></blockquote></li><li><p>怎样解决hash冲突？</p><blockquote><p>源码中通过nextIndex(i, len)方法来解决hash冲突，该方法为((i + 1 &lt; len) ? i + 1 : 0)，也就是线性探测。</p></blockquote></li><li><p>怎样解决“脏”Entry？</p><blockquote><p>在分析ThreadLocal、ThreadLocalMap和Enty的关系的时候，我们知道ThreadLocal可能存在内存泄漏，在源码中针对key为null的Entry称之为“stale entry”，直译为不新鲜的entry，可以理解为“脏entry”。</p><p>set方法的for循环中寻找到和当前key相同的可覆盖entry的时候，若该entry为“脏entry”则通过replaceStaleEntry方法来解决脏entry。若当前table[i]为null，直接插入新entry后也会执行cleanSomeSlots来解决脏entry问题。</p></blockquote></li><li><p>如何进行扩容？</p><blockquote><p>threshold的确定：</p><p>threshold表示当前哈希表的可用容量。</p><p>在第一次对ThreadLocal进行赋值的时候会创建一个大小为16的ThreadLocalMap，并通过setThreshold方法设置threshold 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next size value at which to resize.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Set the resize threshold to maintain at worst a 2/3 load factor.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其值为哈希数组长度乘以2&#x2F;3，也就是说加载因子为2&#x2F;3。（加载因子过小，内存利用率不高但是hash冲突可能性小，过大，hash冲突的可能性增大）</p><p>resize()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Double the capacity of the table.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1 创建新数组，长度为原数组的2倍</span><br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//2 移动旧数组元素到新数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-comment">//遍历过程中如果遇到脏entry的话</span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//直接置value为null,有助于value能够被回收</span><br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//重新确定entry在新数组的位置，然后进行插入</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    .-*<br>                    看，。看来你h90 <span class="hljs-number">798</span> = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>           &#125;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//3 设置新哈希表的threshHold和size属性</span><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="getEntry方法"><a href="#getEntry方法" class="headerlink" title="getEntry方法"></a>getEntry方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br><span class="hljs-comment">//1. 确定在散列数组中的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//2. 根据索引i获取entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br><span class="hljs-comment">//3. 满足条件则返回该entry</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br><span class="hljs-comment">//4. 未查找到满足条件的entry，额外在做的处理(hash冲突)</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-comment">//找到和查询的key相同的entry则返回</span><br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//解决脏entry的问题</span><br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//继续向后环形查找</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove the entry for key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br><span class="hljs-comment">//将entry的key置为null</span><br>            e.clear();<br><span class="hljs-comment">//将该entry的value也置为null</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Thread-Local的使用场景"><a href="#Thread-Local的使用场景" class="headerlink" title="Thread Local的使用场景"></a>Thread Local的使用场景</h1><p>ThreadLocal不是用来解决共享对象的多线程访问问题的，数据实质上是放在每个thread实例引用的threadLocalMap中，也就是说每个不同的线程都拥有专属于自己的数据容器（threadLcoalMap），彼此不印象。</p><p>因此ThreadLocal只适用于共享对象会造成线程安全问题的业务场景。比如hibernate中通过threadLocal管理Session就是一个典型的案例，不同的请求线程（用户）拥有自己的Session，若将session共享出去被多线程访问，必然带来线程安全问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ConcurrentLinkedQueue</title>
    <link href="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/"/>
    <url>/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/</url>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentLinkedQueue简介"><a href="#ConcurrentLinkedQueue简介" class="headerlink" title="ConcurrentLinkedQueue简介"></a>ConcurrentLinkedQueue简介</h1><p>ConcurrentLinkedQueue是一个线程安全的队列，其数据结构是链表。</p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>ConcurrentLinkedQueue的底层节点类Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        <span class="hljs-keyword">volatile</span> E item;<br>        <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br>.......<br>&#125;<br></code></pre></td></tr></table></figure><p>Node包含两个属性：（都使用volatile修饰，保证内存可见性）</p><ul><li><p>一个数据域item，用于保存数据</p></li><li><p>一个next指针，用于构成链式队列</p></li></ul><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;<br></code></pre></td></tr></table></figure><p>ConcurrentLinkedQueue通过持有链表的头尾节点来管理队列。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentLinkedQueue</span><span class="hljs-params">()</span> &#123;<br>    head = tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/1633459982863c26tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="1.ConcurrentLinkedQueue初始化状态.png"></p><h2 id="操作Node的几个CAS操作"><a href="#操作Node的几个CAS操作" class="headerlink" title="操作Node的几个CAS操作"></a>操作Node的几个CAS操作</h2><p>在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更改Node中的数据域item</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casItem</span><span class="hljs-params">(E cmp, E val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, itemOffset, cmp, val);<br>&#125;<br><span class="hljs-comment">//更改Node中的指针域next</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySetNext</span><span class="hljs-params">(Node&lt;E&gt; val)</span> &#123;<br>    UNSAFE.putOrderedObject(<span class="hljs-built_in">this</span>, nextOffset, val);<br>&#125;<br><span class="hljs-comment">//更改Node中的指针域next</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, nextOffset, cmp, val);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些方法实际上通过UNSAFE实例的方式，UNSAFE位sun.misc.Unsafe类，该类是hotspot底层方法。</p><h1 id="offer-方法"><a href="#offer-方法" class="headerlink" title="offer()方法"></a>offer()方法</h1><p>关于offer源码的思考方向：</p><ul><li><p>单线程offer</p></li><li><p>多个线程offer</p></li><li><p>部分线程offer，部分线程poll</p><ul><li><p>offer的速度快于poll</p><blockquote><p>队列长度越来越长，offer在队列尾部操作，poll在队头，两个线程不会互相影响</p></blockquote></li><li><p>poll的速度快于offer</p><blockquote><p>队列会越来越短，offer线程和poll线程会出现“交集”，这一时刻可以称offer线程和poll线程同时操作的节点为临界点。</p><p>对于该临界点poll和offer的发生相对顺序的思考角度：</p><ul><li><p>offer-poll-offer</p><blockquote><p>当offer线程在Node1后扎入Node2时，此时poll线程已经将Node1删除，这种情况需要在offer方法中考虑</p></blockquote></li><li><p>poll-offer-poll</p><blockquote><p>当poll线程准备删除节点（队列为空），此时offer线程插入一个节点使得队列为非空，这种情况应该是poll线程考虑</p></blockquote></li></ul></blockquote></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//null判断</span><br>    checkNotNull(e);<br>    <span class="hljs-comment">//将数据包装成一个Node类</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>    <span class="hljs-comment">//循环直到成功插入Node</span><br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<br>        <span class="hljs-comment">//t为tail,但是tail并不一定指向真正的尾节点，因为tail是被延迟更新的</span><br>        <span class="hljs-comment">//p为指针用于寻找真正尾节点，q用于辅助p判断是否到达尾节点</span><br>        Node&lt;E&gt; q = p.next;<br>        <span class="hljs-comment">//1 p为尾节点，执行插入</span><br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//CAS插入新节点，如果CAS失败会在下一次循环重试</span><br>            <span class="hljs-keyword">if</span> (p.casNext(<span class="hljs-literal">null</span>, newNode)) &#123;<br>                <span class="hljs-comment">//插入节点成功后更新tail（tail延迟更新机制）</span><br>                <span class="hljs-comment">//p为真尾节点，t为tail，如果tail没有指向真尾节点，则更新tail</span><br>                <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// hop two nodes at a time</span><br>                casTail(t, newNode);  <span class="hljs-comment">// Failure is OK.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//2 p不为尾节点，移动p指针直到找到尾节点</span><br>        <span class="hljs-comment">//2.1 p节点其next指向自己，这种节点称之为哨兵节点，说明在本线程执行offer的过程中，p节点被删除了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>            p = (t != (t = tail)) ? t : head;<br>        <span class="hljs-comment">//2.2 如果p指向的不是真正的尾节点</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//移动p指针，寻找真正尾节点</span><br>            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单线程offer分析"><a href="#单线程offer分析" class="headerlink" title="单线程offer分析"></a>单线程offer分析</h2><p>单线程相关代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br></code></pre></td></tr></table></figure><p>在单线程中，条件(p !&#x3D; t &amp;&amp; t !&#x3D; (t &#x3D; tail))一定为false，所以单线程offer中该代码段等价于p &#x3D; q</p><h2 id="多线程offer分析"><a href="#多线程offer分析" class="headerlink" title="多线程offer分析"></a>多线程offer分析</h2><p>多线程offer相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">t != (t = tail))<br></code></pre></td></tr></table></figure><p>若在执行offer操作的过程中，有其他的offer线程执行完毕（tail值可能更新），左边t为旧值压入栈中，右边t被赋予新的tail值，该表达式为真，说明tail更新，直接将tail赋予p</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599933a4aabtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="5.线程A和线程B有可能的执行时序.png"></p><h2 id="offer-poll-offer分析"><a href="#offer-poll-offer分析" class="headerlink" title="offer-poll-offer分析"></a>offer-poll-offer分析</h2><p>初始状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599c2390c2btplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="10.offer和poll相互影响分析时队列初始状态.png"></p><p>在执行offer的时候，有一个线程完成poll：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599cd4cbdabtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="11.线程A和线程B可能存在的执行时序.png"></p><p>另一个线程完成poll后的状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599d7d92981tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="12.线程B进行poll后队列的状态图.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>    p = (t != (t = tail)) ? t : head;<br></code></pre></td></tr></table></figure><p>p &#x3D;&#x3D; q表示在当前线程在执行offer操作的时候，其他线程已经将p设置为哨兵节点了，此时需要重新给p赋值来寻找真正的尾节点</p><p>由前面的多线程分析可知，若t !&#x3D; (t &#x3D; tail))为真，说明在当前线程执行offer期间tail更新了，则将p置为tail，若没有，则将p置为head（因为其他线程设置哨兵节点的时候肯定会更新head）</p><h1 id="poll-方法"><a href="#poll-方法" class="headerlink" title="poll()方法"></a>poll()方法</h1><p>poll方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//标记点</span><br>    restartFromHead: <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//初始化h,p,q</span><br>        <span class="hljs-comment">//p指针用于寻找真正的头节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;; p = q) &#123;<br>            <span class="hljs-keyword">final</span> E item;<br>            <span class="hljs-comment">//1 若p为头节点，CAS将其数据item置为null（若CAS失败，则会等待下一次循环重试）</span><br>            <span class="hljs-keyword">if</span> ((item = p.item) != <span class="hljs-literal">null</span> &amp;&amp; p.casItem(item, <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-comment">//1.1 若真正的头节点不为head，则更新head</span><br>                <span class="hljs-keyword">if</span> (p != h) <span class="hljs-comment">// hop two nodes at a time</span><br>                    <span class="hljs-comment">//若p为尾节点，则将p置为head，若p不为尾节点，则将p.next置为head</span><br>                    updateHead(h, ((q = p.next) != <span class="hljs-literal">null</span>) ? q : p);<br>                <span class="hljs-comment">//1.2 返回头节点数据</span><br>                <span class="hljs-keyword">return</span> item;<br>            &#125;<br>            <span class="hljs-comment">//2 若队列为空，返回null</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                updateHead(h, p);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//3 若p已经被其他线程给poll出去了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>                <span class="hljs-comment">//返回标记点重试poll操作</span><br>                <span class="hljs-keyword">continue</span> restartFromHead;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更新head</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateHead</span><span class="hljs-params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> &#123;<br>    <span class="hljs-keyword">if</span> (h != p &amp;&amp; casHead(h, p))<br>        <span class="hljs-comment">//lazySetNext将h的next设置为其自己</span><br>        h.lazySetNext(h);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="head属性的延迟更新"><a href="#head属性的延迟更新" class="headerlink" title="head属性的延迟更新"></a>head属性的延迟更新</h2><p>初始状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599936bd919tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="6.队列初始状态.png"></p><p>第一次poll过后的状态：</p><blockquote><p>只是简单的将head指向的节点item置为null，标记其已经被poll出去了</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/163345999f3d68bbtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="7.队列出队操作后的状态.png"></p><p>第二次poll：</p><ul><li><p>第一次循环结束：</p><blockquote><p>第一次循环p指针指向的不是真正的head，所以第一次循环只是移动p指针</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599bd85583btplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="8.经过一次循环后的状态.png"></p></li><li><p>第二次循环结束：</p><blockquote><p>经过第一次循环移动p指着过后，此时p已经指向真正的头节点，此时执行updateHead设置head</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599be78fddetplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="9.Node2从队列中出队后的状态.png"></p></li></ul><h2 id="单线程poll分析"><a href="#单线程poll分析" class="headerlink" title="单线程poll分析"></a>单线程poll分析</h2><ul><li>若p指向节点的item不为null，说明该节点为真正头节点（待删除节点）<ul><li>若p与head相等，只需要将其item置为null，不需要真正执行删除</li><li>若不相等，则需要使用updateHead更新head，真正执行删除（）</li><li>最后返回item即可。</li></ul></li><li>若p指向的节点item为null，说明该节点并非真正的头节点，那么就需要移动p指针寻找真正头节点（item不为null的节点）</li></ul><h2 id="多线程poll分析"><a href="#多线程poll分析" class="headerlink" title="多线程poll分析"></a>多线程poll分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>    <span class="hljs-keyword">continue</span> restartFromHead;<br></code></pre></td></tr></table></figure><p>p &#x3D;&#x3D; q说明p指向的节点已经称为哨兵节点，即已经被其他线程poll出去了，则需要从restartFromHead重新开始执行poll，重新用到的是最新的head</p><h2 id="poll-offer-poll情况分析"><a href="#poll-offer-poll情况分析" class="headerlink" title="poll-offer-poll情况分析"></a>poll-offer-poll情况分析</h2><p>在执行poll线程的时候，若执行到else if ((q &#x3D; p.next) &#x3D;&#x3D; null) 已经判断队列为空了，这时另一个线程完成了offer操作，此时线程已经判断队列为空，但是实际上队列不为空，该线程仍会返回null</p><p>所以说判断空队列不能通过poll操作返回null进行判断，而是要使用isEmpty方法进行判断。</p><h1 id="HOPS的设计"><a href="#HOPS的设计" class="headerlink" title="HOPS的设计"></a>HOPS的设计</h1><h2 id="tail和head更新触发机制"><a href="#tail和head更新触发机制" class="headerlink" title="tail和head更新触发机制"></a>tail和head更新触发机制</h2><p>通过上面个的offer和poll的分析，我们可知tail和head的更新是延迟的，二者的更新触发机制：</p><ul><li>tail更新：当tail指向的节点的下一个节点不为null的时候（不是真正的尾节点），会执行定位队列真正尾节点的操作，找到尾节点后完成插入操作之后，才会通过casTail进行tail的更新；当tail指向的下一个节点为null的时候，只插入节点不更新tail</li><li>head更新：当head指向的节点的item域为null的时候，会执行定位队列真正头节点的操作，找到头节点后完成删除之后，通过updateHead更新head，当head指向的item不为null的时候，只删除节点不更新head</li></ul><h2 id="延迟更新的目的"><a href="#延迟更新的目的" class="headerlink" title="延迟更新的目的"></a>延迟更新的目的</h2><p>更新tail和head是CAS操作，使用延迟更新可以减少CAS更新的操作。通过p指针定位头尾节点操作，来代替每次都CAS更新头尾节点的操作，提高offer和poll操作的效率。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-CopyOnWriteArrayList</title>
    <link href="/2022/10/18/Java%E5%B9%B6%E5%8F%91-CopyOnWriteArrayList/"/>
    <url>/2022/10/18/Java%E5%B9%B6%E5%8F%91-CopyOnWriteArrayList/</url>
    
    <content type="html"><![CDATA[<h1 id="CopyOnWriteArrayList简介"><a href="#CopyOnWriteArrayList简介" class="headerlink" title="CopyOnWriteArrayList简介"></a>CopyOnWriteArrayList简介</h1><p>ArrayList并不是线程安全的，可以使用Vector，或者Collections的静态方法将ArrayList包装成一个线程安全的类，这两种方式都是使用synchronized加锁的方式，利用独占锁来保证线程安全的，效率低。</p><p>业务场景，很多业务都是读多写少的：</p><ul><li><p>比如系统配置信息，除了在初始进行系统配置的时候需要写入数据，其他大部分时刻都只需要读取配置</p></li><li><p>又比如白名单、黑名单</p></li></ul><p>读多写少的情况可以使用ReentrantReadWriteLock：</p><ul><li>优点：读写分离，读读之间不会阻塞</li><li>局限：写锁被写线程获取后，读线程会被阻塞</li></ul><p>CopyOnWriteArrayList容器可以解决读写锁的局限性。</p><h1 id="COW的设计思想"><a href="#COW的设计思想" class="headerlink" title="COW的设计思想"></a>COW的设计思想</h1><p>COW通俗理解：</p><p>COW通俗的理解是当我们往容器中添加一个元素的时候，不直接往容器中添加，而是先将当前容器进行Copy，复制出来一个新的容器，然后将元素添加到新的容器中，添加完元素后，再将原容器的引用指向新容器。</p><p>对CopyOnWrite容器进行并发读的时候，不用加锁，因为当前容器不会添加新元素。</p><p>对CopyOnWrite容器进行并发写的时候，是在新建的容器中执行写，所以读取到的数据会有延迟，放弃了数据实时性。</p><p>数据实时性：</p><p>若是简单的使用读写锁，在写锁被获取后，读写线程都会被阻塞，只有当写锁释放后，读线程才有机会获取到读锁读取数据。站在读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性。COW通过<strong>牺牲数据实时性</strong>，满足数据的最终一致性来避免读线程的阻塞。</p><h1 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h1><p>数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//该数组只能通过getArray()和setArray()方法访问</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></td></tr></table></figure><ul><li><p>CopyOnWriteArrayList内部维护的是一个数组。</p></li><li><p>该数组引用被volatile修饰，保证其可见性。</p></li></ul><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><span class="hljs-keyword">final</span> Object[] getArray() &#123;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br><span class="hljs-comment">//1. 使用Lock,保证写线程在同一时刻只有一个</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//2. 获取旧数组引用</span><br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br><span class="hljs-comment">//3. 创建新的数组，并将旧数组的数据复制到新数组中</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//4. 往新数组中添加新的数据</span><br>newElements[len] = e;<br><span class="hljs-comment">//5. 将旧数组引用指向新的数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="COW-vs-读写锁"><a href="#COW-vs-读写锁" class="headerlink" title="COW vs 读写锁"></a>COW vs 读写锁</h2><p>相同点：</p><ul><li>两种都是通过读写分离的思想实现</li><li>读线程间是互不阻塞的</li></ul><p>不同点：</p><ul><li>读写锁：为了实现数据实时性，在写锁被获取后，读线程会被阻塞。为了解决“脏读”问题，读锁被获取后，写线程会被阻塞</li><li>COW则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延迟感知的，因此读线程永远不会被阻塞。</li></ul><h2 id="COW的缺点"><a href="#COW的缺点" class="headerlink" title="COW的缺点"></a>COW的缺点</h2><ul><li>内存占用问题：因为COW的运行机制，在写操作的时候，内存中会有两个对象（旧容器和新容器）。</li><li>数据一致性问题：COW容器只能保证数据的最终一致性，不能保证数据的实时一致性。（弱一致性）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-ConcurrentHashMap</title>
    <link href="/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/"/>
    <url>/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashmap简介"><a href="#ConcurrentHashmap简介" class="headerlink" title="ConcurrentHashmap简介"></a>ConcurrentHashmap简介</h1><p>HashMap在多线程情况下扩容可能会陷入死循环。</p><p>线程安全的map使用：</p><ul><li>hashtable类</li><li>Collections提供的方法将map包装成线程安全的map。Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</li><li>concurrentHashMap</li></ul><p>上面两种方式都是通过synchronized关键字来实现线程安全的。</p><p>concurrentHashMap的不同版本：</p><ul><li><p>JDK1.6</p><blockquote><ul><li>segment继承ReentrantLock充当锁的角色,为每一个segement提供线程安全保障</li><li>每个segment维护了哈希散列表的若干个桶,每个桶由HashEntry构成链表</li></ul></blockquote></li><li><p>JDK1.8</p><blockquote><ul><li><p>通过synchronized和CAS无锁操作</p><blockquote><p>1.8中的synchronized引入了锁升级的机制，使得其性能相较于ReentrantLock的性能持平甚至更优</p></blockquote></li><li><p>底层数据结构改变为数组 + 链表 + 红黑树</p></li></ul></blockquote></li></ul><h1 id="关键属性及类"><a href="#关键属性及类" class="headerlink" title="关键属性及类"></a>关键属性及类</h1><h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><ul><li><p>table</p><blockquote><p>volatile Node&lt;K,V&gt;[] table：装载Node的数组</p><p>作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是2的幂次方</p></blockquote></li><li><p>nextTable</p><blockquote><p>volatile Node&lt;K,V&gt; nextTabele：扩容时使用</p><p>平时为null，在扩容的时候为非null</p></blockquote></li><li><p>sizeCtl</p><blockquote><p>volatile int sizeCtl：用于控制table数组的大小</p><p>根据是否初始化和是否正在扩容有集中情况：</p><ul><li><p>值为负：</p><ul><li>-1：正在初始化</li><li>-N：当前正有N-1个线程进行扩容操作</li></ul></li><li><p>值为正：</p><ul><li><p>如果数组为null，表示table正在初始化，sizeCtl表示初始化数组的长度</p></li><li><p>若数组不为null，表示已经初始化完毕，sizeCtl表示临界值</p><blockquote><p>插入节点数超过临界值后需要扩容，具体指数组容量乘以加载因子（loadFactor）</p></blockquote></li><li><p>当值为0时，即数组长度为默认初始长度</p></li></ul></li></ul></blockquote></li><li><p>sun.misc.Unsafe U</p><blockquote><p>ConcurrentHashMap的实现中大量的使用CAS来修改ConcurrentHashMap的一些属性。就是通过调用Unsafe类的compareAndSwapXXXX的方法实现的。</p><p>该类提供了一些可以直接操控内存和线程的底层操作，可以理解为Java中的“指针”。</p><p>该成员变量的获取是在静态代码中执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        U = sun.misc.Unsafe.getUnsafe();<br>        .......<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li><p>Node</p><blockquote><p>Node类实现了Map.Entry接口，主要存放key-value对，且拥有next域，由于链接成链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>TreeNode</p><blockquote><p>继承于Node类。</p><p>而红黑树的操作是针对TreeBin类，TreeNode会被TreeBin封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-type">boolean</span> red;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>TreeBin</p><blockquote><p>TreeBin，不负责包装用户的key-value信息，而是包装很多的TreeNode节点。</p><p>ConcurrentHashMap的“数组”中，存放的是TreeBin对象，而不是TreeNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    TreeNode&lt;K,V&gt; root;<br>    <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<br>    <span class="hljs-keyword">volatile</span> Thread waiter;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lockState;<br>    <span class="hljs-comment">// values for lockState</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WRITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">READER</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>ForwardingNode</p><blockquote><p>该节点在扩容的时候才会出现，其key、value和hash全为null。</p><p>其拥有nextTable指针引用新的table数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;<br>    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.nextTable = tab;<br>    &#125;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h1 id="重点方法解析"><a href="#重点方法解析" class="headerlink" title="重点方法解析"></a>重点方法解析</h1><h2 id="CAS关键操作"><a href="#CAS关键操作" class="headerlink" title="CAS关键操作"></a>CAS关键操作</h2><p>ConcurrentHashMap中会大量使用CAS修改它的属性和一些操作，在理解其他方法之前先了解如下几个常用的CAS算法，用于保障线程安全。</p><ul><li><p>tabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取table数组中索引为i的Node元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>casTabAt</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//CAS操作设置table数组中索引为i的元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i,</span><br><span class="hljs-params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;<br>    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置table数组中索引为i的元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;<br>    U.putObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="实例构造器方法"><a href="#实例构造器方法" class="headerlink" title="实例构造器方法"></a>实例构造器方法</h2><h3 id="ConcurrentHashMap提供的构造器方法："><a href="#ConcurrentHashMap提供的构造器方法：" class="headerlink" title="ConcurrentHashMap提供的构造器方法："></a>ConcurrentHashMap提供的构造器方法：</h3><p>构造器方法只是确定了table数组的长度，并未进行table数组的初始化。等到第一次插入数据的时候，table数组才真正进行初始化工作。</p><ul><li><p>ConcurrentHashMap()</p><blockquote><p>默认map大小为16</p></blockquote></li><li><p>ConcurrentHashMap(int initalCapacity)</p><blockquote><p>给定map的大小</p></blockquote></li><li><p>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</p><blockquote><p>给定一个map用于创建ConcurrentHashMap</p></blockquote></li><li><p>ConcurrentHashMap(int initialCapacity, float loadFactor)</p><blockquote><p>给定map的大小和记载因子</p></blockquote></li><li><p>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</p><blockquote><p>给定map的大小、加载因子和并发度（预计同时操作数据的线程）</p></blockquote></li></ul><h3 id="给定map大小的构造器方法解析"><a href="#给定map大小的构造器方法解析" class="headerlink" title="给定map大小的构造器方法解析"></a>给定map大小的构造器方法解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造器的工作只有给sizeCtl赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br><span class="hljs-comment">//1. 小于0直接抛异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ?<br>               MAXIMUM_CAPACITY :<br>               <span class="hljs-comment">//将输入的值转化为一个2的幂次方数</span><br>               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));<br><span class="hljs-comment">//3. 赋值给sizeCtl</span><br>    <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-comment">//若table还未初始化，或者table的长度为0，通过while循环执行初始化</span><br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1 sizeCtl &lt; 0，说明已经有线程在初始化table了</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">//让出CPU时间片</span><br>            Thread.yield();<br>        <span class="hljs-comment">//2 CAS设置sizeCtl状态为-1，表示有线程在执行初始化</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">//2.1 若CAS成功，说明没有其他线程在执行初始化，则当前线程执行初始化工作</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//得出数组的大小</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//这里才真正的初始化数组</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br><span class="hljs-comment">//计算数组中可用的大小：实际大小n*0.75（加载因子）</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//在finally中为sizeCtl赋值，退出初始化状态</span><br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-comment">//初始化完成，退出while循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//2.2 若CAS失败，说明有其他线程在执行初始化且CAS竞争成功，则线程在while循环中spin直到初始化操作完成</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-comment">//计算key的hash值（spread对hashCode进行重哈希，以减小Hash冲突）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br><span class="hljs-comment">//1 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <br>        <span class="hljs-comment">//获取table中索引为i的元素f</span><br><span class="hljs-comment">//2 tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br><span class="hljs-comment">//3 当前正在扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-comment">//4 索引i处已经有数据，将node插入该处的链表或树</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//使用同步代码块的方式，锁定</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br><span class="hljs-comment">//4.1 当前为链表，在链表中插入新的键值对</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">//初始化指针e，每一次循环都会将e后移动，有两个出口</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-comment">//出口一、若节点key与要插入的key相同，则覆盖旧值即可</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-comment">//出口二、e到达链表结尾，新建节点插入链表</span><br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br><span class="hljs-comment">//4.2 当前为红黑树，将新的键值对插入到红黑树中</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">//4.3 插入完键值对后再根据实际大小看是否需要转换成红黑树</span><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//临界值为8</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//5 对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcurrentHashMap是一个哈希桶数组，结构如下：</p><p><img src="/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/163344e982f9eed4tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="ConcurrentHashMap散列桶数组结构示意图"></p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br><span class="hljs-comment">//重hash</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//1. table[i]桶节点的key与查找的key相同，则直接返回</span><br><span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br><span class="hljs-comment">//2. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//3. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br><span class="hljs-comment">//1. 新建Node数组，容量为之前的两倍</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// initiating</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nextTable = nextTab;<br>        transferIndex = n;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br><span class="hljs-comment">//2. 新建forwardingNode引用，在之后会用到</span><br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>        <span class="hljs-comment">// 3. 确定遍历中的索引i</span><br><span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-type">int</span> nextIndex, nextBound;<br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                advance = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                     (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                      nextBound = (nextIndex &gt; stride ?<br>                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//4.将原数组中的元素复制到新数组中去</span><br><span class="hljs-comment">//4.5 for循环退出，扩容结束修改sizeCtl属性</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-type">int</span> sc;<br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                nextTable = <span class="hljs-literal">null</span>;<br>                table = nextTab;<br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    <span class="hljs-keyword">return</span>;<br>                finishing = advance = <span class="hljs-literal">true</span>;<br>                i = n; <span class="hljs-comment">// recheck before commit</span><br>            &#125;<br>        &#125;<br><span class="hljs-comment">//4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符)</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br><span class="hljs-comment">//4.2 如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    Node&lt;K,V&gt; ln, hn;<br>                    <span class="hljs-comment">//4.3 处理当前节点为链表的头结点的情况</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        ...<br>                    <span class="hljs-comment">//4.4 处理当前节点是TreeBin时的情况 </span><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        ...<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于ConcurrentHashmap的size-方法"><a href="#关于ConcurrentHashmap的size-方法" class="headerlink" title="关于ConcurrentHashmap的size()方法"></a>关于ConcurrentHashmap的size()方法</h2><p>对于ConcurrenHashMap来说，这个table中到底装了多少个Node是不确定的，因为多线程的关系。</p><p>不可能像GC时“stop the world”暂停所有线程来统计，所以说这个数量是个估计值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6、7中的ConcurrentHashmap：</p><ul><li>使用Segment来减小锁的颗粒度，分割成若干个Segment，在put的时候锁住对应的Segment，get的时候不加锁</li><li>使用volatile来保证可见性</li><li>当要统计全局时（如size），首先会尝试多次计算modcount，若这几次尝试中没有其他线程进行修改操作，直接返回size，若有，则需要依次锁住所有Segment来计算</li><li>put定位节点：先定位到具体Segment，再在Segment中定位到具体的桶</li></ul><p>JDK8之后：</p><ul><li>不使用Segment而是采用Node，锁住Node来减小锁粒度</li><li>设计了MOVED状态，当resize的过程中，其他执行put的线程会帮助resize</li><li>CAS替代锁，使用了3个CAS操作来确保对Node的一些操作的原子性</li><li>sizeCtl的不同值来代表不同的状态，起到控制作用</li><li>采用synchronized而不是ReentrantLock</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-LockSupport</title>
    <link href="/2022/10/18/Java%E5%B9%B6%E5%8F%91-LockSupport/"/>
    <url>/2022/10/18/Java%E5%B9%B6%E5%8F%91-LockSupport/</url>
    
    <content type="html"><![CDATA[<h1 id="LockSupport简介"><a href="#LockSupport简介" class="headerlink" title="LockSupport简介"></a>LockSupport简介</h1><p>调用LockSupport场景：</p><ul><li><p>AQS的底层实现中</p></li><li><p>锁的实现</p></li><li><p>Condition中，线程的等待&#x2F;通知机制</p></li></ul><p>LockSupport位于java.util.concurrent.locks包下，LockSupport时线程的阻塞原语，用来阻塞和唤醒线程。</p><p>每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可以在线程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用unpark()使其可用。但是注意，许可不可重入，也就是说只能调用一次park()方法，否则会一直阻塞。</p><h1 id="LockSupport方法介绍"><a href="#LockSupport方法介绍" class="headerlink" title="LockSupport方法介绍"></a>LockSupport方法介绍</h1><p>阻塞线程：</p><ul><li><p>void park()</p><blockquote><p>唤醒当前线程，如果调用unpark方法或者当前线程被中断，才能从park()方法中返回</p></blockquote></li><li><p>void park(Object blocker)</p><blockquote><p>功能同park()，入参增加了一个Object对象，用于记录导致线程阻塞的阻塞对象，方便进行问题排查</p></blockquote></li><li><p>void parkNanos(long nanos)</p><blockquote><p>增加了超时返回特性</p></blockquote></li><li><p>void parkNanos(Object blocker, long nanos)</p></li><li><p>void parkUntil(long deadline)</p><blockquote><p>阻塞档期那线程，知道deadline</p></blockquote></li><li><p>void parkUntil(Object blocker, long deadline)</p></li></ul><p>唤醒线程：</p><ul><li><p>void unpark(Thread thread)</p><blockquote><p>唤醒处于阻塞状态的指定线程</p></blockquote></li></ul><h1 id="LockSupport底层"><a href="#LockSupport底层" class="headerlink" title="LockSupport底层"></a>LockSupport底层</h1><p>LockSupport阻塞和唤醒线程的功能都是依赖于sun.misc.Unsafe类实现。</p><p>阻塞线程方法都有一个带Object阻塞对象的重载方法。该阻塞对象用于记录阻塞对象，类似于synchronized阻塞了线程dump线程时，都会有阻塞对象的藐视。在Java5推出LockSupport的时候遗漏了这一点，所以说在Java6中补充了这些带Object阻塞对象的重载方法。</p><p>synchronized与LockSupport阻塞区别：</p><ul><li>synchronized使线程阻塞，线程进入BLOCKED状态</li><li>LockSupport方法阻塞线程，线程进入WAITING状态</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Condition</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/</url>
    
    <content type="html"><![CDATA[<h1 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h1><p>等待通知机制的实现：</p><ul><li><p>Object：</p><blockquote><p>任何一个Java对象都是继承自Object类，在线程间实现通信往往会使用到Object的的wait()和notify()来实现等待&#x2F;通知机制。</p><p> Object的wait()和notify()是与对象监视器配合完成线程间的等待&#x2F;通知机制</p></blockquote></li><li><p>Condition:</p><blockquote><p>Condition实现和Object类wait()和notify()同样功能。</p><p>Condition是与Lock配合完成等待&#x2F;通知机制</p></blockquote></li></ul><p>前者是java底层级别的，Condition是语言级别的，具有更高的可控性和扩展性。</p><p>Condition支持，但Object方式不支持的功能特性：</p><ul><li>可以不响应中断</li><li>多个等待队列：Condition能够至此多个等待队列（new多个Condition对象）</li><li>设置超时时间</li></ul><p>Condition对应于Object的等待通知机制的方法：</p><ul><li><p>针对Object的wait方法</p><blockquote><p>Condition提供的方法：</p><ul><li>void await() throws InterruptedException</li></ul><blockquote><p>当前线程进入等待状态，如果其他线程调用condition的signal方法，并且当前线程获取锁，从await方法返回，如果在等待状态中被中断会抛出被中断异常</p></blockquote><ul><li>long awaitNanos(long nanosTimeout)</li></ul><blockquote><p>当前线程进入等待状态，直到被通知、中断或超时</p></blockquote><ul><li><p>boolean await(long time, TimeUnit unit) throws InterruptedException</p></li><li><p>boolean awatiUntil(Date deadline) throws InterruptedException</p></li></ul></blockquote></li><li><p>针对Object的notify方法</p><blockquote><p>Conditon提供的方法:</p><ul><li>void signal()</li></ul><blockquote><p>唤醒一个等待在condition上的线程，将该线程从等待队列转移到同步队列中，如果被唤醒的线程能够在同步队列中竞争到锁，则可以从等待方法中返回</p></blockquote><ul><li>void signalAll()</li></ul><blockquote><p>于signal的区别在于，signalAll会唤醒所有等待在condition上的线程</p></blockquote></blockquote></li></ul><h1 id="Condition实现原理"><a href="#Condition实现原理" class="headerlink" title="Condition实现原理"></a>Condition实现原理</h1><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><h3 id="新建condition对象："><a href="#新建condition对象：" class="headerlink" title="新建condition对象："></a>新建condition对象：</h3><p>创建condition对象是通过lock.newConditon()，这个方法实际上会new出一个ConditionObject对象，该类是AQS的一个内部类。condition要配合lock使用，而lock的实现又依赖于AQS，所以说CondetionObject作为AQS的一个内部类比较合理。</p><h3 id="等待队列："><a href="#等待队列：" class="headerlink" title="等待队列："></a>等待队列：</h3><p>在锁机制的实现上，AQS内部维护一个同步队列，若是独占式锁的话，获取锁失败的线程会尾插入同步队列。AQS通过head和tail指针来维护同步队列。</p><p>同样，condition内粗维护一个等待队列，调用condition.await() 方法的线程会加入到等待等待队列中，并将线程状态转换为等待状态。ConditionObject同样通过持有等待队列的头尾指针来管理队列。等待队列是通过复用Node类，使用其nextWaiter属性实现，可知其为单向队列。</p><p>Condition中的头尾节点成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//等待队列头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br><span class="hljs-comment">//等待队列尾节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br></code></pre></td></tr></table></figure><p>Node节点中的关于等待队列的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//后继节点</span><br>Node nextWaiter;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e65f9685tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="AQS持有多个Condition.png"></p><p>ConditionObject是AQS的内部类，因此每个ConditionObject能够访问到AQS提供的方法，相当于每个Condition都拥有所属同步器的引用。</p><h2 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h2><p>当调用condition.await() 方法后会使得当前获取lock的线程进入等待队列，直到被signal唤醒，使得当前线程从等待队列移至同步队列，直到线程获取锁后才从await方法中返回</p><p>awati ()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-comment">// 1. 将当前线程包装成Node，尾插入到等待队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br><span class="hljs-comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">// 3. 当前线程进入到等待状态</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><span class="hljs-comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br><span class="hljs-comment">// 5. 处理被中断的情况</span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将线程添加到等待队列"><a href="#将线程添加到等待队列" class="headerlink" title="将线程添加到等待队列"></a>将线程添加到等待队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br><span class="hljs-comment">//将当前线程包装成Node</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>    <span class="hljs-comment">//若为插入等待队列的一个节点，初始化firstWaiter</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-comment">//否则，尾插入</span><br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br><span class="hljs-comment">//更新lastWaiter</span><br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="释放锁的过程"><a href="#释放锁的过程" class="headerlink" title="释放锁的过程"></a>释放锁的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br><span class="hljs-comment">//成功释放同步状态</span><br>            failed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//不成功释放同步状态抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何从await中退出"><a href="#如何从await中退出" class="headerlink" title="如何从await中退出"></a>如何从await中退出</h3><p>第一次调用condition.await ()方法时，会进入这个while循环中，然后通过LockSupport.park(this)使得当前线程进入等待状态。</p><p>若要退出await方法，前提就是退出这个while循环，有两个出口：</p><ol><li><p>逻辑走到break退出while循环</p></li><li><p>while循环中逻辑判断为false</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//出口1: 若当前节点被移动到同步队列中，退出循环</span><br><span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">//当前线程进入到等待状态</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//出口2：若当前节点对应的线程被中断，break</span><br>    <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出while循环的条件：当前线程被中断或者调用condition.signal方法将当前节点移动到了同步队列。</p><p>退出while循环后会调用acquireQueued(node, savedState)，该方法自旋获取同步状态，直至成功（获取锁）。</p><h3 id="await执行示意图"><a href="#await执行示意图" class="headerlink" title="await执行示意图"></a>await执行示意图</h3><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e74cead3tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="await方法示意图"></p><h3 id="condition特性的实现"><a href="#condition特性的实现" class="headerlink" title="condition特性的实现"></a>condition特性的实现</h3><h4 id="超时机制的支持"><a href="#超时机制的支持" class="headerlink" title="超时机制的支持"></a>超时机制的支持</h4><p>实现基本于AQS中的tryAcquire方法一致。</p><h4 id="不响应中断支持"><a href="#不响应中断支持" class="headerlink" title="不响应中断支持"></a>不响应中断支持</h4><p>想要不响应中断可以调用condition.awaitUninterruptibly()方法，方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法基本于await()方法一致，只不过是减少了对中断的处理，省略了reportInterruptAfterWait方法抛出被中断异常</p><h2 id="signal实现原理"><a href="#signal实现原理" class="headerlink" title="signal实现原理"></a>signal实现原理</h2><p>signal()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 先检测当前线程是否已经获取lock</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//2. 获取等待队列中第一个节点，之后的操作都是针对这个节点</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure><p>doSignal()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>    <span class="hljs-comment">//do-while至少执行一次</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//1. 移动firstWaiter指针，若移动后指向null说明等待队列为空</span><br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//将lastWaiter置null</span><br>            lastWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//2. 将头结点从等待队列中移除，帮助垃圾回收</span><br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//3. while中transferForSignal方法对头结点做真正的处理</span><br>    <span class="hljs-comment">//transferForSignal将头节点插入同步队列</span><br>    <span class="hljs-comment">//若返回true，则表示插入成功，while循环结束</span><br>   <span class="hljs-comment">//若返回false，表示插入失败，while逻辑判断中的（frist = firstWaiter）移动first指针，再重复do-while逻辑</span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>transferForSignal(Node node)源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//传入参数node为等待队列的头节点</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-comment">//1. CAS更新node状态为0</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-comment">//若CAS失败，说明有多线程冲突，返回false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">//2. 将该节点尾插入到同步队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-comment">//看当前线程能否直接获取锁被唤醒</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-comment">//3. 节点插入同步队列成功后，返回true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>signal执行示意图：</p><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e7650d62tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="signal执行示意图"></p><p>signalAll()：</p><p>signalAll()和signal ()方法区别在于doSignalAll()方法：循环将等待队列中的节点移入同步队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;<br>    lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br>        transferForSignal(first);<br>        first = next;<br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="await与signal结合思考"><a href="#await与signal结合思考" class="headerlink" title="await与signal结合思考"></a>await与signal结合思考</h1><p>等待&#x2F;通知机制，这种机制能够解决最经典的问题“生产者与消费者问题”。</p><p>await和signal方法就像是一个开关控制着线程A（等待方）和线程B（通知方）。</p><p>关系示意图：</p><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e7911395tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="condition下的等待通知机制.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ReentrantReadWriteLock</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[<h1 id="读写锁简介"><a href="#读写锁简介" class="headerlink" title="读写锁简介"></a>读写锁简介</h1><p>独占锁与共享锁：</p><blockquote><p>独占式获取锁，同一时刻只有一个线程能够获取锁。</p><p>而在一些业务场景中，大部分只是读数据，写数据很少，读数据不会影响数据的正确性，使用独占锁的话会出现性能瓶颈。</p><p>读锁允许同一时刻被多个线程获取，但是写锁会阻塞所有的读写线程。</p></blockquote><ul><li>独占锁：<ul><li>Java关键字synchronized</li><li>concurrents包中实现Lock接口的ReentrantLock</li></ul></li><li>共享锁：<ul><li>concurrents包中实现Lock接口的ReentrantReadWriteLock</li></ul></li></ul><p>读写锁的特性：</p><ul><li>公平性选择：至此非公平（默认）和公平的锁获取方式，非公平吞吐量更优</li><li>重入性：支持重入，读锁获取后能再次获取，写锁获取后能够再次获取写锁，同时也能够获取读锁</li><li>锁降级：遵循获取写锁，获取读锁，再释放写锁的次序，写锁能够降级为读锁</li></ul><p>关于读写锁的的几个问题：</p><ul><li>读写锁是如何是心啊分别记录读写状态的</li><li>写锁是怎样获取去和释放的</li><li>读锁是怎样获取和释放的</li></ul><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><h2 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h2><p>写锁在同一时刻不能被多个线程所获取，所以说写锁是独占式锁。实现写锁的同步语义是通过重写AQS中的tryAcquire方法实现的。</p><h3 id="tryAcquire-源码：（获取写锁）"><a href="#tryAcquire-源码：（获取写锁）" class="headerlink" title="tryAcquire ()源码：（获取写锁）"></a>tryAcquire ()源码：（获取写锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//同步状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">//写锁状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>    <br>    <span class="hljs-comment">//1 锁已经被线程获取，只有重入写锁能够获取锁</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1.1 判断是否满足重入条件</span><br>        <span class="hljs-comment">//若当前线程不是获取锁的线程，或读锁已经被获取（c != 0 且 w == 0，说明读锁被获取）</span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>            <span class="hljs-comment">//不满足重入条件，获取锁失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">//走到这儿，说明当前线程已经获取读锁</span><br>        <span class="hljs-comment">//1.2 执行重入写锁的操作</span><br>        <span class="hljs-comment">//写锁计数溢出</span><br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br><span class="hljs-comment">//修改写锁同步状态</span><br>        setState(c + acquires);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">//2 锁未被任何线程获取</span><br>    <span class="hljs-comment">//2.1 若被阻塞，或者CAS修改同步状态失败，获取锁失败</span><br>    <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//2.2 否则获取写锁成功，设置当前线程独占锁</span><br>    setExclusiveOwnerThread(current);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于同步状态："><a href="#关于同步状态：" class="headerlink" title="关于同步状态："></a>关于同步状态：</h3><blockquote><p>读锁和写锁的获取次数都保存在同步状态这一个变量中，高16位保存的是读状态，低十六位保存的是写状态</p></blockquote><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/163262ec97ebeac9tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="读写锁的读写状态设计.png"></p><p>获取写状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写状态通过掩码（0x0000FFFF）与同步状态相与获取</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br></code></pre></td></tr></table></figure><p>获取读状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读状态通过同步状态右移16位获取</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;<br></code></pre></td></tr></table></figure><h2 id="写锁释放"><a href="#写锁释放" class="headerlink" title="写锁释放"></a>写锁释放</h2><p>tryRelease()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-comment">//1. 同步状态减去写状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br><span class="hljs-comment">//2. 当前写状态是否为0，为0则释放写锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (free)<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//3. 不为0则更新同步状态</span><br>    setState(nextc);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><h2 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h2><p>tryAcquiredShared()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">//1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前</span><br><span class="hljs-comment">// 线程获取读锁失败返回-1</span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>        getExclusiveOwnerThread() != current)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>        r &lt; MAX_COUNT &amp;&amp;<br><span class="hljs-comment">//2. 当前线程获取读锁</span><br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<br><span class="hljs-comment">//3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法</span><br><span class="hljs-comment">//返回当前获取读锁的次数</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>            firstReader = current;<br>            firstReaderHoldCount = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>            firstReaderHoldCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                cachedHoldCounter = rh = readHolds.get();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                readHolds.set(rh);<br>            rh.count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-comment">//4. 处理在第二步中CAS操作失败的自旋已经实现重入性</span><br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读锁释放"><a href="#读锁释放" class="headerlink" title="读锁释放"></a>读锁释放</h2><p>tryReleaseShared()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 前面还是为了实现getReadHoldCount等新功能</span><br>    <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>        <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;</span><br>        <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)<br>            firstReader = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span><br>            firstReaderHoldCount--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>        <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>            rh = readHolds.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> rh.count;<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>            readHolds.remove();<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> unmatchedUnlockException();<br>        &#125;<br>        --rh.count;<br>    &#125;<br>    <span class="hljs-comment">// 自旋CAS释放读锁</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h1><p>写锁能够降级为读锁，不支持锁升级。写锁在获取读锁后释放写锁，则写锁降级为读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// Must release read lock before acquiring write lock</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck state because another thread might have</span><br>                <span class="hljs-comment">// acquired write lock and changed state before we did.</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>            cacheValid = <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-comment">// Downgrade by acquiring read lock before releasing write lock</span><br>          rwl.readLock().lock();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          rwl.writeLock().unlock(); <span class="hljs-comment">// Unlock write, still hold read</span><br>        &#125;<br>      &#125;<br> <br>      <span class="hljs-keyword">try</span> &#123;<br>        use(data);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        rwl.readLock().unlock();<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ReentrantLock</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantLock/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h1 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h1><p>ReentrantLock重入锁，是实现Lock接口的一个类。</p><ul><li><p>支持<strong>重入性</strong>，表示能够对共享资源重复加锁，即当前获取该锁的线程再次获取不会被阻塞。Java关键字synchronized通过获取自增，释放自减的方式实现重入。</p></li><li><p>ReentrantLock还支持<strong>公平锁和非公平锁</strong>两种方式。</p></li></ul><h1 id="重入性的实现原理"><a href="#重入性的实现原理" class="headerlink" title="重入性的实现原理"></a>重入性的实现原理</h1><h2 id="支持重入性需要解决的两个问题"><a href="#支持重入性需要解决的两个问题" class="headerlink" title="支持重入性需要解决的两个问题"></a>支持重入性需要解决的两个问题</h2><ul><li>在获取锁的时候，如果已经获取锁的线程是当前线程的话直接再次获取成功</li><li>由于锁会被获取n次，那么只有在锁同样被释放n次过后，该锁才算完全释放</li></ul><h2 id="实现重入性的核心方法"><a href="#实现重入性的核心方法" class="headerlink" title="实现重入性的核心方法"></a>实现重入性的核心方法</h2><blockquote><p>同步组件通过重写AQS的几个protected方法来表达自己的同步语义</p></blockquote><h3 id="nonfairTryAcquire"><a href="#nonfairTryAcquire" class="headerlink" title="nonfairTryAcquire()"></a>nonfairTryAcquire()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//1 如果该锁未被任何线程占有，该锁能被当前线程获取</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//2 检查占有线程是否是当前线程</span><br>    <span class="hljs-comment">//2.1 若是，锁重入，返回true</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>       <span class="hljs-comment">//计算重入后的锁重入次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-comment">//避免锁重入次数逸出int范围（几乎不会出现，增加程序健壮性）</span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        <span class="hljs-comment">//设置重入后的锁状态</span><br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//2.2 若不是，直接返回false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">//当前没有获取锁的线程不能释放锁</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//1 同步状态减1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">//free表示锁完全被释放（获取n次锁，释放n次锁，即为完全释放。）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//2 只有当同步状态为0时，锁完全被释放</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-comment">//3 返回锁释放状态free（完全释放为true，还没有释放完为false）</span><br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><h2 id="ReentrantLock的构造方法"><a href="#ReentrantLock的构造方法" class="headerlink" title="ReentrantLock的构造方法"></a>ReentrantLock的构造方法</h2><blockquote><p>构造方法的主要内容就是指定同步器。</p><p>ReentrantLock内部有两个实现了AQS的同步器，一个是公平锁，另一个是非公平锁。</p></blockquote><p>无参构造（非公平锁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>传入boolean值指定是否为公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公平锁的tryAcquire-方法"><a href="#公平锁的tryAcquire-方法" class="headerlink" title="公平锁的tryAcquire()方法"></a>公平锁的tryAcquire()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在非公平锁的基础上，增加了前驱节点判断，有前驱节点的话就不能获取锁，保证按照入队顺序获取锁</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//若当前锁没有线程获取</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果有前驱节点，则获取锁失败（公平锁的实现逻辑）</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//若当前线程已经拿到锁</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><ul><li>“饥饿”现象：<ul><li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源上的绝对顺序。</li><li>而非公平锁，刚释放锁的线程再次参与锁竞争，可能继续获取锁，有可能导致其他线程永远获取不到锁，造成“饥饿”现象</li></ul></li><li>性能：<ul><li>公平锁为了保证获取锁的FIFO顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销</li><li>所以ReentrantLock默认选择的是非公平锁，则是为了减少部分上下文切换，保证系统更大的吞吐量</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-AQS深入理解</title>
    <link href="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <url>/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h1><p>在同步组件的实现中，AQS是核心部分</p><p>同步组件的实现者通过AQS提供的模板方法实现同步组件的同步语义</p><p>AQS则实现了对同步状态的管理，以及对阻塞线程的排队、等待和通知等一些底层的实现</p><p>AQS核心：</p><ul><li>同步队列</li><li>独占式锁的获取于释放</li><li>共享锁的获取和释放</li><li>可中断锁、超时等待锁获取</li></ul><p>AQS提供的模板方法：</p><ul><li><p>独占式锁</p><ul><li><p>void acquire(int arg)</p><blockquote><p>独占式获取同步状态，如果获取失败则插入同步队列进行等待</p></blockquote></li><li><p>void acquireInterruptibly(int arg)</p><blockquote><p>与acquire方法相同，但在同步队列中进行等待的时候可以检测中断</p></blockquote></li><li><p>boolean tryAcquireNanos(int arg, long nanosTimeout)</p><blockquote><p>在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获取同步状态返回false</p></blockquote></li><li><p>boolean release(int arg)</p><blockquote><p>释放同步状态，该方法会唤醒在同步队列中的下一个节点</p></blockquote></li></ul></li><li><p>共享式锁</p><ul><li><p>void acquireShared (int arg)</p><blockquote><p>共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态</p></blockquote></li><li><p>void acquireSharedInterruptibly(int arg)</p><blockquote><p>在acquireShared方法基础上增加了能响应中断的功能</p></blockquote></li><li><p>boolean tryAcquireSharedNanos(int arg, long nanoTimeout)</p><blockquote><p>在acquireSharedInterruptibly基础上增加了超时等待的功能</p></blockquote></li><li><p>boolean releaseShared(int arg)</p><blockquote><p>共享式释放同步状态</p></blockquote></li></ul></li></ul><h1 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h1><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。</p><h2 id="同步队列的数据结构"><a href="#同步队列的数据结构" class="headerlink" title="同步队列的数据结构"></a>同步队列的数据结构</h2><p>就数据结构而言，队列的实现有两种：数组、链表</p><p>AQS中的同步队列则是通过<strong>链表</strong>方式进行实现。</p><p>对于AQS同步队列的一些问题：</p><ul><li>节点的数据结构是什么样的？</li><li>同步队列是单项还是双向？</li><li>同步队列带不带头节点？</li></ul><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node是AQS的一个静态内部类，用来保存获取同步状态失败的线程引用以及等待状态信息</p><p>Node的属性：</p><ul><li><p>volatile int waitStatus</p><blockquote><p>节点状态</p><ul><li><p>int CANCELLED &#x3D; 1</p><blockquote><p>节点从同步队列中取消</p></blockquote></li><li><p>int INITIAL  &#x3D; 0</p><blockquote><p>初始状态</p></blockquote></li><li><p>int SIGNAL &#x3D; -1</p><blockquote><p>后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点能都运行</p></blockquote></li><li><p>int CONDITION &#x3D; -2</p><blockquote><p>当前节点进入等待队列</p></blockquote></li><li><p>int PROPAGATE &#x3D; -3</p><blockquote><p>表示下一次共享式同步状态获取将会无条件传播下去</p></blockquote></li></ul></blockquote></li><li><p>volatile Thread thread</p><blockquote><p>当前节点所封装的线程</p></blockquote></li><li><p>volatile Node prev</p><blockquote><p>同步队列前驱动节点</p></blockquote></li><li><p>volatile Node next</p><blockquote><p>同步队列后继节点</p></blockquote></li><li><p>Node nextWatier</p><blockquote><p>等待队列中的下一个节点</p></blockquote></li></ul><h2 id="AQS对同步队列的管理"><a href="#AQS对同步队列的管理" class="headerlink" title="AQS对同步队列的管理"></a>AQS对同步队列的管理</h2><p>AQS通过持有同步队列的头尾节点的指针来对节点进行管理</p><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637bb25796tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对节点和同步队列的了解：</p><ul><li>节点的数据结构，即AQS的静态内部类Node，节点的等待状态等信息</li><li>同步队列是一个双向队列，AQS通过持有头尾节点的指针管理同步队列</li></ul><p>同步队列和锁的关系：</p><p>节点的入队和出队实际上对应着锁的获取和释放两个操作获取锁失败进行入队操作，获取锁成功进行出队操作。</p><h1 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h1><p>方法分析层级（数字表示层级）：</p><ul><li><p>1 lock()</p><blockquote><p>实现Lock接口的锁的获取锁的方法</p></blockquote><ul><li><p>2 acquire()</p><blockquote><p>lock ()方法通过调用锁中的继承自AQS的内部类的acqure方法来获取锁</p></blockquote><ul><li><p>3 addWaiter()</p><blockquote><p>将当前线程打包成Node插入同步队列</p></blockquote><ul><li><p>4 enq()</p><blockquote><p>完成同步队列头节点初始化，并将Node插入同步队列</p></blockquote></li></ul></li><li><p>3 acquireQueued()</p><blockquote><p>阻塞排队获取锁</p></blockquote><ul><li><p>4 shouldParkAfterFailedAcquire()</p><blockquote><p>将前置节点状态设置为SIGNAL</p></blockquote></li><li><p>4 parkAndCheckInterrupt()</p><blockquote><p>阻塞当前线程，并检测当前线程是否被中断</p></blockquote></li></ul></li></ul></li></ul></li></ul><h2 id="独占式锁的获取（acquire）"><a href="#独占式锁的获取（acquire）" class="headerlink" title="独占式锁的获取（acquire）"></a>独占式锁的获取（acquire）</h2><p>在使用lock.lock()方法获取独占式锁的时候，获取失败就将当前线程加入同步队列，成功则线程执行。</p><p>lock()实际调用的是AQS的acquire()方法。</p><p>acquire ()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><span class="hljs-comment">//先看同步状态是否获取成功，如果成功则方法结束返回</span><br><span class="hljs-comment">//若失败则先调用addWaiter()方法再调用acquireQueued()方法</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>源码通过逻辑运算的短路特性来精简语句，以下是我写的逻辑更清晰一点的啰嗦语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//1 如果获取同步状态失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg))&#123;<br>        <span class="hljs-comment">//1.1 将当前线程打包成Node节点插入同步队列，并返回打包好的Node节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>        <span class="hljs-comment">//1.2 Node节点排队获取锁</span><br>        <span class="hljs-keyword">if</span>(acquireQueued(node, arg))&#123;<br>            selfInterupt();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2 如果获取成功，方法结束返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="addWaiter-方法"><a href="#addWaiter-方法" class="headerlink" title="addWaiter() 方法"></a>addWaiter() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">//1 将当前线程打包成Node类型</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">//2 将Node插入同步队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//2.1 尾节点不为null，当前节点尾插入的方式插入同步队列中</span><br>        node.prev = pred;<br>        <span class="hljs-comment">//如果CAS插入成功，则直接返回，若CAS失败则通过enq()方法插入</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2.2 尾节点为null，说明当前线程是第一个加入同步队列进行等待的线</span><br>    enq(node);<br>    <span class="hljs-comment">//3 返回打包好的node节点</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//获取tail的指针</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">//tail为null，在未插入节点之前需要初始化头节点</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">//1 初始化头结点。通过CAS设置头节点，避免因为多线程竞争导致重复初始化头节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        <span class="hljs-comment">//tail不为null，</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//2 尾插入，若CAS操作失败，可通过for循环不断进行CAS插入</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acquireQueued（）方法"><a href="#acquireQueued（）方法" class="headerlink" title="acquireQueued（）方法"></a>acquireQueued（）方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//1 获得当前节点的先驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">//2 当前节点能否获取独占式锁</span><br>            <span class="hljs-comment">//2.1 获取锁成功，获取锁的节点出队</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">//队列头指针用指向当前节点</span><br>                setHead(node);<br>                <span class="hljs-comment">//释放前驱节点，帮助GC回收</span><br>                p.next = <span class="hljs-literal">null</span>;<br>                <br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">//2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span><br>            <span class="hljs-comment">//使用CAS将前驱节点状态由INITIAL设置成SIGNAL，若CAS失败则通过for循环不断重试</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node))&#123;<br>                <span class="hljs-comment">//当节点状态设置成功，则阻塞当前线程</span><br>                <span class="hljs-keyword">if</span>(parkAndCheckInterrupt()))&#123;<br>                    interrupted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;  <br>            <span class="hljs-comment">/*上面一段代码的源码</span><br><span class="hljs-comment">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="hljs-comment">                    parkAndCheckInterrupt())</span><br><span class="hljs-comment">                    interrupted = true;</span><br><span class="hljs-comment">            */</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">//若前驱节点状态已经为SIGNAL，直接返回true</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//若前驱节点状态为CANCELLED，往前寻找状态不为CANCELLED的节点作为前驱节点</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    <span class="hljs-comment">//其他情况，使用CAS将前驱动节点状态改为SIGNAL</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//使得该线程阻塞</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//返回当前线程是否被中断</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acquire-方法流程图"><a href="#acquire-方法流程图" class="headerlink" title="acquire ()方法流程图"></a>acquire ()方法流程图</h3><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637c891cc2tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="独占式锁获取（acquire()方法）流程图.png"></p><h2 id="独占式锁的释放（release）"><a href="#独占式锁的释放（release）" class="headerlink" title="独占式锁的释放（release）"></a>独占式锁的释放（release）</h2><p>release()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//如果释放锁成功</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//唤醒后继节点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">//1 若当前要释放锁的node状态为负数，则将其状态置0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//2 唤醒后续节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">//若后继节点为null或状态为CANCELLED</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//从尾节点往前寻找一个没有被CANCELLED的节点</span><br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">//若s为null说明没有有效后继节点了，则不需要唤醒线程</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//后继节点不为null时唤醒后继节点对应的线程</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="独占式锁小结"><a href="#独占式锁小结" class="headerlink" title="独占式锁小结"></a>独占式锁小结</h3><ul><li>线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头节点初始化工作以及CAS操作失败的重试</li><li>线程获取锁是一个自旋的过程，当且仅当当前线程的前驱节点是头节点并且成功获取同步状态时，节点出队，即该节点引用的线程获得锁，否则，当不满足条件时就会调用LockSupport.park()方法使得线程阻塞</li><li>释放锁得时候会唤醒后继节点</li></ul><p>总的来说：在获取同步状态时，AQS维护一个同步队列，获取同步状态失败得线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是*<em>前驱节点是头节点并且成功获得了同步状态</em>。在释放同步状态时，同步器会调用unparkSuucessor()方法唤醒后继节点。</p><h2 id="可中断式获取锁（acquireInterruptibly）"><a href="#可中断式获取锁（acquireInterruptibly）" class="headerlink" title="可中断式获取锁（acquireInterruptibly）"></a>可中断式获取锁（acquireInterruptibly）</h2><p>acquireInterruptilbly()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//若线程已经被中断，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">//尝试获取锁。若获取锁成功，直接方法结束</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>        <span class="hljs-comment">//获取锁失败，进行可中断式获取锁</span><br>        doAcquireInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-comment">//将节点插入到同步队列中</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">//获取锁出队</span><br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br><span class="hljs-comment">//线程中断抛异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>acquireInterruptibly()与acquire()的关系：</p><ul><li>该方法与acquire方法逻辑几乎一致</li><li>唯一的区别在于，当parkAndCheckInterrupt()返回true时的处理<ul><li>acquire()将interrupted属性置为true</li><li>acquireInterruptilbly()直接抛出异常</li></ul></li></ul><h2 id="超时等待式获取锁（tryAcquireNanos）"><a href="#超时等待式获取锁（tryAcquireNanos）" class="headerlink" title="超时等待式获取锁（tryAcquireNanos）"></a>超时等待式获取锁（tryAcquireNanos）</h2><p>调用lock.tryLock()方式达到超时等待式获取锁，该方法只有在如下情况下才会返回：</p><ul><li>在超时时间内，成功获取锁</li><li>在超时时间内，被中断</li><li>超时时间结束，仍未获得锁</li></ul><p>tryAcquireNanos()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//若线程被中断，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">//若能直接获取锁，则返回true</span><br>    <span class="hljs-keyword">if</span>(tryAcquire(arg))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//若获取锁失败，尝试超时等待式获取锁</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> doAcquireNanos(arg, nanosTimeout);<br>    &#125;<br>    <span class="hljs-comment">//上面一小段的源码：return tryAcquire(arg) || (arg, nanosTimeout);</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//1. 根据超时时间和当前时间计算出截止时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><span class="hljs-comment">//2. 当前线程获得锁出队列</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">// 3.1 重新计算超时时间</span><br>            nanosTimeout = deadline - System.nanoTime();<br>            <span class="hljs-comment">// 3.2 已经超时返回false</span><br><span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 3.3 线程阻塞等待 </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                nanosTimeout &gt; spinForTimeoutThreshold)<br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>            <span class="hljs-comment">// 3.4 线程被中断抛出被中断异常</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序逻辑：</p><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637d087f5etplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="超时等待式获取锁（doAcquireNanos()方法）"></p><p>程序逻辑同可响应中断式独占锁基本一致，唯一不同在于，获取锁失败后的超时时间处理。</p><ul><li>理论截至时间计算：根据当前系统内和时间超时时间计算出截至时间</li><li>超时判断：截至时间减去系统当前时间<ul><li>若为负，超时直接返回false</li><li>若为正，调用LockSupport.parkNanos()阻塞当前线程</li></ul></li></ul><p>增加了独立的中断检测。</p><h1 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h1><h2 id="共享锁的获取（acquireShared）"><a href="#共享锁的获取（acquireShared）" class="headerlink" title="共享锁的获取（acquireShared）"></a>共享锁的获取（acquireShared）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//tryAcquireShared返回值大于等于0的话表示获取锁成功</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//获取锁失败，执行共享式获取锁</span><br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; ) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//当该节点的前驱节点是头结点且成功获取同步状态</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享锁的释放（releaseShared）"><a href="#共享锁的释放（releaseShared）" class="headerlink" title="共享锁的释放（releaseShared）"></a>共享锁的释放（releaseShared）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">     * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">     * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">     * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">     * fails, if so rechecking.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                 <span class="hljs-comment">// loop to recheck cases</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;           <br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-comment">// loop on failed CAS</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <br>        &#125;<br>        <span class="hljs-comment">// loop if head changed</span><br>        <span class="hljs-keyword">if</span> (h == head)                   <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理"><a href="#可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理" class="headerlink" title="可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理"></a>可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Lock与AQS初识</title>
    <link href="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/"/>
    <url>/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h1><h2 id="包结构："><a href="#包结构：" class="headerlink" title="包结构："></a>包结构：</h2><ul><li>atomic子包</li><li>locks子包</li><li>阻塞队列以及executors</li></ul><h2 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h2><blockquote><p>底层依赖volatile和CAS</p></blockquote><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff7cb847ctplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><h1 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h1><p>锁使用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</p><h2 id="Lock接口与syncronized"><a href="#Lock接口与syncronized" class="headerlink" title="Lock接口与syncronized"></a>Lock接口与syncronized</h2><p>在Lock接口出现之前，Java程序主要靠synchronized关键字实现锁。</p><p>Lock拥有比synchronized更多的同步特性：</p><ul><li>主动控制锁获取与释放</li><li>可中断获取锁</li><li>超时获取锁</li></ul><p>注意：synchronized同步块执行完成或者遇到异常，锁会自动释放，而Lock需要主动调用unlock()方法释放锁，所以需要在finally块中释放。</p><h2 id="Lock接口API"><a href="#Lock接口API" class="headerlink" title="Lock接口API"></a>Lock接口API</h2><ul><li><p>void lock()</p><blockquote><p>阻塞式获取锁</p></blockquote></li><li><p>void lockInterruptibly() throws InterruptedException</p><blockquote><p>阻塞式获取锁，获取锁的过程能够响应中断</p></blockquote></li><li><p>boolean tryLock()</p><blockquote><p>非阻塞式、响应中断、立即返回，获取锁返回true，失败返回false</p></blockquote></li><li><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</p><blockquote><p>超时获取锁，未超时且未中断能够获取锁</p></blockquote></li><li><p>Condition newCondition()</p><blockquote><p>获取与lock绑定的等待通知组件（当前线程必须获取了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回）</p></blockquote><h2 id="Lock接口的实现"><a href="#Lock接口的实现" class="headerlink" title="Lock接口的实现"></a>Lock接口的实现</h2></li></ul><p>concurrent.locks包中实现了Lock接口的类的实现方式</p><ul><li>类中包含一个继承自AQS的静态内部类</li><li>通过调用该类的方法实现Lock接口的方法</li></ul><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><blockquote><p>AQS全称AbstractQueuedSynchronizer，简称同步器。</p></blockquote><p>作用：同步器用来构建锁和其他同步组件的基础框架</p><p>实现：依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列</p><p>子类需要重写的方法：</p><ul><li>修改同步状态的方法<ul><li>getState</li><li>setState</li><li>compareAndSetState</li></ul></li><li>实现排队和阻塞机制的方法</li></ul><p>同步器和锁的关系：</p><ul><li><p>同步器是实现锁的关键，锁聚合同步器，利用同步器实现锁的语义</p></li><li><p>锁面向使用者，定义使用者与锁交互的接口，隐藏了实现的细节</p></li><li><p>同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理、线程的排队、等待和唤醒等底层操作</p></li><li><p>二者分别屏蔽了使用者和实现者所需要关注的领域</p></li></ul><h2 id="AQS的模板方法设计模式"><a href="#AQS的模板方法设计模式" class="headerlink" title="AQS的模板方法设计模式"></a>AQS的模板方法设计模式</h2><blockquote><p>AQS开放一些方法给子类进行重写。同步组件调用同步器的方法，而这些方法又会调用子类重写的方法。</p></blockquote><ul><li>同步组件（锁和同步工具）的实现依赖于同步器AQS，在同步器的实现中，使用AQS的方式推荐被定义未继承了AQS的静态内部类</li><li>AQS采用模板方法进行设计，AQS的peotected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法的时候就会调用被重写的方法</li><li>AQS负责同步状态的管理，线程的排队、等待和唤醒等底层操作，而Lock等同步组件主要专注于实现同步语义</li><li>在重写AQS的方法是，使用AQS提供的getState()、setState()、compareAndSetState()方法进行同步状态的修改</li></ul><p>可重写的方法：</p><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff7d16b38tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>AQS为同步组件提供的模板方法（大概分为三类）：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中等待线程情况</li></ul><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff87fe8bftplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p><strong>同步组件通过AQS提供的模板方法实现自己的同步语义</strong></p><h1 id="同步组件与AQS的关系"><a href="#同步组件与AQS的关系" class="headerlink" title="同步组件与AQS的关系"></a>同步组件与AQS的关系</h1><h2 id="同步组件实现者的角度："><a href="#同步组件实现者的角度：" class="headerlink" title="同步组件实现者的角度："></a>同步组件实现者的角度：</h2><p>通过可重写的方法：</p><ul><li>独占式：<ul><li>tryAcquire()</li><li>tryRelease()</li></ul></li><li>共享式：<ul><li>tryAcquireShared()</li><li>tryReleaseShared()</li></ul></li></ul><p>通过这些方法告诉AQS如何判断当前同步状态是否成功获取或者失败。</p><p>同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。</p><h2 id="AQS的角度"><a href="#AQS的角度" class="headerlink" title="AQS的角度"></a>AQS的角度</h2><p>对于AQS来所，只需要同步组件返回的true和false即可，因为AQS会对true和false有不同的操作，true会认为当前线程获取同步组件成功而直接返回，若为falseAQS也会执行将当前线程插入同步队列等一系列方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步组件通过重写AQS的方法实现字节想要表达的同步语义，而AQS只需要同步组件表达的true和false来执行不同的处理。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发关键字</title>
    <link href="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a>synchronized简介</h2><p>线程安全问题的主要来源于JMM的设计，集中在</p><ul><li>主内存和工作内存导致内存可见性问题</li><li>重排序导致的有序性问题</li></ul><p>多线程的意义在于多个线程协作共同完成一件事情，那么多个线程就必然需要访问共享数据。</p><p>如何保证共享数据的线程安全问题？即每个线程依次访问该共享变量，synchronize关键字具有让每个线程依次访问共享数据的功能。它是并发容器实现的基础。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>sychronized使用场景</p><ul><li><p>方法</p><blockquote><p>可以作用于实例方法和静态方法</p><p>区别在于被锁对象一个是实例对象，一个是类对象</p></blockquote></li><li><p>代码块（锁住方法相当于锁住整个方法的代码块）</p><blockquote><p>可以使用各种对象作为锁</p><p>this：使用类的实例对象作为锁</p><p>.class：使用类对象作为锁</p><p>Object：使用任意实例对象作为锁</p></blockquote></li></ul><h3 id="对象锁（moniter）机制"><a href="#对象锁（moniter）机制" class="headerlink" title="对象锁（moniter）机制"></a>对象锁（moniter）机制</h3><h4 id="获取与释放对象锁："><a href="#获取与释放对象锁：" class="headerlink" title="获取与释放对象锁："></a>获取与释放对象锁：</h4><p>在编译后的字节码中使用monitorenter指令获取到monitor（对象锁）后才能继续执行代码块中的指令，最后通过monitorexit指令释放所持有的monitor。</p><p>正常执行return退出代码块或者抛出异常退出代码块都能够执行monitorexit释放持有的对象锁</p><h4 id="对象锁（monitor）"><a href="#对象锁（monitor）" class="headerlink" title="对象锁（monitor）"></a>对象锁（monitor）</h4><p>每个对象都存在一个与之关联的monitor，线程对monitor持有的方式以及持有时机决定了synchronized的锁状态以及synchronized的状态升级方式</p><p>monitor是通过C++中的ObjectMonitor实现的：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/%E5%AF%B9%E8%B1%A1%E9%94%81.drawio.png" alt="对象锁.drawio"></p><ul><li>ObjectMonitor维护WaitSet和EntryList两个队列来保存ObjectWaiter对象</li><li>EntryList：阻塞等待获取锁的线程会被封装成ObjectWaiter进入EntryList队列，等待锁释放后竞争锁，获取锁后线程执行完成后退出并释放锁。</li><li>WaitSet：获取锁的线程若调用wait方法后会进入WaitSet中等待被唤醒，若被唤醒，则线程会进入EntryList中</li></ul><h3 id="synchronized与happens-before的关系"><a href="#synchronized与happens-before的关系" class="headerlink" title="synchronized与happens-before的关系"></a>synchronized与happens-before的关系</h3><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/5c09eea06aa64329bdae63dc31aa9622tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p><p>箭头表示happens-before</p><ul><li>程序顺序规则：黑色箭头顺序</li><li>监视器锁队则：红色箭头顺序</li><li>传递性规则：由上面两个推导出来的蓝色箭头顺序</li></ul><h3 id="获取锁和释放锁的内存语义"><a href="#获取锁和释放锁的内存语义" class="headerlink" title="获取锁和释放锁的内存语义"></a>获取锁和释放锁的内存语义</h3><p>释放锁：释放锁的时候会将线程对共享变量的修改写回主内存</p><p>获取锁：会强制从主内存中获取共享变量的新值</p><p>所以从横向看，线程之间基于主内存中的共享变量互相感知对方的数据操作，基于共享变量完成并发实体中的协作工作，整个过程就像是线程发送数据变更的“通知”，这种通知机制就是基于共享内存的并发模型导致的。</p><h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>synchronized最大特征就是同一时刻只能有一个线程能够获取对象的monitor，从何确保线程同步，对于线程之间表现为<strong>互斥性（排他性）</strong></p><p>优化的方向：</p><ul><li>让获取锁的速度变快</li><li>降低阻塞等待的概率</li></ul><p>对于优化需要先了解：</p><ul><li>CAS</li><li>Java对象头</li></ul><p>具体的优化：（锁升级）</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><h4 id="CAS概念"><a href="#CAS概念" class="headerlink" title="CAS概念"></a>CAS概念</h4><p>悲观锁：线程获取锁是一种悲观锁策略，即假设每次执行临界区代码都会产生冲突，所以当前线程获取锁的同时会阻塞其他线程获取该锁</p><p>乐观锁：CAS操作（又称无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，那么线程之间就不会出现阻塞。CAS操作会检测是否发生了冲突，则发生冲突，CAS会重试直到没有冲突</p><h4 id="CAS操作过程"><a href="#CAS操作过程" class="headerlink" title="CAS操作过程"></a>CAS操作过程</h4><p>CAS比较交换的过程可以大概理解为CAS(V, O, N)</p><ul><li>V（vary）：变量</li><li>O（old）：旧值</li><li>N（new）：新值</li></ul><p>过程：（整个过程是基于硬件指令级实现，具有原子性）</p><blockquote><p>读取V的值，若V &#x3D;&#x3D; O，那么说明内存中的值没有别其他线程修改过，就没有线程冲突，那么即可将N写入V。若V !&#x3D; O，说明该值已经被修改过了，CAS失败。</p></blockquote><p>Synchronized VS CAS:</p><blockquote><p>synchronized在存在线程竞争的情况下，会出现线程阻塞和唤醒带来的性能问题，这是一种<strong>阻塞同步</strong></p><p>CAS会在CAS操作失败后进行一定的尝试，而不是进行耗时的挂起唤醒操作，因此也叫做<strong>非阻塞同步</strong></p></blockquote><h4 id="CAS的应用场景"><a href="#CAS的应用场景" class="headerlink" title="CAS的应用场景"></a>CAS的应用场景</h4><ul><li><p>concurrency包的实现</p></li><li><p>Lock实现中CAS该百年state变量</p></li><li><p>atomic包的实现</p></li></ul><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><ul><li><p>ABA问题</p><blockquote><p>问题：</p><p>CAS通过检查旧值是否变化来检测变量是否改变，若变量变化如下A-&gt;B-&gt;A，那么CAS则无法检测到变量的变化</p><p>解决方法：</p><p>加上版本号1A-&gt;2B-&gt;3A</p><p>Java在atomic包中提供了AtomicStampedReference来解决ABA问题</p></blockquote></li><li><p>自旋对CPU的占用带来的性能消耗</p><blockquote><p>CAS若失败不会将线程挂起释放CPU资源，会进行自旋（死循环）进行重试直到CAS成功，自旋时间过程的话会对性能造成很大消耗</p><p>若JVM支持处理器提供的pause指令，可以在效率上有一定提升</p></blockquote></li><li><p>只能保证一个共享变量的原子操作</p><blockquote><p>问题：</p><p>对一个变量执行CAS操作可以保证器原子性，若对多个共享便变量进行操作，CAS就不能保证这个操作的原子性</p><p>解决办法：</p><p>利用对象整合多个共享变量，对对象执行CAS操作。</p><p>atomic包中提供了AtomicReference来保证引用对象之间的原子性</p></blockquote></li></ul><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>如何理解对象锁：</p><p>对象锁是对象的一个标志，这个标志存放在Java对象的对象头的Mark Word中。</p><p>Mark Word：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315cff10307a29tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315d056598e4c2tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>锁在大多数情况下不存在多线程竞争，并且总是由同一线程多次获得，为减少同一线程获取锁的代价而引入偏向锁</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxODMyMjU1,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="偏向锁逻辑"><a href="#偏向锁逻辑" class="headerlink" title="偏向锁逻辑"></a>偏向锁逻辑</h4><p>通用逻辑：</p><ol><li>检测锁标志位。若为01，说明处于无锁或偏向锁状态，才能进行偏向锁逻辑判断。</li><li>检测偏向锁标志位。若为0，说明是无锁（无锁不可偏向），进入轻量级锁逻辑（CAS竞争锁），若是1说明是偏向锁，进入偏向锁逻辑。</li></ol><p>偏向锁逻辑：</p><ol start="3"><li>检查Mark Word中的Thread Id。若为当前线程ID说明当前线程已经获取锁，不需要再获取锁，而是往自己的线程栈中添加一条Displaced Mark Word为空的Lock Record，用于重入统计。</li></ol><blockquote><p>偏向锁的释放与偏向锁的撤销：</p><p>偏向锁的释放：</p><ul><li>时机：退出同步代码块</li><li>操作：删除线程栈中的Lock Word（不会修改对象头中的锁状态）</li></ul><p>偏向锁的撤销：</p><ul><li>时机：发生锁竞争</li><li>操作：锁升级或者重偏向</li></ul></blockquote><ol start="4"><li>若Mark Word中的Thread Id不是当前线程ID，则进行CAS操作替换Thread Id。若当前对象锁处于匿名偏向状态（Thread Id为0，无锁可偏向）CAS会成功，则获取锁，并插入Lock Word到当前线程栈，执行同步代码块</li></ol><p>锁撤销逻辑：</p><ol start="5"><li>若CAS失败，说明对象锁已经被其他线程占用，进入偏向锁撤销逻辑。</li><li>等到全局安全点，暂停持有对象锁的线程，检测其状态，若其存活且在执行同步块代码，则将锁升级为轻量级锁。</li><li>若线线程未存活或者存活但未执行同步块代码。若开启重偏向，则将锁置为匿名偏向状态然后CAS获取偏向锁，若没开启重偏向，将锁置为无锁状态，然后升级为轻量级锁。</li><li>最后唤醒暂停的线程，从安全点继续执行代码</li></ol><h4 id="批量重偏向与批量撤销"><a href="#批量重偏向与批量撤销" class="headerlink" title="批量重偏向与批量撤销"></a>批量重偏向与批量撤销</h4><p>为什么有该机制：</p><blockquote><p>在出现锁竞争，即执行锁撤销逻辑的时候，需要暂停线程，并等到safe point，再撤销锁或升级锁，会消耗一定性能。若多线程竞争频繁，那么偏向锁不会提高性能，反而导致性能下降。</p></blockquote><p>解决的场景：</p><blockquote><p> 批量重偏向机制：一个线程创建大量对象，并执行了初始的同步操作，后面另一个线程也将这些对象作为锁对象进行操作，这样就会导致大量的锁撤销操作</p><p>批量撤销机制：再多线程竞争激烈的场景下竞争使用偏向锁</p></blockquote><p>原理：</p><blockquote><p>偏向锁撤销计数器：以class为单位，为每个class维护一个偏向锁撤销计数器，每次次该class的对象发生偏向撤销操作，该计数器+1</p><p>当计数器达到批量重偏向阈值（20）：</p><blockquote><p>epoch字段：</p><p>每个class对象会有一个epoch字段（可以理解为第几代偏向锁），处于偏向锁状态的对象的Mark Word中也有该字段，初始值为创建该对象时class中的epoch值。</p><p>批量重偏向操作：</p><p>将class中的epoch值+1（表示之前那一代的偏向锁失效）</p><p>被线程持有的该class类的锁对象，将其epoch值+1（保证已加锁的线程继续持有锁）（该操作需要等到全局安全点）</p><p>已经被线程释放的锁对象，其epoch值没有更新，其他线程去申请锁时，发现对象锁的epoch值与class中的epoch值不一致，则会进行自动重偏向（即不会进行锁撤销，而是直接通过CAS将其MarkWord中的Thread Id改为当前线程）</p></blockquote><p>当计数器达到批量撤销阈值（40）：</p><blockquote><p>直接标记该class为不可偏向，之后该class的锁直接走轻量级锁的逻辑</p></blockquote></blockquote><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><ol><li><p>复制Mark Word。</p><blockquote><p>线程再执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称之为<strong>Displaced Mark Word</strong>。</p></blockquote></li><li><p>CAS替换Mark Word。</p><blockquote><p>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获取锁。</p></blockquote></li><li><p>自旋获取锁。</p><blockquote><p>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</p></blockquote></li></ol><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>使用CAS操作将Displaced Mark Word替换回对象头</p><ul><li>成功：说明没有竞争发生</li><li>失败：说明当前锁存在竞争，锁回膨胀为重量级锁</li></ul><h3 id="锁比较"><a href="#锁比较" class="headerlink" title="锁比较"></a>锁比较</h3><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315cb91da523d9tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="各种锁的对比"></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="volatile简介"><a href="#volatile简介" class="headerlink" title="volatile简介"></a>volatile简介</h2><blockquote><p>被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p></blockquote><p>synchronized是阻塞式同步，在线程竞争激烈的情况下回升级成重量级锁，会执行线程的挂起和唤醒操作。而volatile就可以说是JVM提供的<strong>最轻量级</strong>的同步机制。</p><h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><blockquote><p>在生成汇编代码的时候会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀指令</strong></p></blockquote><h3 id="Lock前缀指令对多核处理器产生的影响"><a href="#Lock前缀指令对多核处理器产生的影响" class="headerlink" title="Lock前缀指令对多核处理器产生的影响"></a>Lock前缀指令对多核处理器产生的影响</h3><ul><li>将当前CPU核心缓存行的数据写回系统内存</li><li>使其他CPU核心内缓存了该内存地址的数据无效</li></ul><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>缓存一致性协议的意义：</p><blockquote><p>一个CPU核心将更新后的数据写回系统内存，但是其他核心中的数据还是旧的，若使用旧值执行计算就会有问题，缓存一致性协议能够保证个个CPU核心中的缓存是一致的。</p></blockquote><p>缓存一致性协议的实现：</p><blockquote><p> 每个核心通过嗅探总线上传播的数据来检查自己缓存的数据是否已经过期。若核心发现缓存行对应的内存地址上数据发生修改，就会将对应缓存行设置为无效状态，当核心需要该数据时，会重新从系统内存中加载数据。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Lock前缀指令会引起处理器缓存写回内存</li><li>一个处理器的缓存写回内存会导致其他处理器中的缓存失效</li><li>处理器读取变量数据，发现本地缓存失效，会从内存中读取最新值</li></ul><h2 id="volatile的happens-before关系"><a href="#volatile的happens-before关系" class="headerlink" title="volatile的happens-before关系"></a>volatile的happens-before关系</h2><h3 id="并发分析的切入点"><a href="#并发分析的切入点" class="headerlink" title="并发分析的切入点"></a>并发分析的切入点</h3><h4 id="两个核心："><a href="#两个核心：" class="headerlink" title="两个核心："></a>两个核心：</h4><ul><li>JMM内存模型</li><li>happens-before</li></ul><h4 id="三大性质："><a href="#三大性质：" class="headerlink" title="三大性质："></a>三大性质：</h4><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="volatile的happens-befores规则"><a href="#volatile的happens-befores规则" class="headerlink" title="volatile的happens-befores规则"></a>volatile的happens-befores规则</h3><blockquote><p>对一个volatile域的写，happens-befors于任意后续对这个volatile域的读</p></blockquote><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span>&#123;<br>        a = <span class="hljs-number">1</span>;          <span class="hljs-comment">//1</span><br>        flag = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//2</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(flag)&#123;      <span class="hljs-comment">//3</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">//4</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码实例的happens-before关系图：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796b904658tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="VolatileExample的happens-before关系推导"></p><p>happens-before分析：</p><p>加锁线程A先执行writer方法，然后线程B执行reader方法。</p><p>黑色箭头：程序顺序规则</p><p>红色箭头：volatile读写顺序规则</p><p>蓝色箭头：传递性规则</p><p>线程A happen-before 线程B，操作2 happensbefore 操作3，所以在线程A中的操作flag &#x3D; true可以马上被线程B感知，并且根据传递性规则，操作1 happens-before操作4，保证线程A对a的修改可以被线程B感知。</p><h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>还是针对上述代码进行分析，假设线程A执行writer方法，线程B随后执行reader方法，初始线程flag和a为初始状态。</p><p>线程A执行volatile写后的状态图：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796b8acbd7tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="线程A执行volatile写后的内存状态图"></p><p>线程B读取volatile变量的内存变化：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796bd467fbtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="线程B读volatile后的内存状态图"></p><p>从横向看，线程A和线程B之间进行了依次通信，线程A在写volatile变量时，就像是给线程B发送了一个消息，告诉线程B它对应的变量过期了，线程B得知自己的变量过期了，那么线程B需要读取变量的时候就去主存中加载最新值。</p><h2 id="volatile的内存语义实现"><a href="#volatile的内存语义实现" class="headerlink" title="volatile的内存语义实现"></a>volatile的内存语义实现</h2><blockquote><p>为了性能优化，在不改变正确语义的前提下，允许编译器和处理器的指令重排序，为了实现volatile的内存语义，就需要禁止一些重排序。通过添加<strong>内存屏障</strong>实现</p></blockquote><p>内存屏障分类：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e1471c0tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="内存屏障分类表"></p><p>JMM针对编译器制定的volatile重排序规则表：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e2f06datplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="volatile重排序规则表"></p><p>对于上述规则的简述：</p><ul><li>禁止volatile读后的任何操作与之重排序</li><li>禁止volatile写前的任何操作与之重排序</li><li>禁止volatile写于volatile读重排序</li></ul><p>JMM实现上述规则采用的内存屏障策略：</p><ul><li>对于volatile写<ul><li>写前插入StoreSore屏障</li><li>写后插入StoreLoad屏障</li></ul></li><li>对于volatile读<ul><li>读后插入LoadLoad屏障</li><li>读后插入LoadLoad屏障</li></ul></li></ul><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e03b351tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e799b76d34ctplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="final的具体使用场景"><a href="#final的具体使用场景" class="headerlink" title="final的具体使用场景"></a>final的具体使用场景</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h4><p>每个类的成员变量可以分为<strong>类变量、实例变量</strong>。</p><p>final变量必须初始化，系统不会进行隐式初始化。</p><p>成员变量的赋初值时机：</p><ul><li>类变量：<ul><li>在声明的时候直接赋初值</li><li>在静态代码块中给类变量赋初值</li></ul></li><li>实例变量：<ul><li>声明变量的时候给实例变量赋初值</li><li>在非静态代码块中赋初值</li><li>在构造器中赋初值</li></ul></li></ul><h4 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h4><p>final局部变量在方法中定义，<strong>形参或者方法体内</strong></p><p>若final变量未在定义的时候初始化，可以在方法体内有一次赋值机会，赋值之后再次赋值就会出错。</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320f7dbcfd83a2tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h4 id="final基本数据类型-VS-final引用数据类型"><a href="#final基本数据类型-VS-final引用数据类型" class="headerlink" title="final基本数据类型 VS final引用数据类型"></a>final基本数据类型 VS final引用数据类型</h4><p>final保证其修饰的变量有且只有一次赋值机会，赋值过后不会再该改变。</p><p>基本数据类型：</p><p>变量保存的是数据本身，所以数据不能修改。</p><p>引用数据类型：</p><p>变量保存的是对象的引用，就是说这个变量保存的应用不能变，即变量只能指向该对象，不能指向其他对象。但是对象本身的属性是可以改变的。</p><h4 id="宏变量"><a href="#宏变量" class="headerlink" title="宏变量"></a>宏变量</h4><blockquote><p>宏变量即常量，在程序中使用到宏变量的地方，编译器会直接将宏变量替换未该变量的字面值</p></blockquote><p>成为宏变量需要满足的三个条件：</p><ul><li>使用final修饰符修饰</li><li>在定义变量的时候就指定了初始值</li><li>该初始值在编译时就能唯一确定</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>被final修饰的方法不能够被子类重写</p></li><li><p>被final修饰的方可以重载</p></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>当一个类被final修饰的时候，表示该类时不能被子类继承的。</p><p>子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此当一个类希望不被继承的时候就可以使用final修饰。</p><h3 id="final使用的例子"><a href="#final使用的例子" class="headerlink" title="final使用的例子"></a>final使用的例子</h3><h4 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h4><p>定义：</p><p>不变类的意思时创建该类的实例后，该实例的实例变量时不可改变的。</p><p>成为不变类需要满足的条件：</p><ul><li>使用private和final修饰符修饰该类的成员变量</li><li>提供带参的构造器用于初始化类的成员变量</li><li>仅为该类的成员变量提供getter方法，不提供setter方法</li><li>有必要的话重写hashCode()和equals()方法，保证用equals判断相同的两个对象其Hashcode值也是相等的</li></ul><h4 id="JDK中提供的不变类"><a href="#JDK中提供的不变类" class="headerlink" title="JDK中提供的不变类"></a>JDK中提供的不变类</h4><p>String类、八个包装类 </p><h2 id="多线程中的final域重排序"><a href="#多线程中的final域重排序" class="headerlink" title="多线程中的final域重排序"></a>多线程中的final域重排序</h2><h3 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h3><h4 id="写final域重排序规则"><a href="#写final域重排序规则" class="headerlink" title="写final域重排序规则"></a>写final域重排序规则</h4><blockquote><p> 禁止对final域的写重排序到构造函数之外。</p></blockquote><p>实现：</p><ul><li>对于编译器：JMM禁止编译器把final域的写重排序到构造函数之外</li><li>对于处理器：编译器在final域写之后，构造函数return之前，插入一个storestore屏障。该屏障可以禁止处理器把final域的写重排序到构造函数之外</li></ul><p>该规则确保：</p><p>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具备这个保证。</p><h4 id="读final域重排序规则"><a href="#读final域重排序规则" class="headerlink" title="读final域重排序规则"></a>读final域重排序规则</h4><blockquote><p> 在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。（这个规则针对处理器）</p></blockquote><p>实现：</p><p>编译器在读final域操作前插入LoadLoad屏障。（实际上，读对象的引用和对该对象的final域存在简介依赖性，一般处理不会重排序这两个操作，但是有些处理器会，这个禁止重排序规则就是针对这些处理器而设定的）</p><p>该规则确保：</p><p>在读一个对象的final域之前，一定会先读这个包含final域的对象的引用</p><h3 id="final域为引用类"><a href="#final域为引用类" class="headerlink" title="final域为引用类"></a>final域为引用类</h3><h4 id="对final修饰的成员域写操作"><a href="#对final修饰的成员域写操作" class="headerlink" title="对final修饰的成员域写操作"></a>对final修饰的成员域写操作</h4><blockquote><p>在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作不能重排序</p></blockquote><h4 id="对final修饰的对象的成员域读操作"><a href="#对final修饰的对象的成员域读操作" class="headerlink" title="对final修饰的对象的成员域读操作"></a>对final修饰的对象的成员域读操作</h4><p>JMM不保证单独对final修饰对象的成员域的修改，与读取final修饰对象的成员域之间的重排序</p><h2 id="final的实现原理"><a href="#final的实现原理" class="headerlink" title="final的实现原理"></a>final的实现原理</h2><ul><li>final域写后插入StoreStore屏障</li><li>final域读前插入LoadLoad屏障</li></ul><h2 id="为什么final引用不能从构造函数中“逸出”"><a href="#为什么final引用不能从构造函数中“逸出”" class="headerlink" title="为什么final引用不能从构造函数中“逸出”"></a>为什么final引用不能从构造函数中“逸出”</h2><p>final域写重排序规则确保在使用一个对象引用的时候该对象的final域已经在构造函数中被初始化过了。</p><p>但是这儿其实有一个前提条件：</p><p>在构造函数结束之前，不能让这个被构造的对象被其他线程可件，也就是说该对象引用不能再构造函数中“逸出”</p><p>逸出的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalReferenceEscapeDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> FinalReferenceEscapeDemo referenceDemo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalReferenceEscapeDemo</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>;  <span class="hljs-comment">//1</span><br>        referenceDemo = <span class="hljs-built_in">this</span>; <span class="hljs-comment">//2</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalReferenceEscapeDemo</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (referenceDemo != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//3</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> referenceDemo.a; <span class="hljs-comment">//4</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程A执行writer方法，线程B执行reader方法</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320f7de16b0ec0tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="final域引用可能的执行时序"></p><p>在线程A中操作1和操作2没有依赖关系，所以操作2可以排在操作1前（操作2是让自己引用自己），这样在构造函数还没结束的时候，线程B已经拿到了构造的对象，但是这个对象还没有构造完成（构造函数还没有结束），此时线程B读final域会读到还未初始化的final域值。</p><h1 id="三大性质"><a href="#三大性质" class="headerlink" title="三大性质"></a>三大性质</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote><p>一个操作时不可中断的，要么全部执行成功，要么全部执行失败，有着“同生共死”的感觉</p></blockquote><h3 id="JMM中的8个原子操作"><a href="#JMM中的8个原子操作" class="headerlink" title="JMM中的8个原子操作"></a>JMM中的8个原子操作</h3><ul><li>lock</li><li>unlock</li><li>read</li><li>load</li><li>use</li><li>assign</li><li>store</li><li>write</li></ul><h3 id="JVM提供的原子性保证："><a href="#JVM提供的原子性保证：" class="headerlink" title="JVM提供的原子性保证："></a>JVM提供的原子性保证：</h3><ul><li><p>基本数据类型的访问读写具有原子性（除了long和double）</p><blockquote><p>原子性变量操作 read、load、use、assign、store、write</p></blockquote></li><li><p>synchronized满足原子性</p><blockquote><p>lock和unlock虽然没有开放使用，但是反映到JVM则是以monitorenter和monitorexit指令开放使用，反映到Java代码中则是synchronized关键字</p></blockquote></li><li><p>volatile不能保证原子性</p><blockquote><p>若要让volatile保证原子性需要符合两条规则</p><ul><li>运算结果不依赖于变量的当前值，或者确保只有一个线程修改便变量的值</li><li>变量不需要域其他的状态变量共同参与不变约束</li></ul></blockquote></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>锁被占用后其他线程只能等待，所以synchronized具有有序性</p></blockquote><h3 id="volatile-1"><a href="#volatile-1" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>volatile包含禁止指令重排序的语义，器具有有序性</p></blockquote><h4 id="Java程序的天然有序性可以总结为："><a href="#Java程序的天然有序性可以总结为：" class="headerlink" title="Java程序的天然有序性可以总结为："></a>Java程序的天然有序性可以总结为：</h4><p>如过在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。即as-if-serial语义。</p><h4 id="DCL（双重检查锁定-Double-Checked-Locking）例子："><a href="#DCL（双重检查锁定-Double-Checked-Locking）例子：" class="headerlink" title="DCL（双重检查锁定 Double-Checked Locking）例子："></a>DCL（双重检查锁定 Double-Checked Locking）例子：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-keyword">public</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重点在于为什么对instance加volatile</strong></p><blockquote><p>instance &#x3D; new Singleton();</p><p>该语句实际包含三个操作：</p><ol><li><p>分配对象的内存空间</p></li><li><p>初始化对象</p></li><li><p>设置instance指向刚分配的内存地址</p></li></ol></blockquote><p>重排序带来的问题：</p><p>重排序可能会导致操作3发生在操作2之前，即对象还没有初始化，instance对象的引用已经可以获取。相当于其他线程可能会拿到还没有初始化完成的instance对象的引用。</p><p>volatile解决：</p><p>使用volatile修饰instance对象，可以禁止2和3的重排序，避免上述问题。</p><ul><li><p>1、2、3操作在单线程中要满足as-if-serial语义</p></li><li><p>为volatile变量instance赋值happens-before读instance变量</p></li><li><p>传递性原则可以推导出，在对instance的初始化发生于对instance对象的访问前</p></li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>synchronized锁释放会将共享变量写回主内存，锁获取会从主内存获取共享变量的最新值。</p><p>volatile变量的读写都会立即更新</p><p>所以说synchronized和volatile都具有见性</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>synchronized：具有原子性、有序性和可见性</li><li>volatile：具有有序性和可见性</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Java内存模型</title>
    <link href="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>线程不安全：</p><blockquote><p>在多线程中代码执行的结果与预期正确的结果不一致，那么这个线程就是线程不安全的</p></blockquote><p>线程安全：</p><blockquote><p>当多个线程访问同一个对象时，如果：</p><ul><li><p>不用考虑这些线程在运行时环境下的调度和交替运行</p></li><li><p>不需要进行额外的同步</p></li><li><p>不需要在调用方进行任何其他的协调操作</p></li></ul><p>调用这个对象的行为都可以获取正确的结果，那么这个对象是线程安全的</p></blockquote><h2 id="出现线程不安全的原因"><a href="#出现线程不安全的原因" class="headerlink" title="出现线程不安全的原因"></a>出现线程不安全的原因</h2><ul><li><p>主内存和工作内存数据不一致</p><blockquote><p>多线程通信</p></blockquote></li><li><p>重排序</p><blockquote><p>性能优化：编译器和处理器指令重排序</p></blockquote></li></ul><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="关于并发编程"><a href="#关于并发编程" class="headerlink" title="关于并发编程"></a>关于并发编程</h2><h3 id="并发编程需要解决的两个问题："><a href="#并发编程需要解决的两个问题：" class="headerlink" title="并发编程需要解决的两个问题："></a>并发编程需要解决的两个问题：</h3><ol><li><p>线程之间如何通信</p><ul><li><p>消息传递</p></li><li><p>共享内存</p></li></ul></li><li><p>线程之间如何同步</p></li></ol><h3 id="Java内存模型是共享内存的并发模型"><a href="#Java内存模型是共享内存的并发模型" class="headerlink" title="Java内存模型是共享内存的并发模型"></a>Java内存模型是<strong>共享内存</strong>的并发模型</h3><blockquote><p>线程之间主要通过读-写共享变量来完成隐式通信</p><p>共享变量：（堆内存数据）</p><ul><li>实例域</li><li>静态域</li><li>数组元素</li></ul><p>局部变量：（栈内存数据）</p><ul><li>方法定义参数</li><li>异常处理参数</li></ul></blockquote><h2 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h2><p>为什么会有内存模型：</p><blockquote><p>CPU和主存的读写速度不在一个数量级别，所以CPU有多级缓存，用于平衡这种差距，内存模型用于抽象这种模式</p></blockquote><p>内存模型的工作方式：</p><blockquote><p>共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且把位于主存中的共享变量拷贝到自己的工作内存中，之后线程对共享变量的而读写均作用于该副本，并在某个时刻将修改过的副本写回主存</p></blockquote><p>内存模型的任务：</p><blockquote><p>JMM决定了一个线程对共享变量的写入何时对其他线程可见（何时将工作内存中修改的副本写回主内存）</p></blockquote><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b2410a9e3ebtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p>Java内存模型下的线程通信：</p><blockquote><p>A线程和B线程的通信过程：</p><ol><li>线程A从主内存中将共享变量读入线程A的工作内存，并对其进行修改，修改过后将数据重新写回主内存中覆盖旧数据</li><li>线程B从主内存中读取最新的共享变量</li></ol><p>可能遇见的问题:</p><ul><li>“脏读”现象：线程A修改数据后还没有写回主内存，此时线程B读到的是过期的数据</li></ul><p>如何解决脏读：</p><ul><li>同步机制：通过同步机制控制不同线程操作发生的相对顺序来保证读写的顺序</li><li>volatile关键字：使用volatile关键字强制刷新到主内存，使得每次对volatile变量的修改立即对每个线程可见</li></ul></blockquote><h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><h2 id="重排序简介"><a href="#重排序简介" class="headerlink" title="重排序简介"></a>重排序简介</h2><p>重排序的目的：</p><blockquote><p>一个好的内存模型要放松对处理器和编译器队则的束缚。</p><p>软件和硬件的共同目标：在不改变程序执行结果的前提下，尽可能提高并行度</p></blockquote><p>重排序分类：</p><ul><li><p>编译器重排序</p><blockquote><p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序</p></blockquote></li><li><p>处理器重排序</p><ul><li><p>指令级并行重排序</p><blockquote><p>现代处理器采用指令级并行技术将多条指令重叠执行。</p><p>如果<strong>不存在数据依赖性</strong>，处理器可以改变语句对应机器指令的执行顺序</p></blockquote></li><li><p>内存系统重排序</p><blockquote><p>由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去是乱序执行</p></blockquote></li></ul></li></ul><p>针对重排序JMM做了什么：</p><ul><li><p>针对编译器重排序</p><blockquote><p>禁止一些特定类型的编译器重排序：</p><p>JMM的编译器重排序规则会禁止一些特定类型的编译器重排序</p></blockquote></li><li><p>针对处理器重排序</p><blockquote><p>内存屏障指令：</p><p>编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序</p></blockquote></li></ul><h2 id="重排序规则"><a href="#重排序规则" class="headerlink" title="重排序规则"></a>重排序规则</h2><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p>as-if-serial语义：</p><blockquote><p>对于程序员来说单线程程序是按照顺序执行的</p></blockquote><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before语义：</p><blockquote><p>一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</p></blockquote><p>八项规则：</p><ol><li><p>程序顺序规则（as-if-serial）</p><blockquote><p>一个线程中的每个操作，happens-before于该线程中的任意后续操作</p></blockquote></li><li><p>监视器锁规则</p><blockquote><p>对一个锁的解锁，happens-before于随后对于这个锁的加锁</p></blockquote></li><li><p>volatile变量规则</p><blockquote><p>对于一个volatile域的写，happens-befors于任意后续对这个volatile域的读</p></blockquote></li><li><p>传递性</p><blockquote><p>若A happens-before B，B happens-before C，那么A happens-before C</p></blockquote></li><li><p>start()规则</p><blockquote><p>如果A线程启动线程B，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作</p></blockquote></li><li><p>join()规则</p><blockquote><p>如果线程A执行ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作返回</p></blockquote></li><li><p>程序中断规则</p><blockquote><p>对线程的interrupted()方法的调用先行于被中断函数的代码检测到中断时间的发生</p></blockquote></li><li><p>对象finalize规则</p><blockquote><p>一个对象的初始化完成（构造函数执行结束）先于发生它的finalize()方法的执行</p></blockquote></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h2><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b3505fe3170tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="JMM层级图"></p><p>JMM是语言级的内存模型，JMM处于中间层：</p><p>向上面向程序员：</p><ul><li>提供基于JMM的关键字和J.U.C包下的一些具体类方便程序员进行并发编程</li><li>happens-before语义为程序员提供易于理解、易于编程的内存模型</li></ul><p>向下面向编译器和处理器：</p><ul><li><p>禁止编译器特定重排序，处理器内存屏障指令，实现happens-before语义</p></li><li><p>允许不改变程序执行结果的优化</p><blockquote><ul><li>允许不改变happens-before语义的重排序</li><li>编译器分析一个锁只会被单个线程访问，可以消除锁</li><li>编译器分析一个volatile变量只会被单个线程访问，编译器将其作为普通变量处理</li></ul></blockquote></li></ul><h2 id="happens-before与JMM的关系"><a href="#happens-before与JMM的关系" class="headerlink" title="happens-before与JMM的关系"></a>happens-before与JMM的关系</h2><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b4732a0ed2ctplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="happens-before与JMM的关系"></p><ul><li><p>一个happens-before规则对应一个或多个编译器和处理器重排序规则。</p></li><li><p>对于Java程序员来说，只需要根据happens-before规则进行多线程编程即可</p></li><li><p>JMM为程序员提供内存可见性保证，以及实现复杂的重排序规则</p></li></ul><h2 id="后续可能需要关注的问题"><a href="#后续可能需要关注的问题" class="headerlink" title="后续可能需要关注的问题"></a>后续可能需要关注的问题</h2><ul><li>可见性问题：数据“脏读”现象</li><li>有序性问题：DCL（双重检查锁）问题，需要使用volatile禁止重排序</li><li>原子性问题：i++，可能跟出现线程安全问题</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发基础</title>
    <link href="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="并发缺点"><a href="#并发缺点" class="headerlink" title="并发缺点"></a>并发缺点</h2><h3 id="1-频繁的上下文切换"><a href="#1-频繁的上下文切换" class="headerlink" title="1. 频繁的上下文切换"></a>1. 频繁的上下文切换</h3><h4 id="为什么会有频繁的多线程切换："><a href="#为什么会有频繁的多线程切换：" class="headerlink" title="为什么会有频繁的多线程切换："></a>为什么会有频繁的多线程切换：</h4><ul><li><p>真多线程：多核CPU，每个线程在不同的CPU上执行</p></li><li><p>宏观多线程：CPU分配给每个线程一定的时间片，CPU通过不断切换线程，宏观上就是多个线程同时执行</p><blockquote><p>每次切换线程需要保存线程当前状态，加载下一个线程之前保存的状态，这就是上下文切换，每个线程执行的时间很短，所以说上下文切换就很频繁。</p></blockquote></li></ul><h4 id="减少上下文切换的方法："><a href="#减少上下文切换的方法：" class="headerlink" title="减少上下文切换的方法："></a>减少上下文切换的方法：</h4><ul><li><p>无锁并发编程</p><blockquote><p>参考concurrentHashMap锁分段思想，减少多线程竞争</p></blockquote></li><li><p>CAS算法</p><blockquote><p>使用乐观锁，减少锁竞争带来的上下文切换</p></blockquote></li><li><p>使用最少线程</p><blockquote><p>避免创建不必要的线程</p></blockquote></li><li><p>协程</p><blockquote><p>在单线程中实现多任务调度</p></blockquote></li></ul><h3 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2. 线程安全问题"></a>2. 线程安全问题</h3><h4 id="线程安全问题：死锁"><a href="#线程安全问题：死锁" class="headerlink" title="线程安全问题：死锁"></a>线程安全问题：死锁</h4><h5 id="如何避免死锁："><a href="#如何避免死锁：" class="headerlink" title="如何避免死锁："></a>如何避免死锁：</h5><ul><li>避免一个线程获得多个锁&#x2F;多个资源</li><li>使用定时锁</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则可能会解锁失败</li></ul><h4 id="JMM内存模型中的问题"><a href="#JMM内存模型中的问题" class="headerlink" title="JMM内存模型中的问题"></a>JMM内存模型中的问题</h4><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步和异步通常用来形容一次方法调用。</p><ul><li>同步方法：调用者必须等待同步方法结束后，才会执行后面的代码。</li><li>异步方法：调用者调用方法后会直接继续执行后续代码，被调用的代码执行完毕后会通知调用者</li></ul><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li>并发：一个CPU核心分时执行多个线程</li><li>并行：多个CPU核心同时分别执行一个线程</li></ul><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><ul><li>阻塞：若一个线程占有了临界区的资源，其他线程若要访问，那么就需要等待这个线程释放该资源，会导致等待的线程挂起，这就叫阻塞</li><li>非阻塞：强调没有线程可以阻塞其他线程，所有线程都会尝试地往前运行</li></ul><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用，但是同一时刻只能由一个线程占有</p><h2 id="线程状态转换及其基本操作"><a href="#线程状态转换及其基本操作" class="headerlink" title="线程状态转换及其基本操作"></a>线程状态转换及其基本操作</h2><h3 id="1-新建线程"><a href="#1-新建线程" class="headerlink" title="1. 新建线程"></a>1. 新建线程</h3><blockquote><p>Java程序天生就是多线程的，包含：</p><ol><li>分发处理发送个JVM信号的线程</li><li>调用对象finalize方法的线程</li><li>清除Reference的线程</li><li>main线程，用户线程的入口</li></ol></blockquote><ul><li><p>方法一、继承Thread类，重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        Sytem.out.println(<span class="hljs-string">&quot;通过继承Thread&quot;</span>)<br>        <span class="hljs-built_in">super</span>.run();<br>    &#125;<br>&#125;;<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p>方法二、实现runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;通过实现runnable接口&quot;</span>)<br>    &#125;<br>&#125;);<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p>方法三、实现callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecuterService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;String&gt; future = service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>()&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;通过实现Callable接口&quot;</span><br>    &#125;<br>&#125;);<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get();<br>    System.out.println(result);<br>&#125;<span class="hljs-keyword">catch</span>(Exception)&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意事项：</strong></p><ul><li><p>优先考虑通过实现接口创建线程（Java只能单一继承）</p></li><li><p>可以将callable包装成FutureTask</p><blockquote><p>FutureTask同时实现Future接口和Runnable接口，所以将FutureTask提交给ExecutorService执行后，可以直接从FutureTask获取异步结果</p><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159b250b111f7tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p></blockquote></li><li><p>可以将runnable包装成callable</p><blockquote><p>runnable执行不会返回结果，callable执行后会返回结果</p></blockquote></li></ul><h3 id="2-线程状态转换"><a href="#2-线程状态转换" class="headerlink" title="2. 线程状态转换"></a>2. 线程状态转换</h3><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159b8a740b329tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p>六个状态：</p><ul><li><p>NEW</p><blockquote><p>线程创建后即为NEW状态</p></blockquote></li><li><p>RUNNABLE</p><blockquote><p>线程执行start()过后进入RUNNABLE状态，此时线程由系统调度分配时间片，线程也可以使用yeild()主动放弃时间片</p><p>使用Object.notify()或Object.notifyAll()方法可以将WAITING和TIME_WAITING状态的线程切换至RUNNABLE状态</p></blockquote></li><li><p>BLOCKED</p><blockquote><p>当线程出现资源竞争，即进入synchronized方法或代码块时需要获取锁，若没有获取锁则进入阻塞状态</p></blockquote></li><li><p>WAITING</p><blockquote><ul><li><p>调用锁对象的wait()、join ()方法</p></li><li><p>LockSupport.lock()</p></li><li><p>调用juc包中的锁对象进行加锁（因为其底层调用的是LockSupport的方法）</p></li></ul></blockquote></li><li><p>TIME_WAITING</p><blockquote><ul><li>wait(long)</li><li>sleep(long)</li><li>join(long)</li><li>LockSupport.parkNanos()</li><li>LockSupport.parkUtil()</li></ul></blockquote></li><li><p>TERMINATID</p></li></ul><h3 id="3-线程的基本操作"><a href="#3-线程的基本操作" class="headerlink" title="3. 线程的基本操作"></a>3. 线程的基本操作</h3><ol><li><p>interrupted</p><blockquote><p>中断可以理解为线程的一个标志位，它表示一个运行中的线程是否被其他线程执行了中断操作。</p><ul><li><p>其他线程可以通过interrupt()方法打断某线程</p></li><li><p>线程可以在线程内部调用isInterrupted()来感知是否被其他线程中断</p></li><li><p>Thread的静态方法可以对档期那线程进行中断操作，同时该操作会清除中断标志位</p></li></ul></blockquote><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159c1a4cc499dtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><blockquote><p>中断可以看作是线程间的一种简便的交互方式。在结束线程时通过中断标志位，使线程由机会清理资源，相较于直接结束线程，这种方式更加优雅和安全。</p></blockquote></li><li><p>join</p><blockquote><p>join方法可以看作是线程间协作的一种方式。</p><p>A执行threadB.join()语义：表示线程A需要等待另线程B执行完毕后才能继续执行</p></blockquote></li><li><p>sleep</p><blockquote><p>方法签名：public static native void sleep(long millis)</p><p>由上可看出sleep时Thread的静态方法，本地实现，让当前线程睡眠指定时间</p></blockquote><p>sleep()与wait()区别：</p><ul><li>sleep()是Thread的静态方法，而wait()是Object的实例方法</li><li>wait必须要在同步方法或同步方法块中调用，即调用前该线程必须已经获得对象锁。sleep没有限制</li><li>wait会释放CPU资源和线程占有的对象锁，使得该线程进入该对象锁的等待队列。sleep只会释放CPU资源，不会释放对象锁</li><li>sleep休眠固定时间后唤醒，等待CPU时间片。wait等待对象锁notify唤醒后离开等待队列，等待CPU时间片</li></ul></li><li><p>yield</p><blockquote><p>方法签名：public static native void yield()</p><p>yield是Thread的静态方法</p><ul><li>当前线程主动让出CPU时间片</li><li>让出的时间片只会分配给与当前线程优先级相同的线程</li><li>当前线程让出CPU时间片后还会参与CPU时间片的竞争</li></ul></blockquote></li></ol><h3 id="4-守护线程Daemon"><a href="#4-守护线程Daemon" class="headerlink" title="4. 守护线程Daemon"></a>4. 守护线程Daemon</h3><blockquote><p>守护线程：守护线程是在后台默默守护一些系统服务，比如垃圾回收线程、JIT线程</p><p>用户线程：用户线程就是系统的工作线程，完成整个系统的业务操作</p></blockquote><ul><li><p>用户线程代表整个系统的业务任务全部完成，因此系统没有对象需要守护，守护线程自然也就结束。</p></li><li><p>当一个Java应用中只剩下守护线程的时候，虚拟机就会退出。</p></li><li><p>守护线程不会执行finnaly块中的代码</p></li><li><p>在线程调用start()前对调用setDaemon (true)将线程设置为守护线程</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>鼎桥面试预习</title>
    <link href="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/"/>
    <url>/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>A</p><ol><li><p>TCP和UDP的区别 </p><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>可靠性</td><td>不可靠传输</td><td>可靠传输，流量控制和拥塞控制</td></tr><tr><td>连接对象数量</td><td>一对N，N对一，多对多</td><td>只能一对一</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>小，8字节</td><td>大，20-60字节</td></tr><tr><td>使用场景</td><td>实时应用：IP电话、视频会议、直播</td><td>要求可靠传输的应用：文件传输</td></tr></tbody></table><ul><li>TCP（可靠性：文件下载，查看网页，邮件）<ul><li>面向连接：三次握手，四次挥手</li><li>仅支持单播传输</li><li>面向字节流：TCP对于来自应用层的报文可能会拆分后分别加上TCP头传输</li><li>可靠传输：TCP段编码和确认号可以进行<strong>丢包判断</strong>，和保证包的<strong>按序接收</strong></li><li>拥塞控制</li><li>全双工通信：TCP允许通信双方的应用程序在任何时候都能发数据，且双方都有缓存，TCP可以立即发送报文，也可以缓存后一次发送多个报文。</li></ul></li><li>UDP（实时性：电话会议）<ul><li>面向<strong>无连接</strong>：UDP只会在收发数据的时候增加或去除一个协议头</li><li><strong>面向报文</strong>：UDP对应用层发送来的报文不做处理，保留边界（不合并，不拆分）。所以应用程序必须自己选择合适大小的报文。</li><li><strong>单播、多播和广播</strong>功能</li><li><strong>不可靠</strong>性：UDP不管发送的数据是否被接收到；UDP没有拥塞控制，发送速度取决于上层，在网络拥堵的时候会丢包，但是在实时性要求高的场景需要使用UDP</li><li>头部小，效率高</li></ul></li></ul></li><li><p>UDP不可靠，为什么还要用UDP</p><ul><li>UDP头部开销小，无连接的特性使其传输效率高</li><li>实时性应用更关心数据的实时性，可以牺牲一定的可靠性</li></ul></li><li><p>UDP采取什么措施来提高正确率</p><ul><li>有两字节的检验和，用于判断数据在传输中是否出错，有错就丢弃</li></ul></li></ol><p>B</p><ol><li><p>Zoo<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>er的原理有了解吗？为什么要用Zoo<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>er做服务注册</p></li><li><p>Http和Https的区别，证书有什么用？</p><ul><li><p>HTTPS可以理解位HTTP + SSL&#x2F;TLS</p></li><li><p>TLS的前身是SSL：SSl协议位于TCP和各种应用层协议之间，为数据传输提供安全支持</p></li><li><p>数字证书：CA使用自己的私钥将服务器公钥进行加密生成数字签名，然后将（公钥信息+公钥+数字签名）打包成数字证书。服务器在发送内容时，使用私钥对内容进行签名，连同证书一起发给客户端，客户端拿到（私钥加密的内容+数字证书）后，向CA请求数字证书真伪，然后CA使用私钥解密，将公钥发送给客户端。</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程"></p></li></ul></li><li><p>Http的传输协议是什么？</p><ul><li>TCP</li></ul></li><li><p>MySQL 插入一条<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>，会直接更新到磁盘中吗？（change pool）</p><p>不会，WAL技术（Write-Ahead Logging）先写日志（redo log），再写磁盘（服务器空闲的时候）</p></li><li><p>MySQL宕机了怎么保证事务？（redo log）</p><p>redo log两阶段提交：（保证两个log的一致性）</p><ol><li>redo log写入日志处于prepare状态</li><li>binlog写入日志后redo log处于commit状态</li><li>后面服务器会根据redolog将数据真正写入数据库中</li></ol><p>宕机：</p><ol><li>在redolog写入前宕机，没有日志，且没有提交事务，不需要处理</li><li>在redolog的prepare状态后宕机，可以根据redolog来继续提交或者回滚</li><li>在redolog的commit状态后宕机，根据redolog把数据写入磁盘</li></ol></li><li><p>TCP和UDP的区别</p></li><li><p>TCP的<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>-live是什么？</p><ul><li><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p></li><li><p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p></li></ul></li><li><p>索引失效的例子？</p><ul><li><p>联合索引不满足左前缀法则</p><blockquote><p>联合索引:（a，b）先根据a排序，在a相同的情况下，使用b排序</p><p>最左前缀原则：若索引有多列，查询要从最左前列开始并且不跳过索引中的列</p></blockquote><ul><li>直接查找where b &#x3D; xxx；</li><li>like索引失效</li><li>范围查询右边失效原理。where a &gt; xxx and b &#x3D; xxx;</li></ul></li><li><p>在索引列参与运算，或使用了函数</p></li><li><p>使用select *</p></li><li><p>类型隐式转换</p></li><li><p>使用or操作：or左右是不同的列，且其中一个是全表扫描；或者or左右是相同列，同时使用&gt;和&lt;</p></li><li><p>两列做比较</p></li><li><p>is not null，not in，not exists</p></li><li><p>order by</p></li><li><p>DBMS针对不同参数优化：若全表扫描比索引快，则使用全表扫描</p></li></ul></li><li><p>遇到慢查询，你怎么解决？</p><ul><li>升级硬件。CPU和IO</li><li>软件排查<ul><li>使用EXPLAIN查看执行计划关注key和extra</li><li>查询没有命中任何索引，优化表索引结构</li><li>查询、排序没有命中覆盖索引，考虑添加联合索引</li></ul></li><li>优化建议<ul><li>select数据太多（分页控制、分批查询、精简查询列）</li><li>索引失效的解决</li><li>可能未定义索引</li><li>查询语句过于复杂（拆分为多个简单查询，放于同一事务）</li></ul></li></ul></li><li><p>索引为什么用B+树不用B树</p><ul><li>单一节点存储更多元素，查询IO次数会更少</li><li>所有查询都要查找叶子节点，查找性能稳定</li><li>所有子节点形成有序链表，便于范围查询</li></ul></li><li><p>聚集索引和非聚集索引的区别是啥？</p><ul><li>聚集索引和非聚集索引的<strong>根本区别</strong>是表记录的排列顺序和与索引的排列顺序是否一致。</li></ul></li></ol><p>C</p><ol><li><p>重载和重写区别</p><ul><li>重载：一个类的多态性的表现，在一个类中定义了多个方法名相同，参数数量或种类和次序不同的方法。</li><li>重写：子类与父类的以一种多态性表现，子类中存在和父类方法名、参数、返回值均相同的方法。</li></ul></li><li><p>GC算法有那些</p><ul><li><p>复制算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916203852553.png" alt="img"></p></li><li><p>标记 - 清除算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204202965.png" alt="img"></p></li><li><p>标记 - 整理算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204205977.png" alt="img"></p></li><li><p>分代回收算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204228959.png" alt="img"></p></li></ul></li></ol><p>D</p><ol><li><p>springBoot启动流程</p><ol><li>new SpringApplication对象。从main中找到run()方法前new一个SpringApplication对象</li><li>创建应用监听器。进入run()方法，创建SpringApplicationRunListeners开始监听</li><li>加载配置环境。加载ConfigurableEnvironment，然后把配置Environment加入监听对象</li><li>加载应用上下文。加载ConfigurableApplicationContext，作为run方法的返回对象</li><li>创建Spring容器、refreshContext（context），实现starter自动化配置和bean的实例化等工作</li></ol></li><li><p>springAOP（Aspect-oriented Programming）</p><p>为什么引入AOP</p><ul><li><p>OOP的局限性</p><blockquote><p>静态化语言：类结构一旦定义，不容易被修改</p><p>侵入式扩展：通过继承或组合组织新的类结构</p></blockquote></li><li><p>通过AOP抽离非业务逻辑代码</p><blockquote><p> 通过AOP可以将一些非业务逻辑的代码从业务中抽离出来，以非入侵的方式与原方法进行协同。这样可以使原方法更专注于业务逻辑，代码接口更加清晰，便于维护</p></blockquote></li></ul><p>AOP使用场景</p><ul><li>日志</li><li>统计</li><li>安防</li><li>性能</li></ul><p>AOP中的重要概念</p><ul><li><p>AspectJ：切面。</p><blockquote><p>（Join point + Advice + Pointcut）三者的统称。只是一个概念，没有具体的接口或类与之对应。</p></blockquote></li><li><p>Join point：连接点。</p><blockquote><p>指程序执行过程中的一个点，例如方法调用、异常处理等。在Spring AOP中，仅支持方法级别的连接点。</p></blockquote></li><li><p>Advice：通知。</p><blockquote><p>我们定义的一个切面中的横切逻辑，有”around“，”before“和”after“三种类型。在很多的AOP实现框架中，Advice通常作为一个拦截器，也可以包含多个拦截器作为一个链路围绕着Join point进行处理。</p></blockquote></li><li><p>Pointcut：切点。</p><blockquote><p>用于匹配连接点,一个AspectJ中包含哪些Join point需要由Pointcut进行筛选 。</p></blockquote></li><li><p>Introduction：引介。</p><blockquote><p>让一个切面可以被声明被通知的对象实现任何他们没有真正实现的额外接口。例如让一个代理对象代理两个目标类</p></blockquote></li><li><p>Weaving：织入。</p><blockquote><p>在有了连接点、切点、通知以及切面，如何将让门应用到程序中呢？就是使用织入，在切点的引导下，将通知逻辑插入到目标方法上，使得我们的通知逻辑在方法调用时得以执行。</p></blockquote></li><li><p>AOP proxy：AOP代理。</p><blockquote><p>指在AOP实现框架中实现切面协议的对象。在Spring AOP中有两种代理，JDK动态代理和CGLIB动态代理。</p></blockquote></li><li><p>Target object：目标对象。</p><blockquote><p>被代理的对象。</p></blockquote></li></ul></li><li><p>springAop是基于哪两种动态代理</p><ul><li>JDK动态代理</li><li>CGLIB动态代理</li></ul></li><li><p>SpringMVC一次请求的过程</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/5220087-3c0f59d3c39a12dd.png" alt="img"></p></li><li><p>springBean默认是什么模式（单例）</p></li><li><p>如何将其改为非单例</p></li><li><p>mybatis如何防止sql注入</p><ul><li><p>SQL注入发生在SQL预编译阶段</p></li><li><p>PreparedStatement预编译对象</p></li><li><p>预编译，替换占位符</p></li></ul></li><li><p>mysql隔离级别、事务特性</p><p>事务特性：</p><ul><li>原子性</li><li>一致性</li><li>隔离性<ul><li>读未提交</li><li>读提交</li><li>可重复度</li><li>串行化</li></ul></li><li>持久性</li></ul></li><li><p>可重复读是怎么解决不可重复读问题的（间隙锁）</p><p>在事务开始的时候创建快照，并对更新的行加上行锁</p></li><li><p>Java集合类</p></li><li><p>JVM内存模型</p><p>线程共享：</p><ul><li><p>方法区</p><blockquote><p>类信息、常量、静态变量、JIT编译后的代码</p><p>运行时常量池：编译期间生成的各种字面常量和符号引用</p></blockquote></li><li><p>堆</p><blockquote><p>实例对象</p></blockquote></li></ul><p>线程私有：</p><ul><li><p>虚拟机栈、本地方法栈</p><blockquote><p>栈帧：局部变量表、操作数表</p></blockquote></li><li><p>程序计数器</p></li></ul></li><li><p>垃圾回收过程</p></li><li><p>redis基本类型</p></li><li><p>redis的持久化</p></li><li><p>redis的发布订阅</p></li><li><p>kafka如何保证数据不丢失</p></li><li><p>kafka消费者采用的是哪种模式</p></li></ol><p>E</p><ol><li><p>&#x3D;&#x3D;和equals的区别</p></li><li><p>GC如何判断一个对象可回收</p><ul><li>引用计数法</li><li>可达性分析</li></ul></li><li><p>常用的GC roots对象</p><ul><li>虚拟机栈中的引用对象</li><li>本地方法栈中JNI的引用对象</li><li>方法区中的<strong>类静态属性</strong>引用对象</li><li>方法区中<strong>常量</strong>引用的对象</li></ul></li><li><p>volatile关键字</p><ul><li>变量可见性问题</li><li>指令重排序，Happens-Before</li></ul></li><li><p>为什么会有线程可见性问题</p><ul><li>工作内存中的是主内存的副本，线程之间的工作内存不共享</li><li>A修改后作用在A的工作内存，B看不到</li></ul></li><li><p>线程安全的方式</p><ul><li>synchronized关键字（互斥锁，悲观锁）</li><li>使用Lock接口下的实现类（悲观锁）</li><li>使用线程本地存储ThreadLocal</li><li>使用乐观锁机制，使用版本控制判断实现</li></ul></li><li><p>synchronized在普通方法和静态方法的区别</p></li><li><p>数据库的隔离级别</p></li><li><p>可重复读和读提交哪个性能更好</p></li><li><p>select for update和select区别</p><ul><li>select for update会对查询的行添加排他锁</li></ul></li><li><p>Spring中事务传播属性</p></li><li><p>线程死锁的例子</p></li><li><p>left jon和inner join区别</p><ul><li><p>left join以左表为基础，右表中有不匹配的行直接置为null</p></li><li><p>innerjoin，若有左右表不匹配的行，直接去除</p></li></ul></li><li><p>数据库结果集去重</p><ul><li>DISTINCT（多条记录的每一个字段值完全相同）</li><li>GROUP BY（只有部分字段值重复，但是表存在主键）</li><li>复制到临时表，再查询（只有部分字段重复，但是表没有主键，复制到临时表中就是为了给记录添加自增增长的id）</li></ul></li><li><p>客户端如何实现认证已登录</p><ul><li>cookie+session</li><li>Token</li></ul></li><li><p>同一条url,已登录和未登录为什么不同</p></li><li><p>IOC原理</p><ul><li>Java反射机制</li><li>被调用者实例本来由调用者创建</li><li>IOC使得将对象全部交给Spring管理</li></ul></li><li><p>java异常</p><ul><li>Error<ul><li>OutOfMemoryError</li><li>IOError</li></ul></li><li>Exception<ul><li>IOException</li><li>RuntimeException</li></ul></li></ul></li><li><p>常用的线程安全类</p></li><li><p>设计一个线程安全的HashSet</p></li><li><p>设计模式及其作用</p></li><li><p>SQL注入问题,解决</p></li><li><p>两台tomcat服务器,你已经登录上一台,但是随机访问到另一台要重新登录,如何解决这个问题</p></li></ol><p>F</p><ol><li>JVM新生代和老年代</li><li>线程池的建立</li><li>用过那些数据库</li><li>http和https的区别</li><li>抽象类和接口的区别</li><li>集合类相关</li><li>java中栈和链表是如何实现</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务隔离级别及其实现原理</title>
    <link href="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><ol><li><p>是什么</p><p>数据库事务指的是一组数据操作，事务内的操作要么全部成功，要么全部失败，什么都不做。（实际上事务中可能部分操作已经完成，但是有一部分失败，事务的作用就是回滚已经成功的所有操作）</p></li><li><p>作用</p><p>每一次操作由一系列动作组成，若其中某一个环节异常，那么整个操作都要撤回。</p><p>例如：网购付款，付款后的两个操作，订单更新、库存更新，这两个操作要么都完成，要么都不完成，如果只有一个操作执行，那么订单的数据和库存的数据就不一致。</p></li><li><p>事务特性（<strong>ACID</strong>）</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li><strong>隔离性（Isolation）</strong></li><li>持久性（Durability）</li></ul></li></ol><h2 id="事务隔离要解决的问题"><a href="#事务隔离要解决的问题" class="headerlink" title="事务隔离要解决的问题"></a>事务隔离要解决的问题</h2><ul><li><p><strong>脏读</strong>（未提交的数据（可能会回滚而失效）被其他事务读取）</p><blockquote><p>脏读指读到其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。</p><p>读到了并不一定存在的数据，这就是脏读。</p></blockquote></li><li><p><strong>不可重复读</strong>（同一事务不同时刻同样的查询条件，查出来的数据不同）</p><blockquote><p>通常针对数据<strong>更新（UPDATE）</strong>操作。</p><p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。</p><p>对比可重复读，不可重复读指的是在同一事务内，不同时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。</p></blockquote></li><li><p><strong>幻读</strong>（更新了数据但是好像未生效）</p><blockquote><p>幻读针对数据<strong>插入（INSERT）</strong>操作来说。</p><p>例如：</p><p>事务A对某行内容做了更改，未提交，</p><p>此时事务B插入了与A修改前记录相同的行，并在A事务提交之前提交了，</p><p>此时在A事务中查询，发现刚才做的更改好像未生效（其实是事务B刚插入的），</p><p>这就叫幻读。</p></blockquote></li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>读未提交（READ UNCOMMITTED）</li><li>读提交（READ COMMITTED）解决脏读</li><li>可重复读（REPEATABLE READ）解决不可重复读 <strong>默认</strong></li><li>串行化（SERIALIZABEL）解决幻读</li></ul><h3 id="查看与设置隔离级别"><a href="#查看与设置隔离级别" class="headerlink" title="查看与设置隔离级别"></a>查看与设置隔离级别</h3><ul><li>查看隔离级别</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW variables LIKE &#x27;transaction_isolation&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20220913223306947.png" alt="image-20220913223306947"></p><ul><li>修改隔离级别</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET 作用域 TRANSACTION ISOLATION LEVEL 事务隔离级别;<br></code></pre></td></tr></table></figure><blockquote><p>作用域：</p><ul><li>SESSION：指针对当前会话窗口</li><li>GLOBAL：全局</li></ul><p>事务隔离级别</p><ul><li>READ UNCOMMITTED</li><li>READ COMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li></ul></blockquote><h3 id="在MySQL中执行事务"><a href="#在MySQL中执行事务" class="headerlink" title="在MySQL中执行事务"></a>在MySQL中执行事务</h3><p>事务流程：开始事务–》执行操作–》结束事务（提交&#x2F;回滚）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">BEGIN;/START TANSACTION;#事务开始于BEGIN命令后的第一条语句<br>#执行操作<br>COMMIT;<br></code></pre></td></tr></table></figure><p>查看正在运行的事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.innodb_trx;<br></code></pre></td></tr></table></figure><h3 id="隔离级别分析"><a href="#隔离级别分析" class="headerlink" title="隔离级别分析"></a>隔离级别分析</h3><h4 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h4><p>脏读问题：</p><blockquote><p>A更新的数据还未提交，B直接读取，若A进行回滚，那么A刚才更新的数据就是无效的，B获取到了无效的数据，即脏读。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-77225da0805e43183c076c24f270e75b_720w.jpg" alt="img"></p><h4 id="读提交（READ-COMMITTED）"><a href="#读提交（READ-COMMITTED）" class="headerlink" title="读提交（READ COMMITTED）"></a>读提交（READ COMMITTED）</h4><p>解决脏读问题：</p><blockquote><p>一个事务只能读取到其他事务已经提交过的数据。这样脏读问题就解决了。</p></blockquote><p>不可重复读问题：</p><blockquote><p>B某一时刻读取了数据之后，A对其作了更新，B在同一事务中再去读同一数据，读取到的和第一次读取到的不一样，即为不可重复读。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-90289243339a900aaf3f87d9c9930258_720w.jpg" alt="img"></p><h4 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h4><p>解决不可重复读问题：</p><blockquote><p>事务不会读到其他事务对已有的数据的<strong>修改</strong>，即使其他事务已提交。也就是说事务开始读到的已有数据到事务提交之前都是不会变的。</p><p>但是，对于其他事务插入的数据是可以读到的。这也就引发了幻读问题。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-85fd2da20ae7cf219bf55d8b81f8bd94_720w.jpg" alt="img"></p><p>幻读问题：</p><blockquote><p>事务B对某行做了修改，事务A插入了一行，并且这行与B进行修改的行的原始数据一致，然后B再进行查询，发现读取到和未修改行一样的数据，就好像B做的修改没有生效一样，即幻读。</p><p>MySQL中的可重复度隔离解决了幻读问题。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-457f695ba253674e7a998297660c1a01_720w.jpg" alt="img"></p><h4 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h4><p>串行化相当于单线程，事务逐一执行，自然就不会存在因为并发而引起的脏读、不可重复读、幻读的问题。</p><h2 id="MySQL中事务隔离的实现"><a href="#MySQL中事务隔离的实现" class="headerlink" title="MySQL中事务隔离的实现"></a>MySQL中事务隔离的实现</h2><p>读未提交：性能最好，相当于没加锁。</p><p>串行化：读时加共享锁，可并发读，写时加排他锁，其他事务不能进行读写。</p><h3 id="读提交和可重复读的实现"><a href="#读提交和可重复读的实现" class="headerlink" title="读提交和可重复读的实现"></a>读提交和可重复读的实现</h3><p>采用MVVC（多版本并发控制）的方法</p><h4 id="行记录版本和事务id"><a href="#行记录版本和事务id" class="headerlink" title="行记录版本和事务id"></a>行记录版本和事务id</h4><p>概述：</p><blockquote><p>我们在数据库中看到的一条行记录可能实际上有多个版本，每个版本除了记录数据外，还有一个表示版本的字段，记未row trx_id，而整个字段就是使其产生的事务的id，事务id记为transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p></blockquote><p>图解：</p><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-114dd6691636883a92e7c1060210a014_720w.jpg" alt="img"></p><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>读提交和可重复读实现的关键就是快照，学名叫做一致性视图。</p><blockquote><ul><li><p>可重复读是在事务开始的时候生成一个当前事务全局性的快照。</p></li><li><p>而读提交是每次执行语句的时候都重新生成一次快照。</p></li></ul></blockquote><p>快照能够读取到的版本：</p><blockquote><ul><li>当前事务内的更新，可以读到；</li><li>快照创建前未提交的版本不可读；</li><li>快照创建后的提交的版本不可读</li></ul></blockquote><p>综上：可重复读和读提交二者<strong>唯一的区别就是快照的创建</strong></p><h3 id="并发写的问题"><a href="#并发写的问题" class="headerlink" title="并发写的问题"></a>并发写的问题</h3><p>问题：</p><blockquote><p>两个事务对同一数据做修改。最终的结果应该时间靠后的哪个事务。</p><p>并且在更新之前要先读数据，这里所说的读和上面说到的读不一样，更新之前的读叫做“当前读”，总是当前版本的数据，也就是多版本中最新一次提交的那版。</p></blockquote><p>例子：</p><blockquote><p>若A执行UPDATE操作，在UPDATE执行期间，要对所修改的行加<strong>行锁</strong>，这个行锁在提交过后才释放。在A提交之前，B若想UPDATE这行数据，需要先申请锁，但是锁已经被A占有，所以B需要等到A提交并释放锁过后才能获取锁继续执行。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-da32a0f82e9585e39c655ac490c6f3d8_720w.jpg" alt="img"></p><p>两种加锁过程：</p><ol><li><p>有索引（只锁对应行）</p><blockquote><p>例如：<code>UPDATE user SET age=11 WHERE id = 1;</code></p><p>id是这张表的主键，是有索引的情况，那么MySQL直接就在索引数中找到这行数据，让后将该行上行锁。</p></blockquote></li><li><p>无索引（全锁，在解锁留下对应行）</p><blockquote><p>例如：&#96;UPDATE user SET age&#x3D;11 WHERE age&#x3D;10;</p><p>age并非索引，所以MySQL无法直接定位该行（或者多行）数据。然后MySQL就对表中的所有行加行锁（并非表锁），然后分局条件过滤，释放掉不满足条件的行的行锁。</p><p>这个加锁和解锁的过程非常影响性能，所以对于大表需要合理的设计索引来避免这种情况。</p></blockquote></li></ol><h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><p> 并发写问题 的解决方式是行锁，而解决幻读的方式则是间隙锁。MySQL将行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做Next-Key锁</p><p>间隙锁：</p><ul><li>表：</li></ul><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-6a7c4b03297309813d57213a2a2d7366_720w.jpg" alt="img"></p><ul><li>间隙锁：</li></ul><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-f07516da40274690e8ece9bc415eab88_720w.jpg" alt="img"></p><blockquote><p>MySQL会在筛选的索引列和其两端的索引列之间加上间隙锁。</p><p>例如执行：<code>UPDATE user SET name = ‘风筝2号’ WHERE age = 10; </code></p><p>（其中age是索引列，唯一）那么MySQL就会在age为[负无穷，10）、（10，30）这两个区间加上间隙锁，那么所有age在这两个区间的数据在此期间就无法插入。（30之后的区间插入数据不会有幻读问题，所以不需要加间隙锁）</p></blockquote><ul><li><p>加锁过程</p><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-3ce9ac24fb6fdf3ff60d03e070136175_720w.jpg" alt="img"></p><blockquote><p>在A提交之前，因为事务B插入的数据age&#x3D;10，由于age&#x3D;10的行添加了行锁，两边有间隙锁，所以插入操作无法完成，需要等到A提交后才能插入。这样就不存在幻读问题了。（age  &gt; 30的行插入不受影响）</p></blockquote><blockquote><p>若age不是索引列，那么数据库将为整个表加上间隙锁，那么不管age为何值均要等到事务A提交才能成功插入。</p></blockquote></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法</title>
    <link href="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h2><h3 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h3><ul><li>平方阶：冒泡排序、插入排序、选择排序</li><li>n^(1.3-2)阶：希尔排序</li><li>线性对数阶：快速排序、归并排序、堆排序</li><li>线性阶：计数排序、桶排序、基数排序、</li></ul><h3 id="稳定度："><a href="#稳定度：" class="headerlink" title="稳定度："></a>稳定度：</h3><blockquote><p>算法稳定指的是两个相等键值的顺序和排序之前它们的顺序相同</p></blockquote><ul><li>稳定排序：冒泡排序、插入排序、归并排序、计数排序、桶排序、基数排序</li><li>不稳定排序：选择排序、希尔排序、快速排序、堆排序</li></ul><p><strong>注意：算法稳定与否和具体的实现有关！！！</strong></p><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><blockquote><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个。每一次将最大的元素放到合适的位置。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" alt="img"></p><h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><blockquote><p>每次遍历寻找最小&#x2F;大元素放到首&#x2F;尾</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" alt="img"></p><h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><blockquote><p>将未排序元素依次插入到已排序序列合适位置（初始化第一个元素未已排序序列）</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertionSort.gif" alt="img"></p><h2 id="四、希尔排序（插入排序-缩小增量）"><a href="#四、希尔排序（插入排序-缩小增量）" class="headerlink" title="四、希尔排序（插入排序|缩小增量）"></a>四、希尔排序（插入排序|缩小增量）</h2><p>又叫（缩小增量排序），是插入排序改进版</p><p>基于插入排序特性进行优化:</p><blockquote><ul><li>插入排序在对几乎已经拍好序的数据操作时，效率高。</li><li>但是一般来说插入排序是低效的，因为每次插入只能将数据移动一位。</li></ul></blockquote><p>希尔排序的基本思想：</p><blockquote><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1024555-20161128110416068-1421707828.png" alt="img"></p><h2 id="五、归并排序（分治法）"><a href="#五、归并排序（分治法）" class="headerlink" title="五、归并排序（分治法）"></a>五、归并排序（分治法）</h2><ul><li><p><strong>分治法</strong>的典型应用。</p></li><li><p>问题分解：要将数组排序，先将数组分解成两份，将两份分别排好序后，再将两份数组合并，合并后的数组就排好序了。</p></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1024555-20161218163120151-452283750.png" alt="img"></p><h2 id="六、快速排序（分治法-冒泡排序）"><a href="#六、快速排序（分治法-冒泡排序）" class="headerlink" title="六、快速排序（分治法|冒泡排序）"></a>六、快速排序（分治法|冒泡排序）</h2><ul><li><p><strong>分治法</strong>的典型应用。</p></li><li><p>从本质上看，快速排序算是<strong>在冒泡排序基础上的递归分治法</strong></p></li><li><p>算法思想：</p><blockquote><p>选择一个基准元素，然后以它为基准将数组分为两个区。然后将比基准值小的都放到基准值左边，大的放到基准值右边，然后对两个区域分别递归排序排序。</p><p>划区的操作就相当于是冒泡操作，每一层递归，一个元素就放置到了它该在的位置。</p></blockquote></li><li><p>算法实现：</p><blockquote><p>在单独的一层递归中，选择首元素作为基准元素，然后使用双指针，从第二个元素和末尾元素向中间遍历，左指针找比基准元素小的元素，右指针找比基准元素大的值，然后交换，最后将基准元素与左指针指向元素互换，这样基准元素左边都比它小，右边都比他大，此时他已经到了该在的位置。</p></blockquote></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" alt="img"></p><h2 id="七、堆排序（选择排序-堆）"><a href="#七、堆排序（选择排序-堆）" class="headerlink" title="七、堆排序（选择排序|堆）"></a>七、堆排序（选择排序|堆）</h2><ul><li><p>基于堆这种数据结构而设计</p><blockquote><p>堆是具有一下性质的<strong>完全二叉树</strong>：每个节点的值都大于或等于其左右子节点的值，称为大顶堆。反之为小顶堆。</p></blockquote></li><li><p>堆排序是一种<strong>选择排序</strong></p></li><li><p>堆排序的基本思想：</p><blockquote><p>1、将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。</p><p>2、将其与末尾元素进行交换，此时末尾就为最大值，然后将剩余的n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。</p><p>如此反复执行，就能得到一个有序序列。</p></blockquote></li></ul><h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><ul><li><p>计数排序的思想：</p><blockquote><p>将输入的数值转换为键存储在额外开辟的数组空间中。要求输入的数据是有确定范围的整数</p></blockquote></li><li><p>计数排序不是比较排序。用于计数的数组大小取决于数据的范围，所以说计数排序只适合于数据范围较小的数组。</p></li><li><p>但是计数排序可以用在基数排序中，用来排序数据范围很大的数组。</p></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/countingSort.gif" alt="img"></p><h2 id="九、桶排序（计数排序-桶）"><a href="#九、桶排序（计数排序-桶）" class="headerlink" title="九、桶排序（计数排序|桶）"></a>九、桶排序（计数排序|桶）</h2><ul><li><p>桶排序是计数排序的升级版。</p><blockquote><ul><li><p>计数排序是将每个值占用一个数组位置（相当于桶大小为1），然后直接顺序取值后全部元素就已拍好序列。</p></li><li><p>而桶排序则是将一定范围内的值放入一个桶中，然后对每个桶中元素单独排序（可以使用各种算法，一般采用插入排序，若桶内已经有元素，则新来的元素使用插入排序放入桶中），最后依次从桶中取出拍好序的元素归位。</p></li></ul></blockquote><ol><li>将元素分配到桶中</li></ol><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Bucket_sort_1.svg_.png" alt="img"></p><ol start="2"><li>将每个桶中元素进行排序</li><li>然后依次将每个桶中的元素取出归位</li></ol><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Bucket_sort_2.svg_.png" alt="img"></p></li></ul><h2 id="十、基数排序（桶排序-按位分配桶）"><a href="#十、基数排序（桶排序-按位分配桶）" class="headerlink" title="十、基数排序（桶排序|按位分配桶）"></a>十、基数排序（桶排序|按位分配桶）</h2><blockquote><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位切割成不同的数字，然后根据每个位上数字来分配桶（1-9共十个桶）。</p><p>基数排序还可以用于字符串和浮点数的排序。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/radixSort.gif" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/09/04/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/04/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="1-Java语言特点"><a href="#1-Java语言特点" class="headerlink" title="1. Java语言特点"></a>1. Java语言特点</h3><ul><li>面向对象（封装、继承、多态）</li><li>平台无关性（Java虚拟机）</li><li>多线程（语言级支持）</li><li>网络编程（Java诞生就是为了简化网络编程设计）</li><li>编译与解释并存</li><li>简单易学、可靠性、安全性</li></ul><h3 id="2-JVM、JRE、JDK"><a href="#2-JVM、JRE、JDK" class="headerlink" title="2. JVM、JRE、JDK"></a>2. JVM、JRE、JDK</h3><ul><li><p>JVM</p><blockquote><p>JVM是运行Java字节码的虚拟机，JVM针对不同的系统的特定实现，目的是使用相同的字节码，在不同平台的JVM上运行都能产生相同结果。</p></blockquote><ul><li><p>什么是字节码？采用字节码的好处？</p><blockquote><p>在Java中，JVM可以理解的代码就是字节码（.class文件）、它不面向特定处理器，只面向虚拟机。Java通过字节码的方式，一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释性语言可移植的特点。所以因为采用字节码，Java程序运行比较高效，而且由于字节码不针对特定机器，所以Java程序无需重新编译即可在不同操作系统上运行。</p></blockquote></li><li><p>Java程序从源代码到运行的流程</p><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/image-20220904193326678.png" alt="image-20220904193326678"></p><blockquote><p>.class -&gt; 机器码，由JVM进行转换。有两种转换方式：</p><ul><li>一是解释执行，先加载字节码文件，经过解释器解释执行；</li><li>二是编译执行，对于热点代码，由编译器完成一次编译过后将字节码对应的机器码保存下来，下次直接使用。</li></ul></blockquote></li></ul></li><li><p>JRE</p><blockquote><p>JRE是Java与模型时环境，它时运行已编译Java程序所需的所有内容的集合，包括JVM、Java类库、java命令和一些其他的基础构件。但是，它不能用于创建新程序。</p></blockquote></li><li><p>JDK</p><blockquote><p>JRE + 编译器（javac）+ 工具（如javadoc和jdb）。它能创建和编译程序。</p></blockquote></li></ul><p>   总结：</p><ul><li>JVM：（执行java字节码文件）</li><li>JRE：JVM + java类库 + java命令 + 基础构件（运行java程序）</li><li>JDK：JRE + 编译器 + 工具（创建和编译程序）</li></ul><h3 id="3-Oracle-JDK-和-OpenJDK"><a href="#3-Oracle-JDK-和-OpenJDK" class="headerlink" title="3. Oracle JDK 和 OpenJDK"></a>3. Oracle JDK 和 OpenJDK</h3><ul><li>OpenJDK完全开源，作为一个参考模型。Oracle JDK是OpenJDK的一个实现，包含自己的商业内容，不完全开源。</li><li>Oracle更稳定，有更多的类和一些错误修复。性能更好。</li></ul><h3 id="4-Java和C-的区别"><a href="#4-Java和C-的区别" class="headerlink" title="4. Java和C++的区别"></a>4. Java和C++的区别</h3><ul><li><p>都是面向对象的语言，都支持封装、继承和多态</p></li><li><p><strong>指针</strong>，Java不提供指针用来直接访问内存，程序内存更安全</p></li><li><p><strong>继承</strong>，Java的类是单继承的，C++支持多继承。虽然Java的类不能多继承，但是接口可以多继承（实现）</p></li><li><p><strong>内存管理</strong>，Java通过JVM自动管理内存，不需要程序员手动释放无用内存</p></li><li><p><strong>字符串结束符</strong>，C语言中字符串和字符数组随后都有额外字符 ‘\0’ 来表示结束。Java语言中没有结束符这一概念。</p><blockquote><p>Java是面向对象的，字符串和数组均是对象，对象有属性length来记录长度，所以说再额外使用结束符来标识末尾。</p></blockquote></li></ul><h3 id="5-什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#5-什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="5. 什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>5. 什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><blockquote><p>一个程序可以有很多个类，但是只能由一个类是主类。再Java应用程序中，这个主类是指包含main方法的类。</p></blockquote><blockquote><p>在小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是pulic类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p></blockquote><h3 id="6-Java应用程序（Application）和小程序（Applet）之间的差别"><a href="#6-Java应用程序（Application）和小程序（Applet）之间的差别" class="headerlink" title="6. Java应用程序（Application）和小程序（Applet）之间的差别"></a>6. Java应用程序（Application）和小程序（Applet）之间的差别</h3><ul><li>（1）运行方式不同。Java Application是完整的程序，可以独立运行；Java Applet程序不能单独运行，<br>它必须嵌入到用HTML语言编写的Web页面中，通过与Java兼容的浏览器来控制执行。</li><li>（2）运行工具不同。Java Application程序被编译以后，用普通的Java解释器就可以使其边解释边执行，<br>而Java Applet必须通过网络浏览器或者Applet观察器才能执行。</li><li>（3）程序结构不同。每个Java Application程序必定含有一个并且只有一个main方法，程序执行时<br>首先寻找main方法，并以此为入口点开始运行。含有main方法的那个类，常被称为主类，也就是说<br>Java Application程序都含有一个主类。而Applet程序则没有含main方法的主类，这也正是Applet程序不能独立运行的原因。<br>尽管Applet没有含main方法的主类，但Applet一定有一个从 java.applet.Applet派生的类，它是由Java系统提供的。</li><li>（4）受到的限制不同Java Application程序可以设计成能进行各种操作的程序，包括读／写文件的操作<br>但是 Java Applet 对站点的磁盘文件既不能进行读操作，也不能进行写 操作。然而，由于Applet的引入<br>使Web页面具有动态多媒体效果和可交互性能，这使由名为超文本、实为纯文本的HTML语言编写成的Web页面真正具有了超文本功能</li></ul><h3 id="7-import-java-x2F-javax有啥区别"><a href="#7-import-java-x2F-javax有啥区别" class="headerlink" title="7. import java&#x2F;javax有啥区别"></a>7. import java&#x2F;javax有啥区别</h3><blockquote><p>刚开始的时候JavaAPI所需的包均以是以java开头的包，javax作为扩展API包使用。随着时间的推移，javax逐渐成为JavaAPI的一部分，但是将javax包移动到java包中太麻烦，且会破坏一堆现有代码，所以直接将javax纳入为JavaAPI的一部分</p></blockquote><h3 id="8-为什么说Java语言“编译与解释并存”？"><a href="#8-为什么说Java语言“编译与解释并存”？" class="headerlink" title="8. 为什么说Java语言“编译与解释并存”？"></a>8. 为什么说Java语言“编译与解释并存”？</h3><blockquote><p>高级程序语言按照程序的执行方式分为编译型和解释型。</p><ul><li>编译型语言指编译器针对特定操作系统将源代码一次性翻译成可被该平台执行的机器码</li><li>解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</li></ul></blockquote><blockquote><p>Java语言既有编译型语言特征，也有解释型语言特征。java源码先编译成字节码，字节码再由解释器解释执行（同时也有编译器对热点代码进行编译）</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="1-字符型常量和字符串常量的区别？"><a href="#1-字符型常量和字符串常量的区别？" class="headerlink" title="1. 字符型常量和字符串常量的区别？"></a>1. 字符型常量和字符串常量的区别？</h3><ul><li>形式：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干字符</li><li>含义：字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串再内存中的存放地址）</li><li>占用内存：字符常量只占2个字节；字符串常量占若干字节</li></ul><h3 id="2-关于注释？"><a href="#2-关于注释？" class="headerlink" title="2. 关于注释？"></a>2. 关于注释？</h3><blockquote><p>注释并非越详细越好，好的代码本身就是注释，尽量通过规范和美化代码来减少不必要的注释。</p></blockquote><ul><li><p>注释种类</p><ul><li><p>单行注释</p><blockquote><p>&#x2F;&#x2F;注释</p></blockquote></li><li><p>多行注释</p><blockquote><p> &#x2F;*</p><p>注释</p><p>注释</p><p>*&#x2F;</p></blockquote></li><li><p>文档注释</p><blockquote><p>&#x2F;**</p><p>*文档注释</p><p>*&#x2F;</p></blockquote></li></ul></li></ul><h3 id="3-标识符和关键字的区别？"><a href="#3-标识符和关键字的区别？" class="headerlink" title="3. 标识符和关键字的区别？"></a>3. 标识符和关键字的区别？</h3><blockquote><p>在编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符。简单来说标识符就是一个名字。</p></blockquote><blockquote><p>但是有一些标识符，Java语言已经赋予其特殊含义，只能又在特定地地方，这种特殊的标识符就是关键字。因此关键字是被赋予特殊含义的标识符。</p></blockquote><h3 id="4-常见关键字"><a href="#4-常见关键字" class="headerlink" title="4. 常见关键字"></a>4. 常见关键字</h3><ul><li><p>访问控制：private、protected、public</p></li><li><p>类、方法和变量的修饰符：abstract、static、interface、final、extends、implments、new、native、strictfp、synchronized、transient、volatile、class</p></li><li><p>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</p></li><li><p>错误处理：try、catch、throw、throws、finally</p></li><li><p>包相关：import、package</p></li><li><p>基本类型：boolean、byte、char、double、float、int、long、short、null、true、false</p></li><li><p>变量引用：super、this、void</p></li><li><p>保留字：goto、const</p></li></ul><h3 id="5-continue、break和return区别"><a href="#5-continue、break和return区别" class="headerlink" title="5. continue、break和return区别"></a>5. continue、break和return区别</h3><ul><li>提前终止循环<ul><li>continue：跳出当前这一次循环（此次循环中continue后的语句不执行，直接跳到循环的开头进行循环的条件判断，执行下一次循环）</li><li>break：跳出当前所在的整个循环体，执形循环后的语句</li></ul></li><li>结束方法的运行<ul><li>return：直接结束方法的执行，用于没有返回值的方法</li><li>return value：返回一个特定值，并结束方法的执行</li></ul></li></ul><h3 id="6-泛型、类型擦除、通配符？"><a href="#6-泛型、类型擦除、通配符？" class="headerlink" title="6. 泛型、类型擦除、通配符？"></a>6. 泛型、类型擦除、通配符？</h3><ul><li><p>泛型：泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数</p><blockquote><p>泛型的三种使用方法：</p><ul><li><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> T key;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span>&#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实例化泛型类</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure></li><li><p>泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//实现泛型接口，不指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实现泛型接口，指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(E[] inputArray)</span>&#123;<br>    <span class="hljs-keyword">for</span>(E element : inputArray)&#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s&quot;</span>, element);<br>    &#125;<br>    System.out.println();<br>&#125;<br><span class="hljs-comment">//创建不同类型的数组，使用同一泛型方法打印</span><br>Integer[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>String[] stringArray = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br>printArray(intArray);<br>printArray(stringArray);<br></code></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>常用通配符：T、E、K、V、？</p><ul><li>？标识不确定的java类型</li><li>T（type）标识具体的一个java类型</li><li>K V（key value）分别标识java键值中的Key Value</li><li>E（element）标识数组中的元素类型</li></ul></blockquote></li><li><p>类型擦除：Java的泛型是<strong>伪泛型</strong>，因为Java在编译期间，所有的泛型信息都会被擦除，这就是通常所说的类型擦除。 所有的泛型在编译过后均为Object，所以说，在运行期间通过反射可以向Integer泛型的List中添加String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>list.add(<span class="hljs-number">12</span>);<br><span class="hljs-comment">//直接往Integer的list中添加string会在编译器报错</span><br>list.add(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-comment">//通过反射获取运行期，list的add方法</span><br>Class&lt;? extend List&gt; clazz = list.getClass();<br><span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br><span class="hljs-comment">//通过反射获取的add方法可以往Integer的list中添加string</span><br>add.invoke(list, <span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-x3D-x3D-和equals-的区别"><a href="#7-x3D-x3D-和equals-的区别" class="headerlink" title="7. &#x3D;&#x3D;和equals()的区别"></a>7. &#x3D;&#x3D;和equals()的区别</h3><ul><li><p>&#x3D;&#x3D;：比较的是值，若是基本数据类型，即直接比较它们的值是否相等；若是比较对象，因为引用变量的值是对象的地址，即比较的是对象的地址是否相同。</p></li><li><p>equals：它的作用是比较两个对象是否相等，不能用于比较基本数据类型变量。equals方法存在于Object类中，而Object类是所有类的父类，所有说所有的类都有equals方法。</p><blockquote><p>类的equals方法可以重写，重写即是定义规则使用&#x3D;&#x3D;比较对象的属性，来判断两个对象是否相等。</p><p>若没有重写则使用Object的默认equals方法，比较两个对象的地址，即和&#x3D;&#x3D;一样。</p></blockquote></li></ul><h3 id="8-hashCode-与equals"><a href="#8-hashCode-与equals" class="headerlink" title="8. hashCode()与equals()"></a>8. hashCode()与equals()</h3><ol><li><p>hashCode()介绍：</p><blockquote><p>hashCode()的作用是获取哈希码，也称为散列码；它返回一个int整数，用于确定对象在哈希表中的索引位置。</p></blockquote></li><li><p>为什么要有hashCode？</p><blockquote><p> 减少equals的使用次数。若要将对象加入HashSet，首先会计算对象的hashcode，与其他已加入的对象的hashcode值比较，若没有重复的hashcode，则没有重复的对象。若有重复的hashcode，则使用equals方法来确定对象是否真的相同。若是hashcode相同的不同对象，则会将后加入的对象散列到其他位置</p></blockquote></li><li><p>为什么重写equals时必须重写hashCode方法？</p><blockquote><p>hashCode方法要实现equals方法认定相等的对象返回相同的hashcode值。若是默认的hashCode方法，使用的是对象地址转换的hashcode值，但是两个不同的对象地址不同，但是它们可以是相等的。若使用默认的Object类的hashCode方法则相等的对象有不同的hashcode值</p></blockquote></li><li><p>为什么hashcode值相等的对象不一定相等？</p><blockquote><p>hash碰撞</p></blockquote></li></ol><h3 id="9-获取键盘输入"><a href="#9-获取键盘输入" class="headerlink" title="9. 获取键盘输入"></a>9. 获取键盘输入</h3><ol><li><p>通过Scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> input.nextLine();<br>input.close();<br></code></pre></td></tr></table></figure></li><li><p>通过BufferedReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferReader</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> input.readLine();<br></code></pre></td></tr></table></figure></li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="1-Java中有几种基本数据类型-以及其对应的包装类是什么-各自占用多少字节"><a href="#1-Java中有几种基本数据类型-以及其对应的包装类是什么-各自占用多少字节" class="headerlink" title="1. Java中有几种基本数据类型?以及其对应的包装类是什么?各自占用多少字节?"></a>1. Java中有几种基本数据类型?以及其对应的包装类是什么?各自占用多少字节?</h3><table><thead><tr><th>基本类型</th><th>包装类</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>short</td><td>Short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>int</td><td>Integer</td><td>32</td><td>4</td><td>0</td></tr><tr><td>long</td><td>Long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>float</td><td>Float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>Double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>char</td><td>Character</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>boolean</td><td>Boolean</td><td>1</td><td></td><td>false</td></tr></tbody></table><blockquote><p>long类型的数值一定要在数值后加上<strong>L</strong>，否则作为整型解析；</p><p>对于boolean，不同JVM不同实现，逻辑上是占一位，但实际中会考虑在计算机中的高效存储。</p></blockquote><h3 id="2-自动拆装箱"><a href="#2-自动拆装箱" class="headerlink" title="2.自动拆装箱"></a>2.自动拆装箱</h3><ul><li><p>是什么</p><blockquote><p>装箱：Integer i &#x3D; 10;</p><p>拆箱：int n &#x3D; i;</p></blockquote></li><li><p>原理</p><blockquote><p>在编译的时候自动调用包装类对应的方法来进行拆装箱</p><p>装箱：Integer.valueOf(int)</p><p>拆箱：Integer.intValue()</p></blockquote></li></ul><h3 id="3-包装类的常量池"><a href="#3-包装类的常量池" class="headerlink" title="3.包装类的常量池"></a>3.包装类的常量池</h3><p>常量池技术的意义：</p><blockquote><p>在缓存数据范围内的包装类，新建的多个相同数值的包装类会指向同一个地址</p><p>浮点数类型包装类并没有实现常量池技术</p></blockquote><ul><li><p>整型：Byte、Short、Integer、Long</p><blockquote><p>这四种包装类拆创建了数值[-128, 127]的相应类型的缓存数据</p></blockquote></li><li><p>Character</p><blockquote><p>创建了[0, 127]范围的缓存数据</p></blockquote></li><li><p>Boolean</p><blockquote><p>直接返回True Or False</p></blockquote></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-为什么Java中只有值传递？"><a href="#1-为什么Java中只有值传递？" class="headerlink" title="1.为什么Java中只有值传递？"></a>1.为什么Java中只有值传递？</h3><p>程序设计语言中的一些术语：</p><blockquote><ul><li><p>按值调用（call by value）：表示方法接收的是调用者提供的值</p></li><li><p>按引用调用（call by reference）：表示方法接收的是调用者提供的变量地址</p></li></ul></blockquote><p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p>Java中方法参数的使用情况：</p><blockquote><ul><li>一个方法不能修改一个基本数据类型的参数（数值型或布尔型）</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用另一个新的对象</li></ul></blockquote><h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h3><blockquote><p>重载：同一个方法名，根据不同的输入数据，做出不同的处理</p><p>重写：子类继承父类的方法，若子类要对于相同的数据，做出与父类不同的响应的时候，要重写父类方法</p></blockquote><h4 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h4><ul><li><strong>方法的签名</strong>包括方法名和参数类型</li><li>重载发生在同一个类中，方法名相同，参数不同（类型、个数、顺序），重载的方法可以有不同的返回值和访问修饰符</li><li>方法签名不包括方法的返回类型，所以说不能存在方法签名相同，但是返回类型不同的方法。</li></ul><h4 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h4><ul><li>重写发生在运行期</li><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围不超过父类，访问修饰符范围不低于父类。</li><li>若父类方法范文修饰符为 private&#x2F;final&#x2F;static 则子类不能重写该方法，但是被static修饰的方法能够被再次声明</li><li>构造方法无法被重写</li></ul><table><thead><tr><th>区别点</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类中</td><td>子类中</td></tr><tr><td>参数</td><td>必须修改</td><td>一定不能改</td></tr><tr><td>返回类型</td><td>可修改</td><td>一定不能改</td></tr><tr><td>异常</td><td>可修改</td><td>可以减少或删除，一定不能抛出更广的异常</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>可以扩大范围吧范围，一定不能缩小</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table><h3 id="3-深拷贝VS浅拷贝"><a href="#3-深拷贝VS浅拷贝" class="headerlink" title="3.深拷贝VS浅拷贝"></a>3.深拷贝VS浅拷贝</h3><p>对于基本数据类型都一样进行值传递</p><p>对与引用数据类型：</p><ul><li>浅拷贝：拷贝原对象的引用</li><li>深拷贝：创建一个新的对象，并对原引用对象的数据进行复制，将新对象的引用拷贝</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h3><blockquote><p>面向过程就是分析出解决问题所需的步骤，然后使用函数把这些步骤一步一步实现，使用的时候依次调用。</p><p>面向对象就是把问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</p></blockquote><h3 id="2-构造器能够被重写"><a href="#2-构造器能够被重写" class="headerlink" title="2. 构造器能够被重写"></a>2. 构造器能够被重写</h3><blockquote><p>构造器不能被重写，但是可以被重载，所以说一个类中可以有多个构造器</p></blockquote><h3 id="3-关于构造方法"><a href="#3-关于构造方法" class="headerlink" title="3. 关于构造方法"></a>3. 关于构造方法</h3><h4 id="3-1-构造方法的作用？若类没有声明构造方法会怎样？"><a href="#3-1-构造方法的作用？若类没有声明构造方法会怎样？" class="headerlink" title="3.1 构造方法的作用？若类没有声明构造方法会怎样？"></a>3.1 构造方法的作用？若类没有声明构造方法会怎样？</h4><blockquote><p>构造方法的主要作用是完成类对象的初始化工作</p></blockquote><blockquote><p>若一个类没有声明构造方法，也就生成一个默认得无参构造方法，我们在创建对象得时候加一个空括号就是在调用这个无参构造方法。若我们添加了类的构造方法，那么就不会生成默认得无参构造方法。</p></blockquote><h4 id="3-2在调用子类构造方法之前会先调用父类的构造方法，其目的是？"><a href="#3-2在调用子类构造方法之前会先调用父类的构造方法，其目的是？" class="headerlink" title="3.2在调用子类构造方法之前会先调用父类的构造方法，其目的是？"></a>3.2在调用子类构造方法之前会先调用父类的构造方法，其目的是？</h4><blockquote><p>帮助子类完成初始化工作</p></blockquote><h4 id="3-3-在Java中定义一个无参构造方法的意义"><a href="#3-3-在Java中定义一个无参构造方法的意义" class="headerlink" title="3.3 在Java中定义一个无参构造方法的意义"></a>3.3 在Java中定义一个无参构造方法的意义</h4><blockquote><p>Java程序在执行子类的构造方法之前，若没有使用super显式地调用父类地构造方法，就会调用父类中地无参构造方法。若父类中没有无参构造方法，而且子类没有用super调用父类中特定的构造方法，则编译的时候就会出错。</p></blockquote><h4 id="3-4-构造方法的特性"><a href="#3-4-构造方法的特性" class="headerlink" title="3.4 构造方法的特性"></a>3.4 构造方法的特性</h4><ul><li>名字与类名相同</li><li>没有返回值，但是不能用void声明构造函数</li><li>构造方法子啊生成类时自动执行，无需调用</li></ul><h3 id="4-成员变量和局部变量的区别"><a href="#4-成员变量和局部变量的区别" class="headerlink" title="4. 成员变量和局部变量的区别"></a>4. 成员变量和局部变量的区别</h3><ul><li>语法形式：<ul><li>成员变量属于类，局部变量属于方法；</li><li>成员变量可以被public、private、static等修饰符修饰，局部变量不能。但是二者都可以被final修饰</li></ul></li><li>存储形式：<ul><li>若成员变量被static修饰，那么这个成员变量属于类，若没有，那么这个成员变量属于实例。</li><li>对象存储在堆内存，局部变量存储在栈内存</li></ul></li><li>生存时间：<ul><li>成员变量属于对象，随着对象的创建而存在</li><li>局部变量随着方法的调用而消失</li></ul></li><li>默认值：<ul><li>成员变量若没有被初值，则会以类型的默认值赋值（被final修饰的成员变量必须显式的赋值）</li><li>局部变量不会自动赋值</li></ul></li></ul><h3 id="5-对象实体与对象引用有何不同？"><a href="#5-对象实体与对象引用有何不同？" class="headerlink" title="5. 对象实体与对象引用有何不同？"></a>5. 对象实体与对象引用有何不同？</h3><ul><li>使用new运算符创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用在栈内存中）</li><li>一个对象引用可以指向0或1个对象；一个对象可以有n个引用指向它</li></ul><h3 id="6-对象相等与指向它们的引用相等的区别"><a href="#6-对象相等与指向它们的引用相等的区别" class="headerlink" title="6. 对象相等与指向它们的引用相等的区别"></a>6. 对象相等与指向它们的引用相等的区别</h3><p>对象相等比较的是对象的内容是否相等。而引用相等比较的是它们指向的内存地址时候相等。</p><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><p>封装就是把一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。可以提供一些可以被外界访问的方法来操作属性。</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h3><p>不同类型的对象，相互之间经常有一定数量的共同点，与此同时每个对象还拥有自己的额外特性。例如小红同学和小明同学，它们都是学生拥有学生的特征（学号，班级等），但是每个同学由有各自不同的优点，比如小红数学好，小明力气大。</p><p>继承是使用已经存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，但是不能选择性地继承父类。</p><p>通过使用继承，可以快速地创建新地类，可以提高代码地重用，程序的可维护性，节省大量创建新类的时间，提高开发效率。</p><p>关于继承：</p><ul><li><strong>继承</strong>，子类拥有父类对象的所有属性和方法（包括私有的属性和方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。</li><li><strong>拓展</strong>，子类可以拥有自己的属性和方法，即子类可以对父类进行拓展。</li><li><strong>重写</strong>，子类可以用自己的方式实现父类的方法。</li></ul><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h3><p>多态表示一个对象具有多种状态。具体表现为父类的引用指向子类的实例。</p><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有 <strong>继承&#x2F;实现</strong> 的关系；</li><li>对象类型不可变，引用类型可变；</li><li>方法具有多态性，属性不具有多态性；</li><li>引用类型不能调用 ”只在子类存在但是在父类不存在的“ 方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆写的方法。</li></ul><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h4 id="1-为什么在静态方法内调用一个非静态成员是非法的？"><a href="#1-为什么在静态方法内调用一个非静态成员是非法的？" class="headerlink" title="1. 为什么在静态方法内调用一个非静态成员是非法的？"></a>1. 为什么在静态方法内调用一个非静态成员是非法的？</h4><p>因为静态方法可以不通过类调用，不通过对象调用，而非静态成员存在与对象中，所以说在静态方法中，不能访问&#x2F;调用其他非静态成员。</p><h4 id="2-静态方法和实例方法的区别"><a href="#2-静态方法和实例方法的区别" class="headerlink" title="2. 静态方法和实例方法的区别"></a>2. 静态方法和实例方法的区别</h4><ul><li>调用，在外部调用静态方法时，可以使用 ”类名.方法名“ 和 ”对象名.方法名” 的方式访问。也就是说，静态方法的调用无需创建对象。</li><li>类成员访问范围，静态方法只能访问本类的静态成员，即（静态成员变量和静态方法）。</li></ul><h4 id="3-常见修饰符总结"><a href="#3-常见修饰符总结" class="headerlink" title="3.常见修饰符总结"></a>3.常见修饰符总结</h4><p><strong>3.1 修饰类：</strong></p><ul><li><p>访问权限修饰符</p><ul><li><p>public：完全开放</p></li><li><p>protected：同包及子类访问</p></li><li><p>default：同包访问</p></li><li><p>private：只能本类访问</p></li></ul></li><li><p>限定符</p><ul><li>abstract：指定为抽象类</li><li>final：指定为最终类，不可被继承</li></ul></li></ul><p><strong>3.2 修饰成员变量：</strong></p><ul><li><p>限定符</p><ul><li><p>static：类属性，可直接通过类名调用</p><blockquote><p>static 不能修饰普通类，但是可以用来<strong>修饰内部类</strong>，因为内部类时类的成员变量。若用static修饰内部类，可以直接使用new OuterClass.InnerClass()直接创建出来。</p></blockquote></li><li><p>final：该成员不能不重写，即定义常量</p><blockquote><p>final修饰的<strong>属性变量</strong>必须在定义或者构造函数中初始化</p><p>final修饰的<strong>局部变量</strong>在使用前赋值即可</p><p>通常与static一起使用以创建<strong>类常量</strong>，此时该变量必须在定义的时候进行初始化</p></blockquote></li><li><p><del>transient</del>：不许列化</p></li><li><p><del>volatile</del>：同步变量</p></li></ul></li></ul><p><strong>3.3修饰成员方法：</strong></p><ul><li><p>限定符</p><ul><li><p>static：类方法，可通过类名直接调用</p></li><li><p>final：方法不能被重写</p></li><li><p>abstract：抽象方法，没有方法体</p><blockquote><p>抽象方法不能被声明为final和static</p></blockquote></li><li><p><del>synchronized</del>：同步方法</p></li><li><p><del>native</del>：本地方法（集成其他语言的代码）</p></li></ul></li></ul><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范。</p><ul><li>接口的方法默认是public，抽象类可以有非抽象方法，抽象方法可以有的访问修饰符不能是privat，因为抽象方法就是为了被重写的，而private修饰的方法是无法被子类访问的，更不用说重写了。</li><li>接口中只能有static、final变量，不能有其他变量，抽象类中不一定。</li><li>一个类可以实现多个接口，但是只能继承一个类。接口本身可以实现多个接口。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-String、StringBuffer、StringBuilder区别？String为什么不可变？"><a href="#1-String、StringBuffer、StringBuilder区别？String为什么不可变？" class="headerlink" title="1. String、StringBuffer、StringBuilder区别？String为什么不可变？"></a>1. String、StringBuffer、StringBuilder区别？String为什么不可变？</h3><p>存储：</p><ul><li>String：使用final修饰的字符数组来保存字符串，因此String不可变。</li><li>StringBuilder和StringBuffer都继承自AbstractStringBuilder，使用字符串数组保存字符串，但是没有使用final修饰，所有保存的字符串可变</li></ul><p>线程安全：</p><ul><li><p>String不可变，可以理解为常量，所以说线程安全</p></li><li><p>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以说线程安全</p></li><li><p>StringBuilder没有对方法加锁，是非线程安全的</p><blockquote><p>String类型改变时会生成新的String对象，然后将指针指向新的String对象。</p><p>StringBuilder直接对对象本身修改。用多线程不安全的风险换10%左右的性能提升。</p></blockquote></li></ul><h3 id="2-Object类的常见方法"><a href="#2-Object类的常见方法" class="headerlink" title="2. Object类的常见方法"></a>2. Object类的常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于返回当前运行时对象的Class对象，使用final关键词修饰，故不允许子类重写</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br><br><span class="hljs-comment">//返回对象的哈希码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//默认比较两个对象地址是否相等，可重写自定义对象相等比较</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br><span class="hljs-comment">//用于创建并返回当前对象的一份拷贝。使用必须重写，Object类没有实现Cloneable接口，直接使用会抛错。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br><br><span class="hljs-comment">//默认返回类名@实例的哈希码的16进制的字符串</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//---------------------------线程相关-------------------------------------</span><br><br><span class="hljs-comment">//唤醒一个在此对象监视器上等待的线程</span><br>notify();<br><br><span class="hljs-comment">//唤醒所有在此对象监视器上等待的线程</span><br>notifyAll();<br><br><span class="hljs-comment">//暂停线程的执行。sleep方法没有释放锁，wait方法在暂停期间释放锁。</span><br>wait();<br><br><span class="hljs-comment">//实例被垃圾回收期回收的时候触发的操作</span><br>finalize();<br></code></pre></td></tr></table></figure><h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/gailan-01.png" alt="img"></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/npe-1.jpg" alt="img"></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-程序、线程、进程的基本概念和它们之间的关系"><a href="#1-程序、线程、进程的基本概念和它们之间的关系" class="headerlink" title="1. 程序、线程、进程的基本概念和它们之间的关系"></a>1. 程序、线程、进程的基本概念和它们之间的关系</h3><ul><li><p>程序：</p><blockquote><p>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中,也就是说程序是静态的代码。</p></blockquote></li><li><p>进程：（资源分配的最小单位）</p><blockquote><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此<strong>进程是动态的</strong>。</p><p>系统运行一个程序即是一个进程从创建、运行到消亡的过程。简单来看，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行，同时每个进程还占有某些系统资源，比如说CPU时间，内存空间，文件，输入输出设备的使用权等。</p></blockquote></li><li><p>线程：（系统调度的最小单位）</p><blockquote><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小很多，也正因为如此，线程也被称为轻量级进程。</p></blockquote></li></ul><p>关系：</p><p>当程序被执行时，将会被操作系统载入内存中。线程时进程划分成的更小的运行单位。线程和进程的最大不同在于基本各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一个角度来说进程属于操作系统的范畴，主要是同段时间内，可以同时执行一个以上的程序，而线程则是在一个同一程序内几乎同时执行一个以上的程序段</p><h3 id="2-线程的基本状态"><a href="#2-线程的基本状态" class="headerlink" title="2. 线程的基本状态"></a>2. 线程的基本状态</h3><blockquote><ul><li><p>NEW：初始状态</p><blockquote><p>线程被构建，但是还没调用start()方法</p></blockquote></li><li><p>RUNNABLE：运行状态</p><blockquote><p>Java线程将操作系统中的就绪和运行两种状态笼统地称为“运行中”</p></blockquote></li><li><p>BLOCKED：阻塞状态</p><blockquote><p>表示线程阻塞与锁</p></blockquote></li><li><p>WAITING：等待状态</p><blockquote><p>表示线程进入等待状态，进入该状态表示档期那线程需要等待其他线程做出一些特定动作（通知或中断）</p></blockquote></li><li><p>TIME_WAITING：超时等待状态</p><blockquote><p>该状态不同于WAITING，它是可以在指定地时间自行返回地</p></blockquote></li><li><p>TERMINATED：终止状态</p><blockquote><p>表示当前线程已经执行完毕</p></blockquote></li></ul></blockquote><h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="1-Java中的IO流分为几种"><a href="#1-Java中的IO流分为几种" class="headerlink" title="1. Java中的IO流分为几种"></a>1. Java中的IO流分为几种</h3><p>划分方式：</p><blockquote><p><strong>流的流向分</strong>：输入流和输出流</p><p><strong>操作单元</strong>：字节流和字符流</p><p><strong>流的角色</strong>：节点流和处理流</p></blockquote><p>IO流的派生抽象基类</p><blockquote><p>InputStream&#x2F;Reader：输入流 + 字节流&#x2F;字符流</p><p>OutputStream&#x2F;Writer：输出流 + 字节流&#x2F;字符流</p></blockquote><h3 id="2-有了字节流为什么还要有字符流"><a href="#2-有了字节流为什么还要有字符流" class="headerlink" title="2. 有了字节流为什么还要有字符流"></a>2. 有了字节流为什么还要有字符流</h3><p>问题本质：</p><blockquote><p>不管是文件读写还是网络发送接收，信息的最小存储单位都是字节，那为什么I&#x2F;O流操作要分为字节流操作和字符流操作？</p></blockquote><p>回答：</p><blockquote><p>字符流是由Java虚拟机将字节转换得到的，问题就出在这个过程非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以，I&#x2F;O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果有音频、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p></blockquote><h3 id="3-BIO，BIO，AIO有什么区别"><a href="#3-BIO，BIO，AIO有什么区别" class="headerlink" title="3. BIO，BIO，AIO有什么区别"></a>3. BIO，BIO，AIO有什么区别</h3><ul><li><p>BIO（Blocking I&#x2F;O）：同步阻塞IO</p><blockquote><p>数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每个连接专注于自己的I&#x2F;O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的来连接或请求。但是，当面对十万甚至是百万级连接的时候，传统的BIO模型无能为力。因此需要一种更高效的I&#x2F;O处理模型来应对更高的并发量。</p></blockquote></li><li><p>NIO（Non-blocking&#x2F;New I&#x2F;O）：同步非阻塞IO</p><blockquote><p>在Java1.4引入NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持<strong>面向缓冲</strong>的，<strong>基于通道</strong>的I&#x2F;O操作方法。NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。</p></blockquote></li><li><p>AIO（Asynchronous I&#x2F;O）：异步非阻塞IO</p><blockquote><p>在Java7中引入了NIO的改进版NIO2，它是异步非阻塞的IO模型。异步IO是<strong>基于事件和回调机制实现</strong>的也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成、操作系统会通知相应的线程进行后续的操作。AIO是异步IO的许哦谢，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。</p><p><strong>AIO应用还不广泛。</strong></p></blockquote></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题 - 蜗牛大师 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://juejin.cn/post/6844903917835419661">聊一聊-JAVA 泛型中的通配符 T，E，K，V，？ - 掘金 (juejin.cn)</a></p></li><li><p><a href="https://developer.aliyun.com/article/799160#:~:text=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87,%E6%93%8D%E4%BD%9C%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E3%80%82">怎么理解面向对象和面向过程到底的本质区别？ .-阿里云开发者社区 (aliyun.com)</a></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL进阶</title>
    <link href="/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>在安装MySQL时已经指定了默认编码为UTF8，所以在创建数据库、创建表的时候都无需指定编码。</p><ul><li><p>几个关于编码的参数：</p><ul><li><p>character_set_client</p><blockquote><p>服务器用来解读用户发来数据所使用的编码</p></blockquote></li><li><p>character_set_results</p><blockquote><p>服务器发送给客户数据的编码</p></blockquote></li><li><p>character_set_connection</p></li><li><p>character_set_database</p></li><li><p>character_set_server</p></li><li><p>character_set_system</p></li></ul></li><li><p>查看数据库当前编码设置：<code>SHOW VARIABLES LIKE &#39;char%&#39;</code>;<img src="/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/image-20220903103244158.png" alt="image-20220903103244158"></p></li><li><p>编码的修改：</p><ol><li><p>命令行临时修改</p><blockquote><p><code>set character_set_client=gbk;</code></p></blockquote></li><li><p>配置文件永久修改</p><blockquote><p>可以在my.ini配置文件中修改</p><p>default-character-set&#x3D;gbk</p><p>该项目会同时修改三个变量的编码：client、results、connection</p></blockquote></li></ol><p>注意：修改后要重启MySQL服务</p><ul><li><code>net stop mysql</code></li><li><code>net start mysql</code></li></ul></li></ul><h1 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h1><blockquote><p>备份：数据库 –&gt; SQL脚本</p><p>恢复：SQL脚本 –&gt; 数据库</p></blockquote><ol><li><p>数据库导出SQL脚本（备份数据库内容）</p><ul><li>命令：<code>mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本文件路径</code></li><li>注意:<ul><li>不要打分号，不要登录mysql，直接在cmd下运行</li><li>生成的脚本文件中不包含create database语句</li></ul></li></ul></li><li><p>从SQL脚本恢复至数据库</p><blockquote><p>方法一、不用登录数据库</p><p>命令：<code>mysql -u用户名 -p密码 数据库名&lt;用于恢复的脚本文件路径</code></p></blockquote><blockquote><p>方法二、登录数据库，并在选择对应数据库</p><p>命令：<code>source 用于恢复的脚本文件路径</code></p></blockquote></li></ol><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>  约束是添加到列上的，用来约束列</p><h2 id="一、主键约束：PRIMARY-KEY"><a href="#一、主键约束：PRIMARY-KEY" class="headerlink" title="一、主键约束：PRIMARY KEY"></a>一、主键约束：PRIMARY KEY</h2><ul><li>主键特点：<strong>非空、唯一、被引用</strong></li></ul><blockquote><p>当表的某一列被指定为主键后，该列就不能为空，不能有重复着值出现。</p></blockquote><ul><li><p>主键的创建与删除</p><ul><li><p>创建表时指定主键：(指定sid为主键列，即为sid列添加主键约束)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE stu(<br>sidCHAR(6) PRIMARY KEY,<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE stu(<br>sidCHAR(6),<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>PRIMARY KEY(sid)<br>);<br></code></pre></td></tr></table></figure></li><li><p>修改表时指定主键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE stu ADD PRIMARY KEY(sid);<br></code></pre></td></tr></table></figure></li><li><p>删除主键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE stu DROP PRIMARY KEY;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>主键自增长</p><ul><li><p>设置主键自增长</p><ol><li><p>在创建表时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE stu(<br>sidINT PRIMARY KEY AUTO_INCREMENT,<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>);<br></code></pre></td></tr></table></figure></li><li><p>在修改表时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE stu MODIFY sid INT AUTO_INCREMENT;<br></code></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h2 id="二、非空约束：NOT-NULL"><a href="#二、非空约束：NOT-NULL" class="headerlink" title="二、非空约束：NOT NULL"></a>二、非空约束：NOT NULL</h2><h2 id="三、唯一约束：UNIQUE"><a href="#三、唯一约束：UNIQUE" class="headerlink" title="三、唯一约束：UNIQUE"></a>三、唯一约束：UNIQUE</h2><h2 id="四、外键约束：CONSTRAINT-FOREIGN-KEY-REFERENCES"><a href="#四、外键约束：CONSTRAINT-FOREIGN-KEY-REFERENCES" class="headerlink" title="四、外键约束：CONSTRAINT | FOREIGN KEY | REFERENCES"></a>四、外键约束：CONSTRAINT | FOREIGN KEY | REFERENCES</h2><ul><li><p>添加外键约束：</p><ul><li><p>创建时添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE 表名(<br>    主键列名 INT PRIMARY KEY AUTO_INCREMENT,<br>    列名1 VARCHAR(50),<br>    外键列名 INT,<br>    CONSTRAINT 外键约束名 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表中的关联列)<br>);<br></code></pre></td></tr></table></figure></li><li><p>更新时添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE 表名 ADD CONSTRAINT 外键约束名 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表中的关联列);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>外键特点：</p><ul><li>可为NULL</li><li>可重复</li><li>必须在关联表中关联列中存在。</li></ul></li></ul><h1 id="模型与关系"><a href="#模型与关系" class="headerlink" title="模型与关系"></a>模型与关系</h1><h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><ul><li><p>对象模型：</p><ul><li>在java中是domain</li><li>可以双向关联，而且引用的是对象，而不是一个主键</li></ul></li><li><p>关系模型：</p><ul><li>在数据库中是表</li><li>只能多方引用一方，而且引用的只是主键，而不是一整行记录</li></ul></li></ul><p>当我们要完成一个软件系统时，需要把系统中的实体抽取出来，形成概念模型。例如部门、员工都是系统中的实体。</p><ul><li><p><strong>实体之间的关系：</strong></p><ul><li><p>一对多（最常见）</p><blockquote><p>部门与员工，一个部门中有多个员工，而每个员工只属于一个部门。其中员工是多方，部门是一方。</p></blockquote></li><li><p>一对一</p><blockquote><p>夫妻，老公、老婆之间就是一对一的关系。</p></blockquote></li><li><p>多对多</p><blockquote><p>老师与学生，一个老师对应对个学生，一个学生也有多个老师</p></blockquote></li></ul></li></ul><p>概念模型中的实体最终会成为Java中的类、数据库中的表。类使用成员变量来完成关系，一般都是<strong>双向关联</strong>。</p><ul><li><p>一对多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> Department department;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span> &#123;<br><span class="hljs-keyword">private</span> List&lt;Employee&gt; employee;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>一对一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br>    <span class="hljs-keyword">private</span> Wife wife;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wife</span> &#123;<br>    <span class="hljs-keyword">private</span> Husband husband;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多对多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Teacher&gt; teacher;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Student&gt; student;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul><li><p>一对一关系：</p><blockquote><p>从表的主键作为外键关联主表的主键</p></blockquote><p>husband不做处理，将wife中的主键作为外键关联到husband的主键。从而实现一对一的关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE husband(<br>hid INT PRIMARY AUTO_INCREMENT,<br>    hname VARCHAR(50)<br>);<br><br>CREATE TABLE wife(<br>wid INT PRIMARY KEY AUTO_INCREMENT,<br>    wname VARCHAR(50),<br>    CONSTRAINT fk_wife_husband FOREIGN KEY(wid) REFERENCES husband(hid);<br>);<br></code></pre></td></tr></table></figure></li><li><p>多对多关系</p><blockquote><p>使用中间表 (关联表)</p></blockquote><p>师生关系，创建一个学生表，一个老师表，在创建一个师生关系表，其中一个键为学生，一个键为老师，分别使用外键关联到学生表，老师表。相当与将师生关系抽离出来单独使用一张表来存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE student(<br>sid INT PRIMARY KEY,<br>    ...<br>);<br>CREATE TABLE teacher(<br>tid INT PRIMARY KEY,<br>    ...<br>);<br><br>CREATE TABLE stu_tea(<br>sid INT,<br>    tid INT,<br>    ADD CONSTRAINT fk_stu_tea_sid FOREIGN KEY(sid) REFERENCES student(sid),<br>    ADD CONSTRAINT fk_stu_tea_tid FOREIGN KEY(tid) REFERENCES teacher(tid)<br>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="一、合并结果集"><a href="#一、合并结果集" class="headerlink" title="一、合并结果集"></a>一、合并结果集</h2><blockquote><ul><li>要求被合并的表，列的类型和列数相同（即两张表结构完全相同）</li><li>合并结果集语法<ul><li>UNION，在合并的时候去除重复行</li><li>UNION，不去除重复行</li></ul></li></ul></blockquote><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM a<br>UNION ALL<br>SELECT * FROM b;<br></code></pre></td></tr></table></figure><h2 id="二、连接查询"><a href="#二、连接查询" class="headerlink" title="二、连接查询"></a>二、连接查询</h2><ul><li><p><strong>内连接</strong></p><ul><li><p>方言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * <br>FROM 表1 别名一，表2 别名2 <br>WHERE 别名1.xx=别名2.xx;<br></code></pre></td></tr></table></figure><blockquote><ul><li>若没有WHERE子句，那么查询出来的结果个数成为笛卡尔积，即表一中的每一项分别与表二中的每一项匹配生成表，即最终共的结果数目为：表一数据个数*表二数据个数</li><li>WHERE子句的作用就是去笛卡尔积，一般使用表一中对应的连接的内键和外键来去笛卡尔积</li></ul></blockquote></li><li><p>标准：<strong>INNER JOIN | ON</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * <br>FROM 表1 别名一 INNER JOIN 表2 别名2 <br>ON 别名1.xx=别名2.xx;<br></code></pre></td></tr></table></figure></li><li><p>自然：<strong>NATRURAL JOIN</strong></p><blockquote><p>自然连接会在两张表中寻找名字相同的列自动进行匹配，相当于自动完成<code>ON 别名1.xx=别名2.xx</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * <br>FROM 表1 别名一 NATURAL JOIN 表2 别名2;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>外连接</strong></p><blockquote><p>外连接有一主一次，主表中的所有记录不论是否满足条件，都会打印出来，主表中没有对应的次表项，那么对应的次表条目使用NULL填充</p></blockquote><ul><li>左外连接：<strong>LEFT OUTER JOIN</strong></li><li>右外连接：<strong>RIGHT OUTER JOIN</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT e.ename, e.sal IFNULL(d.dname, &#x27;无部门&#x27;) AS dname<br>FROM emp e LEFT OUTER JOIN dept d<br>ON e.deptno=d.depton;<br></code></pre></td></tr></table></figure></li></ul><h2 id="三、子查询"><a href="#三、子查询" class="headerlink" title="三、子查询"></a>三、子查询</h2><ul><li><p>不同子查询结果的应用：</p><ul><li><p>多行多列</p><blockquote><p>FROM后，子查询的结果作为用于查询的表</p></blockquote></li><li><p>单行单列</p><blockquote><p>WHERE后，子查询的结果作为过滤条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT *<br>FROM emp<br>WHERE sal=(SELECT MAX(SAL) FROM emp);<br></code></pre></td></tr></table></figure><p>查询本公司工资最高的员工的详细信息，条件为工资最高，最高工资要使用MAX()查询</p></blockquote></li><li><p>多行单列：<strong>IN | ALL | ANY</strong></p><blockquote><p>WHERE后，与IN\ALL\ANY一起，作为搜索条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">    &gt;SELECT *<br>FROM emp<br>WHERE sal &gt; ALL (SELECT sal FROM emp WHERE deptno=30);<br></code></pre></td></tr></table></figure><p>搜索工资大于30部门所有员工工资的员工</p></blockquote></li><li><p>单行多列</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT *<br>FROM emp<br>WHERE (job, depno) IN (SELECT job, depno FROM emp WHERE ename=&#x27;殷天正&#x27;)；<br></code></pre></td></tr></table></figure><p>查询工资和部门与殷天正完全相同的员工</p></blockquote></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL入门笔记</title>
    <link href="/2022/09/02/MySQL%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/02/MySQL%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><ol><li><p>什么是 SQL</p><blockquote><p>结构化查询语言（Structured Query Language）</p></blockquote></li><li><p>SQL 的作用</p><blockquote><p>客户端使用SQL来操作服务器</p></blockquote></li><li><p>语法规范</p><blockquote><ul><li>SQL语句可以在单行或多行书写, 以<strong>分号结尾</strong></li><li>可以使用空格和缩进来增强语句的<strong>可读性</strong></li><li>MySQL不区分大小写, 但是<strong>建议使用大写</strong></li></ul></blockquote></li><li><p>SQL语句分类</p><blockquote><ul><li><p>DDL(Data Definition Language): 数据定义语言</p><blockquote><p>创建、删除、修改：库、表结构</p></blockquote></li><li><p>DML(Data Manipulation Language): 数据操作语言</p><blockquote><p>增、删、改：表记录</p></blockquote></li><li><p>DQL(Data Query Language):  数据查询语言</p><blockquote><p>用来查询记录（数据）</p></blockquote></li><li><p>DCL(Data Control Language): 数据控制语言</p><blockquote><p>用来定义访问权限和安全级别（用户创建，以及用户的权限管理）</p></blockquote></li></ul></blockquote></li></ol><h1 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h1><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><ul><li>查看所有数据库：<code>SHOW DATABASES</code></li><li>切换（选择要操作的）数据库：<code>USE 数据库名</code></li><li>创建数据库：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名</code> </li><li>删除数据库：<code>DROP DATABASE [IF EXISTS] 数据库名</code></li><li>修改数据库编码：<code>ALTER DATABASE 数据库名CHARACTER SET 编码名</code></li></ul><h2 id="数据类型（列数据类型）"><a href="#数据类型（列数据类型）" class="headerlink" title="数据类型（列数据类型）"></a>数据类型（列数据类型）</h2><ul><li><p>int：整型</p></li><li><p>double：浮点型</p><blockquote><p>double(5, 2)表示最多5位，其中必须有两位小数</p></blockquote></li><li><p>decimal：浮点型</p><blockquote><p>十进制浮点类型，不会出现浮点数精度丢失问题，在跟钱相关的方面使用该类</p></blockquote></li><li><p>char：固定长度字符串</p><blockquote><p>char(255)，数据长度不足，则会补足到指定长度</p></blockquote></li><li><p>varchar：可变长字符串类型</p><blockquote><ul><li><p>varchar(65535)，最大指定长度为65535，当数据长度不足指定长度的时候，不用补足到指定长度。</p></li><li><p>需要使用额外的一个字节来记录数据长度</p></li></ul></blockquote></li><li><p>text：字符串类型</p><blockquote><p>MySQL的方言，在标准SQL中为clob</p></blockquote><ul><li>tinytext：256B</li><li>text：64K</li><li>mediumtext：16M</li><li>longtext：4G</li></ul></li><li><p>blob：字节类型</p><ul><li>varblob</li><li>tinyblob</li><li>blob</li><li>mediumblob</li><li>longblob</li></ul></li><li><p>时间相关</p><ul><li>date：日期类型，格式：yyyy- MM-dd;</li><li>time：时间类型， 格式：hh:mm:ss；</li><li>timestamp：时间戳类型：</li></ul></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><p><strong>注意：所有对表的操作都要在选定数据库之后</strong></p><ol><li><p>创建表</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE [IF NOT EXISTS] 表名(<br>列名 列类型,<br>    ...<br>    列名 列类型,<br>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>查看表</p><blockquote><ul><li><p>查看当前数据库中左右表名称：<code>SHOW TABLES;</code></p></li><li><p>查看指定表的创建语句：<code>SHOW CREATE TABLE 表名;</code>(了解)</p></li><li><p>查看表结构： <code>DESC 表名;</code></p></li></ul></blockquote></li><li><p>删除表：<code>DROP TABLE 表名;</code></p></li><li><p>修改表：<strong>ALTER</strong></p><ul><li><p>添加列：<strong>ADD</strong></p><blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD(<br>列名 列类型,<br>    ...<br>    列名 列类型,<br>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>删除列：<strong>DROP</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 DROP 列名;<br><br>  - 修改列类型：**MODIFY**<br><br>```mysql<br>ALTER TABLE 表名 MODIFY 列名 列类型;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>修改列名：<strong>CHANGE</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 CHANGE  原列名 新列名 列类型；<br></code></pre></td></tr></table></figure></blockquote></li><li><p>修改表名称：<strong>RENAME</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 原表名 RENAME TO 新表名<br></code></pre></td></tr></table></figure></blockquote></li></ul></li></ol><h1 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h1><blockquote><p>先了解一个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SLEECT * FROM 表名<br></code></pre></td></tr></table></figure><ul><li>显示所有数据库：<code>SHOW DATABASES;</code></li><li>选择数据库：<code>USE 数据库名;</code></li><li>显示数据库中所有表：<code>SHOW TABLES;</code></li></ul></blockquote><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><ol><li>给出插入列</li></ol><blockquote><ul><li>列名与列值对应，不一定要按照表中列顺序，若插入的是部分列，那么未填写的列为null值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 表名(<br>列名1,列名2，列名3<br>)<br>VALUES(<br> 列对应值1，列对应值2，对应列值3<br>);<br></code></pre></td></tr></table></figure></blockquote><ol start="2"><li>不给出插入列</li></ol><blockquote><ul><li>默认插入所有列，必须根据表中列的排序给出所有列值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INT 表名 VALUES(<br>列值1，列值2，列值3<br>);<br></code></pre></td></tr></table></figure></blockquote><p><strong>注意：</strong>MySQL中的字符串<strong>必须使用单引号</strong></p><h2 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h2><p>基本语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UPDATE</span> 表名 SET 列名<span class="hljs-number">1</span>=列值<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span>=列值<span class="hljs-number">2</span><span class="hljs-meta"> [WHERE 条件]</span><br></code></pre></td></tr></table></figure><p>注意：若没有WHERE条件，那么这个表中的所有行都会被修改。WHERE 条件用于选择需要修改的行。</p><p>条件：</p><blockquote><p>运算符</p><ul><li>**&#x3D;**、!&#x3D;(&lt;&gt;等价)&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;</li><li>区间：BETWEEN…AND…</li><li>枚举：IN(…)</li><li>IS NULL</li><li>连接多个条件：NOT、OR、AND</li></ul></blockquote><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>基本语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM 表名 [WHERE 条件]<br></code></pre></td></tr></table></figure><p>注意：不加WHERE整个表中数据都会被删除（表还在）</p><h1 id="DCL（数据控制语言）"><a href="#DCL（数据控制语言）" class="headerlink" title="DCL（数据控制语言）"></a>DCL（数据控制语言）</h1><p>对于DCL的理解：</p><blockquote><ul><li>一个项目创建一个用户，一个项目对应的数据库只有一个</li><li>这个用户只拥有该数据库的权限，无法操作其他数据库</li></ul></blockquote><h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1. 创建用户"></a>1. 创建用户</h2><p>用户只能在指定IP登录</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 用户名@IP地址 IDENTIFIED BY &#x27;密码&#x27;;<br></code></pre></td></tr></table></figure></blockquote><p>用户可以在任意IP登录</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 用户名@IP&#x27;*&#x27; IDENTIFIED BY &#x27;密码&#x27;;<br></code></pre></td></tr></table></figure></blockquote><h2 id="2-给用户授权"><a href="#2-给用户授权" class="headerlink" title="2. 给用户授权"></a>2. 给用户授权</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">GRANT 权限1,...,权限n ON 数据库.* TO 用户名@IP地址;<br></code></pre></td></tr></table></figure><ul><li><p>将<strong>指定数据库</strong>的<strong>指定权限</strong>赋予<strong>指定用户</strong></p></li><li><p>要素：权限、数据库、用户</p><blockquote><p>权限：</p><ul><li><p>CREATE、ALTER、DROP、INSERT、UPDATE、DELETE、SELECT</p></li><li><p>ALL表示所有权限</p></li></ul></blockquote></li></ul><h2 id="3-撤销授权"><a href="#3-撤销授权" class="headerlink" title="3. 撤销授权"></a>3. 撤销授权</h2><p>操作基本同授权一样，使用REVOKE替换GRANT即可</p><h2 id="4-查看权限"><a href="#4-查看权限" class="headerlink" title="4. 查看权限"></a>4. 查看权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GRANTS FOR 用户名@IP地址;<br></code></pre></td></tr></table></figure><h2 id="5-删除用户"><a href="#5-删除用户" class="headerlink" title="5. 删除用户"></a>5. 删除用户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP USER 用户名@IP地址<br></code></pre></td></tr></table></figure><h1 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h1><h2 id="一、基础查询"><a href="#一、基础查询" class="headerlink" title="一、基础查询"></a>一、基础查询</h2><ul><li><strong>查询所有列（整张表）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名;<br></code></pre></td></tr></table></figure><h3 id="1-列控制"><a href="#1-列控制" class="headerlink" title="1. 列控制"></a>1. 列控制</h3><ol><li>查询指定列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT 列名1,列名2 FROM 表名;<br></code></pre></td></tr></table></figure><ol start="2"><li>完全重复的记录只有一次</li></ol><blockquote><p>当查询结果中多行记录一摸一样时，只显示一行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT DISTINCT 列名 FROM 表名;<br></code></pre></td></tr></table></figure><ol start="3"><li>列运算</li></ol><ul><li><p>数量类型的列可以做加减乘除运算</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名*1.5 FROM 表名;<br>SELECT 列名1+列名2 FROM 表名;<br></code></pre></td></tr></table></figure></li><li><p>字符串类型的列可以做连续运算</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT CONCAT(&#x27;S&#x27;, 列名) FROM 表名;<br></code></pre></td></tr></table></figure></li></ul><blockquote><ul><li>转换NULL值</li></ul>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT IFNULL (列名1,0)+1000 FROM 表名;<br></code></pre></td></tr></table></figure><blockquote><p>IFNULL(列名1，0) 表示，如果列1中的值为NULL，则当为0计算</p></blockquote><ul><li>给列起别名</li></ul><blockquote><p>在使用列运算后自动生成的列名称不直观，可以给列名起个别名(<strong>AS可省略</strong>)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT IFNULL (列名1,0)+1000 AS 奖学金 FROM 表名;<br></code></pre></td></tr></table></figure></blockquote><h3 id="2-行控制"><a href="#2-行控制" class="headerlink" title="2. 行控制"></a>2. 行控制</h3><ol><li><p>条件查询: <strong>WHERE</strong></p><blockquote><p>同前面的UPDATE和DELETE语句一样，使用WHERE子句来控制记录</p></blockquote></li><li><p>模糊查询: <strong>LIKE</strong></p><blockquote><p>用来对<strong>字符串列</strong>进行模糊查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WHERE 列名 LIKE &#x27;李_&#x27;;<br></code></pre></td></tr></table></figure><ul><li>_下划线，用来匹配一个字符</li><li>%百分号，用来匹配0-n个字符</li></ul></blockquote></li></ol><h3 id="二、排序：ORDER-BY"><a href="#二、排序：ORDER-BY" class="headerlink" title="二、排序：ORDER BY"></a>二、排序：ORDER BY</h3><ol><li><p>默认升序: <strong>ASC</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名；<br></code></pre></td></tr></table></figure></li><li><p>降序排序: <strong>DESC</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名 DESC;<br></code></pre></td></tr></table></figure></li><li><p>多条件排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名1 DESC, 列名2 ASC;<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、聚合函数"><a href="#三、聚合函数" class="headerlink" title="三、聚合函数"></a>三、聚合函数</h2><ol><li><p>查询有效行数：<strong>COUNT()</strong></p><blockquote><p>括号中可以是列名、*、数字，其中*和数字等效</p></blockquote></li><li><p>计算</p><blockquote><p> 计算中的括号中只能填写数字列</p></blockquote><ul><li>总和：<strong>SUM()</strong></li><li>最大值：<strong>MAX()</strong></li><li>平均值：<strong>AVG()</strong></li></ul></li><li><p>综合计算</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT COUNT(*),SUM(列名1)，MAX(列名2) FROM 表名;<br></code></pre></td></tr></table></figure></li></ol><h2 id="四、分组查询：GROUP-BY-HAVING"><a href="#四、分组查询：GROUP-BY-HAVING" class="headerlink" title="四、分组查询：GROUP BY|HAVING"></a>四、分组查询：GROUP BY|HAVING</h2><blockquote><ul><li>分组</li></ul><blockquote><p>将一列中值相同的行分为一组</p></blockquote><ul><li>查询</li></ul><blockquote><p>分组查询不能使用个人信息查询，都是使用聚合信息进行查询</p></blockquote></blockquote><p>分组查询过滤</p><ul><li><p>分组前过滤条件（对整张表进行过滤）</p><blockquote><p>WHERE</p><p>在GROUP BY之前</p></blockquote></li><li><p>分组后过滤条件（对分组查询的结果过滤）</p><blockquote><p>HAVING</p><p>在GROUP BY之后</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名1(展示列), 聚合函数 FROM 表名 WHERE 分组前条件 GROUP BY 列名2(分组列) HAVING 分组后条件 ORDER BY 列名3(排序列)<br></code></pre></td></tr></table></figure><blockquote><p>同一SQL语句中，关键字使用顺序(执行顺序也是如此)：</p><ol><li>SELECT</li><li>FROM</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>ORDER BY</li></ol></blockquote><h2 id="五、LIMIT方言"><a href="#五、LIMIT方言" class="headerlink" title="五、LIMIT方言"></a>五、LIMIT方言</h2><p>LIMIT作用：</p><blockquote><ul><li>用来限定查询结果的起始行，以及总行数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM 表名 LIMIT a,b;<br></code></pre></td></tr></table></figure><p>从第a行开始查b行数据</p></blockquote><p>LIMIT应用：</p><blockquote><ul><li>用于分页查询</li></ul><p>若每页十行数据，那么如果要查第三页，语句如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 LIMIT 20,10;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL45讲笔记</title>
    <link href="/2022/09/02/MySQL45%E8%AE%B2/"/>
    <url>/2022/09/02/MySQL45%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="学习MySQL原理的意义"><a href="#学习MySQL原理的意义" class="headerlink" title="学习MySQL原理的意义"></a>学习MySQL原理的意义</h1><p>即使是MySQL的使用者，而非开发者，也需要理解MySQL的原理</p><ul><li>提升数据库的性能</li><li>更快速的定位并解决问题</li></ul><h1 id="一条MySQL语句是怎么执行的"><a href="#一条MySQL语句是怎么执行的" class="headerlink" title="一条MySQL语句是怎么执行的"></a>一条MySQL语句是怎么执行的</h1><h2 id="MySQL的基本架构"><a href="#MySQL的基本架构" class="headerlink" title="MySQL的基本架构"></a>MySQL的基本架构</h2><p><img src="/2022/09/02/MySQL45%E8%AE%B2/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p><h3 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><blockquote><p>管理连接，权限验证</p></blockquote><ul><li><p>数据库<strong>连接命令</strong>:  <code>mysql -h$ip -P$port -u$user -p</code></p></li><li><p>用户的<strong>权限</strong>在建立连接的时候获取, 对于已经成功建立连接的用户, 管理员再修改其权限, 不会影响当前连接的权限</p></li><li><p>连接没有操作就会处于**休眠(Sleep)**状态, 超过8个小时休眠, 会自动断开连接, 右参数wait_timeout控制</p></li><li><p>长连接与短连接</p><ul><li><p>长连接不需要频繁的建立连接, 而建立连接的过程比较复杂, 所以说<strong>尽量使用长连接</strong></p></li><li><p>MySQL在执行过程中临时使用的内存是管理在连接对象中的, 这些资源在连接断开的时候才会释放, 若全部使用长连接, 可能会导致内存占用过大, 被系统强行杀掉(OOM), 从现象上看就是MySQL异常重启</p><blockquote><p>解决办法:</p><ol><li>定期断开长连接。使用一段时间或者执行一个内存占用较大的查询后,断开连接，下一次查询的时候再重连。</li><li>重新初始化连接资源。在执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将来连接恢复至刚刚创建完时的状态。</li></ol></blockquote></li></ul></li></ul><h4 id="缓存器"><a href="#缓存器" class="headerlink" title="缓存器"></a>缓存器</h4><blockquote><p>已经被淘汰</p></blockquote><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><blockquote><p>词法分析，语法分析</p></blockquote><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><blockquote><p>执行计划生成,索引选择</p></blockquote><p>优化器实在表中有<strong>多个索引</strong>的时候，决定使用哪个索引，或者在一个语句有<strong>多个表关联</strong>的时候，决定各个表的连接顺序。</p><p>不同的执行顺序，执行的效率有所不同，优化器的作用就是选择执行顺序。</p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><blockquote><p>操作引擎, 返回结果</p></blockquote><ol><li><p>检查权限</p></li><li><p>打开表，根据表的引擎定义，区使用该引擎提供的接口</p></li></ol><p>执行器执行流程:</p><blockquote><ul><li>命令: <code>select * from T where ID=10;</code></li></ul><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</li></ol></blockquote><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul><li>InnoDB (默认)</li><li>MyISAM</li><li>Memory</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>表T没有字段K，但是执行<code>select * from T where k=1</code>，肯定会报错”不存在这个列”，这个错误实在哪个阶段报出来的？</p><blockquote><p>分析器阶段。在分析阶段，会判断语句是否正确，表是否存在，列是否存在。</p></blockquote></li></ul><h2 id="MySQL的日志系统"><a href="#MySQL的日志系统" class="headerlink" title="MySQL的日志系统"></a>MySQL的日志系统</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown入门</title>
    <link href="/2022/09/01/MarkDownBase/"/>
    <url>/2022/09/01/MarkDownBase/</url>
    
    <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. <strong>标题</strong></h3><blockquote><p># H1 </p><p>## H2</p><p>### H3</p><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3></blockquote><h3 id="2-粗体"><a href="#2-粗体" class="headerlink" title="2. 粗体"></a>2. <strong>粗体</strong></h3><blockquote><p>*<em>bold text</em>*</p><p><strong>bold text</strong></p></blockquote><h3 id="3-斜体"><a href="#3-斜体" class="headerlink" title="3. 斜体"></a>3. <strong>斜体</strong></h3><blockquote><p>*italicized text*</p><p><em>italicized text</em></p></blockquote><h3 id="4-引用块"><a href="#4-引用块" class="headerlink" title="4. 引用块"></a>4. <strong>引用块</strong></h3><blockquote><p>&gt; blockquote</p><blockquote><p>blockquote</p></blockquote></blockquote><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. <strong>有序列表</strong></h3><blockquote><ol><li>First item</li><li>Second item</li><li>Third item</li></ol></blockquote><h3 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6. 无序列表"></a>6. <strong>无序列表</strong></h3><blockquote><p>- First item</p><p>- Second item</p><p>- Third item</p><ul><li>First item</li><li>Second item</li><li>Third item</li></ul></blockquote><h3 id="7-代码"><a href="#7-代码" class="headerlink" title="7. 代码"></a>7. <strong>代码</strong></h3><blockquote><p>`code&#96;</p><p><code>code</code></p></blockquote><h3 id="8-分隔线"><a href="#8-分隔线" class="headerlink" title="8. 分隔线"></a>8. <strong>分隔线</strong></h3><blockquote><p>-–</p><hr></blockquote><h3 id="9-链接"><a href="#9-链接" class="headerlink" title="9. 链接"></a>9. <strong>链接</strong></h3><blockquote><p>[title](<a href="http://www.example.com/">http://www.example.com</a>)</p><p><a href="http://www.example.com/">title</a></p></blockquote><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10. 图片"></a>10. <strong>图片</strong></h3><blockquote><p>![alt text](<a href="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot;picture">https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot;picture</a> title”)</p><p><img src="/2022/09/01/MarkDownBase/googlelogo_color_272x92dp.png" alt="alt text" title="picture title"></p></blockquote><h2 id="二、扩展语法"><a href="#二、扩展语法" class="headerlink" title="二、扩展语法"></a>二、扩展语法</h2><h3 id="1-表格"><a href="#1-表格" class="headerlink" title="1. 表格"></a>1. <strong>表格</strong></h3><blockquote><p>| Syntax    | Description |<br>| ——— | ———– |<br>| Header    | Title       |<br>| Paragraph | Text        |</p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></blockquote><h3 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2. 代码块"></a>2. <strong>代码块</strong></h3><blockquote><p>`&#96;&#96;json<br>{<br>“firstname”: “John”,<br>“lastname”: “Smith”,<br>“age”: 25<br>}<br>`&#96;&#96;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;firstname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;lastname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="3-脚注"><a href="#3-脚注" class="headerlink" title="3. 脚注"></a>3. <strong>脚注</strong></h3><blockquote><p>Here’ s a sentence with a footnote.[^1]</p><p>[^1]:This is the footnote.</p></blockquote><p>Here’ s a sentence with a footnote.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="This is the footnote.">[1]</span></a></sup></p><h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4. 删除线"></a>4. <strong>删除线</strong></h3><blockquote><p>~~The world is flat.~~</p><p><del>The world is flat.</del></p></blockquote><h3 id="5-任务列表"><a href="#5-任务列表" class="headerlink" title="5. 任务列表"></a>5. <strong>任务列表</strong></h3><blockquote><p>- [x] Write the press release</p><p>- [ ] Update the website</p><p>- [ ] Contact the media</p><ul><li><input checked disabled type="checkbox"> Write the press release</li><li><input disabled type="checkbox"> Update the website</li><li><input disabled type="checkbox"> Contact the media</li></ul></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>This is the footnote.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="/2022/09/01/HexoBlogBuild/"/>
    <url>/2022/09/01/HexoBlogBuild/</url>
    
    <content type="html"><![CDATA[<ol><li><h1 id="Hexo博客-搭建-美化-使用"><a href="#Hexo博客-搭建-美化-使用" class="headerlink" title="Hexo博客 搭建+美化+使用"></a>Hexo博客 搭建+美化+使用</h1><h2 id="一、搭建"><a href="#一、搭建" class="headerlink" title="一、搭建"></a>一、搭建</h2><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h3><h4 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a>1.1 注意事项</h4><ul><li>命令可以使用Windows的<strong>cmd</strong>和<strong>git bash</strong>来完成，cmd可能会有一些问题，建议全部使用git bash执行</li><li>hexo版本差异大，网上一些配置信息基于2.x，注意区别</li><li>hexo中有两种_config.yml文件，一个hexo根目录下的,一个是各个theme目录下的</li></ul><h4 id="1-2-安装所需软件"><a href="#1-2-安装所需软件" class="headerlink" title="1.2 安装所需软件"></a>1.2 安装所需软件</h4><ul><li>node.js<ul><li>官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装后验证：<code>node -v</code></li></ul></li><li>git<ul><li>官网：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li><li>安装后验证：<code>git -v</code></li></ul></li><li>cnpm<ul><li>安装命令： <code>npm install -g cnpm –registry==https://registry.npm.taobao.org</code></li><li>安装后验证：<code>cnpm -v</code></li></ul></li><li>hexo<ul><li>安装命令：<code>cnpm install -g hexo-cli</code></li><li>安装后验证：<code>hexo -v</code></li></ul></li></ul><h3 id="2-配置GitHub"><a href="#2-配置GitHub" class="headerlink" title="2. 配置GitHub"></a>2. 配置GitHub</h3><h4 id="2-1-在GitHub上创建仓库"><a href="#2-1-在GitHub上创建仓库" class="headerlink" title="2.1 在GitHub上创建仓库"></a>2.1 在GitHub上创建仓库</h4><ol><li>创建一个以<strong>你的用户名.github.io</strong>的仓库</li><li>注意：我的用户名为xiang-4422，所以仓库为xiang-4422.githun.io，网站的访问地址就是<a href="http://xiang-4422.github.io/">http://xiang-4422.github.io</a>。由此可见，每个github账户只能创建一个这样可以直接使用域名访问的仓库。</li></ol><h4 id="2-2-绑定域名（可选）"><a href="#2-2-绑定域名（可选）" class="headerlink" title="2.2 绑定域名（可选）"></a>2.2 绑定域名（可选）</h4><ol><li>注册域名<ul><li>godaddy</li><li>阿里云</li></ul></li><li>绑定域名<ul><li>带www</li><li>不带www</li><li>无论域名是否带www，在访问的时候使用两种方式都能跳转</li></ul></li><li>域名配置<ul><li>方式一、CNAME<ul><li>CNAME填写域名，即<strong>用户名.github.io</strong></li></ul></li><li>方式二、A记录<ul><li>A记录填写IP</li><li>不带www的方式只能采用A记录，所以需要先ping一下网站的IP，然后到域名DNS设置页中，将A记录指向ping出来的IP</li></ul></li></ul></li></ol><h3 id="3-配置SSH免密登录"><a href="#3-配置SSH免密登录" class="headerlink" title="3. 配置SSH免密登录"></a>3. 配置SSH免密登录</h3><h4 id="3-1-获取本地的SSH公钥"><a href="#3-1-获取本地的SSH公钥" class="headerlink" title="3.1 获取本地的SSH公钥"></a>3.1 获取本地的SSH公钥</h4><ol><li>打开电脑文件夹，找到 C:\Users\用户名\.ssh 文件夹并删除</li><li>在 C:\Users\用户名 目录下右键打开Git Bash Here，输入命令<code>ssh-keygen -t rsa -C github邮件地址</code>生成.ssh密钥，输入后连敲三次回车</li><li>生成.ssh文件夹后，打开该文件夹，打开id_rsa.pub文件，复制其中内容</li></ol><h4 id="3-2-在GitHub中添加公钥"><a href="#3-2-在GitHub中添加公钥" class="headerlink" title="3.2 在GitHub中添加公钥"></a>3.2 在GitHub中添加公钥</h4><ol start="4"><li>GitHub主页 -&gt; SSH and GPG keys -&gt; New SSH key，将复制的内容粘贴进去，设置一个title，并保存</li></ol><h4 id="3-3-检查是否配置成功"><a href="#3-3-检查是否配置成功" class="headerlink" title="3.3 检查是否配置成功"></a>3.3 检查是否配置成功</h4><ul><li><p>命令：<code>$ ssh -T git@github.com</code></p></li><li><p>成功后的提示信息：Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.即配置成功</p></li></ul><h4 id="3-4-配置Git信息"><a href="#3-4-配置Git信息" class="headerlink" title="3.4 配置Git信息"></a>3.4 配置Git信息</h4><ul><li>命令：<code>$ git config –global user.name “GitHub用户名”</code></li><li>命令：<code>$ git config –global user.email “GitHub注册邮箱&quot;</code></li></ul><h3 id="4-使用hexo搭建博客"><a href="#4-使用hexo搭建博客" class="headerlink" title="4. 使用hexo搭建博客"></a>4. 使用hexo搭建博客</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><ol><li>在电脑中创建一个文件夹用于存放hexo的代码，作为hexo的根目录</li><li>在该文件夹中右键打开Git Bash Here，输入一下命令<ul><li><code>hexo init</code>: 初始化</li><li><code>hexo g</code>: 在public文件夹中生成相关html文件</li><li><code>hexo s</code>: 启动服务</li></ul></li><li>hexo g开启了本地预览服务，访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看。<ul><li>端口冲突问题解决：<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">https://www.runoob.com/w3cnote/windows-finds-port-usage.html</a></li></ul></li></ol><h4 id="4-2部署到GitHub个人主页"><a href="#4-2部署到GitHub个人主页" class="headerlink" title="4.2部署到GitHub个人主页"></a>4.2部署到GitHub个人主页</h4><ol><li>在hexo根目录下安装hexo-deployer-git插件<ul><li>安装命令：<code>npm install hexo-deployer-git -save</code></li></ul></li><li>编辑hexo根目录下的_config.yml文件，在文件末尾添加如下内容</li></ol><p><img src="/2022/09/01/HexoBlogBuild/8.png" alt="img"></p><ul><li>注意：其中repo中的内容为GitHub个人主页链接地址，如图：</li></ul><p><img src="/2022/09/01/HexoBlogBuild/9.png" alt="img"></p><ol start="3"><li>在根目录下使用命令：<code>hexo d</code>将本地blog推动到GitHub仓库<ul><li>可能需要username &amp; pwd</li><li>推送成功后，即可在浏览器中通过域名访问 <a href="https://xiang-4422.github.io/">https://xiang-4422.github.io/</a></li></ul></li></ol><h2 id="二、美化"><a href="#二、美化" class="headerlink" title="二、美化"></a>二、美化</h2><h3 id="1-更换主题"><a href="#1-更换主题" class="headerlink" title="1. 更换主题"></a>1. 更换主题</h3><ol><li><p>主题下载：</p><ul><li><p><a href="https://hexo.io/themes/">hexo官网</a>上有很多主题，我使用的是 fluid：<a href="https://github.com/fluid-dev/hexo-theme-fluid">GitHub仓库地址</a> | <a href="https://github.com/fluid-dev/hexo-theme-fluid">用户手册</a></p></li><li><p>到hexo根目录下使用Git Bash Here，输入命令<code>$ git clone 主题http链接 themes/主题名称</code>下载主题</p><p><img src="/2022/09/01/HexoBlogBuild/10.png" alt="img"></p></li><li><p>根目录中theme文件下就是博客的主题，可以下载多个，具体选择哪一个可以在hexo配置文件中配置</p></li></ul></li></ol><h3 id="2-使用主题"><a href="#2-使用主题" class="headerlink" title="2. 使用主题"></a>2. 使用主题</h3><ol><li>修改hexo配置文件<ul><li>打开hexo根目录下的_config.yml文件</li><li>找到theme: landscape项目，改为theme: 对应主题名</li><li>执行<code>hexo g</code>重新生成</li></ul></li><li>若出现问题依次执行下面命令<ul><li><code>hexo clean</code>清理public内容</li><li><code>hexo g</code>重新生成</li><li><code>hexo s</code>重新部署</li></ul></li></ol><h3 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h3><ul><li>根据使用主题对对应的配置文档进行主题配置</li><li>我使用过的是fluid：<a href="https://github.com/fluid-dev/hexo-theme-fluid">GitHub仓库地址</a> | <a href="https://github.com/fluid-dev/hexo-theme-fluid">用户手册</a></li></ul><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="1-写博客的步骤"><a href="#1-写博客的步骤" class="headerlink" title="1. 写博客的步骤"></a>1. 写博客的步骤</h3><h4 id="1-1-创建-md文件"><a href="#1-1-创建-md文件" class="headerlink" title="1.1 创建.md文件"></a>1.1 创建.md文件</h4><ul><li><p>方法一、使用hexo命令创建</p><ul><li><p>在hexo根目录，在Git Bash Here中执行命令：<code>hexo new &#39;文章名称&#39;</code></p></li><li><p>hexo会自动在对应位置生成.md文件，且自动在 新建的.md文件中生成如下内容</p><p><img src="/2022/09/01/HexoBlogBuild/16.png" alt="img"></p></li></ul></li><li><p>方法二、直接在hexo根目录\source\_posts文件夹下直接创建.md文件</p></li></ul><h4 id="1-2-编写并保存"><a href="#1-2-编写并保存" class="headerlink" title="1.2 编写并保存"></a>1.2 编写并保存</h4><ul><li>使用typora打开该文件，编写博客，写完后Ctrl+S保存关闭即可</li></ul><h4 id="1-3-推送博客"><a href="#1-3-推送博客" class="headerlink" title="1.3  推送博客"></a>1.3  推送博客</h4><ul><li>在hexo根目录下，在Git Bash Here中依次执行以下命令<ul><li><code>hexo clean</code>清理</li><li><code>hexo g</code>生成</li><li><code>hexo d</code>部署</li></ul></li></ul><h3 id="2-注意使用的文章-Front-matter-语法"><a href="#2-注意使用的文章-Front-matter-语法" class="headerlink" title="2. 注意使用的文章 Front-matter 语法"></a>2. 注意使用的文章 Front-matter 语法</h3><ul><li>不同主题有所不同，在主题的使用文档中查找。<a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5">hexo中的说明</a></li><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5">fluid主题对应文档</a></li></ul><h3 id="3-向hexo博客中插入图片"><a href="#3-向hexo博客中插入图片" class="headerlink" title="3. 向hexo博客中插入图片"></a>3. 向hexo博客中插入图片</h3><h4 id="3-1-常规路径设置，及其问题"><a href="#3-1-常规路径设置，及其问题" class="headerlink" title="3.1 常规路径设置，及其问题"></a>3.1 常规路径设置，及其问题</h4><ul><li><p>md中插入图片的语法为：![]()</p><ul><li><p>[]为图片描述 | ()为图片路径:  路径分为三种</p><ul><li><p>相对路径</p><blockquote><p>在hexo配置文件中启用 post_asset_folder: true</p><p>使用hexo new命令创建文章的时候会生成同名的文件夹用于存放文件资源</p><p>引入图片：![](image.jpg)</p><p>问题：</p><ol><li><p>在Typora中无法显示</p><ul><li><p>在Typora引入相对路径图片：![](文章名&#x2F;image.jpg)</p></li><li><p>在Hexo中引入相对路径图片：![](image.jpg)</p></li></ul></li><li><p>在首页显示</p><ul><li>解决办法：使用标签插件语法 </li></ul></li></ol></blockquote></li><li><p>绝对路径</p><blockquote><p>将图片文件放在：hexo根目录&#x2F;source&#x2F;images&#x2F;image.jpg</p><p>引入图片：![图片描述](&#x2F;images&#x2F;image.jpg)</p><p>问题：</p><ul><li>所有文章的图片都在 source&#x2F;images 目录下，图片资源杂乱</li></ul></blockquote></li><li><p>网络路径</p><blockquote><p>问题：图片链接可能失效</p></blockquote></li></ul></li></ul></li></ul><h4 id="3-2-图片插入的解决办法"><a href="#3-2-图片插入的解决办法" class="headerlink" title="3.2 图片插入的解决办法"></a>3.2 图片插入的解决办法</h4><ol><li><p>asset-image插件</p><ul><li><p>安装: <code>npm install https://github.com/CodeFalling/hexo-asset-image</code></p></li><li><p>修改Hexo配置文件</p><blockquote><p>post_asset_folder: true</p></blockquote></li><li><p>设置好后在Hexo中就可以使用 ![](文章名&#x2F;image.jpg) 插入图片</p></li></ul></li><li><p>asset-image插件+Typora结合</p><ul><li><p>在Typora中， 文件-&gt;偏好设置-&gt;图像中设置<img src="/2022/09/01/HexoBlogBuild/21.png" alt="img"></p></li><li><p>复制网络图片</p><blockquote><p>在网页中复制图片后，粘贴到Typora中，会直接复制该图片到文章资源文件夹中，同时自动更改路径</p><p>如：图片 https:&#x2F;&#x2F;…&#x2F;image.jpg 粘贴到Typora中叫文章名的文章中后，图片的路径自动变为(文章名&#x2F;image.jpg)，同时图片资源自动存入对应文章资源文件夹中</p></blockquote></li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://reclusew.github.io/2021/08/12/blog-setup/">2021年最全搭建+美化+使用博客教程</a></li><li><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li><li><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册 (fluid-dev.com)</a></li><li><a href="http://codecook.site/2020/12/05/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/">hexo图片路径设置</a></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
