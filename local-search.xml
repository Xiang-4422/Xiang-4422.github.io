<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL-内存</title>
    <link href="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/"/>
    <url>/2022/11/05/MySQL-%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Buffer-Pool简介"><a href="#Buffer-Pool简介" class="headerlink" title="Buffer Pool简介"></a>Buffer Pool简介</h1><h2 id="Buffer-Pool的作用"><a href="#Buffer-Pool的作用" class="headerlink" title="Buffer Pool的作用"></a>Buffer Pool的作用</h2><p>MySQL的数据是存储在磁盘中的，但是每次都直接从磁盘读数据，这样性能很差。为此InnoDB存储引擎设计了一个缓冲池，当数据从磁盘中取出来后，缓存在内存中，下次查询相同数据就直接从内存中读取，这样就提高了数据库的读写性能。</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png" alt="img"></p><p>有了缓冲池后的读写操作：</p><ul><li>读取数据时，如果数据存在于Buffer Pool中，客户端就直接读取Buffer Pool中的数据，否则才去磁盘中读取。</li><li>当修改数据时，首先将数从磁盘读到Buffer Pool中，修改Buffer Pool中数据所在页，然后将该页设置为脏页，最后由后台线程将脏页写入磁盘。</li></ul><h2 id="Buffer-Pool缓存"><a href="#Buffer-Pool缓存" class="headerlink" title="Buffer Pool缓存"></a>Buffer Pool缓存</h2><h3 id="Buffer-Pool的缓存大小"><a href="#Buffer-Pool的缓存大小" class="headerlink" title="Buffer Pool的缓存大小"></a>Buffer Pool的缓存大小</h3><p>Buffer Pool在MySQL启动的时候，向操作系统申请一片连续的内存空间，默认128MB。</p><p><code>innodb_buffer_pool_size</code>参数可以设置Buffer Pool的大小，一般建议设置为可用物理内存的60%~80%。</p><h3 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h3><p>InnoDB会把存储的数据划分为若干个页，<strong>以页作为磁盘和内存交互的基本单位</strong>，一个页的默认大小为16KB。因此Buffer Pool同样需要按页来划分。在MySQL启动的时候，InnoDB会为Buffer Pool申请一片连续的内存空间，然后按照16KB的大小划分出一个个页，Buffer Pool中的页称为<strong>缓存页</strong>。</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/bufferpool%E5%86%85%E5%AE%B9.drawio-166788020102019.png" alt="img"></p><p>刚开始的时候，这些缓存页都是空闲的，随着程序的运行才会有磁盘中的页被缓存到Buffer Pool中。因此MySQL刚启动时，使用的虚拟内存空间很大，而使用的物理内存空间很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，将虚拟地址与物理地址建立映射关系。</p><p>因为InnoDB的Buffer Pool缓存是以页为单位缓存数据的，所以如果只是查询一条记录，也需要缓存整个该记录所在页。通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到Buffer Pool后，再通过页中的页目录去定位页中的某条具体记录。</p><h3 id="控制块"><a href="#控制块" class="headerlink" title="控制块"></a>控制块</h3><blockquote><p>为了更好的管理这些在Buffer Pool中的缓存页，InnoDB为每一个缓存页都创建了一个<strong>控制块</strong>。</p></blockquote><p>控制块信息包括：</p><ul><li>缓存页的表空间</li><li>页号</li><li>缓存页地址</li><li>链表节点</li></ul><p>控制块也占有内存空间，它是放在Buffer Pool的最前面，接着才是缓存页，如图：</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" alt="img"></p><p>在控制块和缓存页之间灰色部分称为碎片空间：</p><blockquote><p>在分配了足够多的控制块和缓存页后，可能剩余的空间不够一对控制块和缓存页的大小，这部分空间就无法使用。</p></blockquote><h1 id="如何管理BufferPool"><a href="#如何管理BufferPool" class="headerlink" title="如何管理BufferPool"></a>如何管理BufferPool</h1><h2 id="空闲页管理（Free链表）"><a href="#空闲页管理（Free链表）" class="headerlink" title="空闲页管理（Free链表）"></a>空闲页管理（Free链表）</h2><p>Buffer Pool是一片连续的内存空间，当MySQL运行一段时间后，这片连续的内存空间既有空闲，也有被使用的。当我们需要从磁盘读取数据到Buffer Pool中的时候，需要找到其中空闲的缓存页。</p><p>为了能够快速的找到空闲的缓存页，通过使用链表结构，将空闲的缓存页的控制块作为链表的节点，这个链表称为<strong>Free 链表</strong>（空闲链表）。</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/freelist.drawio.png" alt="img"></p><ul><li><p>Free链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量信息。</p></li><li><p>Free链表节点是一个个的控制块，而每个控制块包含着对应的缓存页的地址，所以相当于Free链表节点都对应一个空闲的缓存页。</p></li></ul><p>有了Free链表后，每当需要从磁盘中加载一个页到Buffer Pool时，就从Free链表中取一个空闲的缓存页，并把该缓存页对应的控制块信息填上，然后将缓存页对应的控制块从Free链表中移除。</p><h2 id="脏页管理（Flush链表）"><a href="#脏页管理（Flush链表）" class="headerlink" title="脏页管理（Flush链表）"></a>脏页管理（Flush链表）</h2><p>设计Buffer Pool除了能提高读性能，还能提高写性能。也就是每次更新数据的时候，不需要每次都要写入磁盘，而是将Buffer Pool对应的缓存页标记为脏页，然后再由后台线程将脏页写入到磁盘。</p><p>为了能快速直到哪些缓存页是脏页，于是就设计出了Flush链表，它跟Free链表类似，链表的节点是控制块，区别在于Flush链表的元素都是脏页。</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/Flush.drawio.png" alt="img"></p><p>有了Flush链表后，后台线程就可以遍历Flush链表，将脏页写入到磁盘。</p><h2 id="提高-缓存命中率"><a href="#提高-缓存命中率" class="headerlink" title="提高  缓存命中率"></a>提高  缓存命中率</h2><p>Buffer Pool的大小有限，所有对于频繁访问的数据我们希望留在Buffer Pool中，而很少访问的数据则在某些时机淘汰。从而保证Buffer Pool不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据保留再Buffer Pool中。这个时候就需要使用淘汰算法来实现，最容易想到的就是LRU（Least recently used）算法。</p><h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么当空间不够的时候，就淘汰末尾最久没被使用的节点，从而腾出空间。</p><p>简单的LRU实现：</p><ul><li>当访问的页在Buffer Pool中，就直接把该页对应的LRU链表节点移动到链表的头部。</li><li>当访问的页不在Buffer Pool中，除了要把页放入到LRU链表的头部，还要淘汰LRU链表末尾的节点。</li></ul><p>至此，我们知道，Buffer Pool里有三种页和三种链表来管理数据：</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/bufferpoll_page.png" alt="img"></p><ul><li><p>Free Page（空闲页）</p><blockquote><p>表示该页未被使用，位于Free链表</p></blockquote></li><li><p>Clean Page（干净页）</p><blockquote><p> 表示此页被使用 ，但页面中的数据未发生修改，位于LRU链表</p></blockquote></li><li><p>Dirty Page（脏页）</p><blockquote><p>表示此页已被使用且被修改，其数据与磁盘上的数据不一致，需要刷盘，刷盘后变为干净页。脏页同时存在于LRU链表和Flush链表。</p></blockquote></li></ul><p>简单的LRU算法存在下面这两个问题会导致缓存命中率降低：</p><ul><li>预读失效</li><li>Buffer Pool污染</li></ul><h3 id="预读失效"><a href="#预读失效" class="headerlink" title="预读失效"></a>预读失效</h3><h4 id="什么是预读失效"><a href="#什么是预读失效" class="headerlink" title="什么是预读失效"></a>什么是预读失效</h4><p>程序是有空间局部性的，靠近当前被访问数据的数据在未来很大概率会被访问到。所以，MySQL在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘I&#x2F;O。但是这些被提前加载进来的数据页，不一定会被访问，若没有被访问，那么这个预读就相当于白做，这就是预读失效。</p><p>如果使用简单的LRU算法，这些预读页会被放到LRU链表的头部，而当Buffer Pool空间不够的时候，需要把尾部的页淘汰，但尾部的页可能比这些预读页被使用的概率更大。这样就会大大的降低缓存命中率。</p><h4 id="如何解决预读失效"><a href="#如何解决预读失效" class="headerlink" title="如何解决预读失效"></a>如何解决预读失效</h4><blockquote><p>预读失效也无法避免，但是对于大部分情况，局部性原理还是成立的。</p></blockquote><p>要避免预读失效带来的影响，最好就是让预读的页在Buffer Pool中停留的时间尽可能短，让真正被访问的页才移动到LRU链表的头部，从而保证真正被读取的热数据留在Buffer Pool中的时间尽可能长。</p><p>MySQL的解决办法：改进LRU算法，将LRU链表分为两个区：old区域和young区域。</p><p>young区域在LRU链表的前半部分，old区域在后半部分，如图所示 ：</p><p><img src="/2022/11/05/MySQL-%E5%86%85%E5%AD%98/young+old.png" alt="img"></p><ul><li>真正被访问的页插入young区的头部</li><li>预读的页加入到old区的头部</li><li>如果预读的页一直没有被访问，就会从old区域移除，这样就不会影响到young区域中的热点数据</li><li>可以通过参数<code>innodb_old_blocks_pc</code>来控制二者比例。默认是37，old区占37%</li></ul><h3 id="Buffer-Pool污染"><a href="#Buffer-Pool污染" class="headerlink" title="Buffer Pool污染"></a>Buffer Pool污染</h3><h4 id="什么是Buffer-Pool污染"><a href="#什么是Buffer-Pool污染" class="headerlink" title="什么是Buffer Pool污染"></a>什么是Buffer Pool污染</h4><p>当某个SQL语句扫描了大量的数据时，在Buffer Pool空间比较有限的情况下，可能回将Buffer Pool中的所有页都替换出去，导致大量热点数据被淘汰。这样等再次访问这些热点数据的时候又需要从磁盘中重新读取，这样就会严重降低缓存命中率，导致MySQL性能急剧下降。这个过程就被称为Buffer Pool污染。</p><p>注意：并不是只有查询语句查询出大量的数据才会出现Buffer Pool污染。当索引失效的时候，会发生全表扫描，即使查询结果只有少量数据，也会导致Buffer Pool污染。</p><p>例如在一个数据量很大的表中，执行该语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_user where name like &quot;%xiaolin%&quot;;<br></code></pre></td></tr></table></figure><p>由于是左模糊查询，所以这条语句会发生索引失效，会进行全表扫描，查询过程如下：</p><ul><li>从磁盘读取数据页加入到LRU链表的old区域头部</li><li>然后从页中读取行记录，此时该页被访问，就把该页放到young区域头部</li><li>接下来拿行记录的name字段与匹配条件进行匹配，若符合条件，就将记录加入到结果集中</li><li>如此往复，直到扫描完全表记录</li></ul><p>经过这样的全表扫描后，原本young区域的热点数据都会被替换掉。</p><h4 id="如何解决Buffer-Pool污染"><a href="#如何解决Buffer-Pool污染" class="headerlink" title="如何解决Buffer Pool污染"></a>如何解决Buffer Pool污染</h4><blockquote><p>像前面这种全表扫描，很多缓冲页只会被访问一次，但是它却只因为被访问了一次就进入到young区域，从而导致热点数据被替换。</p></blockquote><p>LRU链表中young区域中是热点数据，只要我们提高进入young区域的门槛，就能够有效地保证真正的热点数据才会进入young区域。</p><p>MySQL的做法：进入young区域条件增加一个停留在old区域的时间判断。</p><p>具体实现：</p><ul><li>在对处于old区域的缓存页进行第一次访问的时候，在它对应的控制块中记录该访问时间</li><li>若后续访问与第一次访问在某时间间隔内，那么该访问页就继续留在old区</li><li>若后续访问域第一次访问超过某事件间隔，那么就将该缓存页从old区移动到young区头部</li></ul><p>该事件间隔由参数<code>innodb_old_blocks_time</code>控制，默认是1000ms。</p><p>这样old区数据被移动到young区头部的条件为：1. 被访问 2. 在old区域停留超过1秒</p><p>此外，MySQL还对young区域做了一个优化：为了防止young区域节点频繁地移动到头部，只有后3&#x2F;4的节点被访问才会被移动到young区域头部。</p><h2 id="脏页何时刷盘"><a href="#脏页何时刷盘" class="headerlink" title="脏页何时刷盘"></a>脏页何时刷盘</h2><p>引入了Buffer Pool后，当修改数据时，首先修改的时Buffer Pool中的数据所在页，然后将其设置为脏页，但是磁盘中还是原数据。因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致性。</p><p>但是，如果每次修改数据都将被修改的数据页刷入磁盘，则性能会很差，因此一般后会在一定的时机进行批量刷盘。</p><p>但是这些脏数据没即使刷盘，如果MySQL宕机就会丢失数据。于是InnoDB通过WAL策略，即先写日志（持久化），再将数据写入磁盘，通过redo log让MySQL拥有崩溃恢复能力。</p><p>触发脏页刷新的情况：</p><ul><li>redo log日志写满了，会主动触发脏页刷新到磁盘。</li><li>Buffer Pool空间不足，会根据LRU链表淘汰数据页，若淘汰的是脏页，需要先将脏页刷新到磁盘</li><li>MySQL认为空闲时，后台线程会定期将适量的脏页刷入磁盘</li><li>MySQL正常关闭之前，会把所有脏页刷入磁盘</li></ul><p>在我们开启了慢SQL监控后，会发现偶尔由一些用时稍长的SQL，这可能是因为在刷脏页给数据库带来的性能开销，导致数据库操作抖动。若间断地出现这种现象，就需要调大Buffer Pool空间或redo log日志的大小。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-日志</title>
    <link href="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/"/>
    <url>/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>InnoDB引擎层日志：</p><ul><li><p>undo log（回滚日志）</p><blockquote><p>实现了事务中的原子性，主要用于事务回滚和MVCC</p></blockquote></li><li><p>redo log（重做日志）</p><blockquote><p>实现了事务中的持久性，主要用于掉电等故障恢复</p></blockquote></li></ul><p>Server层日志：</p><ul><li><p>binlog（归档日志）</p><blockquote><p>主要用于数据备份和主从复制</p></blockquote></li></ul><h1 id="undo-log（事务回滚，原子性）"><a href="#undo-log（事务回滚，原子性）" class="headerlink" title="undo log（事务回滚，原子性）"></a>undo log（事务回滚，原子性）</h1><h2 id="undo-log的作用"><a href="#undo-log的作用" class="headerlink" title="undo log的作用"></a>undo log的作用</h2><h3 id="作用一、回滚"><a href="#作用一、回滚" class="headerlink" title="作用一、回滚"></a>作用一、回滚</h3><p>因为MySQL默认开启自动提交事务，由<code>autocommit</code>参数决定的。我们在执行一条“增删改”语句的时候，MySQL会隐式地为每一条“增删改”语句开启事务。相当于所有的“增删改”操作都是在事务中完成的。</p><p>undo log（回滚日志），它保证了事务ACID特性的原子性（Atomicity）。</p><blockquote><p>undo log是一种用于撤销回退的日志。在事务没提交之前，MySQL会先记录更新前的数据到undo log日志文件里面，当事务回滚时，可以利用undo log来回滚。</p></blockquote><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png" alt="回滚事务"></p><p>每当InnoDB引擎对一条记录进行操作（新增、删除、修改）时，undo log都会记录回滚所需信息：</p><ul><li>插入记录。undo log将这条记录的主键值记录下来，在回滚时只需要删除主键值对应记录即可。</li><li>删除记录。undo log记录这条记录的完整内容，在回滚时插入该完整记录即可。</li><li>更新记录。undo log把被更新列的旧值记录下来，回滚时将这些列更新为旧值即可。</li></ul><p>不同操作需要记录的信息不同，对应的undo log格式也不同。</p><p>一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer指针和一个trx_id：</p><ul><li><p>通过trx_id可以直到该记录是被哪个事务修改的</p></li><li><p>通过roll_pointer指针可以将undo log串成一个链表，这个链表称为版本链</p><blockquote><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%89%88%E6%9C%AC%E9%93%BE.png" alt="版本链"></p></blockquote></li></ul><h3 id="作用二、实现MVCC"><a href="#作用二、实现MVCC" class="headerlink" title="作用二、实现MVCC"></a>作用二、实现MVCC</h3><p>undo log和Read View一起可以实现MVCC，实现快照读。</p><p>读提交和可重复读这两个隔离级别就是通过Read View + undo log实现的。</p><ul><li>读提交：每个select都生成新的Read View。</li><li>可重复读：在事务启动后执行第一个select生成Read View，之后的事务中就一直使用这个Read View。</li></ul><p>在select的时候，根据Read View中的字段和记录的两个隐藏列（trx_id和roll_pointer），判断当前记录的对于当前事务的可见性，若可见，直接读取记录，若不可见，则根据版本链找到可见的版本读取记录。这样可以控制并发事务访问同一记录时的行为，这就叫做MVCC（多版本并发控制）。</p><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png" alt="Buffer Poo"></p><h3 id="Buffer-Pool的作用"><a href="#Buffer-Pool的作用" class="headerlink" title="Buffer Pool的作用"></a>Buffer Pool的作用</h3><blockquote><p>我们更新数据需要先从磁盘读取数据，然后再在内存中修改这条记录。在修改完这条记录后会缓存在Buffer Pool中，下一次有查询语句命中该记录，就可以直接从缓存中读取，而不需要从磁盘获取，减少磁盘I&#x2F;O。</p></blockquote><ul><li>当读取数据时，若数据在Buffer Pool中，客户端直接读取Buffer Pool中的缓存数据，否则才去磁盘读取。</li><li>当修改数据时，若数据在Buffer Pool中，则直接修改Buffer Pool中的数据所在页，然后将其设置为脏页，否则需要从磁盘读取到Buffer Pool中再做修改。为了减少磁盘I&#x2F;O，脏页不会被立即写回磁盘，后续由后台线程选择何时时机将脏页写入磁盘。</li></ul><h3 id="Buffer-Pool的缓存内容"><a href="#Buffer-Pool的缓存内容" class="headerlink" title="Buffer Pool的缓存内容"></a>Buffer Pool的缓存内容</h3><h4 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h4><blockquote><p>InnoDB将存储的数据划分为若干页，<strong>以页作为磁盘与内存交互的基本单位</strong>，一个页默认16KB。</p></blockquote><p>因此Buffer Pool中同样以页来划分数据。在MySQL启动时，InnoDB会为Buffer Pool申请一片连续的内存空间，然后按照默认的16KB大小划分为一个个的页，Buffer Pool中的页就叫做缓存页。</p><p>MySQL刚启动时缓存页都是空闲的，随着程序的运行，才会由磁盘上的页被缓存到Buffer Pool中。所以在刚启动时，使用的虚拟内存空间很大，而使用的物理内存空间很小，这是因为这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟内存和物理地址建立映射关系。</p><p>因为Buffer Pool和磁盘的内存交互是以页为单位的，所以即使是只查询一条记录，InnoDB也是需要将包含该记录的整页加载到Buffer Pool中的。然后根据页中的页目录去定位具体记录。</p><h4 id="缓存内容"><a href="#缓存内容" class="headerlink" title="缓存内容"></a>缓存内容</h4><blockquote><p>除了缓存数据页和索引页，还包括Undo页、插入缓存、自适应哈希索引和锁信息。</p></blockquote><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/bufferpool%E5%86%85%E5%AE%B9.drawio.png" alt="img"></p><p>Undo页是用于暂存undo log的。undo log记录过后不会直接写入磁盘持久化，而是和修改的数据一样，通过写入到Buffe Pool的undo页中，由后台线程将这些脏页刷盘持久化。</p><h1 id="redo-log（掉电恢复，持久性）"><a href="#redo-log（掉电恢复，持久性）" class="headerlink" title="redo log（掉电恢复，持久性）"></a>redo log（掉电恢复，持久性）</h1><h2 id="WAL技术"><a href="#WAL技术" class="headerlink" title="WAL技术"></a>WAL技术</h2><p>Buffer Pool提高了读写效率，但是Buffer Pool是基于内存的，而内存中的数据会掉电丢失。为了防止断电丢失数据的问题，当有一条记录需要更新的时候，InnoDB引擎就会先更新内存（同时标记为脏页），然后将本次对该页的修改以redo log的形式记录下来，这样时更新操作就算完成。后续InnoDB引擎会在何时的时候由后台线程将脏页写回磁盘。这就是WAL（Write-Ahead logging）。</p><p>简单来说，WAL技术指得就是，MySQL得写操作不是立刻写到磁盘上，而是先写到日志，然后再在合适得时间写入磁盘。</p><p>流程如图：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/wal.png" alt="img"></p><h2 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log"></a>什么是redo log</h2><p>redo log是物理日志，记录了某个数据页做了什么修改，比如对XXX表空间的YYY数据页ZZZ便宜量的地方做了AAA更新。每执行一个事务就会产生这样的一条或多条物理日志。</p><p>在事务提交时，只要将redo log持久化到磁盘中事务就提交成功了。可以不需要等到将脏页全部持久化到磁盘中。当系统崩溃时，对于已提交的事务，虽然脏页可能没有持久化，但是redo log已经持久化，MySQL重启后可以根据redo log中的内容，可以将已提交的事务数据恢复。</p><h2 id="redo-log和undo-log"><a href="#redo-log和undo-log" class="headerlink" title="redo log和undo log"></a>redo log和undo log</h2><p>二者联系（都属于InnoDB存储引擎层日志）：</p><p>在开启事务后，InnoDB更新记录时首先会记录相应的undo log，undo log会写入Buffer Pool中的Undo页中。undo log写入Undo页，Undo页变成脏页，需要记录对应的redo log。</p><p>二者区别：</p><ul><li><p>redo log记录了此次事务完成后的数据状态，记录的时更新后的值</p><blockquote><p>事务提交之后发生崩溃，重启后根据redo log恢复已经提交的事务</p></blockquote></li><li><p>undo log记录了此次事务开始前的数据状态，记录的是更新之前的值</p><blockquote><p>事务提交之前发生崩溃，重启后根据undo log回滚到事务开始前的数据</p></blockquote></li></ul><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png" alt="事务恢复"></p><p>crash-safe能力：</p><p>redo log配合WAL技术，InnoDB可以保证数据库即使发生异常重启，之前已提交的记录都不会丢失，这个能力称为crash-safe（崩溃恢复）。所以redo log保证了事务的持久性。</p><h2 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h2><p>redo log需要写入磁盘，数据也需要写入磁盘，似乎有点多此一举？实际并不是。</p><p>写入redo log是通过追加写操作，对应的磁盘操作是顺序写。而写入数据需要先找到数据写入位置，然后再写入磁盘，对应的磁盘操作时随机写。</p><p>顺序写比随机写更高效。原因的话在于，数据库一般是以机械硬盘来存储数据，随机写每次写入都需要重新寻道，而寻道时所花费的时间就是磁盘写入操作中最耗时的一部分。</p><p>可以说WAL技术将MySQL的写操作从磁盘的随机写变成了顺序写，提高了语句的执行性能。当redo log写入完成后，数据就可以算是写入完成了（因为redo log已经包含了可以恢复数据的信息，redo log已经持久化，即使数据没有完成持久化就断电丢失，也可根据redo log恢复完成数据）。这样MySQL就可以将耗时的数据持久化工作选择合适的时候（服务器比较空闲的时候）持久化到磁盘。</p><p>所以为什么需要redo log：</p><ol><li>将写操作从随机变成顺序写，提升MySQL写入磁盘的性能。</li><li>实现事务的持久化，让MySQL具有crash-safe能力。保证MySQL在任何时候崩溃，在重启后已提交的数据也不会丢失。</li></ol><h2 id="redo-log的持久化"><a href="#redo-log的持久化" class="headerlink" title="redo log的持久化"></a>redo log的持久化</h2><h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p>在执行事务的过程中，产生redo log不是直接写入磁盘的，因为这样会产生大量的I&#x2F;O操作，而且磁盘的读写速度远远慢于内存。</p><p>redo log同样也有自己的缓存：redo log buffer。</p><p>每当产生一条redo log时，会先写入到redo log buffer中，后续再持久化到磁盘中，如图：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/redologbuf.webp" alt="事务恢复"></p><p>redo log buffer默认大小16MB，可以通过参数<code>innodb_log_Buffer_size</code>调整。增大redo log buffer可以让MySQL再处理大事务的时候不必写入磁盘，进而提升写I&#x2F;O的性能。</p><h3 id="redo-log刷盘时机"><a href="#redo-log刷盘时机" class="headerlink" title="redo log刷盘时机"></a>redo log刷盘时机</h3><ul><li>MySQL正常关闭时</li><li>当redo log buffer中记录的写入量大于一半的时候</li><li>InnoDB的后台线程每隔1秒刷一次盘</li><li>事务提交时</li></ul><h3 id="innodb-flush-log-at-trx-commit参数"><a href="#innodb-flush-log-at-trx-commit参数" class="headerlink" title="innodb_flush_log_at_trx_commit参数"></a>innodb_flush_log_at_trx_commit参数</h3><p>默认的事务提交行为：</p><p>单独执行一个更新语句的时候，InnoDB引擎会自己启动一个事务，在执行更新语句的过程中，生成的redo log先写入redo log buffer中，当事务提交时，再将redo log buffer中缓存的redo log按组的方式顺序写到磁盘。</p><p>参数<code>innodb_flush_log_at_trx_commit</code>可以控制事务提交时的刷盘策略：</p><ul><li>设置为0，表示每次事务提交时不会触发redo log buffer刷盘。</li><li>设置为1，为默认行为。</li><li>设置为2，表示在事务提交时，将redo log buffer中的文件写入操作系统的文件缓存。</li></ul><p>上面三种参数的行为如下：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/innodb_flush_log_at_trx_commit.drawio.png" alt="img"></p><p>参数为0和2时的redo log如何持久化：</p><ul><li><p>参数0：会把缓存在redo log buffer 中的redo log，通过调用write()写到操作系统的Page Cache，然后调用fsync()持久化到磁盘。</p><blockquote><p>MySQL进程崩溃会导致上一秒的所有事务数据丢失（后台线程1秒刷一次盘）</p></blockquote></li><li><p>参数2：调用fsync，将缓存在操作体统Page Cache中的redo log持久化到磁盘。</p><blockquote><p>MySQL进程崩溃不会丢失数据，只有操作系统崩溃才会丢失上一秒的所有事务数据。</p></blockquote></li></ul><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/innodb_flush_log_at_trx_commit2.drawio.png" alt="img"></p><p>这三个不同参数的应用场景：</p><p>三个参数的数据安全性和写入性能成反比，二者不可兼得。</p><ul><li>对数据安全性要求比较高的场景：设置参数为1，在每次提交事务后持久化redo log，保证提交后的记录在任何情况下都不会丢失。</li><li>一些可以容忍数据库崩溃时丢失1s数据的场景：设置参数为0，这样可以减少日志写入的磁盘I&#x2F;O操作。</li><li>安全性和性能折中方案：设置参数为2，只要操作系统不宕机，即使数据库崩溃，也不会丢失数据，同时性能也比参数1高。</li></ul><h2 id="redo-log循环写"><a href="#redo-log循环写" class="headerlink" title="redo log循环写"></a>redo log循环写</h2><p>默认情况下，InnoDB引擎有一个重做文件组（redo log Group），它由两个redo log文件组成，这两个redo日志的文件名为<code>ib_logfile0</code>和<code>ib_logfile1</code>。每个文件的大小固定且一致，假设一个文件1G，那么总共就可以记录2GB的redo日志。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84.drawio.png" alt="重做日志文件组"></p><p>重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾又回到开头，相当于一个环形。所以InnoDB引擎会先写ib_logfile0文件，当ib_logfile0被写满后切换到ib_logfile1文件，然后两个文件循环切换。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png" alt="重做日志文件组写入过程"></p><p>redo log是为了防止Buffer Pool中的脏页丢失而设计的。所以说随着系统的运行，Buffer Pool的脏页持久化到磁盘中后，对应的redo log就没有了，这个时候我们擦除这些没用的redo log，以腾出空间记录新的redo log。</p><p>redo log是以循环写的方式记录的。可以通过两个点（write pos和check point）将这个环分为两部分区域：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/checkpoint.png" alt="img"></p><ul><li>write pos和check point的移动都是顺时针方向的</li><li>write pos~check point之间的部分（红色部分）：空闲区域，用来记录新的更新操作</li><li>check point~write pos之间的部分（蓝色部分）：待落盘的脏数据页记录</li></ul><p>如果数据更新太快，redo log落盘太满，那么会出现write pos追上check point的情况：</p><p>这就意味着redo log文件写满了。此时MySQL不能再执行新的更新操作，也就是说MySQL会被阻塞停下来将Buffer Pool中的脏页刷新到磁盘中，擦除旧的redo log记录，移动check point指针，然后MySQL恢复正常。</p><p>所以说针对并发量大的系统，设置足够大小的redo log文件很重要。</p><h1 id="binlog（备份恢复，主从复制）"><a href="#binlog（备份恢复，主从复制）" class="headerlink" title="binlog（备份恢复，主从复制）"></a>binlog（备份恢复，主从复制）</h1><p>MySQL在完成一条更新操作后，Server层还会生成一条binlog，等事务提交之后，会将事务执行过程中产生的binlog同一写入到binlog文件。</p><p>binlog文件记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如SELECT和SHOW操作。</p><h2 id="binlog和redo-log"><a href="#binlog和redo-log" class="headerlink" title="binlog和redo log"></a>binlog和redo log</h2><h3 id="为什么有了binlog，还要有redo-log？"><a href="#为什么有了binlog，还要有redo-log？" class="headerlink" title="为什么有了binlog，还要有redo log？"></a>为什么有了binlog，还要有redo log？</h3><blockquote><p>存储引擎为了实现binlog没有的crash-safe能力而使用redo log。</p></blockquote><p>最开始MySQL没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe能力，binlog只能用于归档。</p><p>而InnoDB是另一家公司以插件形式引入MySQL，由于binlog没有crash-safe能力，所以InnoDB使用redo log来实现crash-sage能力。</p><h3 id="binlog和redo-log区别"><a href="#binlog和redo-log区别" class="headerlink" title="binlog和redo log区别"></a>binlog和redo log区别</h3><ol><li><p>适用对象不同</p><ul><li>binlog是MySQL的Server层实现的日志，所有存储引擎共用</li><li>redo log是Innodb存储引擎实现的日志</li></ul></li><li><p>文件格式不同</p><ul><li><p>binlog有三种格式类型</p><ul><li><p>STATEMENT</p><blockquote><p>每一条修改数据的SQL都会被记录到binlog中（相当于记录了逻辑操作，所以这种格式的binlog可以称为逻辑日志），主从复制中slave端根据SQL重现数据。</p><p>但STATEMENT有动态函数问题，比如适用了uuid或now这些函数，在主库上执行的结果于在从库执行的结果不同，这种随时变化的函数会导致主从数据不一致。</p></blockquote></li><li><p>ROW</p><blockquote><p>记录行数据最终被修改成的样子（这种格式的日志，不能称为逻辑日志）。</p><p>它解决了STATEMENT格式下动态函数的问题。但是ROW格式的缺点在于记录的binlog文件过大，比如一个批量更新的update语句，ROW格式会记录每一条变化的行记录，而STATEMENT格式只需要记录这一条update语句即可。</p></blockquote></li><li><p>MIXED</p><blockquote><p>根据情况使用ROW模式和STATEMENT模式</p></blockquote></li></ul></li><li><p>redo log时物理日志，记录的是在某个数据页做了什么修改。比如XXX表空间种的YYY数据页ZZZ偏移量的地方做了AAA更新</p></li></ul></li><li><p>写入方式不同</p><ul><li>binlog是追加写。写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log是循环写。日志空间大小固定，全部写满就从头开始，保存的是未被刷入磁盘的脏页日志。</li></ul></li><li><p>用途不同</p><ul><li>binlog用于备份恢复、主从复制</li><li>redo log用于掉电等故障恢复</li></ul></li></ol><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="主从复制实现"><a href="#主从复制实现" class="headerlink" title="主从复制实现"></a>主从复制实现</h3><blockquote><p>MySQL的主从复制依赖于binlog，也就是记录MySQL上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将binlog中的数据从主库传输到从库上。</p></blockquote><p>主从复制的过程一般是异步的。也就是主库上执行事务操作的线程不会等待复制binlog的线程同步完成。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png" alt="MySQL 主从复制过程"></p><p>MySQL集群的主从复制过程可以分为三个阶段：</p><ol><li><p>写入binlog：主库写binlog日志，提交事务，并更新本地数据</p><blockquote><p>MySQL主库收到客户端提交的事务请求后，会先写入binlog，在提交事务，更新存储引擎中的数据，事务提交后，返回给客户端“操作成功”的响应</p></blockquote></li><li><p>同步binlog：从库复制主库binlog，并写入从库暂存日志中</p><blockquote><p>从库会创建一个专门的I&#x2F;O线程，连接主库的log dump线程，用于接收主库的binlog日志，再将binlog信息写入relay log的中继日志里，再返回给主库“复制成功”的响应。</p></blockquote></li><li><p>回放binlog：回放binlog，并更新从库存储引擎中的数据</p><blockquote><p>从库会创建一个用于回放binlog的线程，去读取relay log中级日志，然后回放binlog更新存储引擎中的数据，最终实现主从的数据一致性。</p></blockquote></li></ol><h3 id="从库的作用"><a href="#从库的作用" class="headerlink" title="从库的作用"></a>从库的作用</h3><p>完成主从复制之后，可以将客户端的请求分发，写数据在主库，读数据在从库，这样读请求和写请求之间不会相互阻塞。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png" alt="MySQL 主从架构"></p><p>从库可以分担读请求负载，但是从库的数量不是越多越好。</p><p>因为每对应一个从库，主库都要创建一个log dump线程来处理来自从库的复制请求。对主库的资源消耗高，同时还受主库的网络带宽限制。</p><p>实际使用中，一个主库一般2~3个从库（1主2从1备）。</p><h3 id="MySQL其他主从复制模型"><a href="#MySQL其他主从复制模型" class="headerlink" title="MySQL其他主从复制模型"></a>MySQL其他主从复制模型</h3><ul><li><p>同步复制：MySQL主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。</p><blockquote><p>这种方式在实际的项目中，基本没法使用，因为：</p><ul><li>性能差。因为要复制到所有节点才返回响应</li><li>可用性差。主库和所有从库任一数据库出问题，都会影响业务</li></ul></blockquote></li><li><p>异步复制：MySQL主库提交的事务的线程不会等待binlog同步到各从库，就返回客户端结果。</p><blockquote><p>这种模式一旦主库宕机，数据就会发生丢失。</p></blockquote></li><li><p>半同步复制：事务线程不用等待所有的从库复制成功响应，只要其中一个从库复制成功响应，主库的事务线程就可以返回给客户端。</p><blockquote><p>这种半同步复制的方式，兼顾了异步复制和同步复制的优点。即使出现主库宕机，至少有一个从库有最新数据，不存在数据丢失的风险。</p></blockquote></li></ul><h2 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h2><blockquote><p>事务执行过程中，先把日志写到binlog cache（Server层的cache），事务提交的时候，在把binlog cache写到binlog文件中。</p></blockquote><p>MySQL给每个线程分配了一片内存用于缓冲binlog，该内存叫binlog cache。<code>binlog_cache_size</code>参数可以控制binlog cache的大小。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/binlogcache.drawio.png" alt="binlog cach"></p><p>一个事务的binlog是不能被拆开的,因此无论这个事务有多大，也要保证一次性写入。这是因为一个线程只能同时有一个事务在执行，所以每当执行一个begin&#x2F;start transaction的时候，就会默认提交上一个事务，如果一个事务的binlog被拆开，在备库执行就会被当作多个事务分段执行，这就破坏了事务的原子性，这是有问题的。</p><p>在事务提交时，执行器把binlog cache里的完整事务写入到binlog文件中（有多个binlog cache，但最终写到同一binlog文件），并清空binlog cache。</p><ul><li>write：指的是将日志写入到binlog文件，但是这个写入只是写入到操作系统的page cache中，这里不涉及磁盘I&#x2F;O。</li><li>fsync：才是将数据持久化到磁盘的额操作，这里会涉及磁盘I&#x2F;O。</li></ul><p>MySQL提供一个<code>sync_binlog </code>参数来控制数据库的fsync操作频率（每次提交事务都会write，但是什么时候fsync由该参数控制）：</p><ul><li><p>sync_binlog &#x3D; 0，表示由操作系统决定何时执行fsync将数据持久化到磁盘</p><blockquote><p>MySQL系统默认设置为0，也就是不做任何强制性磁盘刷新指令。此时性能最好，但风险最大，因为一旦操作系统宕机，还未持久化到磁盘中的数据就会丢失。</p></blockquote></li><li><p>sync_binlog &#x3D; 1，表示每次提交事务都会马上执行fsync。</p><blockquote><p>此时最安全，但是性能损耗最大。即使操作系统宕机最多也就丢失一个事务的binlog。</p></blockquote></li><li><p>sync_binlog &#x3D; N (N &gt; 1)，表示累计N个事务后才fsync。</p><blockquote><p>如果能容忍少量的binlog日志丢失风险，为了提高写入性能，一般会设置sync_binlog为100~1000。</p></blockquote></li></ul><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><h2 id="一条update语句执行的过程"><a href="#一条update语句执行的过程" class="headerlink" title="一条update语句执行的过程"></a>一条update语句执行的过程</h2><p>当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。</p><p><code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code>执行流程如下：</p><ol><li>执行器负责具体执行，会调用存储引擎接口获取id &#x3D; 1的记录：<ul><li>若id &#x3D; 1这行所在的数据页本来就在buffer pool中，就直接在数据页中搜索该记录并返回给执行器</li><li>若记录不在buffer，存储引擎会根据主键索引数从磁盘将包含该记录的页读到buffer pool中，然后在该数据页搜索该记录返回给执行器</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前后的记录是否一样：<ul><li>若一样的话就不进行后续的更新流程</li><li>若不一样，就将更新前的记录和更新后的记录都当作参数传给InnoDB层，让InnoDB真正执行更新记录的操作</li></ul></li><li>开启事务，InnoDB层更新记录前，首先要记录相应的undo log。undo log会写入到Buffer Pool中的Undo页面，不过在内存修改该Undo页面后，需要记录对应的redo log。</li><li>InnoDB层开始更新记录，会先更新内存，并标记为脏页，然后将记录写到redo log中，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择合适时机将脏页写入磁盘。这就是WAL技术，MySQL的写操作不会立刻写入磁盘，而是先将redo日志持久化到磁盘，然后再选择合适时机持久化被修改的记录。</li><li>至此，一条记录的更新完成。</li><li>再一条更新语句执行完成后，然后开始记录该语句对应的binlog。此时记录的binlog会被保存到binlog cache，并没有刷新到磁盘的binlog文件，在事务提交时才会同一将该事务运行过程中的完整binlog刷新到磁盘。</li><li>事务提交。事务提交是两阶段提交，接下来就是讲关于两阶段提交。</li></ol><h2 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="headerlink" title="为什么需要两阶段提交"></a>为什么需要两阶段提交</h2><blockquote><p>事务提交后，redo log和binlog都要持久化到磁盘，但是这是两个独立的逻辑，可能出现半成功的状态，这样就造成了两份日志之间的逻辑不一致。</p></blockquote><h3 id="如果没有两阶段提交会出现的问题"><a href="#如果没有两阶段提交会出现的问题" class="headerlink" title="如果没有两阶段提交会出现的问题"></a>如果没有两阶段提交会出现的问题</h3><p>举个例子，假设id &#x3D; 1的这行记录的name字段值为‘jay’，然后执行<code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1</code>。</p><p>如果在持久化redo log和binlog两个日志的过程中，出现半成功状态，就有两种情况：</p><ul><li><p>如果redo log刷入磁盘后，MySQL宕机，binlog还没刷入</p><blockquote><p>MySQL重启后，通过redo log能将Buffer Pool中已经更新完成的id &#x3D; 1的这行数据恢复到新值’xiaolin’，但是binlog中没有记录这条更新语句。在主从架构中，从库根据binlog复制主库数据，由于binlog丢失了这条更新语句，从库中的这行记录name字段是旧址’jay’，与主库的值不一致。</p></blockquote></li><li><p>如果binlog刷入磁盘后，MySQL宕机，redo log还没刷入</p><blockquote><p>由于redo log还没写，崩溃恢复后这个事务无效，所以主库中的id &#x3D; 1这行数据的name字段还是旧值’jay’，而binlog里面记录了这条更新语句，从库根据binlog复制数据，这一行的name字段是新值’xiaolin’，与主库的值不一致。</p></blockquote></li></ul><p>可见，在持久化redo log和binlog时，若出现半成功的情况，就会造成主从环境的数据不一致。这是因为redo log影响主库数据，binlog影响从库数据，所以redo log和binlog必须保持一致，才能保证给主从数据一致。</p><h2 id="两阶段提交的过程"><a href="#两阶段提交的过程" class="headerlink" title="两阶段提交的过程"></a>两阶段提交的过程</h2><blockquote><p>两阶段提交其实是<strong>分布式事务一致性协议</strong>，它可以保证多个逻辑操作要么全部成功，要么全部失败，不会出现半成功的状态。有点原子性的意思。</p></blockquote><p>两阶段提交把单个事务的提交拆分成两个阶段，分别是准备（Prepare）阶段和提交（Commit）阶段。每个阶段由协调者（Coordinator）和参与者（Participant）共同完成。</p><p>注意：不要把提交阶段和提交语句混淆。commit语句执行的时候，会包含准备阶段和提交阶段。</p><h3 id="拳击手的例子说明两阶段提交"><a href="#拳击手的例子说明两阶段提交" class="headerlink" title="拳击手的例子说明两阶段提交"></a>拳击手的例子说明两阶段提交</h3><p>举个拳击比赛的例子。两个拳击手（参与者）开始比赛前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？</p><ul><li><p>准备阶段</p><blockquote><p>裁判会依次询问两位拳击手是否准备好了，如果任一选手没有准备好，裁判会宣布比赛暂停（对应事务中的回滚）</p></blockquote></li><li><p>提交阶段</p><blockquote><p>当两位拳击手都准备好了，裁判比赛开始（对应事务提交成功）</p></blockquote></li></ul><h3 id="MySQL中两阶段提交的过程"><a href="#MySQL中两阶段提交的过程" class="headerlink" title="MySQL中两阶段提交的过程"></a>MySQL中两阶段提交的过程</h3><blockquote><p>在MySQL的InnoDB存储引擎中，开启binlog的情况下，MySQL需要同时维护binlog和redo log。为了保证这两个日志的一致性，MySQL使用<strong>内部XA事务</strong>，内粗XA事务由binlog作为协调者，存储引擎是参与者。</p></blockquote><p>  在客户端执行commit语句或在自动提交的情况下，MySQL内部会开启一个XA事务，分两阶段来完成XA事务的提交，如图所示：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png" alt="两阶段提交"></p><p>事务的提交过程有两个阶段，主要就是将redo log的写入拆成了两个步骤：prepare和commit，中间再穿插写入binlog：</p><ul><li><p>prepare阶段</p><blockquote><p>将XID（内部XA事务的ID）写入redo log，同时将redo log对应的事务状态设置为prepare，然后将redo log持久化到磁盘(<code>innodb_flush_log_at_trx_commit = 1</code>的作用)。</p></blockquote></li><li><p>commit阶段</p><blockquote><p>将XID写入到binlog，然后将binlog持久化到磁盘(<code>sync_binlog = 1</code>的作用)，接着调用引擎的提交任务接口，将redo log状态设置为commit。commit状态不需要立即持久化到磁盘，只需要write到文件系统的page cache中即可，因为只要binlog写磁盘成功（此时两个日志已经一致了），事务就算已经执行成功。</p></blockquote></li></ul><h2 id="异常重启会发生什么"><a href="#异常重启会发生什么" class="headerlink" title="异常重启会发生什么"></a>异常重启会发生什么</h2><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png" alt="时刻 A 与时刻 B"></p><p>MySQL重启后会顺序扫描redo log文件，碰到处于prepare状态的redo log，就拿着redo log中的XID去binlog中查看是否存在此XID：</p><ul><li><p>若binlog中不存在该XID</p><blockquote><p>说明redo log完成输盘，但是binlog还没有刷盘，则回滚事务。对应时刻A崩溃恢复的情况。</p></blockquote></li><li><p>若binlog中存在该XID</p><blockquote><p>说明redo log和binlog都已经完成了刷盘，则提交事务。对应时刻B崩溃恢复的情况。</p></blockquote></li></ul><p>可见，对于处于prepare阶段的redo log，既可以提交事务，也可以回滚事务。这取决于在binlog中是否存在于redo log的XID相同的binlog记录。所以说，两阶段提交是以binlog写成功作为事务提交成功的标识。因为binlog写成功，就意味着能在binlog中找到处于prepare状态的redo log相同的XID记录。</p><p>处于prepare阶段的redo log加上完成的binlog，重启就提交事务，MySQL为什么这样设计？</p><blockquote><p>binlog已经写入，就会被从库使用。所以说在主库上也要提交这个事务，这样就能保证主库和从库的数据一致。</p></blockquote><p>事务没提交的时候，redo log会被持久化到磁盘吗？</p><blockquote><p>会。事务执行过程中，每执行完一条语句，redo log就会写入redo log buffer中，有一个后台线程每隔一秒就会将redo log buffer中的缓存持久化到磁盘。</p><p>这些被持久化的redo log处于prepare状态，在其对应的binlog没有持久化前，就算MySQL崩溃，这些redo log因为没有对应的binlog所以不会生效，会执行回滚操作。</p></blockquote><h2 id="两阶段提交有什么问题"><a href="#两阶段提交有什么问题" class="headerlink" title="两阶段提交有什么问题"></a>两阶段提交有什么问题</h2><h3 id="问题一、磁盘I-x2F-O次数高"><a href="#问题一、磁盘I-x2F-O次数高" class="headerlink" title="问题一、磁盘I&#x2F;O次数高"></a>问题一、磁盘I&#x2F;O次数高</h3><blockquote><p>对于“双1”配置，每个事务提交都会进行两次fsync（刷盘），一次redo log刷盘，一次binlog刷盘。</p></blockquote><p>binlog和redo log在内存中都对应有缓存空间。binlog缓存在binlog cache，redo log缓存在redo log buffer，它们持久化到磁盘的时机由两个参数控制。一般为了避免日志的丢失，会将这两个参数设置为1：</p><ul><li>sync_binlog &#x3D; 1</li><li>innodb_flush_log_at_trx_commit &#x3D; 1</li></ul><p>二者都标识在事务提交的时候将缓存中的日志持久化到磁盘，这样每次提交事务都至少调用两次刷盘操作，这会称为性能瓶颈。</p><h3 id="问题二、锁竞争激烈"><a href="#问题二、锁竞争激烈" class="headerlink" title="问题二、锁竞争激烈"></a>问题二、锁竞争激烈</h3><blockquote><p>两阶段提交虽然可以保证单事务中两个日志的内容一致，但在多事务的情况下，却不能保证两个日志的提交顺序椅子。因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</p></blockquote><p>在早期的MySQL中，通过使用prepare_commit_mutex锁来保证事务提交的顺序。一个事务获取到锁时才能进入prepare阶段，直到commit阶段结束释放锁。</p><p>虽然加锁完美解决了顺序一致性的问题，但在并发量较大的时候，就会出现激烈的锁竞争，性能不佳。</p><h3 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h3><blockquote><p>组提交通过合并刷盘操作，细化锁颗粒度，提升两阶段提交的并发效率。</p></blockquote><p>MySQL引入了binlog组提交（group commit）机制，每当有多个事务提交的时候，会将多个binlog刷盘操作合并为一个，从而减少磁盘I&#x2F;O的次数。例如十个事务排队依次刷盘的时间成本是10，那么将这十个事务一次性一起刷盘，则时间成本则近似1 。</p><p>组提交机制将commit阶段拆分为三个过程：</p><ul><li>flush阶段：多个事务按进入的顺序将binlog从cache写入文件（page cache）</li><li>sync阶段：对binlog文件做fsync操作（多个事务的binlog合并一次刷盘）</li><li>commit阶段：各事务按顺序做InnoDB commit操作</li></ul><p>每一个阶段都有一个队列，分别有一个锁保护，因此保证了事务写入的顺序。第一个进入队列的事务会成为leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/commit_4.png" alt="每个阶段都有一个队列"></p><p>对这三个阶段引入队列，锁只针对每个队列保护，不再锁住整个提交事务过程。这样，锁的颗粒度减小了，多个阶段可以并发地执行，从而提升效率。</p><p>在MySQL 5.7引入了redo log的组提交机制。</p><blockquote><p>将prepare阶段融合在flush阶段，将redo log的刷盘延迟到了flush阶段中，sync阶段之前。通过延迟写redo log的方式，为redo log做了一次组写入。</p></blockquote><h4 id="flush阶段"><a href="#flush阶段" class="headerlink" title="flush阶段"></a>flush阶段</h4><blockquote><p>用于支撑redo log的组提交</p></blockquote><p>第一个事务会成为flush阶段的Leader，此后到来的事务都是Follower：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A41.png" alt="img"></p><p>接着，获取队列中的事务组（这里是绿色这组），由Leader事务对redo log做一次刷盘（write + fsync）：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A42.png" alt="img"></p><p>做完prepare阶段后，将这组事务执行过程中产生的binlog写入binlog文件（write）</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/write_binlog.png" alt="img"></p><p>该阶段结束后，该组事务的redo log完成刷盘，binlog还在操作系统的缓存中，并未持久化。若在该阶段完成后崩溃，MySQL会回滚该组事务。</p><h4 id="sync阶段"><a href="#sync阶段" class="headerlink" title="sync阶段"></a>sync阶段</h4><blockquote><p>用于支撑binlog的组提交</p></blockquote><p>一组事务的binlog写入（write）binlog文件后，并不会马上执行刷盘操作，而是等待一段时间，组合更多事务的binlog，然后再刷盘：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A44.png" alt="img"></p><p>如果在等待时，还没到时间，但是事务数量已经达到设定值，则直接将binlog刷盘：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A45.png" alt="img"></p><p>两个控制参数：</p><ul><li>等待时间。<code>binlog_group_commit_sync_delay = N</code>，表示等待N微秒后，直接调用fsync持久化binlog文件。</li><li>队列中的事务最大数量。<code>binlog_group_commit_sync_no_delay_count = N</code>，表示如果队列中的事务数达到N各，就忽视等待时间，直接刷盘</li></ul><p>这一步完成后，binlog和redo log都已经持久化。若此时崩溃，MySQL重启后会通过redo log继续事务的提交。</p><h4 id="commit阶段"><a href="#commit阶段" class="headerlink" title="commit阶段"></a>commit阶段</h4><p>进入commit阶段，调用引擎的提交事务接口，将redo log状态设置未commit：</p><p><img src="/2022/11/05/MySQL-%E6%97%A5%E5%BF%97/%E7%BB%84%E6%8F%90%E4%BA%A46.png" alt="img"></p><p>commit阶段队列的作用时承接sync阶段的事务，完成最后的引擎提交，使得sync可以尽快处理下一组事务，最大化组提交效率。</p><h1 id="MySQL磁盘I-x2F-O优化"><a href="#MySQL磁盘I-x2F-O优化" class="headerlink" title="MySQL磁盘I&#x2F;O优化"></a>MySQL磁盘I&#x2F;O优化</h1><p>在事务提交时，需要将binlog和redo log持久化，可以通过一些参数“延迟”binlog和redo log刷盘时机：</p><ul><li><p>组提交参数</p><blockquote><p><code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>，这两个参数控制在flush阶段的binlog刷盘时机（fsync）。因为binlog已经写入了系统的缓存，所以即使MySQL进程崩溃，也不会丢失数据。</p></blockquote></li><li><p>binlog刷盘时机参数</p><blockquote><p><code>sync_binlog</code>设置为大于1（常见为100~1000），表示每次提交事务都write，但是累积N个事务后才fsync，相当于延迟binlog刷盘时机。</p><p>这样做的风险在于，主机掉电会丢失N个事务的binlog日志</p></blockquote></li><li><p>redo log刷盘时机参数</p><blockquote><p><code>innodb_flush_log_at_trx_commit</code>设置为2，表示每次事务提交，都只是将redo log buffer中的redo log写入到redo log文件。写入到redo log文件，并不意味着持久化，因为操作系统有个Page Cache，用于缓存文件数据，所以写入redo log文件只是写入擦欧总系统的文件缓存，由操作系统决定持久化到磁盘的时机。</p><p>这样做的风险在于主机掉电会丢失数据。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-锁</title>
    <link href="/2022/11/05/MySQL-%E9%94%81/"/>
    <url>/2022/11/05/MySQL-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL有哪些锁"><a href="#MySQL有哪些锁" class="headerlink" title="MySQL有哪些锁"></a>MySQL有哪些锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="全局锁的使用"><a href="#全局锁的使用" class="headerlink" title="全局锁的使用"></a>全局锁的使用</h3><blockquote><p>使用全局锁后，整个数据库就处于只读状态</p></blockquote><p>使用全局锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush tables with read lock<br></code></pre></td></tr></table></figure><p>释放全局锁（会话断开全局锁也会自动断开）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables<br></code></pre></td></tr></table></figure><p>全局锁会阻塞其他线程的如下操作：</p><ul><li>对数据的增删改操作，比如insert、delete、upadte等语句</li><li>对表结构的更改操作，比如alter table、drop table等语句</li></ul><h3 id="全局锁的应用场景"><a href="#全局锁的应用场景" class="headerlink" title="全局锁的应用场景"></a>全局锁的应用场景</h3><blockquote><p>全局锁的主要应用于全库逻辑备份。使用全局锁后，在备份数据库期间不会因为数据或表结构的更新导致备份文件和预期不一致。</p></blockquote><p>假设在全库逻辑备份期间，不加全局锁。观察会出现什么情况：</p><p>如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑时会涉及到多张数据库表的更新。比如在用户表中更新用户余额，在商品表中更新商品库存。</p><p>那么，在备份时，若有用户购买了商品，可能会出现如下顺序：</p><ol><li>先备份了用户表的数据（用户表还未修改余额，因为此时购买商品事件都还没发生）</li><li>有用户发起了购买商品的操作（用户表和商品表都更新了）</li><li>接着再备份商品表（此时的商品表库存已经更新）</li></ol><p>在这种情况下，备份的结果中，用户表的余额没有扣除，但是商品表中的库存减少了。备份的数据库出现表数据了不一致（被备份的数据库中表数据是一致的），这样用该备份恢复数据库的话，会导致用户的余额没减少，但是商品库存减少了（在实际的数据库中，购买商品还对应着订单表，用户余额没减少，但是订单依然存在），相当于用户白嫖了一件商品。</p><p>在全库逻辑备份期间，加上全局锁，没有数据的更新自然就不会出现数据不一致的情况。</p><h3 id="全局锁的缺点与避免"><a href="#全局锁的缺点与避免" class="headerlink" title="全局锁的缺点与避免"></a>全局锁的缺点与避免</h3><h4 id="全局锁的缺点"><a href="#全局锁的缺点" class="headerlink" title="全局锁的缺点"></a>全局锁的缺点</h4><p>加上全局锁，整个数据库都是只读状态。如果数据库很大，备份会花很长的事件，在此期间业务只能读数据，不能更新数据，造成业务停滞。</p><h4 id="使用可重复读的事务代替全局锁"><a href="#使用可重复读的事务代替全局锁" class="headerlink" title="使用可重复读的事务代替全局锁"></a>使用可重复读的事务代替全局锁</h4><p>如果数据库的引擎支持可重复读的隔离级别，那么在备份数据库之前先开启事务。因为开启事务后，会先创建Read View，然后再整个事务期间都会使用该Read View来读取数据做备份，而且由于MVCC的支持，在备份期间其他业务可以正常地对数据进行更新。</p><p>备份数据库地工具是mysqldump，在使用mysqldump时加上<code>-single-transaction</code>参数的时候，就会在备份数据库之间先开启事务。这种方法只适用于支持<strong>可重复读隔离级别的事务</strong>的存储引擎。</p><p>InnoDB存储引擎默认的事务隔离级别就是可重复读，所以可以采用这种方法来备份数据库，MyISAM不支持事务，所以适用MyISAM引擎就需要适用全局锁来备份数据库。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>加表锁的命令（对学生表：t_student加锁）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><br>//表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br></code></pre></td></tr></table></figure><p>释放表锁的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables<br></code></pre></td></tr></table></figure><p>表锁除了会限制其他线程的读写外，也会限制当前线程的读写操作。也就是说对表所加的表所是对所有线程生效的，包括当前线程。例如当前线程对学生表加了共享表锁，那么当前线程对学生表执行写操作是会被阻塞的。</p><p><strong>注意：尽量避免在InnoDB引擎中使用表锁。</strong>因为表锁的颗粒度太大，会影响并发性能，InnoDB的其中一个优势就在于它实现了颗粒度更小的行级锁。</p><h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><blockquote><p>我们不需要显式的使用MDL。</p></blockquote><h4 id="MDL锁的获取"><a href="#MDL锁的获取" class="headerlink" title="MDL锁的获取"></a>MDL锁的获取</h4><p>当我们对数据库表进行操作时，会自动给这个表加上MDL：</p><ul><li><p>对一张表进行CRUD操作时，加的时MDL读锁</p><blockquote><p>加MDL读锁，是为了防止在CRUD操作过程中其他线程对表结构做修改。</p></blockquote></li><li><p>对一张表进行表结构变更操作时，加的是MDL写锁</p><blockquote><p>加MDL写锁，是为了防止在修改表结构的时候其他线程执行CRUD操作。</p></blockquote></li></ul><h4 id="MDL锁的释放"><a href="#MDL锁的释放" class="headerlink" title="MDL锁的释放"></a>MDL锁的释放</h4><p>MDL是在事务提交后才会释放。这意味着在事务执行期间会一直持有MDL锁。</p><h4 id="一个由于MDL锁获取和释放机制带来的阻塞问题"><a href="#一个由于MDL锁获取和释放机制带来的阻塞问题" class="headerlink" title="一个由于MDL锁获取和释放机制带来的阻塞问题"></a>一个由于MDL锁获取和释放机制带来的阻塞问题</h4><p>如果数据库有一个长事务，那么在对表结构做变更操作的时候可能会导致大量的select语句阻塞导致数据库线程爆满。</p><p>比如下面这个顺序的场景：</p><ol><li>线程A先启动一个长事务（一直不提交），在事务中执行select语句，这样该事务就持有了该表的MDL读锁</li><li>然后，线程B对该表执行select语句，此时并不会阻塞，因为读锁是共享的</li><li>接着，线程C尝试修改表字段，因为线程A持有表的MDL读锁，所以线程C无法申请到MDL写锁，就会被一直阻塞</li><li>在线程C被阻塞后，后续所有对该表的select语句都会被阻塞。如果此时有对该表的大量select语句请求到来，就会有大量被阻塞的线程，导致数据库线程爆满</li></ol><p>为什么线程申请不到MDL写锁，会导致后续申请读锁的查询操作阻塞？</p><p>因为申请锁的操作会形成一个队列，按照队列顺序来申请锁。队列中写锁申请优先级高于读锁申请，所以说一旦出现MDL写锁申请阻塞，那么后续的读锁申请都会被阻塞，也就是无法进行对该表的CRUD操作。</p><p>避免该问题的办法：</p><p>在对表结构做变更之前，若有长事务对该表加上了MDL读锁，可以考虑kill掉该长事务后再做表结构的更改。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><blockquote><p>意向锁的目的是为了快速判断表里是否有记录被加锁。</p></blockquote><h4 id="意向锁的获取"><a href="#意向锁的获取" class="headerlink" title="意向锁的获取"></a>意向锁的获取</h4><p>在使用InnoDB引擎时，对表中的某些行记录加上共享锁&#x2F;独占锁之前，需要先给表加上一个意向共享&#x2F;独占锁。</p><p>也就是当执行插入、更新、删除操作时，因为这些操作会获取行锁，需要在获取行锁之前对表加上意向独占锁。普通的select是不会加行级锁的，自然不需要对表加意向锁。因为普通select语句是利用MVCC来实现一致性读，是无锁的。</p><h4 id="锁之间的互斥关系：意向锁、表锁、行锁"><a href="#锁之间的互斥关系：意向锁、表锁、行锁" class="headerlink" title="锁之间的互斥关系：意向锁、表锁、行锁"></a>锁之间的互斥关系：意向锁、表锁、行锁</h4><ul><li><p>意向锁是表级锁，不会于行锁发生冲突</p></li><li><p>意向锁之间也不会发生冲突</p></li><li><p>意向锁只会和表锁之间冲突</p></li><li><p>表锁和行锁之间是读读共享、读写互斥、谢谢互斥的</p></li></ul><h4 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h4><p>因为InnoDB是支持行锁的，如果没有意向锁，那么想要加表锁时，就需要遍历表中的记录，查看是否有行记录存在独占锁，这样效率很低。</p><p>有了意向锁，由于在对行记录加行锁之前，会对表加上意向锁。那么其他线程若要对表加表锁，可以直接查表是否有冲突得意向锁，而不用到表中一条一条的遍历行记录的行锁。</p><h3 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO-INC锁"></a>AUTO-INC锁</h3><blockquote><p>AUTO-INC锁是是实现主键自增的特殊表锁机制</p></blockquote><p>主键设置为自增，是通过对主键字段声明<code>AUTO_INCREMENT</code>属性实现的。</p><p>在插入数据时，会对表加一个AUTO-INC锁，然后自增字段被赋递增的值，等插入语句执行完成后，才释放AUTO-INC锁。</p><p>这是为了保证自增值的唯一性，在插入数据时阻塞其他插入操作，避免多个线程同时插入出现自增值相同的情况。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>AUTO-INC锁要在插入完成后才释放锁，当有大量插入操作时，因为整个插入过程都持有锁，导致大量插入操作被阻塞。在MySQL 5.1.22版本开始，InnoDB引擎提供了一种轻量级的锁用以实现自增。</p><p>该轻量级锁和AUTO-INC锁的区别在于释放锁的时机不同。轻量级锁在插入数据时，为自增字段赋予自增值后就释放锁，不需要等到整个插入语句执行完成才释放锁。降低了持有锁的时间，减少插入阻塞。</p><h4 id="InnoDB中自增锁的选择"><a href="#InnoDB中自增锁的选择" class="headerlink" title="InnoDB中自增锁的选择"></a>InnoDB中自增锁的选择</h4><p>InnoDB存储引擎提供了<code>innodb_autoinc_lock_mode</code>变量用于选择自增时的锁：</p><ul><li>为0时，采用AUTO-INC锁，语句执行完后才释放锁。</li><li>为2时，采用轻量级锁，申请完自增主键后释放锁。</li><li>为1时，普通insert语句，采用轻量级锁；类似insert … select这样的批量插入数据语句，使用AUTO-INC语句。</li></ul><h4 id="使用轻量级锁搭配binlog日志格式为statement时，在“主从复制场景”中的数据不一致问题"><a href="#使用轻量级锁搭配binlog日志格式为statement时，在“主从复制场景”中的数据不一致问题" class="headerlink" title="使用轻量级锁搭配binlog日志格式为statement时，在“主从复制场景”中的数据不一致问题"></a>使用轻量级锁搭配binlog日志格式为statement时，在“主从复制场景”中的数据不一致问题</h4><p>场景如下：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/innodb_autoinc_lock_mode=2.png" alt="img"></p><p>session A往表t中共插入了4行数据，然后sessionB复制了一份相同的表t2，然后两个session同时往表t2中插入数据。</p><p>因为轻量级锁，在申请自增主键后就释放锁，所以说插入语句时并发执行的，就可能出现这种情况：</p><ol><li>session B先插入两个记录：（1，1，1）、（2，2，2）</li><li>然后session A获得轻量级锁，插入记录：（3，5，5）</li><li>之后，session 继续插入两条记录：（4，3，3）、（5，4，4）</li></ol><p>可以看到session B的insert语句插入的四条记录生成的id不连续。</p><p>因为binlog的日志格式为statement，那么binlog只会记录这两条insert语句。建立从库是按照binlog中的SQL语句来建立建立，因为该操作是在同一线程中，SQL语句会一条一条地执行。那么就不会发生像在主库中两个session同时向表t2中插入数据的场景。所以在从库中执行session B的insert语句生成的四条记录id是连续的。这时主从库就发生了数据不一致。</p><p>解决办法：</p><p>将binlog日志格式设置为row，这样在binlog中记录的就是主库的行记录，而不是执行的语句。在主库中分配的自增值已经在binlog中了，从库执行binlog，就不需要自己分配自增值，和主库自增值保持一致。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><blockquote><p>InnoDB引擎支持行级锁，而MyISAM引擎不支持行级锁。</p></blockquote><h3 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h3><blockquote><p>记录锁锁住的是一条记录。而且分为S（Share）锁和X（exclusive）锁。</p></blockquote><p>普通的select语句时不会对记录加锁的，因为它属于快照读。</p><p>如果要在查询时对记录加行锁，可以使用以下范式查询，称为<strong>锁定读</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">//对读取的记录加共享锁<br>select ... lock in share mode;<br><br>//对读取的记录加独占锁<br>select ... for update;<br></code></pre></td></tr></table></figure><p>上面这两条语句必须要在一个事务中，因为当事务提交的时候会释放锁，若不再事务中，锁一直被占用。所以在使用这两条语句前一定要加上begin、start transaction或set autocommit &#x3D; 0来开启事务。</p><p>共享锁和独占锁之间的互斥性：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="img"></p><h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><blockquote><p>间隙锁只存在于可重复读隔离级别，目的是为例解决可重复读隔离级别下当前读的幻读现象。</p></blockquote><p>假设表中有一个范围id为（3，5）的间隙锁，那么其他事务就无法插入id为4的记录，这样就有效的防止了幻读现象的发生。如图所示：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/gap%E9%94%81.drawio.png" alt="img"></p><p>间隙锁虽然存在S型和X型间隙锁，但是并没有什么区别。间隙锁之间不是互斥的，即两个事务可以同时持有包含相同间隙范围的间隙锁，因为间隙锁的目的是防止插入幻影记录而提出的。</p><h3 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h3><blockquote><p>Next-key Lock称为临键锁，是Record Lock + Gap Lock的组合，锁定一个范围，并且锁定记录本身。</p></blockquote><p>假设有一个范围id为（3，5]的next-key lock，那么其他事务不能插入id &#x3D; 4或id &#x3D; 5的记录：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/%E4%B8%B4%E9%94%AE%E9%94%81.drawio.png" alt="img"></p><p>next-key lock即能保护该记录，又能组织其他事务将新纪录插入到被保护记录前的间隙中。</p><p>因为next-key lock是间隙锁 + 记录锁，记录锁之间是由互斥性的，所以next-key lock之间也是由互斥性的。</p><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><blockquote><p> 插入意向锁是一种特殊的间隙锁。</p></blockquote><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加入了间隙锁（next-key lock也包含间隙锁）。如果有，插入操作会阻塞，直到间隙锁释放，在阻塞期间会生成一个插入意向锁，表明有事务想在该区间插入数据。</p><p>假设事务A已经对表加了一个范围id为（3，5）的间隙锁：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/gap%E9%94%81.drawio-166773701920843.png" alt="img"></p><p>当事务A还未提交的时候，事务B向该表插入一条id &#x3D; 4的记录，这时会判断到插入位置有间隙锁，于是事务B生成一个插入意向锁，将锁的状态设置未等待状态（MySQL加锁，是先生成锁结构，再设置锁状态。此时生成了插入意向锁，但是锁状态未等待状态，不代表事务获取到了锁，只有当锁状态未正常状态是，才代表事务成功获取到了锁），此时事务B阻塞，直到事务A提交。</p><p>插入意向锁和间隙锁的关系：</p><ul><li>如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点。从这个角度来说，插入意向锁就是一种特殊的间隙锁。</li><li>插入意向锁和间隙锁之间互斥。即两个事务不能再同一时间内一个拥有间隙锁，另一个拥有间隙锁区间内的插入意向锁</li></ul><h1 id="MySQL如何加锁"><a href="#MySQL如何加锁" class="headerlink" title="MySQL如何加锁"></a>MySQL如何加锁</h1><blockquote><p><strong>给记录加锁的基本单位：next-key lock</strong></p><p>它是由记录锁和间隙锁组合而成。next-key是前开后闭区间，而间隙锁是前开后开区间。但是在一些场景下，<strong>next-key lock会退化</strong>成记录锁或间隙锁。</p></blockquote><p>在使用update、delete、select … for update这些语句时，都是当前读，需要通过加锁来解决幻读问题。并且这些语句都会使用where条件，不同的where条件的加锁情况不同。</p><p>下面以select … for update来说明加锁的情况（update和delete加锁情况一样）：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/954708d2f29c2a619e861e57cdf74c11-166773923532748.png" alt="图片"></p><h2 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h2><ul><li><p>当查询的记录存在。next-key lock退化成记录锁</p><blockquote><p>因为是唯一索引，所以当查询到记录后，不会插入新的相同索引的记录。所以只需要记录锁避免修改行记录即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_test where id = 16 for update;<br></code></pre></td></tr></table></figure><p>next-key lock锁住区间(8, 16]，因为记录16存在，然后退化为Record lock 16。</p></blockquote></li><li><p>当查询的记录不存在。next-key lock退化成间隙锁</p><blockquote><p>记录不存在，只需要锁住查询记录所在区间，避免在该区间内插入数据，就不会出现幻读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_test where id = 10 for update;<br></code></pre></td></tr></table></figure><p>next-key lock锁住(8, 16]，因为记录10不存在，然后退化为gap lock(8, 16)。</p></blockquote></li></ul><h2 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h2><ul><li><p>当查询的记录存在，除了加next-key lock外，还额外加间隙锁，也就是会加两把锁</p><blockquote><p>因为非唯一索引可以插入索引相同的记录。在该索引记录存在的情况下，如果插入相同索引的记录，可能在当前索引前，也可能在当前索引后。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from t_test where b = 16 for update;<br></code></pre></td></tr></table></figure><p>next-key lock先锁住(8, 16]，然后因为是非唯一索引且查询记录存在，所以往后遍历查找到第一个不符合条件的值才停止，因此间隙锁为(16, 32)。即最终锁为next-key lock(8, 16]和gap lock(16, 32)。</p></blockquote></li><li><p>当查询的记录不存在，只会加next-key lock，然后退化为间隙锁</p><blockquote><p>同唯一索引查询一样</p></blockquote></li></ul><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><ul><li><p>唯一索引的范围查询</p><blockquote><p>会从找到满足条件的第一行，以等值查询方式加锁，然后往后查找满足条件的记录，若记录不在查找范围内，则会退化为间隙锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from i_test where id &gt;= 8 and id &lt; 9 for update;<br></code></pre></td></tr></table></figure><p>第一行id &#x3D; 8，所以next-key lock锁住(4, 8]，并退化成记录锁，只锁住8。然后进行范围查找，找到第一个不符合条件的记录id &#x3D; 16，然后next-key lock锁住(8, 16]，因为16不满足条件，所以退化为 (8, 16)。所以说最终的锁是record lock 8和gap lock (8, 16)。</p></blockquote></li><li><p>非唯一索引的范围查询</p><blockquote><p>跟唯一索引的范围查询的区别在于next-key lock不会退化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from i_test where b &gt;= 8 and b &lt; 9 for update;<br></code></pre></td></tr></table></figure><p> 有两个next-key lock，(4, 8]和(8, 16]。</p></blockquote></li></ul><h2 id="没有使用索引"><a href="#没有使用索引" class="headerlink" title="没有使用索引"></a>没有使用索引</h2><p>当没有使用索引的时候，会进行全表扫描，于是会对所有的记录加上next-key lock，那么就相当于整张表被锁住了（但是不是表锁，只是锁住所有记录，效果和表锁相似）。</p><p>在执行update、delete、select … for update等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描，那么会对每一条记录加next-key lock，整张表都被锁住，其余所有的需要加锁的操作都会被阻塞。这是很严重的问题。</p><h2 id="Insert-语句的加锁"><a href="#Insert-语句的加锁" class="headerlink" title="Insert 语句的加锁"></a>Insert 语句的加锁</h2><p>Insert 语句在正常执行时是不会生成锁结构的。它是靠聚簇索引记录自带的trx_id隐藏列来作为隐式锁来保护记录的，在特殊情况下，才会将隐式锁转换为显式锁。</p><p>隐式锁：</p><p>当事务需要加锁时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制叫做隐式锁。隐式锁时InnoDB实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少锁的数量，提高系统整体性能。</p><p>隐式锁转换为显式锁的场景：</p><ul><li><p>记录之间加有间隙锁</p><blockquote><p>在插入一条新记录前，如果待插入记录的下一条记录上已经被加上了间隙锁，此时会生成一个插入意向锁，并将锁设置为等待状态。然后insert语句会被阻塞。</p></blockquote></li><li><p>遇到唯一键冲突</p><blockquote><p>主键索引冲突：插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加S型记录锁</p><p>唯一二级索引冲突：插入新记录的事务会给已存在的二级索引列值重复的二级索引记录添加S型next-key lock。</p></blockquote></li></ul><h1 id="MySQL死锁"><a href="#MySQL死锁" class="headerlink" title="MySQL死锁"></a>MySQL死锁</h1><h2 id="死锁的发生"><a href="#死锁的发生" class="headerlink" title="死锁的发生"></a>死锁的发生</h2><h3 id="发生死锁的业务场景："><a href="#发生死锁的业务场景：" class="headerlink" title="发生死锁的业务场景："></a>发生死锁的业务场景：</h3><p>在新增订单时做幂等性检验。做法是在新增订单前，先通过select … for update查询订单是否存在，若不存在才插入订单记录。</p><h3 id="模拟发生死锁的场景："><a href="#模拟发生死锁的场景：" class="headerlink" title="模拟发生死锁的场景："></a>模拟发生死锁的场景：</h3><p>表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_order` (<br>  `id` int NOT NULL AUTO_INCREMENT,<br>  `order_no` int DEFAULT NULL,<br>  `create_date` datetime DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `index_order` (`order_no`) USING BTREE<br>) ENGINE=InnoDB ;<br></code></pre></td></tr></table></figure><p> 现有表记录：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/54fc00f9f87a60ab7b5ba92d824a892d.png" alt="图片"></p><p>此时有两个事务，一个插入订单1007，一个插入1008：</p><p><img src="/2022/11/05/MySQL-%E9%94%81/90c1e01d0345de639e3426cea0390e80.png" alt="img"></p><h3 id="为什么不用普通的select语句做幂等性检验"><a href="#为什么不用普通的select语句做幂等性检验" class="headerlink" title="为什么不用普通的select语句做幂等性检验"></a>为什么不用普通的select语句做幂等性检验</h3><p>如果使用普通的select语句做幂等性检验，若两个相同订单号请求进来，就会出现重复的订单。因为普通select语句不会对记录加锁。</p><p><img src="/2022/11/05/MySQL-%E9%94%81/8ae18f10f1a89aac5e93f0e9794e469e.png" alt="img"></p><h3 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h3><p>在可重复读隔离级别下存在幻读问题。InnoDB引擎为了解决可重复读隔离级别下的幻读问题，引入了next-key lock。锁的释放时机是事务提交过后，而不是一条语句执行完。这就是造成死锁的原因。</p><p>事务A和事务B执行select … for update后都持有二级索引范围(1006, +∞]的next-key lock。在接下来的插入操作为了获取到插入意向锁，都在等待对方释放间隙锁，造成了循环等待，导致死锁。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>死锁条件：互斥、占有且等待、不可强占、循环等待</p><p>死锁发生后，通过打破<strong>循环等待</strong>来解除死锁：</p><ul><li><p>设置事务等待锁的超时时间。</p><blockquote><p>当一个事务的等待时间超过设定值后，就对事务进行回滚（相当于只要超过等待时间就当作发生了死锁）。</p><p>参数<code>innodb_lock_wait_timeout</code> 用于设置超时时间，默认50秒。</p></blockquote></li><li><p>开启主动死锁检测。</p><blockquote><p>系统主动检测到发生死锁后，主动回滚死锁链条中的某一事务，让其他事务得以继续执行。</p><p>将参数<code>innodb_deadlock_detect</code>设置为on，表示开启死锁检测，默认开启。</p></blockquote></li></ul><p>更好的方式是避免死锁的发生：</p><p>对于上面发生死锁的业务场景，可以通过对order_no字段设置唯一索引列，利用它的唯一性保证订单表不出现重复的订单。有一点不好的地方在于若插入一个已存在的订单记录会抛出异常。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-事务</title>
    <link href="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h1><h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h2><p>通过一个经典的银行转账来说明。</p><p>假设我向你转账，那么转账过程由以下几个步骤组成：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/40b48e0a7c9a57ae6b78b62c3fad4048.png" alt="图片"></p><p>这个转账过程涉及两次修改数据库的操作，一次是修改我的余额，一次是修改你的余额。</p><p>如果说在操作三后服务器掉电，那么我的余额减少，但是你的余额没有增多，前凭空消失了。</p><p>对于转账这个业务来说，这两个操作时不可分割的。要么两个操作都成功，要么两个操作都失败。</p><p>数据库中的业务就是为了达到这样的效果。在转账前开启事务，等所有操作完成后提交事务。对于已经提交的事务，该事务所做的修改将生效，若在事务中途发生错误，那么该事务期间对数据库所做的修改会回滚到没执行该事务之前的状态。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>事务是由MySQL的引擎来完成的，但不是所有引擎都支持事务，比如说InnoDB引擎就支持事务，但MyISAM不支持。</p><p>实现事务必须要遵守4个特性（ACID）：</p><ul><li><p>原子性（Atomicity）</p><blockquote><p>一个事务中所有的操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。通过在事务执行过程出错时的回滚实现。</p></blockquote></li><li><p>一致性（Consistency）</p><blockquote><p>是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性。</p><p>还是以转账操作为例，A有800，B有600，共1400元，若A给B转200元，那么分为两个步骤，A扣200元，B增加200元。一致性就是要求上述步骤操作后，最后结果是A还有600，B有800，总数还是1400。而不会出现A扣了200变600，但是B没有增加，结果总数变成了1200，钱凭空消失。</p></blockquote></li><li><p>隔离性（Isolation）</p><blockquote><p>数据库允许多个事务并发执行，同时对其数据进行读写和修改。隔离性可以防止多个事务并发执行时，不会相互干扰，每一个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说一个消费者购买商品，是不会影响其他消费者购买的。</p></blockquote></li><li><p>持久性（Durability）</p><blockquote><p> 事务处理结束后，对数据的修改就是永久的，即使系统故障也不会丢失。</p></blockquote></li></ul><p>InnoDB中实现这4个特性所对应的技术：</p><ul><li>原子性：undo log（回滚日志）</li><li>持久性：redo log（重做日志）</li><li>隔离性：MVCC（多版本并发控制）或锁机制</li><li>一致性：持久性+原子性+隔离性</li></ul><h1 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h1><h2 id="并行事务带来的问题"><a href="#并行事务带来的问题" class="headerlink" title="并行事务带来的问题"></a>并行事务带来的问题</h2><p>MySQL服务器允许多个客户端连接，这就意味着MySQL需要处理并发事务。在同时处理多个事务的时候，就可能出现脏读、不可重复读、幻读的问题。</p><h3 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h3><blockquote><p>如果一个事务读到了另一个事务<strong>未提交事务修改过的数据</strong>，就意味着发生了脏读。</p></blockquote><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/10b513008ea35ee880c592a88adcb12f.png" alt="图片"></p><p>事务B读取的数据是A还未提交事务修改的数据，随时可能会发生回滚，若发生了回滚，B获得的就是过期的数据，这就称为脏读。</p><h3 id="不可重复读（non-repeatable-read）"><a href="#不可重复读（non-repeatable-read）" class="headerlink" title="不可重复读（non-repeatable read）"></a>不可重复读（non-repeatable read）</h3><blockquote><p>在一个事务内部多次读取同一个数据，如果出现前后两次读到的数据不一致的情况，就意味着发生了不可重复读。</p></blockquote><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片"></p><p>在A事务两次读取余额的操作之间，事务B修改了余额，那么A事务两次读取到的余额不同，这就是不可重复读。</p><h3 id="幻读（phantom-read）"><a href="#幻读（phantom-read）" class="headerlink" title="幻读（phantom read）"></a>幻读（phantom read）</h3><blockquote><p>事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据就意味着发生了幻读。</p></blockquote><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p><p>事务B第一次按条件读取是5条数据，然后事务A插入了一条搜索条件的数据，事务B再次按原条件搜索，读取到了6条数据。对于事务B来说，同样的搜索条件，搜出来的结果不一致，就像发生了幻觉，这就是幻读。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>并发带来的影响事务一致性性的三种现象的严重程度：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/d37bfa1678eb71ae7e33dc8f211d1ec1.png" alt="图片"></p><p>SQL标准提出了四种隔离级别来规避这些现象。隔离级别越高，性能越差，四个隔离级别如下：</p><ul><li><p>读未提交（read uncommitted）</p><blockquote><p>一个事务还未提交，它做的更改就能被其他事务看到</p></blockquote></li><li><p>读提交（read committed）</p><blockquote><p>一个事务提交过后，它做的更改才能被其他事务看到</p><p>解决了脏读现象。</p></blockquote></li><li><p>可重复读（repeatable read）（默认）</p><blockquote><p>指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</p><p>解决了脏读和不可重复读现象。</p></blockquote></li><li><p>串行化（serializable）</p><blockquote><p>对事务读写的记录加上读写锁，在多个事务对同一记录进行读写操作的时候，如果发生读写冲突，那么后访问的事务必须等待前一个事务执行完成后，才能继续执行。</p><p>解决了上述三种现象。</p></blockquote></li></ul><p>四种隔离级别的实现：</p><ul><li><p>读未提交：直接读取最新数据</p></li><li><p>串行化：通过加读写锁的方式避免并行访问</p></li><li><p>读提交和可重复读：</p><blockquote><p>通过Read View来实现，它们的区别在于创建Read View的时机不同，大家可以把Read View理解为一个数据快照。读提交是在每个语句执行前都会重新生成一个Read View，而可重复读隔离级别是启动事务时生成一个Read View，然后整个事务期间都使用这一个Read View</p></blockquote></li></ul><p>事务开启命令与事务启动时机：</p><ul><li><p>begin&#x2F;start transaction命令</p><blockquote><p>执行该命令过后，并不代表事务启动了。只有在执行该命令后执行了增删改查的SQL语句，事务才真正启动，并创建快照。</p></blockquote></li><li><p>start transaction with consistent snapshot命令</p><blockquote><p>该命令会马上启动事务并创建快照</p></blockquote></li></ul><h1 id="Read-View和MVCC"><a href="#Read-View和MVCC" class="headerlink" title="Read View和MVCC"></a>Read View和MVCC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Read-View的四个重要字段"><a href="#Read-View的四个重要字段" class="headerlink" title="Read View的四个重要字段"></a>Read View的四个重要字段</h3><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><ul><li><p>creator_trx_id</p><blockquote><p>指的是创建该Read View的事务的事务id</p></blockquote></li><li><p>m_ids</p><blockquote><p>指的是在创建Read View时，当前数据库中“活跃事务“的事务id列表。注意是一个列表，“活跃事务”指的是启动了但是还没有提交的事务。</p></blockquote></li><li><p>min_trx_id</p><blockquote><p>指的是”活跃事务“列表中事务id最小的事务，也就是m_ids中的最小值</p></blockquote></li><li><p>max_trx_id</p><blockquote><p>这个并不是m_ids中的最大值，而是创建Read View时当前数据库中应该给下一个事务的id值，也就是全局事务中最大的事务id值+1</p></blockquote></li></ul><h3 id="聚簇索引记录中跟事务相关的两个隐藏列"><a href="#聚簇索引记录中跟事务相关的两个隐藏列" class="headerlink" title="聚簇索引记录中跟事务相关的两个隐藏列"></a>聚簇索引记录中跟事务相关的两个隐藏列</h3><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/f595d13450878acd04affa82731f76c5.png" alt="图片"></p><p>聚簇索引记录中有两个隐藏列：</p><ul><li><p>trx_id</p><blockquote><p>当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务id记录在trx_id隐藏列中</p></blockquote></li><li><p>roll_pointer</p><blockquote><p>每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到undo日志中，然后roll_pointer中保存指向这个旧记录的指针，于是我们就可以通过它来找到修改前的旧记录</p></blockquote></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在创建Read View后，我们可以将聚簇索引记录中的trx_id划分为三种情况：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/ReadView.drawio.png" alt="img"></p><p>一个事务去访问记录的时候，会根据Read View与记录的trx_id做对比，来判断记录对于事务的可见性：</p><ul><li><p>trx_id &lt; min_trx_id（可见）</p><blockquote><p>表示这个版本的记录是在创建Read View前，由已经提交的事务生成。所以该版本记录对当前事务可见。</p></blockquote></li><li><p>trx_id &gt;&#x3D; max_trx_id（不可见）</p><blockquote><p>表示这个版本的记录是在创建Read View后才启动的事务生成的。所以该版本记录对当前事务不可见。</p></blockquote></li><li><p>trx_id 在二者之间</p><ul><li><p>若trx_id在m_ids列表中（不可见）</p><blockquote><p>表示生成该版本记录的活跃事务还未提交，该版本记录对当前事务不可见。</p></blockquote></li><li><p>若trx_id不在m_ids列表中（可见）</p><blockquote><p>表示生成该事务的活跃事务已经被提交，所以该版本记录对当前事务可见。</p></blockquote></li></ul></li></ul><p>这种通过”版本链“来控制并发事务访问同一记录的方式就叫做MVCC（多版本并发控制）。</p><h2 id="可重复读是如何工作的"><a href="#可重复读是如何工作的" class="headerlink" title="可重复读是如何工作的"></a>可重复读是如何工作的</h2><blockquote><p>可重复读隔离级别是启动事务时生成一个Read View，然后整个事务期间都使用这个Read View</p></blockquote><h3 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h3><p>假设事务A（事务id为51）启动后，紧接着事务B（事务id为52）也启动。</p><p>两个事务创建时的Read View和事务创建时的字段信息如下：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="img"></p><p>事务A和事务B的Read View内容如下：</p><ul><li>事务A的Read View：它的事务id是51，由于它是第一个启动的事务，它启动时活跃事务的事务就只有它本身（也就是51），那么活跃事务id列表中最小的事务id也是事务A本身，下一个事务id则是52</li><li>事务B的Read View：它的事务id是52，由于事务A是活跃的，所以此时的活跃事务的事务id列表是51和52，活跃事务id中最小的事务id是事务A，下一个事务id是53</li></ul><h3 id="事务执行与分析"><a href="#事务执行与分析" class="headerlink" title="事务执行与分析"></a>事务执行与分析</h3><p>接着，在可重复读隔离级别下，事务A和事务B按顺序执行了以下操作：</p><ol><li><p>事务B读取余额，余额为100万</p><blockquote><p>在找到记录后，先查看该记录的trx_id，发现trx_id为50，比事务B的Read View中的min_trx_id值（51）小，这意味着修改这条记录的事务在事务B启动前就已经提交了，所以该版本记录对事务B是可见的，也就是事务B可以获取到这条记录。</p></blockquote></li><li><p>事务A将余额记录修改为200万（未提交事务）</p><blockquote><p>事务A通过update语句修改了记录，这个时候MySQL会将旧数据记录到undo log中，然后新建记录保存到索引中，并以链表的方式连接新旧记录，形成版本链，如下图：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/image-20221106140535502.png" alt="image-20221106140535502"></p><p>所以最新的记录的trx_id是事务A的事务id（51）</p></blockquote></li><li><p>事务B读取余额，读到余额仍未100万</p><blockquote><p>事务B第二次读取该记录，发现trx_id值为51，在事务B的Read View的min_trx_id和max_trx_id之间，然后再判断trx_id在m_ids中，所以这条记录是被还未提交的事务修改的，所以事务B不会读取这个版本的记录。而是沿着undo log版本链往下找旧版本的记录，直到找到trx_id小于Read View的min_trx_id的第一条记录。所以事务B能读取到的是trx_id为50的记录，也就是余额为100万的记录。</p></blockquote></li><li><p>事务A提交事务</p></li><li><p>事务B读取余额，读到余额仍为100万</p><blockquote><p> 由于隔离级别是可重复读，所以事务B每次读取记录时，都是基于启动事务B时创建的Read View来判断当前版本的记录的可见性。所以，即使事务A修改余额并已提交，事务B读取记录时，读到的仍是余额为100万的这个版本。</p></blockquote></li></ol><h2 id="读提交是如何工作的"><a href="#读提交是如何工作的" class="headerlink" title="读提交是如何工作的"></a>读提交是如何工作的</h2><blockquote><p>读提交隔离级别是在每次读取数据时,都会生成一个新的Read View。</p></blockquote><p>还是同上面一样的执行流程：</p><ol><li><p>事务B读取余额，余额为100万</p><blockquote><p>同可重复读一样</p></blockquote></li><li><p>事务A将余额记录修改为200万（未提交事务）</p><blockquote><p>同可重复读一样</p></blockquote></li><li><p>事务B读取余额，读到余额仍未100万</p><blockquote><p>因为事务A还没提交。所以事务B第二次读取余额创建的Read View和第一次读取余额创建的Read View一样，所以读取到的余额也一样。</p></blockquote></li><li><p>事务A提交事务</p><blockquote><p>同可重复读一样</p></blockquote></li><li><p>事务B读取余额，读到余额为200万</p><blockquote><p>这次创建的Read View如下：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png" alt="img"></p><p> 因为事务A已经提交了，所以事务A不在活跃列表中。</p><p>trx_id为51比Read View中的min_trx_id值小，所以修改该记录的事务在创建Read View之前已经提交了，所以该版本的记录对事务B是可见的。</p></blockquote></li></ol><h1 id="可重复读的幻读解决方案"><a href="#可重复读的幻读解决方案" class="headerlink" title="可重复读的幻读解决方案"></a>可重复读的幻读解决方案</h1><p>MySQl InnoDB引擎的默认隔离级别是可重复读。但是它在很大程度上避免了幻读现象。其解决方案如下：</p><ul><li><p>针对快照读（普通select语句）</p><blockquote><p> 通过MVCC方式解决了幻读。因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据一致，即使中途有其他事务插入了一条数据，对于该事务来说是不可见的，所以就很好地避免了幻读问题。</p></blockquote></li><li><p>针对当前读（select…for update等语句）</p><blockquote><p>通过next-key lock（记录锁+间隙锁）方式解决了幻读。因为在执行select …for update语句的时候，会加上next-key lock，如果有其他事务在next-key lock锁范围内插入一条记录，那么这条插入语句就会别阻塞，无法成功插入，所以就很高地避免幻读问题。</p></blockquote></li></ul><h2 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h2><blockquote><p>官方文档定义的幻读（Phantom Read）：</p><p><em><strong>The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.</strong></em></p><p>当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻读现象。例如，如果SELECT执行了两次，但第二次返回了第一次没有返回的行，则该行时”幻像“行。</p></blockquote><p>例如，在同一事务中的T1时刻和T2时刻分别执行了如下查询语句，T1-T2之间该事务没有执行其他修改语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_test WHERE id &gt; 100;<br></code></pre></td></tr></table></figure><p>只要T1和T2时刻执行产生的结果集是不同的，那就发生了幻读问题。</p><h2 id="快照读是如何避免幻读的"><a href="#快照读是如何避免幻读的" class="headerlink" title="快照读是如何避免幻读的"></a>快照读是如何避免幻读的</h2><blockquote><p>可重复读隔离级别是由MVCC（多版本并发控制）实现的。</p></blockquote><p>启动事务后，在执行第一个查询语句后，创建一个Read View，后续的查询语句会通过这个Read View在undo log版本链中找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的。即使中途插入了新的记录，由于新纪录的版本高于事务的版本，所以事务是查询不到新数据的。</p><h2 id="当前读是如何避免幻读的"><a href="#当前读是如何避免幻读的" class="headerlink" title="当前读是如何避免幻读的"></a>当前读是如何避免幻读的</h2><blockquote><p>当前读是通过next-key lock实现的</p></blockquote><p>MySQL里除了普通查询是快照读，其他都是当前读，比如说update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。因为如果要update一条记录，若其他事务已经delete这条记录并已经提交了，如果update不获取最新记录的话就会产生冲突。另外，select … for update这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p><p>我们假设当前读的时候如果是不加锁的（实际上会加锁）的情况：</p><p>在事务A的两次相同的当前读查询语句之间，事务B插入了一条记录，导致两次查询结果不一致，出现了幻读。</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>Innodb引擎为了解决在可重复读隔离级别中使用当前读而产生的幻读问题，就引入了<strong>间隙锁</strong>。</p><p>在执行当前读的时候，在可能导致幻读的记录间隙加上间隙锁，阻塞其他事务在该范围插入记录，就可以避免当前读的幻读问题。举个例子，场景如下：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/3af285a8e70f4d4198318057eb955520.png" alt="img"></p><p>事务A执行了当前读语句，因为它读取的范围是id &gt; 2，就对表中记录加上范围为（2， +∞）的next-key lock。</p><p>然后事务B在执行插入语句的时候，由于其要插入的位置被事务A加上了next-key lock，于是事务B就会生成一个插入意向锁，同时进入等待状态，直到事务A提交了事务才执行插入操作，这就避免了由于事务B插入新记录而导致事务A发生幻读的现象。</p><h2 id="MySQL未完全解决幻读"><a href="#MySQL未完全解决幻读" class="headerlink" title="MySQL未完全解决幻读"></a>MySQL未完全解决幻读</h2><h3 id="第一个发生幻读的场景"><a href="#第一个发生幻读的场景" class="headerlink" title="第一个发生幻读的场景"></a>第一个发生幻读的场景</h3><p>以该表为例子：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/7f9df142b3594daeaaca495abb7133f5.png" alt="img"></p><p>出现幻读的一个操作时序图：</p><p><img src="/2022/11/05/MySQL-%E4%BA%8B%E5%8A%A1/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p><p>在可重复读隔离级别下，事务A第一次执行普通的select语句时生成ReadView，之后事务B像表中插入一条id为5的记录，此时该记录的trx_id是事务B的id，事务A是查不到该记录的，然后事务A对id为5的这条记录执行了更新操作（因为更新操作是当前读，可以读到其他事务提交的记录），id为5的记录的trx_id被修改为事务A的id，这样之后事务A再使用普通的select语句去查询这条记录时就可以看到该记录。</p><h3 id="第二个发生幻读的场景"><a href="#第二个发生幻读的场景" class="headerlink" title="第二个发生幻读的场景"></a>第二个发生幻读的场景</h3><p>事务A先执行普通select快照读，然后事务B插入一条数据并提交，然后事务A再执行一条当前读语句，此时也会发生幻读现象。</p><h3 id="避免上面特殊场景的幻读现象"><a href="#避免上面特殊场景的幻读现象" class="headerlink" title="避免上面特殊场景的幻读现象"></a>避免上面特殊场景的幻读现象</h3><p>再开启事务之后，马上执行select … for update这类当前读语句，因为它会对记录加next-key lock，从而阻塞其他事务在可能导致幻读的地方插入新记录。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-索引</title>
    <link href="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><blockquote><p>索引就是数据的目录。</p></blockquote><p>当我们想要查阅书中的某个只是的内容的时候，使用目录可以快速定位要找的知识的位置，如果没有目录那么就需要一页一页的找。</p><p>书中的目录，就是充当索引的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。对应到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的来说索引就是数据的目录。</p><p>所谓的存储引擎，就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><h2 id="索引的分类与介绍"><a href="#索引的分类与介绍" class="headerlink" title="索引的分类与介绍"></a>索引的分类与介绍</h2><p>按不同角度分类：</p><p>数据结构：B+Tree索引、Hash索引、Full-text索引</p><p>物理存储：聚簇索引（主键索引）、二级索引（辅助索引）</p><p>字段特性：主键索引、唯一索引、普通索引、前缀索引</p><p>字段个数：单列索引、联合索引</p><h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><p>从数据结构的角度来看，MySQL常见的索引有B+tree索引、Hash索引、Full-text索引。</p><p>不同存储引擎支持的所以类型不同，支持如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" alt="img"></p><p>MySQL的默认引擎是InnoDB，InnoDB的默认索引类型是B+tree索引。</p><h3 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h3><p>从物理存储的角度看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><p>主键索引的B+ Tree和二级索引的B+ Tree的区别：</p><ul><li>主键索引的B+ Tree的叶子节点存放的是实际数据，所有的行数据都存放在主键索引的B+ Tree的叶子节点中</li><li>二级索引的B+ Tree的叶子节点存放的是主键值，而不是实际数据</li></ul><p>二者的创建：</p><ul><li><p>聚簇索引：</p><blockquote><p>在创建表时，InnoDB会根据不同场景选择不同列作为索引生成聚簇索引</p><ul><li>若有主键。默认选择使用主键作为聚簇索引的索引键</li><li>若没有主键。则选择第一个不包含NULL值的唯一列作为聚簇索引的索引键</li><li>若上面二者都没有。InnoDB则会生成一个隐式自增id列作为聚簇索引的索引键</li></ul></blockquote></li><li><p>非聚簇索引：</p><blockquote><p>其他的索引都属于辅助索引（Secondary Index），也称为二级索引或非聚簇索引。</p></blockquote></li></ul><h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><blockquote><p>主键索引就是建立在主键字段上的索引。通常在创建表的时候一起创建，一张表只有一个主键索引，索引列的值不能为空值。</p></blockquote><p>在创建表时，创建主键索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  PRIMARY KEY (index_column_1) USING BTREE<br>);<br></code></pre></td></tr></table></figure><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><blockquote><p>唯一索引是建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值。</p></blockquote><p>创建表时，创建唯一索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  UNIQUE KEY(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure><p>建表后，添加唯一索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE UNIQUE INDEX index_name<br>ON table_name(index_column_1,index_column_2,...); <br></code></pre></td></tr></table></figure><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><blockquote><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为UNIQUE。</p></blockquote><p>建表时，创建普通索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name  (<br>  ....<br>  INDEX(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure><p> 建表后，添加普通索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_name<br>ON table_name(index_column_1,index_column_2,...); <br></code></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><blockquote><p>前缀索引是指字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引。前缀索引可以建立子啊字段类型为char、varchar、binary、varbinary的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，并提升查询效率。</p></blockquote><p>创建表时，创建前缀索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name(<br>    column_list,<br>    INDEX(column_name(length))<br>); <br></code></pre></td></tr></table></figure><p>建表后添加前缀索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_name<br>ON table_name(column_name(length)); <br></code></pre></td></tr></table></figure><h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><p>从字段个数的角度来看，索引分为单列索引、联合索引。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引</li><li>建立在多列上的索引称为联合索引</li></ul><h4 id="联合索引简介："><a href="#联合索引简介：" class="headerlink" title="联合索引简介："></a>联合索引简介：</h4><p>若将上面商品表中的product_no和name字段组合成联合索引（product_no, name）。</p><p>创建联合索引的方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_product_no_name ON product(product_no, name);<br></code></pre></td></tr></table></figure><p>联合索引（product_no, name）的B+ Tree示意图：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png" alt="联合索引"></p><p>可以看到，联合索引的非叶子节点用两个字段的值作为B+ Tree的Key值。</p><p>当在联合索引查询数据时，先按照product_no字段比较，在product_no字段相同的情况下再按name字段比较。也就是说来联合索引中的B+Tree是先按product_no进行排序，再按name排序。</p><h4 id="最左匹配原则："><a href="#最左匹配原则：" class="headerlink" title="最左匹配原则："></a>最左匹配原则：</h4><p>在使用联合索引的时候，存在最左匹配原则，也就是按照最左优先的方式进行索引匹配。</p><p>在使用联合索引进行查询的时候，若不遵守最左匹配原则，联合索引会失效，这样就无法利用索引快速查询的特性了。</p><p>比如说有（a，b，c）这么三个字段组成的联合索引。</p><p>有效的查询条件：</p><ul><li>where a &#x3D; 1;</li><li>where a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3;</li><li>where b &#x3D; 1 and a &#x3D; 2;</li></ul><p>失效的查询条件：</p><ul><li>where b &#x3D; 2;</li><li>where c &#x3D; 3;</li><li>where b &#x3D; 2 and c &#x3D; 3;</li></ul><p>索引失效的原因（只有a字段是全局有序的，b和c字段是局部有序的）：</p><blockquote><p>因为联合索引（a, b, c）是按照a排序，a相同的情况下按b排序，b相同过的情况下按c排序。</p><p>所以说<strong>b和c是全局无序的，局部有序的。</strong></p><p>这样在没有遵守最左匹配原则的情况下，是无法利用到该联合索引的。</p></blockquote><h4 id="联合索引范围查询："><a href="#联合索引范围查询：" class="headerlink" title="联合索引范围查询："></a>联合索引范围查询：</h4><blockquote><p>范围查询的字段可以用到联合索引，范围查询后的字段无法用到联合查询。</p></blockquote><p>联合查询的最左匹配原则会一直向右匹配直到遇到范围查询就会停止匹配。</p><p>三条语句的联合索引使用情况（条件中的字段组成联合索引）：</p><ul><li><pre><code class="mysql">select * from t_table where a &gt; 1 and b = 2<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>  在符合<span class="hljs-keyword">a</span>&gt;<span class="hljs-number">1</span>条件的二级索引记录的范围中，b字段的值是无序的。<br><br>  进行范围扫描的起始记录时符合`<span class="hljs-keyword">a</span> &gt; <span class="hljs-number">1</span>`的第一条记录。<br><br>  所以说只有<span class="hljs-keyword">a</span>字段使用到了联合索引，b字段没有。<br><br>- ```mysql<br>  select * <span class="hljs-built_in">from</span> t_table where <span class="hljs-keyword">a</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>对于a=1的二级索引记录的范围中，b字段的值是有序的。进行范围扫描的起始记录是符合`a = 1 and b = 2 `的第一条记录。a字段和b字段都用到了联合索引。</code></pre></li><li><p>&#96;&#96;&#96;mysql<br>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b &#x3D; 2</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>  在MySQL中<span class="hljs-keyword">BETWEEN</span>类似于大于等于和小于等于的查询。<br><br>- ```mysql<br>  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;j%&#x27;</span> <span class="hljs-keyword">and</span> age = <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p><code>like j%</code>形成的扫描区间是[‘j’, ‘k’]。所以说也同上面的范围查询类似。</p><p>虽然符合‘j’前缀的name字段中的二级索引记录范围中，age字段的值是无序的。但是对于符合name &#x3D; j的二级索引记录的范围里，age字段的值是有序的。</p><p>所以进行范围扫描的起始记录是<code>name = j and age = 22</code>的第一条记录。</p><p>所以这个查询语句也用到了name和age两个字段。</p><p>图示如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/q4-2.drawio.png" alt="img"></p><p>综上：</p><blockquote><p>联合索引的最左匹配原则，在遇到范围查询如（&gt;、&lt;）的时候，停止匹配剩余字段。</p><p>但是对于&gt;&#x3D;、&lt;&#x3D;、 BETWEEN、like前缀匹配的范围查询，并不会停止匹配。</p></blockquote></li></ul><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>对于联合索引（a，b），在执行<code>select * from table where a &gt; 1 and b = 2</code>语句的时候，只有a字段能使用a字段。那么在联合索引的B+Tree中找的了符合a字段条件的主键值后，如何判断b字段是否满足条件呢？</p><ul><li>在MySQL 5.6前，只能通过回表，通过主键id到主键索引中查找出数据行，再对比b字段。</li><li>在MySQL 5.6引入的<strong>索引下推优化</strong>（index condition pushdown），可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。（在查询语句的执行计划中共，Extra为Using index condition，那么说明使用了索引下推的优化）。</li></ul><h4 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h4><p>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高。在实际开发中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的SQL使用到。</p><p>区分度：某个字段column不同值得个数&#x2F;表得总行数</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E5%8C%BA%E5%88%86%E5%BA%A6.png" alt="区分度计算公式"></p><p>例如，性别的区分度很小，不适合建立索引，或不适合排在联合索引列的靠前位置。而UUID这种字段区分度就高。</p><h4 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h4><blockquote><p>因为联合索引的有序性，所以说可以利用该特性来优化有排序的查询语句。</p></blockquote><p>例如该SQL语句的优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from order where status = 1 order by create_time asc<br></code></pre></td></tr></table></figure><ul><li><p>方案一、给status建立一个索引</p><blockquote><p>在查询时，只用到status索引，还是需要对creat_time排序</p></blockquote></li><li><p>方案二、给status和create_time列建立一个联合索引</p><blockquote><p>因为在查询的时候根据statue &#x3D; 1筛选后的数据，已经是根据creat_time拍好序了的，不需要再额外执行排序操作。这样就可以避免MySQL数据库去进行排序操作。</p></blockquote></li></ul><h3 id="B-Tree索引在存储数据中的具体实现"><a href="#B-Tree索引在存储数据中的具体实现" class="headerlink" title="B+ Tree索引在存储数据中的具体实现"></a>B+ Tree索引在存储数据中的具体实现</h3><h4 id="表结构和表数据："><a href="#表结构和表数据：" class="headerlink" title="表结构和表数据："></a>表结构和表数据：</h4><p>先创建一张表，id为主键，表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `product`  (<br>  `id` int(11) NOT NULL,<br>  `product_no` varchar(20)  DEFAULT NULL,<br>  `name` varchar(255) DEFAULT NULL,<br>  `price` decimal(10, 2) DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE<br>) CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;<br></code></pre></td></tr></table></figure><p> 表数据如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/824c43b801c64e81acb0a9b042d50311.png" alt="img"></p><h4 id="行数据在在B-Tree索引中存储的结构："><a href="#行数据在在B-Tree索引中存储的结构：" class="headerlink" title="行数据在在B+ Tree索引中存储的结构："></a>行数据在在B+ Tree索引中存储的结构：</h4><blockquote><p>B+ Tree是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每一个节点中的数据是按照主键顺序存放。</p><p>每一个父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。</p></blockquote><p>主键索引的B+ Tree如图：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/btree.drawio.png" alt="主键索引 B+Tree"></p><h4 id="通过主键查询数据："><a href="#通过主键查询数据：" class="headerlink" title="通过主键查询数据："></a>通过主键查询数据：</h4><p>若我们执行了查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from product where id = 5;<br></code></pre></td></tr></table></figure><p>主键查询的查询过程如下：</p><ol><li>将5与根节点索引数据（1，10，20）比较，5在1-10之间，根据B+ Tree搜索逻辑，找到第二层（1，4，7）；</li><li>在第二层索引数据（1，4，7）中进行查找，因为5在4-7之间，所以找到第三层叶子节点数据（4，5，6）</li><li>在叶子节点数据（4，5，6）中进行查找，然后就找到了索引值为5的行数据</li></ol><p>数据的索引和数据都是存储在硬盘中。我们可以把读取一个节点当作一次磁盘I&#x2F;O操作，那么经过上面的查询进行了3次I&#x2F;O操作。</p><p>B+ Tree存储千万级的数据只需要3-4层高度，也就是说千万级的表查询也只需要3-4次的磁盘I&#x2F;O。</p><h4 id="通过二级索引查询数据："><a href="#通过二级索引查询数据：" class="headerlink" title="通过二级索引查询数据："></a>通过二级索引查询数据：</h4><p>我们将上表中的product_no字段设置为二级索引，那么该二级索引结构如下：</p><blockquote><p>叶子节点的key为product_no字段，Value为主键值id。</p></blockquote><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png" alt="二级索引 B+Tree"></p><p>若通过二级索引查询商品，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from product where product_no = &#x27;0002&#x27;;<br></code></pre></td></tr></table></figure><p>二级索引的查询过程：</p><ol><li>先根据product_no值在二级索引的B+ Tree中找到对应得叶子节点，获取主键值</li><li>在根据主键值，在主键索引得B+ Tree中查询到对应得叶子节点，获取整行数据</li></ol><p>上面这个查询过程叫做<strong>回表</strong>，也就是要查询两个B+ Tree才能查到数据。过程如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/%E5%9B%9E%E8%A1%A8.drawio.png" alt="回表"></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果当查询得数据能在B+ Tree得叶子节点中查询到，这个时候就不用再通过主键索引查，例如执行如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id from product where product_no = &#x27;0002&#x27;;<br></code></pre></td></tr></table></figure><p>这种在二级索引得B+ Tree就能查询到结果得过程叫做                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              <strong>覆盖索引</strong>，也就是只需要查二级索引，不需要回表操作就能找到所需数据。</p><h2 id="什么时候需要索引"><a href="#什么时候需要索引" class="headerlink" title="什么时候需要索引"></a>什么时候需要索引</h2><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>索引的最大好处时提高查询速度。但是索引也有缺点，比如：</p><ul><li>空间占用。索引需要占用物理空间，数量越大，占用空间越大。</li><li>创建和维护索引需要消耗时间。消耗的时间随着数据量的增大而增大。</li><li>降低增删改速度。因为每次增删该索引，B+树为了维护索引的有序性，需要进行动态维护。</li></ul><h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul><li>字段有唯一性限制。例如商品编码。</li><li>经常用于<code>WHERE</code>查询条件的字段。这样可以提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于<code>GROUP BY</code>和<code>ORDER BY</code>的字段。这样在查询的时候就不需要再去做一次排序了，因为再建立了索引之后B+树中的记录都是排好序了的。</li></ul><h4 id="什么时候不需要索引？"><a href="#什么时候不需要索引？" class="headerlink" title="什么时候不需要索引？"></a>什么时候不需要索引？</h4><ul><li>WHERE条件、GROUP BY、ORDER BY里用不到的字段。索引的价值是快速定位，如果起不到定位作用的字段通常是不需要创建索引的。</li><li>区分度小的字段。区分度小的字段，例如性别，无论搜索哪一个值都得到一半左右的数据。再这种情况下，还不如不使用索引，因为查询优化器发现某种值在表中的数据行出现的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引。</li><li>经常更新的字段不用创建索引。例如电商项目中的用户余额字段不要建立索引。因为若索引字段需要频繁修改，由于要维护B+树的有序性，那么就需要频繁的重建索引，这个过程会影响数据库的性能。</li></ul><h1 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h1><h2 id="为什么采用B-树作为索引"><a href="#为什么采用B-树作为索引" class="headerlink" title="为什么采用B+树作为索引"></a>为什么采用B+树作为索引</h2><h3 id="作为索引的数据结构的要求"><a href="#作为索引的数据结构的要求" class="headerlink" title="作为索引的数据结构的要求"></a>作为索引的数据结构的要求</h3><p>MySQL的数据时持久化的，也就是数据（索引+记录）是保存在磁盘上的，这样即使设备断电，数据也不会丢失。</p><p>磁盘的访问速度很慢，磁盘中读取速度比内存满上万倍。磁盘存储数据的最小单位是扇区，扇区的大小只有512B。操作系统读取数据的最小单位是块，一个块包含多个扇区。在Linux中块为4KB，也就是一次磁盘I&#x2F;O操作会读取8个扇区。</p><p>由于数据库的索引是保存到磁盘上的，所以在通过索引查找行数据的时候，需要从磁盘中读取索引到内存，再通过索引从磁盘中找到行数据，然后读入内存。也就是说在查询过程中会发生多次磁盘I&#x2F;O，而磁盘I&#x2F;O次数越多，所消耗的时间越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘I&#x2F;O操作中完成查询工作。另外，MySQL支持范围查找，所以索引的数据结构不仅要能高效地查询单条记录，也要能高效地执行范围查找。</p><p>所以适合MySQL索引的数据结构，需要满足的要求：</p><ul><li>要在尽可能少的磁盘I&#x2F;O操作中完成查询工作</li><li>要能高效的查询某一条记录，也要能高效地执行范围查找</li></ul><h3 id="数组二分查找"><a href="#数组二分查找" class="headerlink" title="数组二分查找"></a>数组二分查找</h3><p>假设使用数组存储索引，那么我们维护这个数组为有序数组，在定位数据的时候就可以使用二分查找法：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/f01bb5e7e940231c4f39e7f1cfb449f3.png" alt="图片"></p><p>这样每次查询的时间复杂度就降为O(logN)。</p><p>数组二分查找的问题：</p><p>使用数组来存储和检索线性排序的数据简单好用，但是插入新元素的时候性能太差。在插入数据的时候，需要移动该数据后面的每一个元素，而且这个操作还是发生在磁盘中。而且在使用二分查找的时候，每次查找还需要计算中间的位置。</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树的特点就是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点。</p><p>这样我们在查询数据时，不需要计算中间节点的位置，只需要将查找的数据与节点数据进行比较。并且有序二叉查找树时非线性结构，插入节点的的时候可以放在任何位置，不需要像线性结构那样移动其余元素。</p><p>二分查找树的问题：</p><p>若每次插入的元素都是二叉查找树中的最大值，二叉查找树就会退化为一条链表。每访问一个节点就对应一次磁盘I&#x2F;O操作，树的高度越高，对应I&#x2F;O操作次数越多，性能越差。并且二分查找树不能范围查询。</p><h3 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h3><p>为例解决二叉树在极端情况下退化成链表，就提出了平衡二叉查找树（AVG）。也就是在二叉查找树的基础上增加了一些条件约束：每个节点的左子树和右子树的高度差不能超过1。这样查询操作的时间复杂度就会一直维持在O（logN）。</p><p>自平衡二叉树的问题：</p><p>随着插入元素的增多，导致树的高度变高，意味着磁盘的I&#x2F;O操作次数变多，影响整体查询效率。因为自平衡二叉树本质上是一颗二叉树，每个节点只能有两个子节点，节点增多，树高曾高，磁盘I&#x2F;O次数增多。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>为例降低树的高度，就提出了B树。它不再限制节点的子节点数量，而是允许M个子节点（M &gt; 2），从而降低树的高度。M称为B树的阶，所以B树是一个多叉树。</p><p>B树的问题：</p><p>B树的每一个节点都包含数据（索引+记录）。这就导致了在查询某节点记录的时候，加载了很多非该节点的记录数据，我们需要的是索引来判断查询节点的位置，但是由于索引和数据记录是绑定在一起的，所以无用的数据记录也被加载。这就导致了磁盘I&#x2F;O次数的增多，也占用了更多的内存资源。并且B树不支持范围查询。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树在B树的基础上做了升级：</p><ul><li>只有也只节点存放实际数据（索引+记录），非叶子节点只会存放索引</li><li>所有索引都会在叶子节点出现，叶子节点之间构成一个链表</li></ul><h5 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h5><p>B+树的非叶子节点只存放索引，所以说每个非叶子节点可以存放更多的子节点，那么B+树就比B树更加矮胖，查询底层节点的磁盘I&#x2F;O会更少。</p><h5 id="插入和删除效率"><a href="#插入和删除效率" class="headerlink" title="插入和删除效率"></a>插入和删除效率</h5><p>因为数据都存储在叶子节点，B+树有大量冗余节点，这样在删除一个节点的时候，可以直接从叶子节点删除，甚至可以不用动非叶子节点。而B树因为没有冗余节点，删除节点可能涉及复杂的树变形。插入也是同理。</p><h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><p>B树和B+树的等值查询原理一致，先从根节点查找，然后对比目标数据的范围，最后递归地进入子节点查找。</p><p>因为B+树地叶子节点之间通过链表连接。当需要进行范围查找地时候，可以先从根节点开始单点查找通过边界值，然后利用链表查找范围数据，不再需要从根节点查询，这样减少了大量地I&#x2F;O。</p><h3 id="Innodb中的B-树"><a href="#Innodb中的B-树" class="headerlink" title="Innodb中的B+树"></a>Innodb中的B+树</h3><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/dd076212a7637b9032c97a615c39dcd7.png" alt="图片"></p><p>Innodb使用的B+树的一些特点：</p><ul><li>叶子节点之间使用双向链表连接</li><li>树节点的内容是数据页，数据页中存放着用户的记录以及各种信息，每个数据页默认大小为16KB</li></ul><p>Innodb根据索引类型分为：</p><ul><li>聚簇索引。叶子节点存放的是实际数据，所有完整的用户记录存放在聚簇索引的叶子节点</li><li>二级索引。叶子节点存放的是主键值，而不是实际数据</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点中，索引Innodb引擎一定会为表创建一个聚簇索引，而且由于数据只在物理上保存一根，所以聚簇索引有且仅有一个，而二级索引可以创建多个。</p><h2 id="从数据页的角度看B-树"><a href="#从数据页的角度看B-树" class="headerlink" title="从数据页的角度看B+树"></a>从数据页的角度看B+树</h2><p>记录是按行来存储的，但是数据库的读取并不是以行为单位。否则一次I&#x2F;O只读取一行数据，效率会很低。</p><p>因此，InnoDB的数据是以<strong>数据页</strong>为单位来读写的，也就是说，当需要读取一条记录的时候，并不是将这个记录本身从磁盘读取出来，而是将该记录所在页整体读入内存。</p><p>数据库I&#x2F;O操作的最小单位是页，默认数据页的大小为16KB。也就是说数据区每次I&#x2F;O最少读&#x2F;写16KB的数据。</p><h3 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h3><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/243b1466779a9e107ae3ef0155604a17.png" alt="图片"></p><p>各部分作用：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p><h4 id="File-Header（文件头）"><a href="#File-Header（文件头）" class="headerlink" title="File Header（文件头）"></a>File Header（文件头）</h4><p>File Header中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/557d17e05ce90f18591c2305871af665.png" alt="图片"></p><p> 采用链表的结构，让数据页之间不需要是物理连续的，而是逻辑连续的。</p><h4 id="Page-Directory（页目录）"><a href="#Page-Directory（页目录）" class="headerlink" title="Page Directory（页目录）"></a>Page Directory（页目录）</h4><p>数据页的作用是存储记录，所以说数据页的重点在于如何组织数据。</p><p>数据页中的记录按照主键顺序组成单向链表。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况需要遍历完链表上的所以节点才能完成检索。</p><p>因此，数据页中有一个页记录，起到记录的索引作用。就像读书时针对章节设立的目录，通过目录快速定位对应章节的页数。</p><h5 id="页目录与记录的关系："><a href="#页目录与记录的关系：" class="headerlink" title="页目录与记录的关系："></a>页目录与记录的关系：</h5><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p><h5 id="页目录的创建过程："><a href="#页目录的创建过程：" class="headerlink" title="页目录的创建过程："></a>页目录的创建过程：</h5><ol><li>将所有记录划分为几个组，这些记录包括最大记录和虽小记录，但不包括”已删除“的记录。</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为n_owned字段（图中粉色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些偏移量会按照先后顺序存储起来，每组的地址便宜量也被称为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li></ol><h5 id="通过页目录查找记录："><a href="#通过页目录查找记录：" class="headerlink" title="通过页目录查找记录："></a>通过页目录查找记录：</h5><ol><li><p>页目录由多个槽组成，槽相当于分组记录的索引；</p></li><li><p>然后，记录按照主键值从小到大排序，索引可以通过二分法快速定位要查询记录所在槽；</p></li><li><p>定位到槽后，再遍历槽内的所有记录，找到对应的记录。无需从最小记录开始遍历整页中共的所有记录。</p></li></ol><p> 因为要遍历槽内数据，所以对每个槽（分组）中记录的条数有规定：</p><ul><li>第一个分组的记录只能有一条</li><li>最后一个分组中的记录条数范围只能在1-8条之间</li><li>剩余的分组中记录条数范围只能在4-8条之间</li></ul><h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+树是如何进行查询的？"></a>B+树是如何进行查询的？</h3><p>上面说的是在数据页中的记录的检索。因为一个数据页中的记录有限，且主键值时候有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索记录所在分组，来降低检索的时间复杂度。</p><p>当我们需要存储大量的记录时，就需要大量数据页，这个时候就需要为这些数据页建立索引，用于快速定位记录所在的页。</p><p>InnoDB采用B+树作为索引。B+树中每个节点都是一个数据页，结构示意图如下：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p><p>B+树特点：</p><ul><li>只有也只节点存放数据，非叶子节点仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量。</li><li>所有节点按照索引键的大小排序，构成一个双向链表，便于范围查询</li></ul><p>B+树搜索主键为6的记录的过程：</p><ol><li>从根节点，通过二分法快速定位到符合页内范围包含查询值得页。因为6在[1, 7)之间，所以到页30中查找；</li><li>在非叶子节点中，递归查找，主键值大于5，所以到叶子节点（页16）中查找</li><li>在叶子节点中，根据页目录定位记录所在槽，单位到槽后，遍历槽内记录，找到主键为6的记录</li></ol><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="一、前缀索引优化"><a href="#一、前缀索引优化" class="headerlink" title="一、前缀索引优化"></a>一、前缀索引优化</h2><blockquote><p>使用某字段中字符串的前几个字符建立索引。</p></blockquote><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引个数，降低树的高度，有效的提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>前缀索引的局限性：</p><ul><li>order by无法使用前缀索引</li><li>无法把前缀索引用作覆盖索引</li></ul><h2 id="二、覆盖索引优化"><a href="#二、覆盖索引优化" class="headerlink" title="二、覆盖索引优化"></a>二、覆盖索引优化</h2><blockquote><p>使用作为联合索引的字段覆盖查询语句中的所有字段。避免回表操作。</p></blockquote><p>当在二级索引的叶子节点中能找到查询语句中所需要的字段，那么就不需要再通过聚簇索引查询完整行记录来获取需要的字段。</p><p>例如查询商品的名称、价格，如何避免回表？</p><p>我们可以建立一个联合索引，即（商品ID、名称、价格）作为联合索引，索引中存在名称和价格字段，查询语句需要的字段可以直接在二级索引中获取，不需要再通过主键索引，避免了回表，减少了I&#x2F;O操作。</p><h2 id="三、主键索引自增"><a href="#三、主键索引自增" class="headerlink" title="三、主键索引自增"></a>三、主键索引自增</h2><blockquote><p>主键索引设置为自增，这样可以避免页分裂。</p></blockquote><p>InnoDB创建主键索引默认为聚簇索引，数据被存放到B+Tree的叶子节点上。也就是说，同一叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据被插入，数据库会根据主键将其插入对应的叶子节点中。</p><p>若使用自增主键：</p><p>每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当该叶子节点页写满后，会自动开辟一个新页面。因为每次插入一条新记录都是追加操作，不需要移动已有数据，因此插入的效率很高。</p><p>若不使用自增主键：</p><p>每次插入主键的索引值都是随机的，因此插入新的数据，可能会插入到现有数据页中间的位置，这样的话就需要移动其他数据来满足新数据的插入，甚至如果该页没有剩余空间，还需要从一个页面复制数据到另一个页面，我们称这种情况为<strong>页分裂</strong>。页分裂可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p><p><strong>此外需要注意：</strong>主键字段的长度不要太大。因为二级索引叶子节点存储的数据是主键字段值，所以说主键长度越短，二级索引占用的空间也就越小</p><h2 id="四、索引设置为NOT-NULL"><a href="#四、索引设置为NOT-NULL" class="headerlink" title="四、索引设置为NOT NULL"></a>四、索引设置为NOT NULL</h2><p>为了更好地利用索引，索引类要设置NOT NULL约束，原因如下：</p><ul><li>索引列存在NULL会使优化器做索引选择的时候更复杂，更难优化。因为可为NULL的列会使索引、索引统计和值比较都更复杂，比如进行索引统计的时候，count会省略值为NULL的行。</li><li>NULL值没有意义，但占用物理空间。允许为NULL会带来存储空间占用的问题。</li></ul><h2 id="五、防止索引失效"><a href="#五、防止索引失效" class="headerlink" title="五、防止索引失效"></a>五、防止索引失效</h2><p>常见索引失效场景：</p><ul><li>左模糊匹配</li><li>对索引列进行计算、函数、类型转换</li><li>没有遵循最左匹配原则</li><li>WHERE子句中，OR前条件为索引列，OR后条件不是索引列</li></ul><h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><p>可以使用使用explain来查看查询语句的执行计划，如图：</p><p><img src="/2022/11/05/MySQL-%E7%B4%A2%E5%BC%95/798ab1331d1d6dff026e262e788f1a28.png" alt="img"></p><p>执行计划中的参数：</p><ul><li>type：数据扫描类型（重点关注）</li><li>possible_key：表示可能用到的索引</li><li>key：实际用到的索引</li><li>key_len：索引的长度</li><li>rows：预估扫描的数据行数</li></ul><h2 id="type参数"><a href="#type参数" class="headerlink" title="type参数"></a>type参数</h2><blockquote><p>type字段描述了找到所需数据时使用的扫描方式是什么。</p></blockquote><p>常见的扫描类型（根据执行效率从低到高排序）：</p><ul><li>ALL（全表扫描）</li><li>index（全索引扫描）</li><li>range（索引范围扫描）</li><li>ref（非唯一索引扫描）</li><li>eq_ref（唯一索引扫描）</li><li>const（结果只有一条的主键或唯一索引扫描）</li></ul><h3 id="index和all"><a href="#index和all" class="headerlink" title="index和all"></a>index和all</h3><p>二者差不多，all采用全表扫描。而index是对索引表进行全扫描，比all好在不需要再对数据进行排序，但是开销依然很大。所以要尽量避免全表扫描和全索引扫描。</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>range表示采用索引范围扫描，一般再WHERE子句中使用&lt;、&gt;、in、between等关键字，只检索给定范围的行，属于范围查找。</p><p>从这一几倍开始，索引的作用会越来越明显，因此我们要尽量让SQL查询可以使用到range这一级别及以上的type访问方式。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref类型标识采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据可能是多条。因为使用了索引，但该索引列的值并不唯一，有重复，这样即使使用索引快速找到了第一条符合条件的数据，但仍不能停止，要进行目标值附件的小范围扫描。但是它的好处是它只需要在一个很小的范围内扫描，因为索引是有序的。</p><h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>eq_ref类型是使用主键或唯一索引产生的访问方式，通常使用在多表联查中。</p><p>比如，对两张表进行联查，关联条件是两张表的user_id相等，且user_id是唯一索引，那么使用EXPLAIN进行执行计划查看的时候，type就会显式eq_ref。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const类型表示使用了主键或唯一索引与常量值进行比较，例如<code>select name from product where id = 1</code>。</p><p>const和eq_ref都使用了主键或唯一索引，不过这两个类型有所区别：const是与常量进行比较，查询效率更快，而eq_ref通常用于多表联查中。</p><h2 id="extra参数"><a href="#extra参数" class="headerlink" title="extra参数"></a>extra参数</h2><p>extra中的几个重要参考指标：</p><ul><li><p>Using filesort（使用排序算法）</p><blockquote><p>当查询语句中包含group by操作，而且无法利用索引完成排序操作的时候，这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率很低，所以要避免这种问题的出现。</p></blockquote></li><li><p>Using tmporary（使用临时表）</p><blockquote><p>使用了临时表保存中间结果，MySQL在对查询结果进行排序时使用临时表，常见于排序order by和分组查询group by。效率低，要避免这种问题的出现。</p></blockquote></li><li><p>Using index（使用索引覆盖）</p><blockquote><p>所需的数据只需在索引即可全部获得，无须再到表中去数据，也就是使用了索引覆盖，避免了回表操作，效率不错。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-select语句的执行过程</title>
    <link href="/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>MySQL执行一条查询语句的流程：</p><p><img src="/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><p>MySQL的架构分为两层：</p><ul><li><p>Server层：负责建立连接、分析和执行SQL</p><blockquote><p>核心模块：连接器、查询缓存、解析器、预处理器、优化器、执行器</p><p>实现内置函数：时间、日期、数学、加密函数</p><p>实现跨存储引擎的功能：存储过程、触发器、视图</p></blockquote></li><li><p>存储引擎层：负责数据的存储和提取</p><blockquote><p>MySQL的存储引擎：InnoDB、MyISAM、Memory</p><p>不同存储引擎共用一个Server层。</p><p>索引的数据结构在存储引擎层实现，不同引擎支持的索引类型也不同。</p></blockquote></li></ul><h1 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h1><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><blockquote><p>MySQL连接的过程需要TCP三次握手，因为MySQL是基于TCO协议进行传输。</p></blockquote><p>命令行连接MySQL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-u 指定用户名，管理员角色名为 root；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span><br>mysql -h$ip -u$user -p<br></code></pre></td></tr></table></figure><p>关于用户的权限：</p><p>如果用户名和密码都没有问题，那么连接器就会获取用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限的验证。所以，如果一个用户已经建立一个连接，在中途管理员修改了该用户的权限，也不会影响已经存在的连接的权限。</p><h2 id="连接的管理"><a href="#连接的管理" class="headerlink" title="连接的管理"></a>连接的管理</h2><h3 id="查看连接数量"><a href="#查看连接数量" class="headerlink" title="查看连接数量"></a>查看连接数量</h3><p>在登录MySQL服务器后，使用<code>show processlist</code>命令</p><p><img src="/2022/11/05/MySQL-select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png" alt="img"></p><p>Command列表示连接的状态，Sleep状态的Time列表示其空闲的时长</p><h3 id="空闲连接的断开"><a href="#空闲连接的断开" class="headerlink" title="空闲连接的断开"></a>空闲连接的断开</h3><ul><li><p>MySQL自动断开：</p><blockquote><p>MySQL定义了空闲连接的最大空闲时长，由<code>wait_timeout</code>参数控制，默认8小时，若超过  该是时长，连接器会自动断开连接。</p></blockquote></li><li><p>手动断开：</p><blockquote><p>使用<code>kill connection + id</code>的命令，可以主动断开连接</p></blockquote></li></ul><p>一个连接被服务器断开后，客户端并不会马上感知到，只有等客户端再发起下一个请求的时候才会报错。</p><h3 id="连接数量限制"><a href="#连接数量限制" class="headerlink" title="连接数量限制"></a>连接数量限制</h3><p>MySQL服务支持的最大连接数由<code>max_connection</code>参数控制。</p><h3 id="MySQL长连接"><a href="#MySQL长连接" class="headerlink" title="MySQL长连接"></a>MySQL长连接</h3><blockquote><p>MySQL也和HTTP一样，有长连接和短链接的概念。</p></blockquote><p><strong>使用长连接的好处：</strong></p><p>使用长连接可以减少建立连接和断开连接的过程</p><p><strong>使用长连接的问题：</strong></p><p>使用长连接后可能会占用内存增多。因为MySQL在执行查询过程中临时使用内存管理连接对象，这些连接对象只有在连接断开的时候才会释放。如果长连接累计很多，将导致MySQL服务器占用内存过大，可能会被系统强制回收，导致MySQL服务器异常重启。</p><p><strong>长连接内存占用问题的解决：</strong></p><ul><li><p>方法一、服务器定时断开长连接</p></li><li><p>方法二、客户端主动重置连接</p><blockquote><p>客户端在执行了一个很大的操作过后，在代码中调用<code>mysql_reset_connection</code>函数来重置连接，达到释放内存的效果。重置连接不需要重连和重新做权限验证，只是将连接恢复至刚刚创建时的状态。</p></blockquote></li></ul><h2 id="连接器工作总结"><a href="#连接器工作总结" class="headerlink" title="连接器工作总结"></a>连接器工作总结</h2><ul><li>与客户端进行TCP三次握手建立连接</li><li>验证用户名和密码，若错误，则报错</li><li>用户名和密码都正确，会读取用户的权限并保存，用于该连接后续的权限逻辑判断</li></ul><h1 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a><del>第二步：查询缓存</del></h1><blockquote><p>MySQL 8.0后的版本已经将查询缓存删掉了。</p><p>查询缓存属于Server层，移除的是Server层的查询缓存，而不是Innodb存储引擎的buffer pool。</p></blockquote><p>查询缓存的执行步骤：</p><ol><li><p>连接器工作完成后，客户端可以向MySQL发送SQL语句，MySQL服务器在收到SQL语句后，就会解析SQL语句的额第一个字段，看看是什么类型的语句。</p></li><li><p>若是查询语句，MySQL则会先去查询缓存中找是否有这条语句执行后的缓存数据。查询缓存是以Key-Value的形式保存在内存中，Key为SQL查询语句，Value为SQL语句查询结果。</p></li><li><p>若查询的语句命中查询缓存，那么就直接返回value给客户端，若没有命中，则继续执行查询流程，执行完后，将查询结果缓存。</p></li></ol><p>查询缓存被抛弃的原因：</p><p>对于更新比较频繁的表，查询缓存的命中率很低，因为只要有一个表有更新，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用，刚好这个表就有更新操作了，那么这个缓存还没被使用过就被清空了。</p><h1 id="第三步：解析SQL"><a href="#第三步：解析SQL" class="headerlink" title="第三步：解析SQL"></a>第三步：解析SQL</h1><p>在执行SQL查询语句之前，MySQL会对SQL语句做解析，由<strong>解析器</strong>完成。</p><ol><li><p>词法分析</p><blockquote><p>MySQL会根据输入的SQL语句识别关键字，构建出SQL语法树，这样方便后面的模块获取SQL类型、表名、字段名、where条件等。</p></blockquote></li><li><p>语法分析</p><blockquote><p>根据词法分析的结果，语法解析器会根据语法规则，判断这个SQL语句是否满足MySQL语法。</p></blockquote></li></ol><p>在这个阶段会检测拼写错误和语法错误，而表和字段是否存在的判断不是在解析器中完成的。</p><h1 id="第四步：执行SQL"><a href="#第四步：执行SQL" class="headerlink" title="第四步：执行SQL"></a>第四步：执行SQL</h1><p>执行分为三个阶段：</p><ol><li><p>prepare阶段，预处理</p></li><li><p>optimize阶段，优化</p></li><li><p>execute阶段，执行</p></li></ol><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>预处理器的工作：</p><ul><li><p>检查SQL查询语句中的表或字段是否存在。</p></li><li><p>将<code>select *</code> 中的<code>*</code>符号，拓展为表上的所有列。</p></li></ul><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过预处理阶段后，需要为SQL查询语句制定的一个<strong>执行计划</strong>。</p><p>执行计划的制定由优化器完成，优化器基于查询成本考虑会选择成本最低的方案（主要是索引的选择）。</p><p>explain命令：</p><blockquote><p>在查询语句前面加个explain命令，就会输出这条查询语句的执行计划（注意只是计划，而不是真正执行这条语句）。</p></blockquote><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>经过优化器优化，确定了执行计划，接下来就要真正开始执行语句了。</p><p>执行计划的执行由执行器完成，在执行过程中，执行器会和存储引擎交互，交互是以记录为单位。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。</p><p>使用设计者模式的<strong>目的</strong>：</p><ul><li>为了实现软件开发的可维护、可扩展</li><li>尽量复用代码</li><li>降低代码的耦合度</li></ul><p>设计模式主要是基于OOP编程提炼的，它基于以下几个<strong>原则</strong>：</p><ul><li><p>开闭原则</p><blockquote><p>软件应对扩展开放，而对修改关闭。</p><p>具体指的是，在增加新功能的时候，最好不要通过修改原有代码来增加功能，而是通过增加新的代码来完成新的功能。</p></blockquote></li><li><p>里氏替换原则</p><blockquote><p>如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行</p></blockquote></li></ul><p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计地复杂度和灵活性，并意识到设计模式并不是完成的。</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>关注点：如何创建对象。</p><p>核心思想：要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p><h2 id="1-工厂方法（Factory-Method）"><a href="#1-工厂方法（Factory-Method）" class="headerlink" title="1. 工厂方法（Factory Method）"></a>1. 工厂方法（Factory Method）</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。</p></blockquote><h3 id="Number工厂方法"><a href="#Number工厂方法" class="headerlink" title="Number工厂方法"></a>Number工厂方法</h3><p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品。</p><p>以解析String到Number的工厂为例，解释工厂方法。</p><p>Number工厂定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象工厂：NumberFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-comment">//抽象产品：Number</span><br>    Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span>;<br>&#125;<br><span class="hljs-comment">//实际工厂：NumberFactoryImpl</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//实际产品；BigDecimal</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端获取实际工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在抽象工厂接口中定义一个静态方法getFactory来获取真正的工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-comment">// 创建方法:</span><br>    Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span>;<br><br>    <span class="hljs-comment">// 获取工厂实例:</span><br>    <span class="hljs-keyword">static</span> NumberFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> impl;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">NumberFactory</span> <span class="hljs-variable">impl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFactoryImpl</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在客户端中，只需要和工厂接口NumberFactory和抽象产品交互：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NumberFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> NumberFactory.getFactory();<br><span class="hljs-type">Number</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> factory.parse(<span class="hljs-string">&quot;123.456&quot;</span>);<br></code></pre></td></tr></table></figure><p>调用方可以完全忽略真正的工厂和实际的产品，这样即使创建产品的代码变化也不会影响到调用方。</p><h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><blockquote><p>很多时候我们不需要抽象工厂，而是直接通过工厂类的静态方法来返回产品</p></blockquote><p>去掉抽象工厂接口后的静态工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Number <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java标准库中就有很多静态工厂方法设计的类，比如Integer和List。</p><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><p>Integer即是产品又是静态工厂。它提供了静态方法valueOf()来创建Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缓存优化：</strong></p><p>使用Integer.valueOf()和new Integer()之间的区别：</p><ul><li><p>使用new来获取一个Integer一定是新建一个对象。</p></li><li><p>而使用valueOf()来获取一个对象，工厂方法可以选择new一个新的Integer，也可以返回一个缓存的Integer。这样就可以避免创建过多重复的Integer对象。因为对于调用方而言，它不关心Integer的创建细节。</p></li></ul><p>工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p><h4 id="lIST"><a href="#lIST" class="headerlink" title="lIST"></a>lIST</h4><p>这个静态工厂方法接收可变参数，然后返回List接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意：调用方获取的产品总是List接口，而且并不关心它的实际类型（里氏替换原则）。</p><h2 id="2-抽象工厂（Abstract-Factory）"><a href="#2-抽象工厂（Abstract-Factory）" class="headerlink" title="2. 抽象工厂（Abstract Factory）"></a>2. 抽象工厂（Abstract Factory）</h2><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></blockquote><p>抽象工厂模式和工厂方法不太一样，它需要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建。因此这个抽象工厂会对应到多个实际工厂，而每个实际工厂负责创建多个实际产品。</p><p>关系示意图如下：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030102323353.png" alt="image-20221030102323353"></p><p>这种模式有点类似于多个供应商提供一系列类型的产品。</p><p>举个例子，我们希望位用户提供一个Markdown文本转HTML和Word的服务，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象工厂接口：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-comment">// 创建Html文档:</span><br>    HtmlDocument <span class="hljs-title function_">createHtml</span><span class="hljs-params">(String md)</span>;<br>    <span class="hljs-comment">// 创建Word文档:</span><br>    WordDocument <span class="hljs-title function_">createWord</span><span class="hljs-params">(String md)</span>;<br>&#125;<br><br><span class="hljs-comment">//抽象产品接口：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HtmlDocument</span> &#123;<br>    String <span class="hljs-title function_">toHtml</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WordDocument</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面只是定义了接口，对于用户而言，只需要接触上面的接口。具体的实现比较困难，由供应商来完成。</p><p>供应商FastDoc Soft的产品便宜，并且转换速度快。供应商GoodDoc Soft的产品贵，但是转换效果好。我们可以同时使用这两家供应商的产品，以便给免费用户和付费用户提供差异化的服务。</p><p>FaseDoc Soft的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实际的产品</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastHtmlDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HtmlDocument</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toHtml</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastWordDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WordDocument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ...<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实际的工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> HtmlDocument <span class="hljs-title function_">createHtml</span><span class="hljs-params">(String md)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastHtmlDocument</span>(md);<br>    &#125;<br>    <span class="hljs-keyword">public</span> WordDocument <span class="hljs-title function_">createWord</span><span class="hljs-params">(String md)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastWordDocument</span>(md);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用Fast Doc的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建AbstractFactory，实际类型是FastFactory:</span><br><span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastFactory</span>();<br><span class="hljs-comment">// 生成Html文档:</span><br><span class="hljs-type">HtmlDocument</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> factory.createHtml(<span class="hljs-string">&quot;#Hello\nHello, world!&quot;</span>);<br>html.save(Paths.get(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;fast.html&quot;</span>));<br><span class="hljs-comment">// 生成Word文档:</span><br><span class="hljs-type">WordDocument</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> factory.createWord(<span class="hljs-string">&quot;#Hello\nHello, world!&quot;</span>);<br>word.save(Paths.get(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;fast.doc&quot;</span>));<br></code></pre></td></tr></table></figure><p>如果客户端要调用不同的服务，只需要把new FastFactory换成new其他的实际工厂即可。</p><p>如果将获取实际工厂的代码封装到AbstractFactory中，那么在客户端则可以和实际工厂完全解耦，要调用不同的服务只需要不同过的名字即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建AbstractFactory，实际类型是FastFactory:</span><br><span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> FastFactory.createFactory(<span class="hljs-string">&quot;fast&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractFactory <span class="hljs-title function_">createFactory</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (name.equalsIgnoreCase(<span class="hljs-string">&quot;fast&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.equalsIgnoreCase(<span class="hljs-string">&quot;good&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GoodFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid factory name&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-生成器-Builder"><a href="#3-生成器-Builder" class="headerlink" title="3. 生成器(Builder)"></a>3. 生成器(Builder)</h2><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>生成器模式是使用多个“小型”工厂来最终创建出一个完成对象。当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p><h3 id="Markdown转HTML"><a href="#Markdown转HTML" class="headerlink" title="Markdown转HTML"></a>Markdown转HTML</h3><p>如果说是针对以下一行文本的转换，使用一个转换器即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markd"># this is a heading<br></code></pre></td></tr></table></figure><p>如果将整个Markdown文档转HTML看作一行一行的转换，每一行根据语法，调用不同的转换器：</p><ul><li>#开头，使用HeadingBuilder转换</li><li>&gt;开头，使用QuoteBuilder转换</li><li>—开头，使用HrBuider转换</li><li>其余使用ParagraphBuilder转换</li></ul><p>HtmlBuider写出来如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HtmlBuilder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HeadingBuilder</span> <span class="hljs-variable">headingBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeadingBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HrBuilder</span> <span class="hljs-variable">hrBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HrBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ParagraphBuilder</span> <span class="hljs-variable">paragraphBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParagraphBuilder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">QuoteBuilder</span> <span class="hljs-variable">quoteBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuoteBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toHtml</span><span class="hljs-params">(String markdown)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">//读取每一行，根据不同的语法，调用不同的子Builder</span><br>        markdown.lines().forEach(line -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;#&quot;</span>)) &#123;<br>                buffer.append(headingBuilder.buildHeading(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;&gt;&quot;</span>)) &#123;<br>                buffer.append(quoteBuilder.buildQuote(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;---&quot;</span>)) &#123;<br>                buffer.append(hrBuilder.buildHr(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                buffer.append(paragraphBuilder.buildParagraph(line)).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们只需要针对每一种类型编写对应的Builder，如果需要修改或增加一种语法，只需要修改或增加一个Builder即可，不需要对整个HtmlBuilder进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeadingBuilder</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">buildHeading</span><span class="hljs-params">(String line)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (line.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            n++;<br>            line = line.substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;&lt;h%d&gt;%s&lt;/h%d&gt;&quot;</span>, n, line.strip(), n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，使用Builder模式，适用于创建比较复杂的对象，先一步一步构造出零件，最后再将零件组装成一个整体对象。</p><h3 id="MimeMessage"><a href="#MimeMessage" class="headerlink" title="MimeMessage"></a>MimeMessage</h3><p>JavaMail的MimeMessage就可以看作是一个Builder模式，只不过它既是Builder也是最终产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 构造产品</span><br><span class="hljs-type">Multipart</span> <span class="hljs-variable">multipart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMultipart</span>();<br><span class="hljs-comment">// 添加text:</span><br><span class="hljs-type">BodyPart</span> <span class="hljs-variable">textpart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeBodyPart</span>();<br>textpart.setContent(body, <span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>multipart.addBodyPart(textpart);<br><span class="hljs-comment">// 添加image:</span><br><span class="hljs-type">BodyPart</span> <span class="hljs-variable">imagepart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeBodyPart</span>();<br>imagepart.setFileName(fileName);<br>imagepart.setDataHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayDataSource</span>(input, <span class="hljs-string">&quot;application/octet-stream&quot;</span>)));<br>multipart.addBodyPart(imagepart);<br><br><span class="hljs-comment">// 2. 发送邮件</span><br><span class="hljs-type">MimeMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMessage</span>(session);<br><span class="hljs-comment">// 设置发送方地址:</span><br>message.setFrom(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InternetAddress</span>(<span class="hljs-string">&quot;me@example.com&quot;</span>));<br><span class="hljs-comment">// 设置接收方地址:</span><br>message.setRecipient(Message.RecipientType.TO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternetAddress</span>(<span class="hljs-string">&quot;xiaoming@somewhere.com&quot;</span>));<br><span class="hljs-comment">// 设置邮件主题:</span><br>message.setSubject(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">// 设置邮件内容为multipart:</span><br>message.setContent(multipart);<br></code></pre></td></tr></table></figure><h3 id="链式调用的构造器"><a href="#链式调用的构造器" class="headerlink" title="链式调用的构造器"></a>链式调用的构造器</h3><p>很多时候，可以简化Builder模式，以链式调用的方式来创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>builder.append(secure ? <span class="hljs-string">&quot;https://&quot;</span> : <span class="hljs-string">&quot;http://&quot;</span>)<br>       .append(<span class="hljs-string">&quot;www.liaoxuefeng.com&quot;</span>)<br>       .append(<span class="hljs-string">&quot;/&quot;</span>)<br>       .append(<span class="hljs-string">&quot;?t=0&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> builder.toString();<br></code></pre></td></tr></table></figure><p>例如构造URL字符串，可以适用Builder模式编写URLBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> URLBuilder.builder() <span class="hljs-comment">// 创建Builder</span><br>        .setDomain(<span class="hljs-string">&quot;www.liaoxuefeng.com&quot;</span>) <span class="hljs-comment">// 设置domain</span><br>        .setScheme(<span class="hljs-string">&quot;https&quot;</span>) <span class="hljs-comment">// 设置scheme</span><br>        .setPath(<span class="hljs-string">&quot;/&quot;</span>) <span class="hljs-comment">// 设置路径</span><br>        .setQuery(Map.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;K&amp;R&quot;</span>)) <span class="hljs-comment">// 设置query</span><br>        .build(); <span class="hljs-comment">// 完成build</span><br></code></pre></td></tr></table></figure><h2 id="4-原型（Prototype）"><a href="#4-原型（Prototype）" class="headerlink" title="4. 原型（Prototype）"></a>4. 原型（Prototype）</h2><blockquote><p>用原型实例指定创建对象的类型，并且通过拷贝这些原型创建新的对象。</p></blockquote><p>JDK中的原型模式：</p><p>如果我们已经有一个String[]数组，想要再创建一个一摸一样的String[]数组该如何实现？</p><p>实际上创建过程很简单，创建一个同样大小的新数组，然后将数组元素一一复制到新数组即可。如果我们将这个过程封装一下，那么就是原型模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原型:</span><br>String[] original = &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span> &#125;;<br><span class="hljs-comment">// 新对象:</span><br>String[] copy = Arrays.copyOf(original, original.length);<br></code></pre></td></tr></table></figure><p>Object的clone() 方法：</p><p>对于一个普通类，要实现原型的拷贝，可以通过Object提供的clone()方法，需要实现一个Cloneable接口标记来标识对象是“可复制的”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-comment">// 复制新对象并返回:</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        std.id = <span class="hljs-built_in">this</span>.id;<br>        std.name = <span class="hljs-built_in">this</span>.name;<br>        std.score = <span class="hljs-built_in">this</span>.score;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>clone()方法的缺点：</p><p>因为clone()的方法签名是在Object中，返回的类型也是Object，所以需要强制转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">std1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>std1.setId(<span class="hljs-number">123</span>);<br>std1.setName(<span class="hljs-string">&quot;Bob&quot;</span>);<br>std1.setScore(<span class="hljs-number">88</span>);<br><span class="hljs-comment">// 复制新对象:</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">std2</span> <span class="hljs-operator">=</span> (Student) std1.clone();<span class="hljs-comment">//clone得到是Object对象，需要强制转型</span><br>System.out.println(std1);<br>System.out.println(std2);<br>System.out.println(std1 == std2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>所以说使用原型模式的更好方法是定义一个copy()方法，返回明确的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        std.id = <span class="hljs-built_in">this</span>.id;<br>        std.name = <span class="hljs-built_in">this</span>.name;<br>        std.score = <span class="hljs-built_in">this</span>.score;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给拎一个对象共享的。只有存储简单类型的“值”对象可以复制。</p><h2 id="5-单例"><a href="#5-单例" class="headerlink" title="5. 单例"></a>5. 单例</h2><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote><h3 id="单例创建与获取"><a href="#单例创建与获取" class="headerlink" title="单例创建与获取"></a>单例创建与获取</h3><p>如何创建单例：</p><p>因为这个类只有一个实例，一次不能通过new来创建实例。所以，单例的构造方法必须是private，这样就防止调用方通过new来创建实例，但是再类的内部，可以用一个静态字段来引用唯一创建的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何获取单例：</p><ul><li><p>对外提供一个静态方法，直接放回实例</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 通过静态方法返回实例:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>直接把static变量暴露给外部</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态字段引用唯一实例:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>综上，单例模式的实现只需要如下操作：</p><ul><li>只有private构造方法，确保外部无法实例化；</li><li>通过private static变量持有唯一实例，确保全局唯一性；</li><li>通过public static方法返回此唯一实例，使外部调用方能获取到实例。</li></ul><h3 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h3><h4 id="延迟加载单例的实现"><a href="#延迟加载单例的实现" class="headerlink" title="延迟加载单例的实现"></a>延迟加载单例的实现</h4><p>延迟加载，即在调用方第一次调用getInstance()时才初始化全局唯一实例，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在多线程中，上面这种写法是错误的，在多线程竞争中会创建多个实例，必须对整个方法加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>加锁严重影响性能，可以使用双重检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Java内存模型的重排序，上面的双重检查会导致实例还未初始化完成，引用就被暴露，还需要使用volatile修饰单例变量。要实现线程安全的延时加载，可以通过Java的ClassLoader机制完成。</p><p>如果没有特殊需求，使用Singleton模式的时候，最好不要使用延迟加载，这样更简单。</p><h4 id="通过枚举类的实现"><a href="#通过枚举类的实现" class="headerlink" title="通过枚举类的实现"></a>通过枚举类的实现</h4><p>因为Java保证枚举类的每个枚举都是单例，所以编写一个只有一个枚举的类即可实现单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">World</span> &#123;<br>    <span class="hljs-comment">// 唯一枚举:</span><br>INSTANCE;<br>    <br><span class="hljs-comment">//枚举类可以定义自己的字段、方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;world&quot;</span>;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> World.INSTANCE.getName();<br></code></pre></td></tr></table></figure><p>枚举实现单例模式还避免了第一种方法实现单例模式的一个潜在问题：即序列化和反序列化会绕过普通类的private构造方法从而创建多个实例。而枚举类就没有这个问题。</p><h4 id="通过约定实现"><a href="#通过约定实现" class="headerlink" title="通过约定实现"></a>通过约定实现</h4><p>何时使用Singleton？</p><p>实际上，很多应用程序，尤其是Web程序，大部分服务类都应该被视作Singleton。</p><p>如果全部都按照Singleton的写法来实现这些服务会很麻烦，所以，通常 通过约定让框（例如Spring）来实例化这些类，让框架来保证只有一个实例，调用方自觉通过框架获取实例，而不是new操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 表示一个单例组件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，除非确实有必要，否则Singleton模式一般以“约定”为主，不会可以去实现它。</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式主要设计如何组合各种对象以便获得更好、更灵活得结构。</p><p>虽然面向对象得继承机制提供了最基本得子类扩展父类得功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p><h2 id="6-适配器（Adapter）"><a href="#6-适配器（Adapter）" class="headerlink" title="6. 适配器（Adapter）"></a>6. 适配器（Adapter）</h2><blockquote><p>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>如果一个接口需要B接口，但是传入的对象缺是A接口，需要如何解决？</p><p>例如：我们已有一个Task类，实现了Callable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Long&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> num;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> &#123;<br>        <span class="hljs-built_in">this</span>.num = num;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; n &lt;= <span class="hljs-built_in">this</span>.num; n++) &#123;<br>            r = r + n;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + r);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若我们想通过一个线程去执行它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-number">123450000L</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(callable); <span class="hljs-comment">// compile error!</span><br>thread.start();<br></code></pre></td></tr></table></figure><p>上面的代码无法编译，因为Thread接收Runable接口，不能接收Callable接口。怎么解决？</p><p>方法一、改写Task类，把实现Callable接口改为Runable接口。</p><blockquote><p>这样做可以让Thread这儿的代码正常运行，但是Task在其他地方可能正作为Callable被引用，改写Task的接口会导致其他正常工作的代码无法编译。即牵一发而动全身。</p></blockquote><p>方法二、不改写Task类，而是用一个新建一个Adapter类来包装Task</p><blockquote><p>首先，Adapter实现Runable接口，作为参数传入Thread</p><p>然后，Adapter通过持有Task实例，实际的方法调用是调用被Adapter包装的Task</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-number">123450000L</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>(callable));<br>thread.start();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 引用待转换接口:</span><br>    <span class="hljs-keyword">private</span> Callable&lt;?&gt; callable;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RunnableAdapter</span><span class="hljs-params">(Callable&lt;?&gt; callable)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callable = callable;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现指定接口:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 将指定接口调用委托给转换接口调用:</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            callable.call();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java标准库中适配器模式的应用：</p><ul><li><p>List[] Arrays.asList(T[])</p><blockquote><p>若我们持有一个String[]，但是需要的是List接口，则可以通过一个Adapter来转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;Good&quot;</span>, <span class="hljs-string">&quot;morning&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>&#125;;<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(exist));<br></code></pre></td></tr></table></figure><p>List[] Arrays.asList([])就相当于一个转换器，可以把数组转换为List</p></blockquote></li><li><p>InputStreamReader</p><blockquote><p>若我们持有一个InputStream，但是希望调用readText(Reader)方法，需要的是一个Reader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> Files.newInputStream(Paths.get(<span class="hljs-string">&quot;/path/to/file&quot;</span>));<br><span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(input, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>readText(reader);<br></code></pre></td></tr></table></figure><p>InputStreamReader就是Java标准库提供的Adapter，它负责将InputStream适配为Reader</p></blockquote></li></ul><p>面向抽象编程原则（面向抽象编程）：</p><p>如果上面的readText(Reader)方法参数从Reader改为FileReader，那么我们需要将InputStream适配为FileReader，直接使用inputStreamReader进行转换得到的是Reader，无法使用，这个时候就会跟麻烦。所以说，我们需要面向抽象编程，持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类型，想要做一些改动就会很困难。</p><h2 id="7-桥接（Bridge）"><a href="#7-桥接（Bridge）" class="headerlink" title="7. 桥接（Bridge）"></a>7. 桥接（Bridge）</h2><blockquote><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p></blockquote><p>假设某汽车厂商生产三个品牌地汽车：Big、Tiny和Boss，每个品牌又可以选择燃油、纯电和混合动力。</p><p>若使用传统的继承来表示最终车型，则有三个抽象类和九个最终子类：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030184005805.png" alt="image-20221030184005805"></p><p>若要新增一个品牌，或新增新引擎的车（比如核动力），那么子类的数量增长更快。</p><p>桥接模式就是为了避免直接继承带来的子类数量暴增问题。</p><p>桥接模式的解决办法：</p><ul><li><p>首先把Car按品牌进行子类化，但是每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br> <span class="hljs-comment">// 引用Engine:</span><br> <span class="hljs-keyword">protected</span> Engine engine;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Engine engine)</span> &#123;<br>     <span class="hljs-built_in">this</span>.engine = engine;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>紧接着，在一个“修正”的抽象类RefindeCar中定义一些额外操作：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RefinedCar</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">super</span>(engine);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.engine.start();<br>        System.out.println(<span class="hljs-string">&quot;Drive &quot;</span> + getBrand() + <span class="hljs-string">&quot; car...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getBrand</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>最终，不同品牌的继承自RefinderCar。不同的引擎继承自Engine</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RefinedCar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BossCar</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">super</span>(engine);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBrand</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Boss&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HybridEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Start Hybrid Engine...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>客户端通过自己选择一个品牌，在配合一种引擎，得到最终的Car：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RefinedCar</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BossCar</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HybridEngine</span>());<br>car.drive();<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>桥接模式的好处在于，如果要增加一种引擎，只需要针对Engine派生一个新的子类，如果需要增加一个品牌，只需要针对RefindedCar派生一个子类。任何RefindedCar的子类和任何Engine都可以自由组合，即一辆车的两个维度：品牌和引擎都可以独立地变化。</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030185415196.png" alt="image-20221030185415196"></p><p>桥接模式实现比较复杂，实际应用也非常少，但是它提供的设计思想值得借鉴，即：</p><p><strong>不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</strong></p><h2 id="8-组合（Composite）"><a href="#8-组合（Composite）" class="headerlink" title="8. 组合（Composite）"></a>8. 组合（Composite）</h2><blockquote><p>将对象组合成树形结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><p>组合模式经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p><p>以XML的树形表示为例：</p><p>在XML或HTML中，从根节点开始，每个节点都能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。</p><p>若要以树的结构抽象XML，我们先抽象出节点Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 添加一个节点为子节点:</span><br>    Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>;<br>    <span class="hljs-comment">// 获取子节点:</span><br>    List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 输出为XML:</span><br>    String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于&lt;abc&gt;这样的节点，我们称之为ElementNode，它可以作为容器包含多个子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElementNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ElementNode</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br>        list.add(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;&quot;</span> + name + <span class="hljs-string">&quot;&gt;\n&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;/&quot;</span> + name + <span class="hljs-string">&quot;&gt;\n&quot;</span>;<br>        <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;&quot;</span>, start, end);<br>        list.forEach(node -&gt; &#123;<br>            sj.add(node.toXml() + <span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> sj.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于普通文本，我们把它看作TextNode，它没有子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">private</span> String text;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TextNode</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-built_in">this</span>.text = text;<br>&#125;<br><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> List.of();<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> text;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，还可以有注释节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">private</span> String text;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CommentNode</span><span class="hljs-params">(String text)</span> &#123;<br><span class="hljs-built_in">this</span>.text = text;<br>&#125;<br><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">children</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> List.of();<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toXml</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;!-- &quot;</span> + text + <span class="hljs-string">&quot; --&gt;&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过ElementNode、TextNode和CommentNode，我们就可以构造出一颗树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;school&quot;</span>);<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;classA&quot;</span>)<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Tom&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Alice&quot;</span>)));<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElementNode</span>(<span class="hljs-string">&quot;classB&quot;</span>)<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Bob&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextNode</span>(<span class="hljs-string">&quot;Grace&quot;</span>))<br>        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommentNode</span>(<span class="hljs-string">&quot;comment...&quot;</span>)));<br>System.out.println(root.toXml());<br></code></pre></td></tr></table></figure><p>最后通过root节点输出的XML如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">classA</span>&gt;</span><br>Tom<br>Alice<br><span class="hljs-tag">&lt;/<span class="hljs-name">classA</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">classB</span>&gt;</span><br>Bob<br>Grace<br><span class="hljs-comment">&lt;!-- comment... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">classB</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可见，使用Composite模式，需要先统一单个节点以及“容器”节点的接口：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030191508298.png" alt="image-20221030191508298"></p><p>作为容器节点的ElementNode又可以添加任意个Node，这样就可以构成层级结构。</p><p>类似的，像是文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p><h2 id="9-装饰器（Decorator）"><a href="#9-装饰器（Decorator）" class="headerlink" title="9. 装饰器（Decorator）"></a>9. 装饰器（Decorator）</h2><blockquote><p>动态地给一个对象添加一些额外地职责。就增加功能来说，相比生成子类更灵活。</p></blockquote><p>装饰器模式，是一种在运行期动态地给某个对象的实例增加功能的方法。</p><p>在Java标准库中，InputStream是抽象类，FileInputStream、ServletInputStream、Socket.getInputStream ()这些都是最终数据源。如果说现在，我们要给不同的数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加数据源或功能，那么子类数量会暴涨。</p><p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最汇总通过醋和获得我们想要地功能。</p><p>例如：给FileInputStream增加缓冲和解压缩功能，用Decorator模式地写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建原始的数据源:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.gz&quot;</span>);<br><span class="hljs-comment">// 增加缓冲功能:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br><span class="hljs-comment">// 增加解压缩功能:</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">gis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GZIPInputStream</span>(bis);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GZIPInputStream</span>( <span class="hljs-comment">// 第二层装饰</span><br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>( <span class="hljs-comment">// 第一层装饰</span><br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.gz&quot;</span>) <span class="hljs-comment">// 核心功能</span><br>                        ));<br></code></pre></td></tr></table></figure><p>观察BufferedInputStream和GZIPInputStream的继承关系，它们都是从FilterInputStream继承来的，而FilterInputStream是一个抽象类。</p><p>用图表示Decorator模式：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221030192800637.png" alt="image-20221030192800637"></p><ul><li><p>最顶层的Component是接口。对应到IO就是InputStream这个抽象类。</p></li><li><p>ComponentA、ComponentB则是实际的子类。对应到IO就是FileInputStream、ServletInputStream这些数据源。</p></li><li><p>Decorator是用于实现各个附加功能的抽象装饰器。对应到IO就是FileInputStream</p></li><li><p>而从Decorator派生的就是一个个的装饰器，它们每个都有独立的功能。对应到IO就是BufferedInputStream、GZIPInputStream等</p></li></ul><p>Decorator模式有什么好处？</p><p>它实际把核心功能和附加功能给分开了。核心功能指FileInputStream这些真正读取数据的数据源，附加功能指的是缓冲、压缩、解密这些功能。如果我们要增加核心功能，就增加Component的子类，例如ByteInputStream。如果我们要增加附加功能，就增加Decorator的子类，例如CipherInputStream。两个部分可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p><p>如何设计完整地Decorator模式？</p><p>以HTML文本渲染为例，文本可以附加一些效果，如加粗、变斜体、加下划线等。为了实现动态地附加效果，可以采用Decorator模式。</p><ul><li><p>定义顶层接口TextNode：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-comment">// 设置text:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span>;<br>    <span class="hljs-comment">// 获取text:</span><br>    String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>核心节点：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpanNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-keyword">private</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;span&gt;&quot;</span> + text + <span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>抽象的Decorator类：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TextNode</span> &#123;<br>    <span class="hljs-comment">//持有一个TextNode</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> TextNode target;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">NodeDecorator</span><span class="hljs-params">(TextNode target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target.setText(text);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>具体的Decorator类：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BoldDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NodeDecorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BoldDecorator</span><span class="hljs-params">(TextNode target)</span> &#123;<br>        <span class="hljs-built_in">super</span>(target);<br>    &#125;<br><span class="hljs-comment">//附加功能</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;b&gt;&quot;</span> + target.getText() + <span class="hljs-string">&quot;&lt;/b&gt;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>客户端组合使用Decorator：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>();<br><span class="hljs-type">TextNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoldDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UnderlineDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>()));<br><span class="hljs-type">TextNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItalicDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BoldDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpanNode</span>()));<br>n1.setText(<span class="hljs-string">&quot;Hello&quot;</span>);<br>n2.setText(<span class="hljs-string">&quot;Decorated&quot;</span>);<br>n3.setText(<span class="hljs-string">&quot;World&quot;</span>);<br>System.out.println(n1.getText());<br><span class="hljs-comment">// 输出&lt;span&gt;Hello&lt;/span&gt;</span><br><br>System.out.println(n2.getText());<br><span class="hljs-comment">// 输出&lt;b&gt;&lt;u&gt;&lt;span&gt;Decorated&lt;/span&gt;&lt;/u&gt;&lt;/b&gt;</span><br><br>System.out.println(n3.getText());<br><span class="hljs-comment">// 输出&lt;i&gt;&lt;b&gt;&lt;span&gt;World&lt;/span&gt;&lt;/b&gt;&lt;/i&gt;</span><br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="10-外观（Facade）"><a href="#10-外观（Facade）" class="headerlink" title="10. 外观（Facade）"></a>10. 外观（Facade）</h2><blockquote><p>为系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></blockquote><p>外观模式的基本思想：</p><p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p><p>以注册公司为例，假设组测公司需要三步：</p><ol><li>向工商局申请营业执照；</li><li>在银行开设账户；</li><li>在税务局开设纳税号；</li></ol><p>三个接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工商注册:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminOfIndustry</span> &#123;<br>    <span class="hljs-keyword">public</span> Company <span class="hljs-title function_">register</span><span class="hljs-params">(String name)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 银行开户:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">openAccount</span><span class="hljs-params">(String companyId)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 纳税登记:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Taxation</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">applyTaxCode</span><span class="hljs-params">(String companyId)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户为了注册公司，需要逐步的去调用这些接口，比较麻烦，这个时候，直接将这些流程全部委托给中介：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>    <span class="hljs-keyword">public</span> Company <span class="hljs-title function_">openCompany</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Company</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.admin.register(name);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.bank.openAccount(c.getId());<br>        c.setBankAccount(bankAccount);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">taxCode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.taxation.applyTaxCode(c.getId());<br>        c.setTaxCode(taxCode);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，用户需要注册公司，只需要调用中介这一个接口，再由中介去执行其他具体流程，用户不需要关心中介如何完成注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用户委托中介注册公司</span><br><span class="hljs-type">Company</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> facade.openCompany(<span class="hljs-string">&quot;Facade Software Ltd.&quot;</span>);<br></code></pre></td></tr></table></figure><p>很多Web程序，内部由多个子系统提供服务，经常使用一个统一的Facade入口，例如一个RestApiController，使得外部用户调用的时候，只需要关系Facade提供的接口，不用管内部是哪个子系统处理的。</p><p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，其本质也是一个Facade（外观的外观），但可以附加一些用户认证、限流限速的额外服务。</p><h2 id="11-享元（Flyweight）"><a href="#11-享元（Flyweight）" class="headerlink" title="11. 享元（Flyweight）"></a>11. 享元（Flyweight）</h2><blockquote><p>运用共享技术有效地支持大量细粒度地对象。</p></blockquote><p>核心思想：</p><p>如果一个对象实例一经创建就不可变，那么反复创建相同地实例就没有必要，直接向调用方返回一个共享地实例就行，这样既节省内粗，又可以减少创建对象地过程，提高运行速度。</p><p>享元模式在Java标准库中地应用：Byte、Integer都是不变类。以Integer为例，通过Integer.valueOf()这个静态方法创建Integer实例，当传入地int范围在-128~到+127之间时，会直接返回缓存地Integer实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>        System.out.println(n1 == n2); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于Byte来说，因为Byte只有256个状态，所以通过Byte.valueOf()创建地Byte实例全部都是缓存对象。</p><p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓冲地实例，而不是新建实例，从而实现不可变实例的复用。（总是使用工厂方法来获取实例，而不是通过new创建实例，可以更好地复用对象）。</p><p>在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不被每次查询数据库或者读取文件，而是直接返回内存中缓存地数据。</p><p>以Student为例，设计一个静态工厂方法，在内部可以返回缓存的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 持有缓存:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Student&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 静态工厂方法:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> id + <span class="hljs-string">&quot;\n&quot;</span> + name;<br>        <span class="hljs-comment">// 先查找缓存:</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-comment">// 若没有缓存：</span><br>        <span class="hljs-keyword">if</span> (std == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 创建新对象</span><br>            System.out.println(String.format(<span class="hljs-string">&quot;create new Student(%s, %s)&quot;</span>, id, name));<br>            std = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, name);<br>            <span class="hljs-comment">// 放入缓存</span><br>            cache.put(key, std);<br>        <span class="hljs-comment">// 若已缓存：</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(String.format(<span class="hljs-string">&quot;return cached Student(%s, %s)&quot;</span>, std.id, std.name));<br>        &#125;<br>        <span class="hljs-keyword">return</span> std;<br>    &#125;<br><span class="hljs-comment">// Student属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">// Student构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际的应用中，我们经常使用成熟的缓存库，例如Guava的Cache，因为它提供了最大缓存数量限制、定时过期等实用功能。</p><h2 id="12-代理（Proxy）"><a href="#12-代理（Proxy）" class="headerlink" title="12. 代理（Proxy）"></a>12. 代理（Proxy）</h2><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><h3 id="Proxy对比Adapter"><a href="#Proxy对比Adapter" class="headerlink" title="Proxy对比Adapter"></a>Proxy对比Adapter</h3><p>Adapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BAdapter</span><span class="hljs-params">(A a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        a.a();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Proxy:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AProxy</span><span class="hljs-params">(A a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//do somthing</span><br>        <span class="hljs-built_in">this</span>.a.a();<br>        <span class="hljs-comment">//do somthing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>区别：</p><ul><li><p>Adapter是将接口A转换为接口B（适配）</p><blockquote><p>目的是为例让只能调用接口B的方法,通过Adapter的转换可以调用接口A。</p></blockquote></li><li><p>Proxy只是将接口A再包了一层（增强）</p><blockquote><p>目的是在不修改原有接口的前提下，对原有接口的方法进行增强。</p><p>可以在调用原接口方法的前后执行扩展操作。</p></blockquote></li></ul><p>可以通过Proxy设计方法进行权限检查，只有拥有对应权限的用户才可以真正调用目标接口方法。</p><p>为什么实用Proxy，而不是直接将权限检查写到接口A的内部？</p><ul><li>编写代码的原则：<ul><li>职责清晰：一个类只负责一件事</li><li>易于测试：一次只测一个功能</li></ul></li><li>代码解耦<ul><li>实用Proxy实现权限检查，代码更加清晰、简介<ul><li>A接口：只定义接口</li><li>ABusinuess类：实现A接口的业务逻辑</li><li>APermissionProxy类：只实现A接口的权限检查代理</li></ul></li><li>如果需要增加其他类型的代理，比如日志记录的代理。不需要对现有A接口、ABusiness类进行修改，只需要再写一个Proxy类即可</li></ul></li></ul><h3 id="Peoxy的应用："><a href="#Peoxy的应用：" class="headerlink" title="Peoxy的应用："></a>Peoxy的应用：</h3><ul><li><p>远程代理（Remote Proxy）</p><blockquote><p>本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法的访问转换成远程调用，然后返回结果。</p><p>Java内置的RMI机制就是一个完整的代理模式</p></blockquote></li><li><p>虚代理（Virtual Proxy）</p><blockquote><p>让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。</p><p>JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p></blockquote></li><li><p>保护代理（Protection Proxy）</p><blockquote><p>用于控制对原始对象的访问，常用于权限鉴定</p></blockquote></li><li><p>智能引用（Smart Reference）</p><blockquote><p>如果有很多客户端对它进行访问，通过内部的计数器可以再外部调用者都不使用后自动释放。</p></blockquote></li></ul><h3 id="通过代理模式编写一个JDBC连接池："><a href="#通过代理模式编写一个JDBC连接池：" class="headerlink" title="通过代理模式编写一个JDBC连接池："></a>通过代理模式编写一个JDBC连接池：</h3><p>调用者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataSource</span> <span class="hljs-variable">lazyDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyDataSource</span>(jdbcUrl, jdbcUsername, jdbcPassword);<br><br>System.out.println(<span class="hljs-string">&quot;get lazy connection...&quot;</span>);<br><span class="hljs-comment">//没有真正打开Connection</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> lazyDataSource.getConnection()) &#123;<br>    <span class="hljs-comment">// 打开了真正的Connection</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> conn.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM students&quot;</span>)) &#123; <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> ps.executeQuery()) &#123;<br>            <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>                System.out.println(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="虚代理LazyConnectionProxy的实现"><a href="#虚代理LazyConnectionProxy的实现" class="headerlink" title="虚代理LazyConnectionProxy的实现"></a>虚代理LazyConnectionProxy的实现</h4><p>首先针对Connection接口实现一个抽象代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractConnectionProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br><br>    <span class="hljs-comment">// 抽象方法获取实际的Connection:</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 实现Connection接口的每一个方法:</span><br>    <span class="hljs-keyword">public</span> Statement <span class="hljs-title function_">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> getRealConnection().createStatement();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> getRealConnection().prepareStatement(sql);<br>    &#125;<br><br>    ...其他代理方法...<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractConnectionProxy抽象代理类的作用时把Connection接口定义的方法全部实现一遍，后面编写LazyConnectionProxy只需要继承它，就不需要再一一实现Connection接口方法。</p><p>LazyConnectionProxy实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyConnectionProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConnectionProxy</span> &#123;<br>    <span class="hljs-keyword">private</span> Supplier&lt;Connection&gt; supplier;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LazyConnectionProxy</span><span class="hljs-params">(Supplier&lt;Connection&gt; supplier)</span> &#123;<br>        <span class="hljs-built_in">this</span>.supplier = supplier;<br>    &#125;<br><br>    <span class="hljs-comment">// 覆写close方法：只有target不为null时才需要关闭:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Close connection: &quot;</span> + target);<br>            <span class="hljs-built_in">super</span>.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) &#123;<br>            target = supplier.get();<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有执行任何SQL语句，那么target字段始终为null。只有第一次执行SQL语句时（调用prepareStatement()方法时，会触发getRealConnection()调用），才会真正打开实际的JDBC连接。</p><h4 id="编写LazyDateSource"><a href="#编写LazyDateSource" class="headerlink" title="编写LazyDateSource"></a>编写LazyDateSource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataSource</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LazyDataSource</span><span class="hljs-params">(String url, String username, String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyConnectionProxy</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>                System.out.println(<span class="hljs-string">&quot;Open connection: &quot;</span> + conn);<br>                <span class="hljs-keyword">return</span> conn;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重复使用连接"><a href="#重复使用连接" class="headerlink" title="重复使用连接"></a>重复使用连接</h4><p>连接池实现复用Connection也是使用的代理模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledConnectionProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConnectionProxy</span> &#123;<br>    <span class="hljs-comment">// 实际的Connection:</span><br>    Connection target;<br>    <span class="hljs-comment">// 空闲队列:</span><br>    Queue&lt;PooledConnectionProxy&gt; idleQueue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PooledConnectionProxy</span><span class="hljs-params">(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.idleQueue = idleQueue;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fake close and released to idle queue for future reuse: &quot;</span> + target);<br>        <span class="hljs-comment">// 并没有调用实际Connection的close()方法,</span><br>        <span class="hljs-comment">// 而是把自己放入空闲队列:</span><br>        idleQueue.offer(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Connection <span class="hljs-title function_">getRealConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复用连接的关键在于覆写close()方法，它并没有真正关闭底层JDBC连接，而是将自己放回一个空闲队列，以便下次使用。</p><p>空闲队列由PooledDataSource维护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataSource</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">// 维护一个空闲队列:</span><br>    <span class="hljs-keyword">private</span> Queue&lt;PooledConnectionProxy&gt; idleQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PooledDataSource</span><span class="hljs-params">(String url, String username, String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><span class="hljs-comment">// 获取一个连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">// 首先试图获取一个空闲连接:</span><br>        <span class="hljs-type">PooledConnectionProxy</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> idleQueue.poll();<br>        <span class="hljs-comment">// 没有空闲连接时，打开一个新连接:</span><br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>            conn = openNewConnection();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Return pooled connection: &quot;</span> + conn.target);<br>        &#125;<br>        <span class="hljs-keyword">return</span> conn;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> PooledConnectionProxy <span class="hljs-title function_">openNewConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>        System.out.println(<span class="hljs-string">&quot;Open new connection: &quot;</span> + conn);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledConnectionProxy</span>(idleQueue, conn);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们实际使用的DataSource，都是基于代理模式实现的，原理同上，但是增加了更多的如动态伸缩功能（一个连接空闲一段时间后自动关闭）。</p><p>Proxy模式与Decorater的区别：</p><ul><li>Decorator模式让调用者自己创建核心类，然后组和各种功能</li><li>Proxy模式绝不能让调用者自己创建再组合，否则就是失去了代理的功能。Proxy模式让调用者认为自己获取到的是核心接口，但实际是代理类。</li></ul><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式主要设计算法和对象之间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p><h2 id="13-责任链（Chain-of-Responsibility）"><a href="#13-责任链（Chain-of-Responsibility）" class="headerlink" title="13. 责任链（Chain of Responsibility）"></a>13. 责任链（Chain of Responsibility）</h2><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p></blockquote><p>责任链模式是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到某个处理成功为止。</p><p>责任链模式把多个处理器串成链，然后让请求在链上传递：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031114411897.png" alt="image-20221031114411897"></p><p>在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：</p><ul><li>Manager：只能审核1000元以下的报销</li><li>Director：只能审核10000元以下的报销</li><li>CEO：可以审核任意额度</li></ul><p>用责任链模式设计这个报销流程时，每个审核者只关心自己责任范围内的请求，并处理它。对于超过自己责任范围的，扔给下一个审核者处理，这样，将来需要添加审核者的时候，不用改动现有逻辑。</p><p>责任链模式的实现：</p><ol><li><p>抽象出请求对象，它将在责任链上传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Request</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> BigDecimal amount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Request</span><span class="hljs-params">(String name, BigDecimal amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>抽象出处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-comment">// 返回Boolean.TRUE = 成功</span><br>    <span class="hljs-comment">// 返回Boolean.FALSE = 拒绝</span><br>    <span class="hljs-comment">// 返回null = 交下一个处理</span><br>Boolean <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>做好约定：如果返回Boolean.TRUE，表示处理成功，如果返回Boolean.FALSE，表示处理失败（请求被拒绝），如果返回null，则交由下一个Handler处理。</p></li><li><p>编写具体的处理器：ManagerHandler、DirectorHandler和CEOHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManagerHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">// 如果超过1000元，处理不了，交下一个处理:</span><br>        <span class="hljs-keyword">if</span> (request.getAmount().compareTo(BigDecimal.valueOf(<span class="hljs-number">1000</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对Bob有偏见:</span><br>        <span class="hljs-keyword">return</span> !request.getName().equalsIgnoreCase(<span class="hljs-string">&quot;bob&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将Handler组合起来，变成一个链，通过一个统一入口处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-comment">// 持有所有Handler:</span><br>    <span class="hljs-keyword">private</span> List&lt;Handler&gt; handlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHandler</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handlers.add(handler);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">// 依次调用每个Handler:</span><br>        <span class="hljs-keyword">for</span> (Handler handler : handlers) &#123;<br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> handler.process(request);<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果返回TRUE或FALSE，处理结束:</span><br>                System.out.println(request + <span class="hljs-string">&quot; &quot;</span> + (r ? <span class="hljs-string">&quot;Approved by &quot;</span> : <span class="hljs-string">&quot;Denied by &quot;</span>) + handler.getClass().getSimpleName());<br>                <span class="hljs-keyword">return</span> r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Could not handle request: &quot;</span> + request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在客户端组装责任链，然后用责任链处理请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造责任链:</span><br><span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ManagerHandler</span>());<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectorHandler</span>());<br>chain.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CEOHandler</span>());<br><span class="hljs-comment">// 处理请求:</span><br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.45&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1234.56&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;12345.67&quot;</span>)));<br>chain.process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123456.78&quot;</span>)));<br></code></pre></td></tr></table></figure></li></ol><p>责任链中Handler添加的顺序很重要，如果顺序不对，处理结果可能不符合要求。</p><p>责任链模式变种：</p><ul><li><p>有些责任链的实现方式是通过Handler手动调用下一个Handler来传递Request，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!canProcess(request)) &#123;<br>            <span class="hljs-comment">// 手动交给下一个Handler处理:</span><br>            next.process(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>还有的责任链模式，每个Handler都有机会处理Request，通常这种责任链被称为拦截器（Interceptor）或过滤器（Filter），它们的目的不是找到某个Handler处理掉Request，而是每个Handler都做一些工作，比如：</p><ul><li>记录日志</li><li>检查权限</li><li>准备相关资源</li><li>…</li></ul><p>例如JavaEE的Servlet规范定义的Filter就是一种责任链。它不但允许每个Filter都有机会处理请求，还允许每个Filter决定是否将请求“放行”给下一个Filter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuditFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        log(req);<br>        <span class="hljs-keyword">if</span> (check(req)) &#123;<br>            <span class="hljs-comment">// 放行:</span><br>            chain.doFilter(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 拒绝:</span><br>            sendError(resp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式不但允许一个Filter自行决定处理ServletRequest和ServletResponse，还可以“伪造”ServletRequest和ServletResponse以便让下一个Filter处理，能实现非常复杂的功能。</p></li></ul><h2 id="14-命令（Command）"><a href="#14-命令（Command）" class="headerlink" title="14. 命令（Command）"></a>14. 命令（Command）</h2><blockquote><p>将一个请求封装成一个对象，从而使你可用不同的请求对客户端进行参数化，对请求判定或记录请求日志，以及支持可撤销的操作。</p></blockquote><p>命令模式是指把一个请求封装成一个命令，然后执行该命令。</p><p>以一个编辑器为例子，看看如何实现简单的编辑操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paste</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> getFromClipBoard();<br>        add(text);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;<br>        buffer.append(s);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (buffer.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.deleteCharAt(buffer.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用一个StringBuilder模拟一个文本编辑器，它支持copy() 、paste ()、add()、delete()等方法。</p><p>上面这个TextEditor的调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>editor.add(<span class="hljs-string">&quot;Command pattern in text editor.\n&quot;</span>);<br>editor.copy();<br>editor.paste();<br>System.out.println(editor.getState());<br></code></pre></td></tr></table></figure><p>调用方需要了解TextEditor的所有接口信息。</p><p>如果改成命令模式，我们需要将调用方发送命令，和执行命令分开。通过引入一个Command接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方创建一个对应的Command，然后执行，并不关心内部是如何执行的：</p><ul><li><p>实现具体的Command</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-comment">// 持有执行者对象:</span><br>    <span class="hljs-keyword">private</span> TextEditor receiver;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyCommand</span><span class="hljs-params">(TextEditor receiver)</span> &#123;<br>        <span class="hljs-built_in">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        receiver.copy();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasteCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> TextEditor receiver;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PasteCommand</span><span class="hljs-params">(TextEditor receiver)</span> &#123;<br>        <span class="hljs-built_in">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        receiver.paste();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将Command和TextEditor组装一下，调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>editor.add(<span class="hljs-string">&quot;Command pattern in text editor.\n&quot;</span>);<br><br><span class="hljs-comment">// 执行一个CopyCommand:</span><br><span class="hljs-type">Command</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyCommand</span>(editor);<br>copy.execute();<br>editor.add(<span class="hljs-string">&quot;----\n&quot;</span>);<br><br><span class="hljs-comment">// 执行一个PasteCommand:</span><br><span class="hljs-type">Command</span> <span class="hljs-variable">paste</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasteCommand</span>(editor);<br>paste.execute();<br>System.out.println(editor.getState());<br></code></pre></td></tr></table></figure></li></ul><p>命令模式的结构：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031190100636.png" alt="image-20221031190100636"></p><p>使用命令模式增加了一定的复杂度，对于简单系统，直接调用会更直观且简单。但是当系统复杂到一定程度的时候，比如要给TextEditor增加Undo、Redo功能，则使用命令行模式逻辑会清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把执行过的一系列命令使用List保存起来，这样就能支持Undo和Redo。这个时候我们又需要一个Invoker对象，负责执行命令并保存历史命令：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031190609564.png" alt="image-20221031190609564"></p><h2 id="15-解释器（Interpreter）"><a href="#15-解释器（Interpreter）" class="headerlink" title="15. 解释器（Interpreter）"></a>15. 解释器（Interpreter）</h2><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>解释模式是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。</p><p>例如，针对以下的匹配条件：</p><ul><li>以+开头的数字表示的区号和电话号码，如+8615566666666</li><li>以英文开头，后接英文和数字，并以.分隔的域名，如<a href="http://www.google.com/">www.google.com</a></li><li>以&#x2F;开头的文件路径，如&#x2F;path&#x2F;to&#x2F;file.txt</li><li>…</li></ul><p>因此，需要一种通用的表达方式——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p><p>实现一个完成的正则表达式解释器很复杂，但是使用解释器模式很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;+861012345678&quot;</span>;<br>System.out.println(s.matches(<span class="hljs-string">&quot;^\\+\\d+$&quot;</span>));<br></code></pre></td></tr></table></figure><p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也很复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p><h2 id="16-迭代器（Iterator）"><a href="#16-迭代器（Iterator）" class="headerlink" title="16. 迭代器（Iterator）"></a>16. 迭代器（Iterator）</h2><blockquote><p> 提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。</p></blockquote><p>迭代器模式实际上在Java集合类汇中已经广泛使用了。</p><p>我们以List为例，要遍历ArrayList，即使我们直到它的内部存储了一个Object[]数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。</p><p>如果使用Iterator遍历，那么，ArrayList和LinkedList都可以以一种统一的接口来遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = ...<br>Iterator&lt;String&gt; it = list.iterator()<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>&#125;<br><br><span class="hljs-comment">//Iterator模式十分有用，Java允许把任何支持Iterator的集合对象用foreach来遍历</span><br>List&lt;String&gt; list = ...<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>Iterator模式的实现：</p><p>实现Iterator模式的关键是返回一个Iterator对象。该对象知道集合内部结构，它可以实现倒序遍历。</p><p>自定义一个集合，通过Iterator模式实现倒序遍历，使用Java的内部类实现Iterator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseArrayCollection</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">private</span> T[] array;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReverseArrayCollection</span><span class="hljs-params">(T... objs)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = Arrays.copyOfRange(objs, <span class="hljs-number">0</span>, objs.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReverseIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>        <span class="hljs-comment">// 索引位置:</span><br>        <span class="hljs-type">int</span> index;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReverseIterator</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 创建Iterator时,索引在数组末尾:</span><br>            <span class="hljs-built_in">this</span>.index = ReverseArrayCollection.<span class="hljs-built_in">this</span>.array.length;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):</span><br>            <span class="hljs-keyword">return</span> index &gt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 将索引移动到下一个元素并返回(倒序往前移动):</span><br>            index--;<br>            <span class="hljs-keyword">return</span> array[index];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用内部类的好处是内部类隐含地持有一个它所在对象地this引用，可以通过ReverseArrayCollection.this引用到它所在地集合。</p><p>上述的地代码实现地逻辑非常简单，但是在实际的应用中，如果考虑多线程访问，则需要仔细设计避免多线程安全问题。</p><h2 id="17-中介（Meiator）"><a href="#17-中介（Meiator）" class="headerlink" title="17. 中介（Meiator）"></a>17. 中介（Meiator）</h2><blockquote><p>用一个中介对象来封装一系列的对象交互。中介者使个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互。</p></blockquote><p>中介模式又称调停者模式，它地目的是把多方会谈变成双方会谈，从而实现多方地松耦合。</p><p>一个多选框的例子：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205600593.png" alt="image-20221031205600593"></p><p>这个小系统有4个参与对象：</p><ul><li>多选框</li><li>“选择全部”按钮</li><li>“取消所有”按钮</li><li>反选按钮</li></ul><p>它的复杂性在于，当多选框变化时，它会影响”选择全部“和”取消所有“按钮的状态（是否可点击），当用户点击某个按钮时，又会影响多选框和其他按钮的状态。</p><p>所以说这是一个多方会谈，逻辑写起来很复杂：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205849415.png" alt="image-20221031205849415"></p><p>如果我们引入一个中介，把多方会谈变成多个单方会谈，虽然多了一个对象，但对象之间的关系就变得简单了：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031205959983.png" alt="image-20221031205959983"></p><p>使用中介模式来实现上面得UI组件交互：</p><ol><li><p>首先把UI组件画出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderFrame</span>(<span class="hljs-string">&quot;Hanburger&quot;</span>, <span class="hljs-string">&quot;Nugget&quot;</span>, <span class="hljs-string">&quot;Chip&quot;</span>, <span class="hljs-string">&quot;Coffee&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFrame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span> &#123;<br>    <span class="hljs-comment">//Frame</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderFrame</span><span class="hljs-params">(String... names)</span> &#123;<br>        setTitle(<span class="hljs-string">&quot;Order&quot;</span>);<br>        setSize(<span class="hljs-number">460</span>, <span class="hljs-number">200</span>);<br>        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>        <span class="hljs-type">Container</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getContentPane();<br>        c.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>(FlowLayout.LEADING, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>));<br>        c.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;Use Mediator Pattern&quot;</span>));<br>        <span class="hljs-comment">//添加多选框</span><br>        List&lt;JCheckBox&gt; checkboxList = addCheckBox(names);<br>        <span class="hljs-comment">//添加三个按钮</span><br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectAll</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Select All&quot;</span>);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectNone</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Select None&quot;</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">selectInverse</span> <span class="hljs-operator">=</span> addButton(<span class="hljs-string">&quot;Inverse Select&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mediator</span>(checkBoxList, selectAll, selectNone, selectInverse);<br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br><span class="hljs-comment">//多选框</span><br>    <span class="hljs-keyword">private</span> List&lt;JCheckBox&gt; <span class="hljs-title function_">addCheckBox</span><span class="hljs-params">(String... names)</span> &#123;<br>        <span class="hljs-type">JPanel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>        panel.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;Menu:&quot;</span>));<br>        List&lt;JCheckBox&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-type">JCheckBox</span> <span class="hljs-variable">checkbox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JCheckBox</span>(name);<br>            list.add(checkbox);<br>            panel.add(checkbox);<br>        &#125;<br>        getContentPane().add(panel);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><span class="hljs-comment">//按钮</span><br>    <span class="hljs-keyword">private</span> JButton <span class="hljs-title function_">addButton</span><span class="hljs-params">(String label)</span> &#123;<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(label);<br>        getContentPane().add(button);<br>        <span class="hljs-keyword">return</span> button;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设计Mediator类，它引用4个UI组件，并负责跟它们交互：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-comment">// 引用UI组件:</span><br>    <span class="hljs-keyword">private</span> List&lt;JCheckBox&gt; checkBoxList;<br>    <span class="hljs-keyword">private</span> JButton selectAll;<br>    <span class="hljs-keyword">private</span> JButton selectNone;<br>    <span class="hljs-keyword">private</span> JButton selectInverse;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mediator</span><span class="hljs-params">(List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse)</span> &#123;<br>        <span class="hljs-built_in">this</span>.checkBoxList = checkBoxList;<br>        <span class="hljs-built_in">this</span>.selectAll = selectAll;<br>        <span class="hljs-built_in">this</span>.selectNone = selectNone;<br>        <span class="hljs-built_in">this</span>.selectInverse = selectInverse;<br>        <span class="hljs-comment">// 绑定事件:</span><br>        <span class="hljs-built_in">this</span>.checkBoxList.forEach(checkBox -&gt; &#123;<br>            checkBox.addChangeListener(<span class="hljs-built_in">this</span>::onCheckBoxChanged);<br>        &#125;);<br>        <span class="hljs-built_in">this</span>.selectAll.addActionListener(<span class="hljs-built_in">this</span>::onSelectAllClicked);<br>        <span class="hljs-built_in">this</span>.selectNone.addActionListener(<span class="hljs-built_in">this</span>::onSelectNoneClicked);<br>        <span class="hljs-built_in">this</span>.selectInverse.addActionListener(<span class="hljs-built_in">this</span>::onSelectInverseClicked);<br>    &#125;<br><br>    <span class="hljs-comment">// 当checkbox有变化时:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCheckBoxChanged</span><span class="hljs-params">(ChangeEvent event)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">allChecked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">allUnchecked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> checkBox : checkBoxList) &#123;<br>            <span class="hljs-keyword">if</span> (checkBox.isSelected()) &#123;<br>                allUnchecked = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                allChecked = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        selectAll.setEnabled(!allChecked);<br>        selectNone.setEnabled(!allUnchecked);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select all:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectAllClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="hljs-literal">true</span>));<br>        selectAll.setEnabled(<span class="hljs-literal">false</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select none:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectNoneClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="hljs-literal">false</span>));<br>        selectAll.setEnabled(<span class="hljs-literal">true</span>);<br>        selectNone.setEnabled(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当点击select inverse:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSelectInverseClicked</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));<br>        onCheckBoxChanged(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>使用Mediator模式后的好处：</p><ul><li>各个UI组件互不引用，这样就减少了组件之间的耦合关系</li><li>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件</li><li>如果新增一个UI组件，我们只需要修改Mediator更新状&#x3D;状态的逻辑，现有的其他UI组件代码不变</li></ul><p>Mediator模式经常用在有众多交互组件的UI上。为例简化UI程序，MVC模式以及MVVM模式都可以看作时Mediator模式的扩展。</p><h2 id="18-备忘录（Memento）"><a href="#18-备忘录（Memento）" class="headerlink" title="18. 备忘录（Memento）"></a>18. 备忘录（Memento）</h2><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p></blockquote><p>备忘录模式，主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p><p>其实我们使用的几乎所有软件都用到了备忘录模式。</p><ul><li>最简单的备忘录模式就是保存到文件，打开文件。</li><li>对于文本编辑器来说，保存就是把TextEditor类的字符串存储到文件，打开就是恢复TextEditor类的状态。</li><li>对于图像编辑器来说，原理也是一样，只是保存和恢复的数据格式比较复杂而已。</li><li>java的序列化也可以看作是备忘录模式</li><li>文本编辑器的Redo、Undo功能也可以使用备忘录模式实现</li></ul><p>标准的备忘录模式有这么几个角色：</p><ul><li>Memonto： 存储的内部状态</li><li>Originator：创建一个备忘录并设置其状态</li><li>Caretake：负责保存备忘录</li></ul><p>在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似TextEditor的类，增加getState() 和setState()就可以了。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        buffer.append(ch);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;<br>        buffer.append(s);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (buffer.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.deleteCharAt(buffer.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//备忘录功能：</span><br>    <span class="hljs-comment">// 获取状态</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 恢复状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.buffer.delete(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.buffer.length());<br>        <span class="hljs-built_in">this</span>.buffer.append(state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-观察者（Observer）"><a href="#19-观察者（Observer）" class="headerlink" title="19. 观察者（Observer）"></a>19. 观察者（Observer）</h2><blockquote><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><p>观察者模式又称发布-订阅模式。它时一种通知机制，让发送方（被观察者）和接收房间（观察者）能彼此分离，互不影响。</p><p>一个例子，假设一个电商网站，有多个Product，同时Customer和Admin对商品上架、价格修改都感兴趣，希望第一时间获得通知。于是Store可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    Customer customer;<br>    Admin admin;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, Product&gt; products = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//新增商品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNewProduct</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(name, price);<br>        products.put(p.getName(), p);<br>        <span class="hljs-comment">// 通知用户:</span><br>        customer.onPublished(p);<br>        <span class="hljs-comment">// 通知管理员:</span><br>        admin.onPublished(p);<br>    &#125;<br>    <br><span class="hljs-comment">//修改商品价格</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProductPrice</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> products.get(name);<br>        p.setPrice(price);<br>        <span class="hljs-comment">// 通知用户:</span><br>        customer.onPriceChanged(p);<br>        <span class="hljs-comment">// 通知管理员:</span><br>        admin.onPriceChanged(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Store类的问题：它直接引用了Cunstomer和Admin。如果要新加入观察者需要修改整个Store类，属性、构造方法、每一个通知方法。问题的根源在于Store希望发送通知给关系Product的对象，但Store并不想知道这些人是谁。</p><p>观察者模式就是要分离被观察者和观察者之间的耦合关系。想要实现这一目标很简单，Store不直接引用Customer和Admin，它引用一个ProductObserver接口的List即可，任何想要观察Store，只要实现这一接口，并把自己注册到Store即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;ProductObserver&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Map&lt;String, Product&gt; products = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 注册观察者:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(ProductObserver observer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.observers.add(observer);<br>    &#125;<br><br>    <span class="hljs-comment">// 取消注册:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(ProductObserver observer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNewProduct</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(name, price);<br>        products.put(p.getName(), p);<br>        <span class="hljs-comment">// 通知观察者:</span><br>        observers.forEach(o -&gt; o.onPublished(p));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProductPrice</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> products.get(name);<br>        p.setPrice(price);<br>        <span class="hljs-comment">// 通知观察者:</span><br>        observers.forEach(o -&gt; o.onPriceChanged(p));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样要增加新的观察者就不需要改动Store类的代码，只需要在客户端调用的时候注册观察者，如果要创建新型的额观察者，也只需要实现Productor接口，并在客户端注册即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// observer:</span><br><span class="hljs-type">Admin</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Admin</span>();<br><span class="hljs-type">Customer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br><span class="hljs-comment">// store:</span><br><span class="hljs-type">Store</span> <span class="hljs-variable">store</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>();<br><span class="hljs-comment">// 注册观察者:</span><br>store.addObserver(a);<br>store.addObserver(c);<br><span class="hljs-comment">// 注册匿名观察者</span><br>store.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductObserver</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPublished</span><span class="hljs-params">(Product product)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[Log] on product published: &quot;</span> + product);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPriceChanged</span><span class="hljs-params">(Product product)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[Log] on product price changed: &quot;</span> + product);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>观察者模式图示：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031213754596.png" alt="image-20221031213754596"></p><p>观察者模式变体：</p><ol><li><p>将被观察者也抽象为接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//被观察者接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductObservable</span> &#123; <span class="hljs-comment">// 注意此处拼写是Observable不是Observer!</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(ProductObserver observer)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(ProductObserver observer)</span>;<br>&#125;<br><span class="hljs-comment">//对应的被观察者实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductObservable</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>把通知变成一个Event对象。不再由多种通知，而是统一为Event通知，观察者在自己从Event对象中读取通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductObserver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(ProductEvent event)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>广义上的观察者模式包括所有的消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031214337749.png" alt="image-20221031214337749"></p><p>消息发送方称为Producer，消息接收方称为Consumer。Producer发送消息的时候必须选择发送到哪个Topic，Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。使用消息系统实现观察者模式的时候，Producer和Consumer甚至经常不是在同一台机器上，并且双方对彼此一无所知，以为注册观察者这个动作都是在消息系统中完成的，而不是在Producer内部完成。</p><p>此外，观察者模式中的通知Observe是依靠语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">observers.forEach(o -&gt; o.onPublished(p));<br></code></pre></td></tr></table></figure><p>这说明，各个观察者是依次获取同步通知，需要一个观察者处理完通知后，下一个观察者才能获取到通知。</p><ul><li>如果观察者处理通知很慢，下一个观察者就不能及时获取通知。</li><li>如果观察者在处理通知的时候出现异常，那么还需要被观察者来处理异常</li></ul><p>Java标准库由Java.util.Observable类和Observer接口，用于帮助实现观察者模式，但是很难用，不推荐使用。</p><h2 id="20-状态（State）"><a href="#20-状态（State）" class="headerlink" title="20. 状态（State）"></a>20. 状态（State）</h2><blockquote><p>允许一个对象在其内部状态改变它的行为。对象看起来似乎修改了它的类。</p></blockquote><p>状态模式经常用在带有状态的对象中。</p><p>什么是状态？以QQ为例，一个用户的QQ的几种状态：</p><ul><li>离线</li><li>正在登录</li><li>在线</li><li>忙</li></ul><p>如何表示状态？定义一个enum就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (state == ONLINE) &#123;<br>    <span class="hljs-comment">// 闪烁图标</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BUSY) &#123;<br>    reply(<span class="hljs-string">&quot;现在忙，稍后回复&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...<br></code></pre></td></tr></table></figure><p>状态模式的目的就是把上面一大堆的if…else… 的逻辑拆分到不同的状态中，将来增加状态就只需要再多写一个状态类即可。</p><p>例如，设计一个聊天机器人，有两个状态：未连接、已连接。</p><p>未连接状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisconnectedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bye!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reply</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>已连接状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, I&#x27;m Bob.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reply</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-keyword">if</span> (input.endsWith(<span class="hljs-string">&quot;?&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Yes. &quot;</span> + input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;!&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (input.endsWith(<span class="hljs-string">&quot;.&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;!&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> input.substring(<span class="hljs-number">0</span>, input.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;?&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>状态模式的关键设计思想在于状态切换，引入BotContext完成状态转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BotContext</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisconnectedState</span>();<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">chat</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-comment">// 收到hello切换到在线状态:</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;hello&quot;</span>.equalsIgnoreCase(input)) &#123;<br>state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectedState</span>();<br><span class="hljs-keyword">return</span> state.init();<br>       <span class="hljs-comment">//  收到bye切换到离线状态:</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bye&quot;</span>.equalsIgnoreCase(input)) &#123;<br>state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisconnectedState</span>();<br><span class="hljs-keyword">return</span> state.init();<br>&#125;<br>        <br>        <span class="hljs-comment">// 调用state的reply方法</span><br><span class="hljs-keyword">return</span> state.reply(input);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-策略（Strategy）"><a href="#21-策略（Strategy）" class="headerlink" title="21. 策略（Strategy）"></a>21. 策略（Strategy）</h2><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。使得算法可以独立于使用它的客户而变化。</p></blockquote><p>策略模式指定义一组算法，并将其封装到一个对象中。然后在运行时，可以灵活地使用其中一个算法。</p><h3 id="Arrays-sort-方法中的策略模式"><a href="#Arrays-sort-方法中的策略模式" class="headerlink" title="Arrays.sort()方法中的策略模式"></a>Arrays.sort()方法中的策略模式</h3><p>Java标准库中策略模式的应用：</p><p>以排序为例，看看Arrays.sort()的排序实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        String[] array = &#123; <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span> &#125;;<br>        Arrays.sort(array, String::compareToIgnoreCase);<br>        System.out.println(Arrays.toString(array));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sort()中的策略：</p><ul><li>String::compareToIgnoreCase就是一个算法，它忽略大小写排序。</li><li>若我们想要倒序排序，就传入(s1, s2) -&gt; s1.compareTo(s2)</li></ul><p>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)，观察方法，它在内部实现了TimSort排序（归并排序优化版本），但是排序算法在比较两个元素大小的时候，需要我们传入的Comparator对象，才能完成比较。因此，这里的策略指的是比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以是根据字符串长度比较。</p><p>上面排序中的策略模式，实际指的是，在方法中，流程是确定的，但是某些关键步骤的算法依赖调用方传入的策略。这样，传入不同的策略，即可获得不同的结果，大大增强系统的灵活性。</p><h3 id="购物结算的折扣策略"><a href="#购物结算的折扣策略" class="headerlink" title="购物结算的折扣策略"></a>购物结算的折扣策略</h3><p>一个完整的策略模式所需：</p><ul><li>定义策略</li><li>使用策略的上下文。</li></ul><p>以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>先定义打折策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-comment">// 计算折扣额度:</span><br>    BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现各种策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通用户策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-comment">// 普通会员打九折:</span><br>        <span class="hljs-keyword">return</span> total.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.1&quot;</span>)).setScale(<span class="hljs-number">2</span>, RoundingMode.DOWN);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//满减策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getDiscount</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-comment">// 满100减20优惠:</span><br>        <span class="hljs-keyword">return</span> total.compareTo(BigDecimal.valueOf(<span class="hljs-number">100</span>)) &gt;= <span class="hljs-number">0</span> ? BigDecimal.valueOf(<span class="hljs-number">20</span>) : BigDecimal.ZERO;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用策略，需要一个上下文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountContext</span> &#123;<br>    <span class="hljs-comment">// 持有某个策略:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DiscountStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDiscountStrategy</span>();<br><br>    <span class="hljs-comment">// 允许客户端设置新策略:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(DiscountStrategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(BigDecimal total)</span> &#123;<br>        <span class="hljs-keyword">return</span> total.subtract(<span class="hljs-built_in">this</span>.strategy.getDiscount(total)).setScale(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>调用方必须先创建一个DiscountContext，并指定一个策略（或使用默认策略），再调用DiscountContext的获取折扣后价格方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DiscountContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiscountContext</span>();<br><br><span class="hljs-comment">// 默认使用普通会员折扣:</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay1</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay1);<br><br><span class="hljs-comment">// 使用满减折扣:</span><br>ctx.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OverDiscountStrategy</span>());<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay2</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay2);<br><br><span class="hljs-comment">// 使用Prime会员折扣:</span><br>ctx.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrimeDiscountStrategy</span>());<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">pay3</span> <span class="hljs-operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="hljs-number">105</span>));<br>System.out.println(pay3);<br></code></pre></td></tr></table></figure><p>完整的策略模式图示如下：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031224335921.png" alt="image-20221031224335921"></p><p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽象出来作为”策略“参数传入，从而使得新增策略不必修改原有逻辑。</p><h2 id="22-模板方法（Templat-Method）"><a href="#22-模板方法（Templat-Method）" class="headerlink" title="22. 模板方法（Templat Method）"></a>22. 模板方法（Templat Method）</h2><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><p>模板方法的主要思想：定义一个操作的一系列步骤，对于某些暂不确定的步骤，留给子类实现，这样不同过的子类就可以定义出不同的步骤。</p><p>因此，模板方法的核心在于定义一个”骨架“。</p><p>加入我们开发一个从数据库读取设置的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Setting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> readFromDatabase(key);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">readFromDatabase</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库读取</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于从数据库读取数据比较满，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库。但是怎么实现缓存，暂时还没想好，但是不妨碍我们写出使用缓存的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Setting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 先从缓存读取:</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> lookupCache(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在缓存中未找到,从数据库读取:</span><br>            value = readFromDatabase(key);<br>            System.out.println(<span class="hljs-string">&quot;[DEBUG] load from db: &quot;</span> + key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>            <span class="hljs-comment">// 放入缓存:</span><br>            putIntoCache(key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;[DEBUG] load from cache: &quot;</span> + key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个流程没问题，但是，lookupCache(Key)和putIntoCache(Key, value)这两个方法还根本没有实现，无法通过编译。我们可以声明两个抽象方法，并将Setting也改为抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getSetting</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> lookupCache(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            value = readFromDatabase(key);<br>            putIntoCache(key, value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，整个类为抽象类，如何实现lookupCache(Key)和putIntoCache(key, value)这两个方法就交给子类即可。子类不需要关系核心代码getSetting(Key)的逻辑，它只需要关心如何完成两个子任务。</p><p>假设我们希望用一个Map做缓存，那么可以写一个LocalSetting：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalSetting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        cache.put(key, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要使用Redis做缓存，那么可以再写一个RedisSetting：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisSetting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSetting</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">RedisClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> RedisClient.create(<span class="hljs-string">&quot;redis://localhost:6379&quot;</span>);<br><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">lookupCache</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;<br>            RedisCommands&lt;String, String&gt; commands = connection.sync();<br>            <span class="hljs-keyword">return</span> commands.get(key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntoCache</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        <span class="hljs-keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;<br>            RedisCommands&lt;String, String&gt; commands = connection.sync();<br>            commands.set(key, value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端使用缓存：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用本地缓存</span><br><span class="hljs-type">AbstractSetting</span> <span class="hljs-variable">setting1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalSetting</span>();<br>System.out.println(<span class="hljs-string">&quot;test = &quot;</span> + setting1.getSetting(<span class="hljs-string">&quot;test&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;test = &quot;</span> + setting1.getSetting(<span class="hljs-string">&quot;test&quot;</span>));<br><span class="hljs-comment">// 使用Redis缓存</span><br><span class="hljs-type">AbstractSetting</span> <span class="hljs-variable">setting2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisSetting</span>();<br>System.out.println(<span class="hljs-string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="hljs-string">&quot;autosave&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="hljs-string">&quot;autosave&quot;</span>));<br></code></pre></td></tr></table></figure><p>模板方法的核心思想：父类定义骨架，子类实现细节。</p><p>安全问题：</p><ul><li><p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用final。</p></li><li><p>对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见。</p></li></ul><p>Java标准库中模板方法的应用：</p><ul><li>AbstractList</li><li>AbstractQueuedSynchronizer</li></ul><h2 id="23-访问者（Visitor）"><a href="#23-访问者（Visitor）" class="headerlink" title="23. 访问者（Visitor）"></a>23. 访问者（Visitor）</h2><blockquote><p>表示一个作用于某对象结构中的各元素的操作。它使哪可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></blockquote><p>访问者模式是一种操作一组操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p><p>访问者模式的设计比较复杂，Gof原始的访问者模式：</p><p><img src="/2022/10/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20221031231737824-16672294603681.png" alt="image-20221031231737824"></p><p>上述模式的复杂之处在于上述访问者模式为了实现所谓的”双重分派“，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出”双重分派“反而加大了代码的复杂性。</p><p>简化的访问者模式：</p><p>假设我们要递归遍历某个文件夹的所有子文件和文件夹，然后找出.java文件。</p><p>一般做法，写个递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(File dir, List&lt;File&gt; collector)</span> &#123;<br>    <span class="hljs-keyword">for</span> (File file : dir.listFiles()) &#123;<br>        <span class="hljs-keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>            collector.add(file);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isDir()) &#123;<br>            <span class="hljs-comment">// 递归调用:</span><br>            scan(file, collector);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的问题在于，扫描目录和处理.java文件的逻辑混在一起。如果下次需要增加一个清理.class文件的功能，那么就必须重写扫描逻辑。</p><p>因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离，以后如果要新增操作（例如清理.class文件），只需要新增访问者，不需要改变现有逻辑。</p><p>用访问者模式改写：</p><ol><li><p>定义访问者接口，即定义访问者能干的事儿：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-comment">// 访问文件夹:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span>;<br>    <span class="hljs-comment">// 访问文件:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义能持有文件夹和文件的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStructure</span> &#123;<br>    <span class="hljs-comment">// 根目录:</span><br>    <span class="hljs-keyword">private</span> File path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileStructure</span><span class="hljs-params">(File path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>为FileStructure增加一个handle()方法，传入一个访问者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStructure</span> &#123;<br>    ...<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>scan(<span class="hljs-built_in">this</span>.path, visitor);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(File file, Visitor visitor)</span> &#123;<br><span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>            <span class="hljs-comment">// 让访问者处理文件夹:</span><br>visitor.visitDir(file);<br><span class="hljs-keyword">for</span> (File sub : file.listFiles()) &#123;<br>                <span class="hljs-comment">// 递归处理子文件夹:</span><br>scan(sub, visitor);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>            <span class="hljs-comment">// 让访问者处理文件:</span><br>visitor.visitFile(file);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样访问者的行为抽象出来了。若要实现一种操作，例如查找.class文件，就传入JavaFileVisitor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileStructure</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileStructure</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;.&quot;</span>));<br>fs.handle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaFileVisitor</span>());<br></code></pre></td></tr></table></figure></li><li><p>实现Visitor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查找.class文件的Visitor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaFileVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Visit dir: &quot;</span> + dir);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span> &#123;<br>        <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Found java file: &quot;</span> + file);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//清理.class文件的Visitor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassFileCleanerVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDir</span><span class="hljs-params">(File dir)</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFile</span><span class="hljs-params">(File file)</span> &#123;<br><span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;<br>System.out.println(<span class="hljs-string">&quot;Will clean class file: &quot;</span> + file);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>可见，访问者模式的核心就是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在”访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p><p>Java标准库提供的Files.walkFileTree()已经实现了一个访问者模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Files.walkFileTree(Paths.get(<span class="hljs-string">&quot;.&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFileVisitor</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现一个FileVisitor:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt; &#123;<br>    <span class="hljs-comment">// 处理Directory:</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre visit dir: &quot;</span> + dir);<br>        <span class="hljs-comment">// 返回CONTINUE表示继续访问:</span><br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理File:</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;visit file: &quot;</span> + file);<br>        <span class="hljs-comment">// 返回CONTINUE表示继续访问:</span><br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Files.walkFileTree()允许访问者返回FileVisitResult.CONTINUE以便继续访问，或者返回FileVisitResult.TERMINATE停止访问。</p><p>类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Hanlder作为访问者处理XML的各个节点。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/10/25/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/10/25/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><h2 id="通过ArrayList简单了解泛型"><a href="#通过ArrayList简单了解泛型" class="headerlink" title="通过ArrayList简单了解泛型"></a>通过ArrayList简单了解泛型</h2><p>首先通过Java标准库提供的ArrayList来了解一下什么是泛型，泛型有什么作用。</p><p>ArrayList可以看作“可变长度”的数组，底层使用Object []数组来存储数据。</p><p>一个简易的可以存储任何类型数据的ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;<br>    <span class="hljs-keyword">private</span> Object[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object e)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要让ArrayList只存储String类型，会有几个缺点：</p><ul><li><p>存的时候，非String类型的数据也能存入ArrayList中</p></li><li><p>取的时候，需要强制转型。第一，麻烦；第二，如果存入的不是String，那么转型失败抛出异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">// 获取到Object，必须强制转型为String:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">0</span>);<br><br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// ERROR: ClassCastException:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>要解决上面的问题，可以为String单独编写一种ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringArrayList</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String e)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样存入的是String、取出的也一定是String，不需要强制转型。</p><p>但是如果要存储Integer或其他类型数据，那么就需要为每种数据类型定义一个ArrayList。</p><p>JDK中的class成百上千，为每种class编写一个ArrayList是不现实的。所以说泛型就出现了。</p><p>通过泛型，将ArrayList变成一种模板：ArrayList<T>：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T e)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>T可以是任何class。编写一个模板，就可以创建任意类型的ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建可以存储String的ArrayList:</span><br>ArrayList&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-comment">// 创建可以存储Float的ArrayList:</span><br>ArrayList&lt;Float&gt; floatList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Float&gt;();<br><span class="hljs-comment">// 创建可以存储Person的ArrayList:</span><br>ArrayList&lt;Person&gt; personList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Person&gt;();<br></code></pre></td></tr></table></figure><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>在Java标准库中的ArrayList<T>实现了List<T>接口，它可以向上转型为List<T>。</T></T></T></p><p>特别注意：</p><ul><li>ArrayList<Integer> 可以向上转型为List<Integer></Integer></Integer></li><li>ArrayList<Integer>不能向上转型为Array List<Number>或List<Number></Number></Number></Integer></li></ul><p>为什么不能？</p><p>一、通过反证法来证明</p><p>如果可以转型的话的话，观察代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建ArrayList&lt;Integer&gt;类型：</span><br>ArrayList&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-comment">// 添加一个Integer：</span><br>integerList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// “向上转型”为ArrayList&lt;Number&gt;：</span><br>ArrayList&lt;Number&gt; numberList = integerList;<br><span class="hljs-comment">// 添加一个Float，因为Float也是Number：</span><br>numberList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>(<span class="hljs-number">12.34</span>));<br><span class="hljs-comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> integerList.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// ClassCastException!</span><br></code></pre></td></tr></table></figure><p>如果我们把ArrayList<Integer>转型为ArrayList<Number>，那么转型过后就可以接收Float类型的数据，因为Float是Number的子类。但是转型过后的ArrayList<Number>实际是一个ArrayList<Integer>对象，不能接收Float类型。简单来说：</Integer></Number></Number></Integer></p><ul><li>如果ArrayList<Integer>可以转型为Array List<Number>，那么按照道理，转型过后应该可以接收Float类型数据</Number></Integer></li><li>但是实际上转型过后，它的实际类型是ArrayLsit<Integer>，不能够接收Float类型数据</Integer></li></ul><p>二、继承关系</p><p>ArrayList<Integer> 和ArrayList<Number>两者完全没有继承关系</Number></Integer></p><h1 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>使用ArrayList时，如果不定义泛型类型，泛型类型实际上就是Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译器警告:</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.add(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">//取出需要强制类型转换</span><br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">0</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>不定义泛型类型的话，只能把<T>当Object使用，没有发挥泛型的优势。</T></p><p>当我们定义泛型<String>后，List,<T>的泛型接口变为强类型List<String>:</String></T></String></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无编译器警告:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.add(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 无强制转型:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>如果编译器能自动推断出泛型类型，就可以省略后面的泛型类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br><span class="hljs-comment">//省略后</span><br>List&lt;Number&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>除了ArrayList<T>这种类可以使用泛型，还可以在接口中使用泛型。</T></p><p>例如Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable<T>这个接口：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h1><p>泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如ArrayList<T>，但是集合类Java库有提供，所以说我们很少需要编写泛型类。</T></p><h2 id="编写泛型类的步骤："><a href="#编写泛型类的步骤：" class="headerlink" title="编写泛型类的步骤："></a>编写泛型类的步骤：</h2><p>一、首先按照某种非泛型类为基础，来编写泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-keyword">private</span> String first;<br>    <span class="hljs-keyword">private</span> String last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(String first, String last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 二、标记所有特定的类，这里是String，将其替换为T，并为泛型类声明<T></T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写熟练过后，可以直接从T开始编写。</p><h2 id="静态泛型方法"><a href="#静态泛型方法" class="headerlink" title="静态泛型方法"></a>静态泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// 对静态方法使用&lt;T&gt;:</span><br>    <span class="hljs-comment">// 会编译错误</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;T&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为静态方法是属于类的，不属于实例对象。而上面的泛型<T>都是通过创建对象的时候才传入的。对于静态方法，无法使用上面的泛型类型T。</T></p><p>在修饰符static后面加上泛型<T>，编译就能通过。如下：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实例的&lt;T&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// 可以编译通过:</span><br>    <span class="hljs-comment">//静态方法的&lt;T&gt;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;T&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这两个<T>不是同一个<T>。所以对于静态方法的泛型类型和实例对象的泛型类型应该区分开来。如下：</T></T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(K first, K last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h2><p>如果我们希望Pair存储两个类型不同的对象，可以使用&lt;T, K&gt;指定多个泛型类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T, K&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> K last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, K last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，指出两种类型即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String, Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h1 id="泛型的实现（擦除法）"><a href="#泛型的实现（擦除法）" class="headerlink" title="泛型的实现（擦除法）"></a>泛型的实现（擦除法）</h1><blockquote><p>泛型是一种类似”模板代码”的技术，不同语言的泛型实现方式不同。</p><p>Java语言的泛型实现是擦除法（Type Erasure）。</p></blockquote><h2 id="擦除法简介"><a href="#擦除法简介" class="headerlink" title="擦除法简介"></a>擦除法简介</h2><p>所谓擦拭法，指的是虚拟机对泛型一无所知，所有的工作都是编译器做的。</p><p>例如，若我们编写了一个泛型类Pair <T>， 源码如下：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br><span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br></code></pre></td></tr></table></figure><p>经过编译器的编译，对泛型的“擦除”，虚拟机中所见如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-keyword">private</span> Object first;<br>    <span class="hljs-keyword">private</span> Object last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(Object first, Object last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pair</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> (String) p.getFirst();<br><span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> (String) p.getLast();<br></code></pre></td></tr></table></figure><p>Java通过擦除法所做的工作：</p><ul><li>编译器将所有的类型<T>视为Object处理</T></li><li>需要转型的时候，编译器根据<T>实现安全的强制类型转换</T></li></ul><h2 id="擦除法的局限"><a href="#擦除法的局限" class="headerlink" title="擦除法的局限"></a>擦除法的局限</h2><ul><li><p><T>不能是基本类型。</T></p><blockquote><p>例如int，因为编译过后的实际类型是Object，Object类型无法持有基本类型。</p></blockquote></li><li><p>无法取得带泛型的Class。</p><blockquote><p>观察如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Pair&lt;String&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> p1.getClass();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p2.getClass();<br>        <span class="hljs-comment">//p1和p2是不同的泛型实例，但是它们是同一个class</span><br>        <span class="hljs-comment">//即无论T为什么类型，getClass返回的都是同一个Class实例</span><br>        <span class="hljs-comment">//因为编译过后它们都是Pair&lt;Object&gt;</span><br>        System.out.println(c1==c2); <span class="hljs-comment">// true</span><br>        System.out.println(c1==Pair.class); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>无法判断带泛型的类型</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br><span class="hljs-comment">// Compile error:</span><br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Pair&lt;String&gt;) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因和前面一样，并不存在Pair<String>.class，而是只有唯一的Pair.class</String></p></blockquote></li><li><p>在泛型类中，不能直接实例化T类型</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Compile error:</span><br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>擦除过后的实际语句为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p>所以说在泛型类中不管T是什么类型，最后都是Object。所以说编译器会阻止这种类型不对的代码。</p><p>如果要实例化T类型，那么就需要传入额外的Class<T>参数，借助反射来实例化：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> &#123;<br>        first = clazz.newInstance();<br>        last = clazz.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="不恰当的覆写方法"><a href="#不恰当的覆写方法" class="headerlink" title="不恰当的覆写方法"></a>不恰当的覆写方法</h2><p>如下代码，看似正确却无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">this</span> <span class="hljs-operator">=</span>= t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为定义的equals(T t)经过泛型擦除过后变成equals(Object t)，而这个方法是继承只Object的，相当于覆写了Object的方法。而编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>解决办法：换衣个方法名，避免于Object.equals(Object) 的冲突</p><h2 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h2><blockquote><p>一个类可以继承自一个泛型类。</p></blockquote><p>例如：父类是Pair<Integer>，子类是IntPair，可以这样继承：</Integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Integer&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，因为子类IntPair并没有泛型类型，所以直接使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntPair</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntPair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="父类的泛型类型T的继承"><a href="#父类的泛型类型T的继承" class="headerlink" title="父类的泛型类型T的继承"></a>父类的泛型类型T的继承</h3><p>因为泛型擦除，所以我们无法获取Pair<T>的T类型。即给定一个变量Pair<Integer> p实例，无法从p中获取到Integer类型。</Integer></T></p><p>但是在泛型的继承中，编译器会把泛型类型的父类中的类型T保存到子类的class文件中。</p><p>所以在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p><p>获取父类的泛型类型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//获取子类的Class实例</span><br>        Class&lt;IntPair&gt; clazz = IntPair.class;<br>        <span class="hljs-comment">//从Class实例中获取Type</span><br>        <span class="hljs-type">Type</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> clazz.getGenericSuperclass();<br>        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">pt</span> <span class="hljs-operator">=</span> (ParameterizedType) t;<br>            Type[] types = pt.getActualTypeArguments(); <span class="hljs-comment">// 可能有多个泛型类型</span><br>            <span class="hljs-type">Type</span> <span class="hljs-variable">firstType</span> <span class="hljs-operator">=</span> types[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 取第一个泛型类型</span><br>            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;<br>            System.out.println(typeClass); <span class="hljs-comment">// Integer</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IntPair</span><span class="hljs-params">(Integer first, Integer last)</span> &#123;<br>        <span class="hljs-built_in">super</span>(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于Type"><a href="#关于Type" class="headerlink" title="关于Type"></a>关于Type</h3><p>由于Java引入了泛型，所以只用Class类标识类型已经不够了。</p><p>所以说Java的类型结构如下：</p><ul><li>父接口Type<ul><li>子接口<ul><li>ParameterizedType</li><li>GenericArrayType</li><li>WildcardType</li><li>TypeVariable</li></ul></li><li>实现类<ul><li>Class</li></ul></li></ul></li></ul><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><h2 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h2><p>在泛型的继承关系中：Pair<Integer>不是Pair<Number>的子类。</Number></Integer></p><h3 id="场景考虑"><a href="#场景考虑" class="headerlink" title="场景考虑"></a>场景考虑</h3><p>首先我们定义了一个pair<T>：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirst</span><span class="hljs-params">(T first)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLast</span><span class="hljs-params">(T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后编写一个工具类PairHelper，其中有一个静态方法，将Pair<Number> 作为参数传入：</Number></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PairHelper</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;Number&gt; p)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用这个静态方法的时候，我们出入一个Pair<Number>实例：</Number></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> PairHelper.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Number&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>注意：传入的类型是Pair<Number>，但Pair<Number>中的实际参数是Integer</Number></Number></p><p>但是如果直接传入Pair<Integer>会编译错误：</Integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> PairHelper.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Number&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">//编译报错</span><br>incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;<br></code></pre></td></tr></table></figure><p>因为add方法传入的参数是Pair<Number>，所以编译器不允许传入Pair<Integer>。</Integer></Number></p><p>但是按照add方法的代码逻辑来说，传入Pair<Integer>是符合要求的。</Integer></p><h3 id="extends的引入"><a href="#extends的引入" class="headerlink" title="extends的引入"></a>extends的引入</h3><p>这里的需求就是：让方法接收泛型类型为Number及其子类的Pair类型</p><p>Pair&lt;? extends Number&gt; 即可实现该需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意：是给方法传入参数的时候使用Pair&lt;? extends Number&gt;，而不是在Pair泛型定义的时候，定义时仍是Pair&lt;T&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用&lt;? extends Number&gt;过后，add方法可以传入各种Pair类型，比如说Pair<Double>、Pair<BigDecimal>等，因为Double和BigDecimal都是Number的子类。</BigDecimal></Double></p><? extends Number>称为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number。### extends的语义（只读）#### get方法我们考察对Pair<? extends Number>类型调用getFirst()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br>    <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>&#125;<br></code></pre></td></tr></table></figure>getFirst()方法编译过后的实际签名为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; getFirst();<br></code></pre></td></tr></table></figure>即返回值是Number或Number的子类，因此使用getFirst方法获取的返回值可以安全的赋值给Number类型的变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> p.getFirst();<br></code></pre></td></tr></table></figure>不能使用Number的子类接收返回值，因为编译器只能确定返回的类型一定是Number及其子类，但是具体类型无法确定。#### set方法对Pair<? extends Number>类型调用setFirst()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> p.getLast();<br>        p.setFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(first.intValue() + <span class="hljs-number">100</span>));<br>        p.setLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(last.intValue() + <span class="hljs-number">100</span>));<br>        <span class="hljs-keyword">return</span> p.getFirst().intValue() + p.getFirst().intValue();<br>&#125;<br><br><span class="hljs-comment">//会得到编译错误</span><br>incompatible types: Integer cannot be converted to CAP#<span class="hljs-number">1</span><br>where CAP#<span class="hljs-number">1</span> is a fresh type-variable:<br>    CAP#<span class="hljs-number">1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> from capture of ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span><br></code></pre></td></tr></table></figure>这是因为<? extends Number>通配符的一个重要限制：> 无法传递任何Number的子类型给setFirst(? extends Number)方法(除了null)。还是利用反证法来证明这个限制的合理性：> 假设传入add方法的是Pair<Integer>，如果没有这个限制，，那么通过setFirst方法可以传入Number类型及其子类，也就是说可以传入Double类型的参数，那么显然是Pair<Integer>  是无法接收Double类型的数据的。### 具体分析Pair<T>定义（简化）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirst</span><span class="hljs-params">(T first)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>将Pair<? extends Number>作为参数传入方法： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> p.getFirst();<br>    p.setFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(first.intValue() + <span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure>传入add方法的p的泛型类型可以是Number类型及其子类。- 那么对p调用get，得到的返回值可能是Integer、Double等，但是一定是Number的子类，所以使用Number可以安全的接收。- 对p调用set方法，由于p的具体泛型类型不知道，p可以接收的类型也不能确定，除了null是一定可以接收的。相当于<? extends Number>把add方法接收的Pair的泛型类型限定在null和Number之间。从Pair中取数据，一定在null和Number之间，所以可以用Number接收。往Pair中存数据，因为Pair能够接收的数据在null和Number之间，只有null能被所有不同泛型类型接收。### extends通配符的作用 考察List<T>接口，它实现一个类似可变数组的列表，其定义如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 获取个数</span><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>; <span class="hljs-comment">// 根据索引获取指定元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T t)</span>; <span class="hljs-comment">// 添加一个新元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(T t)</span>; <span class="hljs-comment">// 删除一个已有元素</span><br>&#125;<br></code></pre></td></tr></table></figure>如果我们要定义一个方法来处理List<T>类型列表中的每一个元素：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sumOfList</span><span class="hljs-params">(List&lt;? extends Integer&gt; list)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.get(i);<br>        sum = sum + n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>为什么定义方法的参数类型是List<? extends Integer>而不是List<Integer>?- 从方法内部的代码看，使用二者是完全一样的。- 但是由于<? extends Integer>的限制，能确保编写的方法对List只进行读操作  > 因为List<? extends Integer>的限制：  >  > - 允许调用List的get方法获取Integer的引用  > - 不允许调用List的set方法传入任何类型数据（除了null）  >  > 因此，定义方法参数类型List<? extends Integer>表名该方法内部只会读取List的元素，不会修改List的元素，即对List<? extends Integer>进行只读操作。### 使用extends限定T类型前面讨论的都是将泛型作为参数传入方法时，限定传入泛型的泛型类型。在定义泛型类型的时候，也可以使用extends通配符来限定能够创建的泛型的泛型类型。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; &#123; ... &#125;<br><span class="hljs-comment">//使用extends限定过后，就只能创建Number及其子类型泛型的实例</span><br>Pair&lt;Number&gt; p1 = <span class="hljs-literal">null</span>;<br>Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Pair&lt;Double&gt; p3 = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//非Number类型的泛型无法通过编译</span><br>Pair&lt;String&gt; p1 = <span class="hljs-literal">null</span>; <span class="hljs-comment">// compile error!</span><br>Pair&lt;Object&gt; p2 = <span class="hljs-literal">null</span>; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure>## super通配符基本同extends通配符，具体不赘述。## 对比extends和super作为方法参数，二者的区别：- <? extend T>允许调用泛型的T get()获取T的实例，但不允许调用set(T)传入T的引用- <? super T> 允许调用set(T)传入T的引用，但不允许调用T get()获取T的实例即一个限定只读，一个限定只写。### extends和super的特性应用先来看看Collections类定义的静态方法copy()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i);<br>            dest.add(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>它的作用是将一个List的元素复制到另一个List中。- 第一个参数：List<? super T> dest。限定只写- 第二个参数：List<? extends T> src。限定只读这个copy ()方法的定义就完美地展示了extends和super的意图：- copy方法内部不会读取dest- cope方法内部不会修改src这是由编译器检查来实现的，如果在copy方法中修改了src或读取了dest，编译器会报错。### PECS原则> Producer Extends Consumer Super。>> PECS原则就是便于记忆何时是使用extends，何时使用super即如果需要返回T，它是生产者Producer，要使用extens通配符如果需要写入T，它是消费者Consumer，要使用super通配符还是以Collections的copy()方法为例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i); <span class="hljs-comment">// src是producer</span><br>            dest.add(t); <span class="hljs-comment">// dest是consumer</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>- src需要返回T，是生产者，因此声明为List<? extends T>- dest需要写入T，是消费者，因此声明为List<? super T>## 无限定通配符前面讨论了<? extends T>和<? super T>作为方法参数的作用。实际上，Java的泛型还允许无限定通配符(Unbounded Wildcard Type)，即只定义一个？：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sample</span><span class="hljs-params">(Pair&lt;?&gt; p)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><?><p>通配符的语义：不能调用set(T)，也不能调用T get()，即不能读也不能写。</p><?>通配符的作用：可以进行null判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNull</span><span class="hljs-params">(Pair&lt;?&gt; p)</span> &#123;<br>    <span class="hljs-keyword">return</span> p.getFirst() == <span class="hljs-literal">null</span> || p.getLast() == <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><?><p>通配符的特点：Pair&lt;?&gt;是所有Pair<T>的超类</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>    Pair&lt;?&gt; p2 = p; <span class="hljs-comment">// 安全地向上转型</span><br>    System.out.println(p2.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p2.getLast());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h1><h2 id="泛型的反射API"><a href="#泛型的反射API" class="headerlink" title="泛型的反射API"></a>泛型的反射API</h2><h3 id="Class-lt-T-gt"><a href="#Class-lt-T-gt" class="headerlink" title="Class&lt;T&gt;"></a>Class&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// compile warning:</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) clazz.newInstance();<br><br><span class="hljs-comment">// no warning:</span><br>Class&lt;String&gt; clazz = String.class;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> clazz.newInstance();<br></code></pre></td></tr></table></figure><p> 调用Class的getSuperclass()方法返回的Class类型是Class&lt;? super T&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;? <span class="hljs-built_in">super</span> String&gt; sup = String.class.getSuperclass();<br></code></pre></td></tr></table></figure><h3 id="Constructor-lt-T-gt"><a href="#Constructor-lt-T-gt" class="headerlink" title="Constructor&lt;T&gt;"></a>Constructor&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Integer&gt; clazz = Integer.class;<br>Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="hljs-type">int</span>.class);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cons.newInstance(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><h3 id="声明与创建泛型数组"><a href="#声明与创建泛型数组" class="headerlink" title="声明与创建泛型数组"></a>声明与创建泛型数组</h3><p>我们可以声明带泛型的数组，但是不能直接使用new操作符创建带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt;[] ps = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ok</span><br>Pair&lt;String&gt;[] ps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;String&gt;[<span class="hljs-number">2</span>]; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>要创建带泛型的数组需要强制转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><h3 id="使用泛型数组"><a href="#使用泛型数组" class="headerlink" title="使用泛型数组"></a>使用泛型数组</h3><p>不安全的使用泛型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>[<span class="hljs-number">2</span>];<br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>ps[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;String&gt;(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Integer&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// ClassCastException:</span><br>Pair&lt;String&gt; p = ps[<span class="hljs-number">1</span>];<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> p.getFirst();<br></code></pre></td></tr></table></figure><blockquote><p>数组实际上运行期没有泛型，编译器可以强制检查变量ps，因为它的类型是泛型数组。</p><p>但是编译器不会检查便变量arr，因为它不是泛型数组。</p><p>但是arr和ps实际都指向同一个数组，操作arr没有泛型数组的限制，可能导致从ps获取元素出错。</p></blockquote><p>如果要安全的使用泛型数组，必须扔掉arr的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p> 带泛型的数组实际上是编译器的类型擦除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>[<span class="hljs-number">2</span>];<br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>System.out.println(ps.getClass() == Pair[].class); <span class="hljs-comment">// true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (String) arr[<span class="hljs-number">0</span>].getFirst();<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> ps[<span class="hljs-number">0</span>].getFirst();<br></code></pre></td></tr></table></figure><p>所以我们不能在发行类中直接创建泛型数组T[]，因为擦拭后代码变为Object[]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abc</span>&lt;T&gt; &#123;<br>    T[] createArray() &#123;<br>        <span class="hljs-comment">// compile error</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">5</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同创建T实例一样，创建泛型数组也需要借助Class&lt;T&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T[] createArray(Class&lt;T&gt; cls) &#123;<br>    <span class="hljs-keyword">return</span> (T[]) Array.newInstance(cls, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以在静态方法中使用泛型可变参数来创建泛型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayHelper</span> &#123;<br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br><br>String[] ss = ArrayHelper.asArray(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>Integer[] ns = ArrayHelper.asArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>使用泛型可变参数创建泛型数组这种方法很危险：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] arr = asArray(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// ClassCastException:</span><br>        String[] firstTwo = pickTwo(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        System.out.println(Arrays.toString(firstTwo));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;<br>        <span class="hljs-keyword">return</span> asArray(k1, k2);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接通过类调用asArray静态方法没有问题。但是在类的另一个静态方法pickTwo中调用asArray，则会抛出异常ClassCastExeption。</p><p>因为泛型擦除，在pickTwo方法内部K被擦除为Object，所以k1和k2都是Object类型数据，那么将k1和k2传入asArray方法返回的就是Object[]数组。</p><p>编译器对所有的可变泛型参数都会发出警告。除非确认完全没有问题，才可以使用@SafeVarargs消除警告。</p></Integer></T></T></T></Integer></Integer>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>注解</title>
    <link href="/2022/10/25/%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/10/25/%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、注解简介"><a href="#一、注解简介" class="headerlink" title="一、注解简介"></a>一、注解简介</h1><h2 id="什么是注解（Annotation）？"><a href="#什么是注解（Annotation）？" class="headerlink" title="什么是注解（Annotation）？"></a>什么是注解（Annotation）？</h2><blockquote><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p><p>注解会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此注解是一种用作标注的“元数据”</p></blockquote><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p><p>注解可以根据其生命周期分为三类：</p><ul><li><p>仅编译器（由编译器使用的注解）</p><blockquote><p>@Override：让编译器检查该方法是否正确地实现了覆写</p><p>@SuppressWarnings：告诉编译器忽略此处代码产生地警告</p><p>这类注解不会被编译进入.class文件，它们只在编译的时候起作用。</p></blockquote></li><li><p>仅class文件（由工具处理.class文件使用的注解）</p><blockquote><p>有些工具会在加载class的时候，对class做动态修改，实现一些功能。</p><p>这些注解会被编译进入.class文件，但加载结束后并不会存在内存中。</p><p>这类注解只被一些底层库使用，一般我们不必自己处理。</p></blockquote></li><li><p>运行期（在程序运行期能够读取的注解）</p><blockquote><p>这类注解在加载后一直存在于JVM中，这也是最常用的注解。</p><p>例如：一个配置了@PostConstruct的方法会在调用构造方法后被自动调用（这是Java代码读取该注解实现的功能，JVm并不会识别该注解）</p></blockquote></li></ul><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>配置参数:</p><blockquote><p>定义一个注解的时候，可以定义配置参数，可以设置默认值。</p></blockquote><p>配置参数类型：</p><blockquote><p>配置参数可以包括：基本类型、String、Classs以及枚举的数组。</p><p>因为配置参数必须是常量，限制配置参数为以上类型，就保证了其为常量。</p></blockquote><p>使用注解：</p><blockquote><p>因为注解的配置参数可以有默认值。所以说使用注解的时候，若某个参数没有传入值，则使用默认参数。</p><p>所有注解都会有一个名为value的配置参数，如果说直写常量，相当于是给value传参。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-meta">@Check(min=0, max=100, value=55)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-meta">@Check(value=99)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> p;<br><br>    <span class="hljs-meta">@Check(99)</span> <span class="hljs-comment">// @Check(value=99)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> x;<br><br>    <span class="hljs-meta">@Check</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、定义注解"><a href="#二、定义注解" class="headerlink" title="二、定义注解"></a>二、定义注解</h1><blockquote><p>Java语言使用@interface语法来定义注解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解的参数类似无参方法，可以用default设定一个默认值。最常用的参数应当命名为value</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><blockquote><p>有一些注解可以修饰其他注解，这些注解就称为元注解。</p></blockquote><p>Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h3 id="Target（最常用）"><a href="#Target（最常用）" class="headerlink" title="@Target（最常用）"></a>@Target（最常用）</h3><blockquote><p>@Target可以定义Annotation能够被应用于源码的哪些位置。</p></blockquote><p>不同参数代表被修饰的注解可以使用的位置：</p><ul><li>类或接口：ElementType.TYPE</li><li>字段：ElementType.FIELD</li><li>方法：ElementType.METHOD</li><li>构造方法：ElementType.CONSTRUCTOR</li><li>方法参数：ElementType.PARAMETER</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义@Report可以用在方法或字段上</span><br><span class="hljs-meta">@Target(&#123;</span><br><span class="hljs-meta">    ElementType.METHOD,</span><br><span class="hljs-meta">    ElementType.FIELD</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//定义@Report可用在方法上</span><br><span class="hljs-comment">//实际上@Target定义value是ElementType[]数组，只有一个元素的时候，可以省略数组的写法</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Retention（必备）"><a href="#Retention（必备）" class="headerlink" title="@Retention（必备）"></a>@Retention（必备）</h3><blockquote><p>@Retention定义了Anotation的生命周期。</p></blockquote><ul><li>仅编译器：RetentionPolicy.SOURCE</li><li>仅class文件：RetentionPolicy.CLASS</li><li>运行期：RetentionPolicy.RUNTIME</li></ul><p>如果没有@Retention，默认该Annotation生命周期为CLASS。</p><p>注意：因为我们自定义的Annotation都是RUNTIME，多以在自定义注解的时候一定要加上@Retention(RetentionPolicy.RUNTIME)这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Repeatable（不常用）"><a href="#Repeatable（不常用）" class="headerlink" title="@Repeatable（不常用）"></a>@Repeatable（不常用）</h3><blockquote><p>@Repeatable定义了Annotaion是否可以重复。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(Reports.class)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Reports &#123;<br>    Report[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Peport注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Report(type=1, level=&quot;debug&quot;)</span><br><span class="hljs-meta">@Report(type=2, level=&quot;warning&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><blockquote><p>使用@Inherited定义子类是否可以继承父类定义的Annotation。</p><p>注意：@Inherited仅针对@Target(ElementType.Type)类型的annotation有效，并且仅针对class的继承，对interface的继承无效。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果一个类用到了@Report：</span><br><span class="hljs-meta">@Report(type=1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br><span class="hljs-comment">//它的子类默认也定义了该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何定义Annotation"><a href="#如何定义Annotation" class="headerlink" title="如何定义Annotation"></a>如何定义Annotation</h2><p>步骤一、用@interface定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤二、添加参数、默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤三、用元注解注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Target、@Retention必须设置</span><br><span class="hljs-comment">//@Inherited、@Repeatable一般不需要</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、处理注解"><a href="#三、处理注解" class="headerlink" title="三、处理注解"></a>三、处理注解</h1><p>Java的注解对代码逻辑没有任何影响。</p><p>根据@Retention的配置：</p><ul><li>SOURCE类型的注解在编译器结束就被丢弃（只使用）</li><li>CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM（由底层工具库使用）</li><li>RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序（经常使用，且还需要编写）</li></ul><p>SOURCE和CLASS类型的注解不需要我们编写。所以说，我们只讨论如何读取RUNTIME类型的注解。</p><h2 id="读取注解"><a href="#读取注解" class="headerlink" title="读取注解"></a>读取注解</h2><blockquote><p>因为注解定义后也是一种class，说有注解都继承自java.lang.annotation.Annotation，因此读取注解，需要使用反射API。</p></blockquote><p>Class、Field、Method哈Constructor这几个类都实现了Annotation相关的反射API。</p><ul><li><p>isAnnotationPresent(Class)：判断某注解是否存在</p><blockquote><p>返回boolean类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断@Report是否存在于Person类:</span><br>Person.class.isAnnotationPresent(Report.class);<br></code></pre></td></tr></table></figure></li><li><p>getAnnotation(Class)：使用反射获取Annotation</p><blockquote><p>如果某注解不存在，使用getAnnotion获取会返回null。</p><p>所以在使用getAnnotation前，可以使用isAnnotationPresent来判断注解是否存在</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Person定义的@Report注解:</span><br><span class="hljs-type">Report</span> <span class="hljs-variable">report</span> <span class="hljs-operator">=</span> Person.class.getAnnotation(Report.class);<br><span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> report.type();<br><span class="hljs-type">String</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> report.level();<br></code></pre></td></tr></table></figure></li></ul><p>上面的示例是获取Class的注解，但是对于方法而言，方法本身可以有注解，方法的参数也可以有注解。</p><ul><li><p>获取方法本身的注解</p><blockquote><p> 和获取Class的注解一样，对Mehod对象调用对应方法即可。</p></blockquote></li><li><p>获取方法参数的注解</p><blockquote><p>因为方法可以有多个参数，每个参数可以有多个注解。所以说获取方法参数的注解需要一个二维数组。</p></blockquote><p>方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> <span class="hljs-meta">@Range(max=5)</span> String name, <span class="hljs-meta">@NotNull</span> String prefix)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取方法参数的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Method实例:</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ...<br><span class="hljs-comment">// 获取所有参数的Annotation:</span><br>Annotation[][] annos = m.getParameterAnnotations();<br><span class="hljs-comment">// 第一个参数（索引为0）的所有Annotation:</span><br>Annotation[] annosOfName = annos[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (Annotation anno : annosOfName) &#123;<br>    <span class="hljs-keyword">if</span> (anno <span class="hljs-keyword">instanceof</span> Range) &#123; <span class="hljs-comment">// @Range注解</span><br>        <span class="hljs-type">Range</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Range) anno;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anno <span class="hljs-keyword">instanceof</span> NotNull) &#123; <span class="hljs-comment">// @NotNull注解</span><br>        <span class="hljs-type">NotNull</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (NotNull) anno;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用注解-1"><a href="#使用注解-1" class="headerlink" title="使用注解"></a>使用注解</h2><p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。</p><h4 id="来看一个-Range注解的例子："><a href="#来看一个-Range注解的例子：" class="headerlink" title="来看一个@Range注解的例子："></a>来看一个@Range注解的例子：</h4><p>我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义</p><p><strong>@Range注解定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Range &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">255</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用@Range注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Range(min=1, max=20)</span><br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-meta">@Range(max=10)</span><br>    <span class="hljs-keyword">public</span> String city;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面只是定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。</p><p>我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(Person person)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException,ReflectiveOperationException &#123;<br>    <span class="hljs-comment">// 遍历所有Field:</span><br>    <span class="hljs-keyword">for</span> (Field field : person.getClass().getFields()) &#123;<br>        <span class="hljs-comment">// 获取Field定义的@Range:</span><br>        <span class="hljs-type">Range</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> field.getAnnotation(Range.class);<br>        <span class="hljs-comment">// 如果@Range存在:</span><br>        <span class="hljs-keyword">if</span> (range != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 获取Field的值:</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.get(person);<br>            <span class="hljs-comment">// 如果值是String:</span><br>            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) value;<br>                <span class="hljs-comment">// 判断值是否满足@Range的min/max:</span><br>                <span class="hljs-keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid field: &quot;</span> + field.getName());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/10/25/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/10/25/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>处理int等基本类型外，Java的其他类型全部都是class（包括interface）。</p><p>例如：</p><ul><li>String</li><li>Object</li><li>Runable</li><li>Exception</li><li>…</li></ul><p>所以说class的本质就是数据类型（Type）。无继承关系的数据类型无法赋值。</p><h2 id="class动态加载"><a href="#class动态加载" class="headerlink" title="class动态加载"></a>class动态加载</h2><p>class由JVM在执行过程中动态加载。JVM在第一次读取到一种class类型时，将其加载进内存。每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。</p><p>注意：这里的Class类型是一个名叫Class的class。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Class</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以String类为例。当JVM加载String类时，它首先读取String.class文件到内存，然后为String类创建一个Class实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>(String);<br></code></pre></td></tr></table></figure><p>这个Class实例时JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法为private，<strong>只有JVM能创建Class实例</strong>，我们自己的Java程序是无法创建Class实例的。</p><p>所以JVM持有的每个Class实例都指向一个数据类型（Class或interface）：</p><p><img src="/2022/10/25/%E5%8F%8D%E5%B0%84/image-20221025203443827.png" alt="image-20221025203443827"></p><p>一个Class实例包含了该class的所有完整信息：</p><p><img src="/2022/10/25/%E5%8F%8D%E5%B0%84/image-20221025203520398.png" alt="image-20221025203520398"></p><p>JVM动态加载特性：程序执行的时候，当JVM发现需要使用到某个类的时候，才会首次加载该类。</p><p>动态加载class的特性对于Java程序非常重要。利用JVM动态加载class的特性，我们才能在运行期根据不同条件加载不同的实现类。</p><p>例如：Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。</p><p>利用JVM动态加载的特性，大致实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">/ Commons Logging优先使用Log4j:<br><span class="hljs-type">LogFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (isClassPresent(<span class="hljs-string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;<br>    factory = createLog4j();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    factory = createJdkLog();<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isClassPresent</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class.forName(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等。因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。</p><p><strong>这种通过Class实例获取class信息的方法称为反射（Reflection）</strong>。</p><p>获取Class实例的方法：</p><ul><li><p>通过class的静态变量class获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> String.class;<br></code></pre></td></tr></table></figure></li><li><p>通过实例变量的getClass()方法获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> s.getClass();<br></code></pre></td></tr></table></figure></li><li><p>根据class的完成类名，通过静态方法Class.forName()获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>因为Class实例在JVM中是唯一的，所以不同方法获取的Class实例是同一个。</p><p><strong>Class实例和instanceof的区别：</strong></p><ul><li>instanceof不但匹配指定的类型，还匹配指定类型的子类</li><li>使用&#x3D;&#x3D;判段class实例可以精确地判断数据类型，不能做子类型比较</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Integer; <span class="hljs-comment">// true，因为n是Integer类型</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Number; <span class="hljs-comment">// true，因为n是Number类型的子类</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> n.getClass() == Integer.class; <span class="hljs-comment">// true，因为n.getClass()返回Integer.class</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> n.getClass() == Number.class; <span class="hljs-comment">// false，因为Integer.class!=Number.class</span><br></code></pre></td></tr></table></figure><p>二者的使用场景：</p><p>通常情况下，我们使用instanceof判断数据类型，因为面向抽象编程地时候，我们不关心具体地子类型。</p><p>当需要精确判断一个类型是不是某个class的时候，我们才使用&#x3D;&#x3D;来判断class实例。</p><p><strong>通过Class实例创建对应类型的实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取String的Class实例:</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-comment">// 创建一个String实例:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) cls.newInstance();<br></code></pre></td></tr></table></figure><p>上述代码相当于new String()。</p><p>通过Class.nweInstance()可以创建类实例，但是它只能调用public的无参构造方法。</p><h1 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h1><h2 id="获取字段信息"><a href="#获取字段信息" class="headerlink" title="获取字段信息"></a>获取字段信息</h2><p>通过Class实例获取字段信息的方法：</p><ul><li>Field getField(name)：根据字段名获取当前类某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getField()：获取所有的public的field（包括父类）</li><li>Field[] get DeclaredFields()：获取所有的field（不包括父类）</li></ul><p>Field对象包含一个字段的所有信息：</p><ul><li>getName()：返回字段名称。返回值为String</li><li>getType()：返回字段类型。返回值也是一个Class实例</li><li>int getModifiers()：返回字段的修饰符。返回值是一个int，不同bit表示不同的含义</li></ul><p>以String的value字段为例，获取其字段信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//String的value字段定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value;<br>&#125;<br><span class="hljs-comment">//获取该字段信息</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> String.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>f.getName(); <span class="hljs-comment">// &quot;value&quot;</span><br>f.getType(); <span class="hljs-comment">// class [B 表示byte[]类型</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> f.getModifiers();<br>Modifier.isFinal(m); <span class="hljs-comment">// true</span><br>Modifier.isPublic(m); <span class="hljs-comment">// false</span><br>Modifier.isProtected(m); <span class="hljs-comment">// false</span><br>Modifier.isPrivate(m); <span class="hljs-comment">// true</span><br>Modifier.isStatic(m); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h2><p><strong>获取字段值的步骤：</strong></p><ol><li>通过实例对象获取Class实例</li><li>由Class实例获取字段对应的Field</li><li>使用获取的Field获取实例对象的字段值</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>);<br>        <span class="hljs-comment">//1. 获取Class</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClass();<br>        <span class="hljs-comment">//2. 获取Field</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//3. 获取字段值</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> f.get(p);<br>        System.out.println(value); <span class="hljs-comment">// &quot;Xiao Ming&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//private无法通过Field获取值</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码执行会抛出IllegalAccessException异常。因为name字段的访问权限时private，正常情况下Main类无法访问Person类的private字段。</p><p>若想要访问实例对象的private字段，则可以先对Field对象执行setAccessible(true)方法，该方法的意思是，不管这个字段的访问权限如何，一律允许访问。</p><p><strong>反射破坏封装：</strong></p><p>通过反射，可以获取对象的private字段的值，这破坏了类的封装。</p><p>既然反射和可以破坏封装，那么封装的意义在哪儿？</p><ul><li>正常情况下，我们总是通过p.name来访问Person的name字段，编译器会根据字段的访问权限来决定是否允许访问字段，这就达到了数据封装的目的。</li><li>而反射是一种非常规的用法，使用反射获取字段值，首先代码繁琐，其次，它更多地是给工具或者底层框架来使用的，目的是在不知道目标实例对象任何信息的情况下，获取特定字段的值。</li><li>setAccessible(true)不是一定成功。如果JVM运行期存在SecurityManager，那么它会根据队则进行检查，可能会阻止对某些类（例如以java和javax开头的package中的类）调用setAccessible(true)，这样可以保证JVM核心库的安全</li></ul><h2 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h2><p>设置字段的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Field.set(Object, Object)<br></code></pre></td></tr></table></figure><ul><li>第一个Object参数是指定需要修改字段值的实例对象</li><li>第二个Object参数是要设置的字段值</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>);<br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Xiao Ming&quot;</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClass();<br>        <br>        <span class="hljs-comment">//获取Field、设置访问权限、设置字段值</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        f.set(p, <span class="hljs-string">&quot;Xiao Hong&quot;</span>);<br>        <br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Xiao Hong&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h1><h2 id="获取Method"><a href="#获取Method" class="headerlink" title="获取Method"></a>获取Method</h2><p>Class类中获取Mehod的方法：</p><blockquote><p>这些方法的含义同上面获取字段方法的含义基本相同。</p><p>name为方法名字</p><p>Class为方法参数对应的Class实例</p></blockquote><ul><li>Method getMehod(name, Class…)</li><li>Method getDeclaredMethod(name, Class…)</li><li>Method getMehods()</li><li>Method get DeclaredMethods()</li></ul><p>Method对象包含一个方法的所有信息：</p><ul><li>String getName()</li><li>Class getReturnType()</li><li>Class[] getParameterTypes()</li><li>int getModifiers()</li></ul><h2 id="通过Method调用方法"><a href="#通过Method调用方法" class="headerlink" title="通过Method调用方法"></a>通过Method调用方法</h2><h3 id="调用普通方法"><a href="#调用普通方法" class="headerlink" title="调用普通方法"></a>调用普通方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-comment">//--常规调用--</span><br><span class="hljs-type">String</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">6</span>); <span class="hljs-comment">// &quot;world&quot;</span><br><br><span class="hljs-comment">//--反射调用--</span><br><span class="hljs-comment">// 获取String substring(int)方法，参数为int:</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> String.class.getMethod(<span class="hljs-string">&quot;substring&quot;</span>, <span class="hljs-type">int</span>.class);<br><span class="hljs-comment">// 在s对象上调用该方法并获取结果:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (String) m.invoke(s, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>对Mehod实例调用invoke就相当于调用该方法</p><ul><li>invoke的第一个参数是对象实例，即在哪个实例上调用该方法</li><li>后面的可变参数要与方法参数一致</li></ul><h3 id="调用静态方法："><a href="#调用静态方法：" class="headerlink" title="调用静态方法："></a>调用静态方法：</h3><p>在调用invoke的时候第一个参数传null即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Integer.parseInt(String)方法，参数为String:</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Integer.class.getMethod(<span class="hljs-string">&quot;parseInt&quot;</span>, String.class);<br><span class="hljs-comment">// 调用该静态方法并获取结果:</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (Integer) m.invoke(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;12345&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="调用非public方法"><a href="#调用非public方法" class="headerlink" title="调用非public方法"></a>调用非public方法</h3><p>通过setAccessible(true)获取访问权限后再调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.getClass().getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        m.setAccessible(<span class="hljs-literal">true</span>);<br>        m.invoke(p, <span class="hljs-string">&quot;Bob&quot;</span>);<br>        System.out.println(p.name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>考察这么一种情况：</p><p>父类Person定义了Hello()方法，并且它的子类也覆写了hello()方法。那么从Person.class获取的Method，作用域Student实例时，调用的方法是Person的hello方法还是Student的hello方法？</p><p>结果：</p><p>通过反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//反射调用方法的代码</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Person.class.getMethod(<span class="hljs-string">&quot;hello&quot;</span>);<br>m.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br><br><span class="hljs-comment">//上述放射代码等价于如下代码</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>p.hello();<br></code></pre></td></tr></table></figure><h1 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h1><p>反射创建实例的方法：</p><ul><li><p>可以通过Class的newInstance方法来反射创建新的实例。但是它只能调用该类的public无参构造方法。</p></li><li><p>如果需要调用类的其他构造方法，那么则需要通过获取Constructor对象来创建实例。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取构造方法Integer(int):</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons1</span> <span class="hljs-operator">=</span> Integer.class.getConstructor(<span class="hljs-type">int</span>.class);<br>        <span class="hljs-comment">// 调用构造方法:</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> (Integer) cons1.newInstance(<span class="hljs-number">123</span>);<br>        System.out.println(n1);<br><br>        <span class="hljs-comment">// 获取构造方法Integer(String)</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cons2</span> <span class="hljs-operator">=</span> Integer.class.getConstructor(String.class);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> (Integer) cons2.newInstance(<span class="hljs-string">&quot;456&quot;</span>);<br>        System.out.println(n2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取Constructor也有四种方法，同上面获取Field和Mehtod类似，不再赘述。</p><p>同样调用private的Construcor时，也需要使用setAccessible(true)设置允许访问。</p><p>注意：Constructor总是当前类定义的构造方法，和父类无关（构造方法无法继承和重载），因此不存在多态问题。</p><h1 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h1><h2 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a>获取父类的Class</h2><p>有了Class实例，我们还可以通过该Class实例获取父类的Class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.class;<br>        <span class="hljs-comment">//Integer父类Number</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.getSuperclass();<br>        System.out.println(n);<br>        <span class="hljs-comment">//Number父类Object</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> n.getSuperclass();<br>        System.out.println(o);<br>        <span class="hljs-comment">//Object父类null</span><br>        System.out.println(o.getSuperclass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a>获取interface</h2><h4 id="获取类实现的接口："><a href="#获取类实现的接口：" class="headerlink" title="获取类实现的接口："></a>获取类实现的接口：</h4><p>由于一个类可以实现一个或多个接口，通过Class实例，可以获取类实现的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Integer.class;<br>        <span class="hljs-comment">//interface也是Class</span><br>        Class[] is = s.getInterfaces();<br>        <span class="hljs-keyword">for</span> (Class i : is) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括父类实现的接口类型。</p><h4 id="获取接口的父接口："><a href="#获取接口的父接口：" class="headerlink" title="获取接口的父接口："></a>获取接口的父接口：</h4><p>因为接口可以继承接口，如果要获取接口的父接口，不能对interface的Class实例调用getSuperclass()，获取接口的父接口要用getinterfaces()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(java.io.DataInputStream.class.getSuperclass()); <br><span class="hljs-comment">// 输出java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span><br><br>System.out.println(java.io.Closeable.class.getSuperclass()); <br><span class="hljs-comment">// 输出null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span><br></code></pre></td></tr></table></figure><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>如果需要判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isDouble</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Double; <span class="hljs-comment">// false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isInteger</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Integer; <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isNumber</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Number; <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isSerializable</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> java.io.Serializable; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Integer i = ?</span><br>Integer.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Integer</span><br><span class="hljs-comment">// Number n = ?</span><br>Number.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Number</span><br><span class="hljs-comment">// Object o = ?</span><br>Object.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Object</span><br><span class="hljs-comment">// Integer i = ?</span><br>Integer.class.isAssignableFrom(Number.class); <span class="hljs-comment">// false，因为Number不能赋值给Integer</span><br></code></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><blockquote><p>动态代理（Dynamic Proxy）机制：可以在运行期动态创建某个interface的实例</p></blockquote><p>Java中class和interface的区别：</p><ul><li>class不可实例化</li><li>interface不能实例化</li></ul><h2 id="interface类型变量的获取"><a href="#interface类型变量的获取" class="headerlink" title="interface类型变量的获取"></a>interface类型变量的获取</h2><h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">morning</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><span class="hljs-comment">//编写实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">morning</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Good morning, &quot;</span> + name);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//创建实例，转型为接口调用</span><br><span class="hljs-type">Hello</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorld</span>();<br>hello.morning(<span class="hljs-string">&quot;Bob&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="通过动态代理获取"><a href="#通过动态代理获取" class="headerlink" title="通过动态代理获取"></a>通过动态代理获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1. 定义一个InvocationHandler实例。它负责实现接口的方法调用</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                System.out.println(method);<br>                <span class="hljs-comment">//通过接口方法名，可以对不同的方法执行不同的操作</span><br>                <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;morning&quot;</span>)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Good morning, &quot;</span> + args[<span class="hljs-number">0</span>]);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//2. 通过Proxy.newProxyInstance()创建interface实例</span><br>        <span class="hljs-comment">//3. 并将返回的Object强制转型为接口</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> (Hello) Proxy.newProxyInstance(<br>            <span class="hljs-comment">//ClassLoader。通常就是接口类的ClassLoader</span><br>            Hello.class.getClassLoader(), <br>            <span class="hljs-comment">//传入要实现的接口</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Hello.class &#125;, <br>            <span class="hljs-comment">//传入处理调用方法的InvocationHandler</span><br>            handler);<br>        hello.morning(<span class="hljs-string">&quot;Bob&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">morning</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理实际上是JVM在<strong>运行期动态创建class字节码并加载</strong>的过程。</p><p>上面的动态代理写成静态实现类大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloDynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Hello</span> &#123;<br>    InvocationHandler handler;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloDynamicProxy</span><span class="hljs-params">(InvocationHandler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">morning</span><span class="hljs-params">(String name)</span> &#123;<br>        handler.invoke(<br>           <span class="hljs-built_in">this</span>,<br>           Hello.class.getMethod(<span class="hljs-string">&quot;morning&quot;</span>, String.class),<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; name &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理就是相当于JVM帮我们自动编写了一个上述类（不需要源码，由JVM直接生成字节码）。并不存在什么可以直接实例化接口的方法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在程序运行中会出现各种<strong>错误</strong>，例如：</p><ul><li>用户造成的错误：<ul><li>输入错误类型</li><li>程序想要读某个文件，但是已经被用户删除了</li></ul></li><li>随机出现，且无法避免的错误：<ul><li>网络中断</li><li>内存耗尽，程序崩溃</li><li>用户点击“打印”，但是根本没有打印机</li></ul></li></ul><p>一个健壮的程序必须处理各种各样的错误。所谓的错误，就是程序调用某个函数的时候，如果失败，就表示出错。</p><p>程序如何获知调用失败的信息？</p><ul><li><p>方法一：约定返回错误码</p><blockquote><p>预定返回不同的内容表示不同的执行情况。</p></blockquote></li><li><p>方法二：在语言层面上提供一个异常处理机制</p><blockquote><p>Java内置了一层异常处理机制，总是使用异常来表示错误。</p><p>异常是一种class，因此它本身带有类型信息。</p><p>异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离。</p></blockquote></li></ul><h2 id="Java异常继承关系"><a href="#Java异常继承关系" class="headerlink" title="Java异常继承关系"></a>Java异常继承关系</h2><p><img src="/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20221024215512715.png" alt="image-20221024215512715"></p><ul><li>Throwable<ul><li><strong>Error：严重错误，程序一般无法处理</strong><ul><li>OutOfMemoryError：内存耗尽</li><li>NoClassDefFoundError：无法加载某个Class</li><li>StackOverflowError：栈溢出</li></ul></li><li><strong>Exception：运行时错误，可以被捕获并处理</strong><ul><li><strong>RuntimeException：程序逻辑错误，需要修复程序本身</strong><ul><li>NullPointerException</li><li>IndexOutOfBoundsException</li><li>IllegalArgumentException<ul><li>NumberFormatException：数值类型的格式错误</li></ul></li></ul></li><li><strong>非RuntimeException：这些异常时程序逻辑处理的一部分(编译器强制处理)</strong><ul><li>IOException<ul><li>FileNotFoundException：未找到文件</li><li>SocketException：读取网络失败</li></ul></li></ul></li></ul></li></ul></li></ul><p>Java对异常处理的规定：</p><ul><li><p>必须捕获的异常：Checked Exception</p><blockquote><p>包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception</p></blockquote></li><li><p>不需要捕获的异常</p><blockquote><p>包括Error及其子类，RuntimeException及其子类</p></blockquote></li></ul><h1 id="异常的抛出、传播和捕获"><a href="#异常的抛出、传播和捕获" class="headerlink" title="异常的抛出、传播和捕获"></a>异常的抛出、传播和捕获</h1><h2 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h2><p>如果说程序出现了需要抛出异常的情况，可以抛出异常，分为两步：</p><ul><li>new一个Excepion实例</li><li>使用throw语句抛出</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span> <span class="hljs-keyword">throws</span> NumberFormatException &#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(<span class="hljs-string">&quot;null&quot;</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>throw和throws：</p><ul><li><p>方法通过throw<strong>抛出</strong>异常实例</p></li><li><p>throws<strong>声明</strong>方法可能会抛出的异常</p></li></ul><h2 id="异常的传播与捕获"><a href="#异常的传播与捕获" class="headerlink" title="异常的传播与捕获"></a>异常的传播与捕获</h2><p>catch异常过后，可以选择处理异常，也可以选择再抛出。再次抛出可以使用另一个异常将原始的异常封装。即新建异常时，将原始异常作为参数传入。也可以直接原封不动地抛出。</p><p>异常传播示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-comment">//捕获并处理异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process1();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//捕获异常，并抛出</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process2();<br>        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(e);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//源头抛出异常</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>异常的栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以从栈信息中查看到完成的方法调用链</span><br><br><span class="hljs-comment">//第二次被抛出时的异常信息</span><br>java.lang.IllegalArgumentException: java.lang.NullPointerException<br>    at Main.process1(Main.java:<span class="hljs-number">15</span>)<br>    at Main.main(Main.java:<span class="hljs-number">5</span>)<br><span class="hljs-comment">//原始异常信息</span><br>Caused by: java.lang.NullPointerException<br>    at Main.process2(Main.java:<span class="hljs-number">20</span>)<br>    at Main.process1(Main.java:<span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure><h2 id="关于finally"><a href="#关于finally" class="headerlink" title="关于finally"></a>关于finally</h2><ul><li><p>在try…catch…finally代码块中不论是否捕获异常，finally代码块都会执行。</p></li><li><p>若在finally代码块中抛出异常，那么原来在catch中准备抛出的异常就会丢失。</p><blockquote><p>如何解决：</p><p>在finally代码块中，新建异常后，使用addSuppressed方法将catch中捕获的异常填进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Exception</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Integer.parseInt(<span class="hljs-string">&quot;abc&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            origin = e;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>            <span class="hljs-keyword">if</span> (origin != <span class="hljs-literal">null</span>) &#123;<br>                e.addSuppressed(origin);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>绝大多数情况不要在finally中抛出异常。</p></blockquote></li></ul><p>finally中的代码在什么时候执行：</p><p>如果try、catch中没有return语句的话，finally中的代码就相当于添加到try和catch代码块的末尾。</p><p>如果说有return，那么finally中的代码在return前执行，准确的说是被return的代码执行完毕，return前。</p><p>例如：return i++;</p><p>执行的步骤，先执行i++获取最终需要return的值，然后执行return。finally代码块就是在i++执行完毕后，return前执行。</p><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>当需要在代码中抛出异常时，尽量使用JDK已定义的异常类型。</p><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系很重要。</p><p>常见的自定义异常做法：</p><ol><li><p>自定义一个BaseException作为“根异常”，然后派生出各种业务类型的异常。</p></li><li><p>BaseException需要从一个合适的Exception派生，通常从RuntimeException派生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(String message, Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其他的业务类型的异常就可以从BaseException派生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseException</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginFailedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseException</span> &#123;<br>&#125;<br><br>...<br></code></pre></td></tr></table></figure></li></ol><p>从RuntimeException继承BaseException的原因：不需要强制try catch</p><h1 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>在所有的RumtimeException异常中，NullPointerException时最常碰到的。</p><p>NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常时由JVM抛出的。（指针这个概念来自C语言，Java语言中并无指针。我们定义的变量实际上是引用，Null Pointer更确切地来说是Null Reference，不过二者区别不大）</p><h2 id="处理NPE"><a href="#处理NPE" class="headerlink" title="处理NPE"></a>处理NPE</h2><p>首先明确NullPointerException是一种代码逻辑错误，遇到NPE，遵循原则是早暴露，早修复，严禁使用try catch来隐藏这种编码错误。</p><p>异常分为两种：</p><ul><li>一种是代码的逻辑错误，需要修复代码。比如一个String为null，然后调用了String的方法。</li><li>另一种是无法避免的外界错误。比如尝试连接网络，网络连接失败，这种异常是代码逻辑的一部分，需要在代码中try catch处理这种异常</li></ul><p>好的编码习惯可以降低NPE的产生，例如：</p><ul><li><p>在成员变量定义的时候初始化</p></li><li><p>使用空字符串””，而不是默认的null</p></li><li><p>使用空数组，而不是默认的null</p></li></ul><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Math.abs(-<span class="hljs-number">123.45</span>);<br>    <span class="hljs-keyword">assert</span> x &gt;= <span class="hljs-number">0</span>;<br>    System.out.println(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>assert x &gt;&#x3D; 0 即为断言，断言预期x &gt;&#x3D; 0 为true。如果计算结果为false，则断言失败，抛出AssertionError。</p><blockquote><p>使用assert语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">assert</span> x &gt;= <span class="hljs-number">0</span> : <span class="hljs-string">&quot;x must &gt;= 0&quot;</span>;<br></code></pre></td></tr></table></figure><p>在抛出异常的时候会带上消息“x must &gt;&#x3D; 0”，更加方便调试</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Java断言的特点：断言失败会抛出AssertionError异常，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开法和测试阶段。</p><p>例如：</p><p>可恢复的程序错误，不应该使用断言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">assert</span> arr != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;array cannot be null&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JVM默认关闭断言指令，遇到assert语句就自动忽略了，不执行。</p><p>要执行assert语句，必须给Java虚拟机传递-enableassertions（简写-ea）参数启动断言。</p><p><strong>注意：在实际开发中很少使用断言。更好的方法是编写单元测试。</strong></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="JDK-Logging"><a href="#JDK-Logging" class="headerlink" title="JDK Logging"></a>JDK Logging</h2><h3 id="日志简介"><a href="#日志简介" class="headerlink" title="日志简介"></a>日志简介</h3><p>没有日志系统时的错误排查过程：</p><blockquote><p>在编写程序的过程中，发现程序运行结果于预期不符合，怎么半？</p><p>使用System.out.println()打印出执行过程中的某些变量，观察每一步的结果于代码逻辑是否符合，然后有针对性地修改代码。</p><p>代码修改好了，然后删除没用地System.out.println()语句。</p><p>又出问题了，再加上System.out.println()语句。</p></blockquote><p>日志的引入：</p><blockquote><p>反复的Sytem.out.println()语句插入与删除，非常麻烦，所以就引入了日志（Logging），它地目的就是为了取代System.out.println()。</p></blockquote><p>输出日志，而不是System.out.println()的好处：</p><ul><li>可以设置输出样式。避免自己重复写”Error: “ + var</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志</li><li>可以重定向到文件。这样可以再程序运行结束后查看日志</li><li>可以按包名控制日志级别。只输出某些包的日志</li></ul><h3 id="如何使用日志"><a href="#如何使用日志" class="headerlink" title="如何使用日志"></a>如何使用日志</h3><p>Java标准库内置了日志包：java.util.logging，我们可以直接使用。</p><p>简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getGlobal();<br>        logger.info(<span class="hljs-string">&quot;start process...&quot;</span>);<br>        logger.warning(<span class="hljs-string">&quot;memory is running out...&quot;</span>);<br>        logger.fine(<span class="hljs-string">&quot;ignored.&quot;</span>);<br>        logger.severe(<span class="hljs-string">&quot;process will be terminated...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Mar <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br>INFO: start process...<br>Mar <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br>WARNING: memory is running out...<br>Mar <span class="hljs-number">02</span>, <span class="hljs-number">2019</span> <span class="hljs-number">6</span>:<span class="hljs-number">32</span>:<span class="hljs-number">13</span> PM Hello main<br>SEVERE: process will be terminated...<br></code></pre></td></tr></table></figure><p>日志包含的信息：时间、调用类、调用方法等</p><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>在上面的例子中，4条日志，只打印了3条，logger.fine()没有打印。这是因为，日志的输出可以设定级别。</p><p>JDK的Logging定义了7个日志级别，从严重到普通：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINERST</li></ul><p>因为默认的级别是INFO，因此，INFO级别一下的日志，不会被打印出来。</p><p>使用日志级别的好处在于：调整日志级别就可以屏蔽掉很多调式无关的日志输出。</p><h3 id="内置Logging的局限"><a href="#内置Logging的局限" class="headerlink" title="内置Logging的局限"></a>内置Logging的局限</h3><ul><li>Loggin系统在JVM启动时读取配置文件并完成初始化，一旦开始运行mian()方法，就无法修改配置</li><li>配置不方便，需要在JVM启动时传参：-Djava.util.logging.config.file&#x3D;&lt;config-file-name&gt;</li></ul><h2 id="Commens-Logging"><a href="#Commens-Logging" class="headerlink" title="Commens Logging"></a>Commens Logging</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>和Java标准库提供的日志不同，Commens Logging是一个第三方日志库，它是由Apache创建的日志模块。</p><p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commens Logging自动搜索并使用Log4j，如果没有找到Log4j，再使用JDK logging。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p><ul><li><p>第一步：通过LogFactory获取Log类的实例</p></li><li><p>第二步：使用Log实例的方法打日志</p></li></ul><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//因为Commons Logging是第三方提供的库，所以要在工程中导入Jar包才能正常使用。</span><br><span class="hljs-comment">//commons-logging-1.2.jar</span><br><span class="hljs-keyword">import</span> org.apache.commons.logging.Log;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory.getLog(Main.class);<br>        log.info(<span class="hljs-string">&quot;start...&quot;</span>);<br>        log.warn(<span class="hljs-string">&quot;end.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Commons Logging定义的六个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO ：默认</li><li>DEBUG</li><li>TRACE</li></ul><p>使用Commons Logging时，如果在静态方法中引用Log，通常直接定义一个静态类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在静态方法中引用Log:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory.getLog(Main.class);<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实例方法中引用Log，通常定义一个实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在实例方法中引用Log:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory.getLog(getClass());<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到：实例变量log的获取方式是LogFactory.getLog(getClass())，而不是LogFactory.getLog(Person.class)。这样的好处在于，子类继承Person类后，继承其属性log，所以在子类中可以直接使用该log实例，无需改动代码。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在子类中使用父类实例化的log:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;bar&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Java类的动态特性，LogFactory.getLog(getClass())，在父类中相当于LogFactory.getLog(Person.class)，在子类中相当于LogFactory.getLog(Student.class)</p><p>Commeons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    log.error(<span class="hljs-string">&quot;got exception!&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Log4Jj"><a href="#Log4Jj" class="headerlink" title="Log4Jj"></a>Log4Jj</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Commons Logging可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p><p>Log4j是一种非常流行的日志框架，它是一个组件化设计的日志系统。</p><p>其框架大概如下：</p><p><img src="/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20221025114909589.png" alt="image-20221025114909589"></p><ol><li>Appender：</li></ol><p>当使用Log4j输出一条日志时，Log4j自动通过不同的Appender把一条日志输出到不同的目的地。</p><ul><li>console：输出到屏幕</li><li>file：输出到文件</li><li>socket：通过网络输出到远程计算机</li><li>jdbc：输出到数据库</li></ul><ol start="2"><li>Filter：</li></ol><p>在输出日志的过程中，通过Filter来过滤那些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志</p><ol start="3"><li>Layout：</li></ol><p>最后通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><p>在实际的使用中不需要关心Log4j的API，而是通过配置文件来配置它。</p><p>以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。</p><p>配置文件示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义日志格式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义文件名变量 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义Appender，即目的地 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到屏幕 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">bufferedIO</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1 MB&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 保留最近10份 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置Log4j比较繁琐，但是一旦配置完成，使用起来就非常方便。</p><h4 id="Jar包导入："><a href="#Jar包导入：" class="headerlink" title="Jar包导入："></a>Jar包导入：</h4><p>Log4j是一个第三方库，所以使用前需要导入其jar包：</p><ul><li>log4j-api-2.x.jar</li><li>log4j-core-2.x.jar</li><li>log4j-jcl-2.x.jar</li></ul><p>因为Commens Logging会自动发现并使用Log4j，所以还需要导入</p><ul><li>commons-logging-1.2.jar</li></ul><h4 id="使用日志"><a href="#使用日志" class="headerlink" title="使用日志"></a>使用日志</h4><p>只需要按照Commons Logging的写法，不需要改动任何代码，就可以得到Log4j的日志输出。</p><p>在开发阶段，始终使用Commens Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件，只需要把正确的配置文件和Log4j相关的jar包导入，就可以把日志自动换成Log4j写入，无需修改任何代码。</p><h2 id="SLF4J和Logback"><a href="#SLF4J和Logback" class="headerlink" title="SLF4J和Logback"></a>SLF4J和Logback</h2><p>前面的Commons Logging和Log4j，他们一个充当日志API，一个负责实现日志底层实现。而SLF4J和Logback也是类似的关系。</p><h3 id="SLF4J对比Commens-Logging接口"><a href="#SLF4J对比Commens-Logging接口" class="headerlink" title="SLF4J对比Commens Logging接口"></a>SLF4J对比Commens Logging接口</h3><h4 id="字符串拼接的改进"><a href="#字符串拼接的改进" class="headerlink" title="字符串拼接的改进"></a>字符串拼接的改进</h4><p>在Commens Logging中是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br>p.setScore(score);<br>log.info(<span class="hljs-string">&quot;Set score &quot;</span> + score + <span class="hljs-string">&quot; for Person &quot;</span> + p.getName() + <span class="hljs-string">&quot; ok.&quot;</span>);<br></code></pre></td></tr></table></figure><p>SLF4J中是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br>p.setScore(score);<br>logger.info(<span class="hljs-string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());<br></code></pre></td></tr></table></figure><p>SLF4J传入带占位符的字符串，使用后面的变量自动替换占位符，使用起来更加自然。</p><h3 id="接口对比"><a href="#接口对比" class="headerlink" title="接口对比"></a>接口对比</h3><p><img src="/2022/10/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20221025171850623.png" alt="image-20221025171850623"></p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ol><li>使用也同Commons加Log4J类似，需要先导入对应的包：</li></ol><ul><li>slf4j-api-1.7.x.jar</li><li>logback-classic-1.2.x.jar</li><li>logback-core-1.2.x.jar</li></ul><ol start="2"><li>同样需要导入一个Logback的配置文件：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>log/output.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>1MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>代码中调用：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(getClass());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-生产者与消费者问题</title>
    <link href="/2022/10/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者模式可以让我们加深对并发编程的理解。</p><p>所谓的生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一类是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据后直接放置在共享数据区中，不需要关心消费者的行为，而消费者只需要从共享数据区中去获取数据，就不再需要去关心生产者的行为。</p><p>这个共享数据区中应该具备这样的线程间并发协作的功能：</p><ul><li>如果共享数据区已满的话，阻塞生产者继续生产数据放置入内</li><li>如果共享数据区为空的话，阻塞消费者继续消费数据</li></ul><p>生产者-消费者的实现有下面三种方式：</p><ul><li>使用Object的wait&#x2F;notify的消息通知机制</li><li>使用Lock的Condition的await&#x2F;signal的消息通知机制</li><li>使用BlockingQueue实现</li></ul><h1 id="wait-x2F-notify的消息通知机制"><a href="#wait-x2F-notify的消息通知机制" class="headerlink" title="wait&#x2F;notify的消息通知机制"></a>wait&#x2F;notify的消息通知机制</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li><p>wait ()</p><blockquote><ul><li><p>该方法用来将当前线程置入休眠状态，直到接收到通知或被中断为止</p></li><li><p>只能在同步方法或同步块中调用wait()方法。</p><blockquote><p>在调用wait()方法之前，线程必须要获得该对象的对象监视器锁，若调用前没有获取锁，则会抛出IllegalMonitorStateException异常，这是个Runtime异常。</p></blockquote></li><li><p>调用wait ()方法之后，当前线程会释放锁。</p></li><li><p>如果再次获取到锁的话，当前线程才能从wait()方法处成功返回</p></li></ul></blockquote></li><li><p>notify()</p><blockquote><ul><li>该方法也需要在同步方法或同步块中调用。</li><li>该方法从等待队列中随机挑选一个处于WAITING状态的线程发出通知，使得被通知的线程由随机队列移入同步队列中，等待有机会再一次获取锁，从而使得调用wait()方法的线程能够从wait()方法处退出。</li><li>调用notify后，当前线程不会马上释放该对象锁，而是要等到程序退出同步块后，当前线程才会释放锁</li></ul></blockquote></li><li><p>notifyAll()</p><blockquote><p>与notify()方法不同的一点在于，notifyAll会通知所有等待线程。</p></blockquote></li></ul><h2 id="wait-x2F-notify潜在的一些问题"><a href="#wait-x2F-notify潜在的一些问题" class="headerlink" title="wait&#x2F;notify潜在的一些问题"></a>wait&#x2F;notify潜在的一些问题</h2><h3 id="问题一、notify早期通知（通知遗漏）"><a href="#问题一、notify早期通知（通知遗漏）" class="headerlink" title="问题一、notify早期通知（通知遗漏）"></a>问题一、notify早期通知（通知遗漏）</h3><p>notify通知遗漏很容易理解，即当threadA还没开始wait的时候，threadB已经notify了。这样，threadB的通知是没有任何响应的，而threadA在notify后wait，便会一直阻塞等待，直到被其他线程打断。</p><p>解决方案：</p><p>添加一个状态标志，让waitThread在调用wait方法前判断通知是否已经发出，如果通知已经发出，则waitThread就不再wait。</p><h3 id="问题二、等待wait的条件发生变化"><a href="#问题二、等待wait的条件发生变化" class="headerlink" title="问题二、等待wait的条件发生变化"></a>问题二、等待wait的条件发生变化</h3><p>如果线程在等待时接收到了通知，但是之后等待的条件发生了变化，并没有对等待条件进行判断，也会导致程序出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionChange</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; lockObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(lockObject);<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(lockObject);<br>        <span class="hljs-type">Productor</span> <span class="hljs-variable">productor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(lockObject);<br>        <span class="hljs-comment">//两个消费者线程</span><br>        consumer1.start();<br>        consumer2.start();<br>        <span class="hljs-comment">//一个生产者线程</span><br>        productor.start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;String&gt; lock;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//这里使用if的话，就会存在wait条件变化造成程序错误的问题</span><br>                    <span class="hljs-keyword">if</span> (lock.isEmpty()) &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; list为空&quot;</span>);<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 调用wait方法&quot;</span>);<br>                        lock.wait();<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  wait方法结束&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> lock.remove(<span class="hljs-number">0</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 取出第一个元素为：&quot;</span> + element);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;String&gt; lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 开始添加元素&quot;</span>);<br>                lock.add(Thread.currentThread().getName());<br>                lock.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br>会报异常：<br>    <br>Exception in thread <span class="hljs-string">&quot;Thread-1&quot;</span> Thread-<span class="hljs-number">0</span> list为空<br>Thread-<span class="hljs-number">0</span> 调用wait方法<br>Thread-<span class="hljs-number">1</span> list为空<br>Thread-<span class="hljs-number">1</span> 调用wait方法<br>Thread-<span class="hljs-number">2</span> 开始添加元素<br>Thread-<span class="hljs-number">1</span>  wait方法结束<br>java.lang.IndexOutOfBoundsException: Index: <span class="hljs-number">0</span>, Size: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>异常原因分析：</p><p>两个消费者启动的时候，List为空。都被阻塞，等待被唤醒后消费List中的数据。</p><p>一个生产者，生产数据过后，notifyAll，两个消费者都被唤醒，第一个消费者正常消费数据，此时List为空，第二个消费者再消费数据的时候List为空，抛出异常。</p><p>即第二个消费者从wait方法退出过后wait条件已经发生变化，再执行程序就出错了</p><p>解决方案：在wait退出之后再对条件进行判断即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改Customer线程的run方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//如果lock为空的话，进入进入循环wait</span><br>            <span class="hljs-keyword">while</span> (lock.isEmpty()) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; list为空&quot;</span>);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 调用wait方法&quot;</span>);<br>                lock.wait();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  wait方法结束&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//出循环后此时lock不为空</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> lock.remove(<span class="hljs-number">0</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 取出第一个元素为：&quot;</span> + element);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题三、”假死“状态"><a href="#问题三、”假死“状态" class="headerlink" title="问题三、”假死“状态"></a>问题三、”假死“状态</h3><p>问题：</p><p>如果时多消费者和多生产者情况，如果使用notify方法可能会出现”假死“的情况，即唤醒的时同类线程。</p><p>原因分析：</p><p>假设当多个生产者线程调用wait阻塞，当其中一个生产者获取到对象锁之后使用notif通知处于等待状态的线程（有生产者和消费者）如果唤醒的仍是生产者线程，就会造成所有的生产者线程都处于等待状态</p><p>解决办法：</p><p>使用notify方法替换notifyAll方法如果使用的是Lock，就将signal替换为signalAll方法</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Object提供的消息通知机制应该遵循如下条件：</p><ul><li><p>永远在while循环中对条件进行判断</p><blockquote><p>在使用线程的等待&#x2F;通知机制时，一般要在while循环中调用wait()方法，因此需要配合使用一个Boolean变量（或其他wait条件），满足wait条件时，进入while循环，执行wait()方法，不满足wait条件时，跳出循环，执行后续代码</p></blockquote></li><li><p>使用notifyAll而不是notify</p></li></ul><p>使用范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The standard idiom for calling the wait method in Java</span><br><span class="hljs-keyword">synchronized</span> (sharedObject) &#123;<br>    <span class="hljs-keyword">while</span> (condition) &#123;<br>    sharedObject.wait();<br>        <span class="hljs-comment">// (Releases lock, and reacquires on wakeup)</span><br>    &#125;<br>    <span class="hljs-comment">// do action based upon condition e.g. take or put into queue</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wait-x2F-notifyAll实现生产者-消费者"><a href="#wait-x2F-notifyAll实现生产者-消费者" class="headerlink" title="wait&#x2F;notifyAll实现生产者-消费者"></a>wait&#x2F;notifyAll实现生产者-消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(linkedList, <span class="hljs-number">8</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(linkedList));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxLength;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List list, <span class="hljs-type">int</span> maxLength)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.maxLength = maxLength;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (list) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (list.size() == maxLength) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list以达到最大容量，进行wait&quot;</span>);<br>                            list.wait();<br>                            System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                        &#125;<br>                        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 生产数据&quot;</span> + i);<br>                        list.add(i);<br>                        list.notifyAll();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List list)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (list) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list为空，进行wait&quot;</span>);<br>                            list.wait();<br>                            System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                        &#125;<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  消费数据：&quot;</span> + element);<br>                        list.notifyAll();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Lock中Conditionn的await-x2F-signal"><a href="#Lock中Conditionn的await-x2F-signal" class="headerlink" title="Lock中Conditionn的await&#x2F;signal"></a>Lock中Conditionn的await&#x2F;signal</h1><p>使用Lock.lock()代替syncchronized(Objcet)</p><p>使用Condition的await()和signal()代替Object的wait()和notify()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(linkedList, <span class="hljs-number">8</span>, lock));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(linkedList, lock));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxLength;<br>        <span class="hljs-keyword">private</span> Lock lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(List list, <span class="hljs-type">int</span> maxLength, Lock lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.maxLength = maxLength;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (list.size() == maxLength) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list以达到最大容量，进行wait&quot;</span>);<br>                        full.await();<br>                        System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                    System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 生产数据&quot;</span> + i);<br>                    list.add(i);<br>                    empty.signalAll();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> Lock lock;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(List list, Lock lock)</span> &#123;<br>            <span class="hljs-built_in">this</span>.list = list;<br>            <span class="hljs-built_in">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  list为空，进行wait&quot;</span>);<br>                        empty.await();<br>                        System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  退出wait&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>                    System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;  消费数据：&quot;</span> + element);<br>                    full.signalAll();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>BlockingQueue会自动阻塞生产者和消费者线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductorConsumer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">15</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(queue));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(queue));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> BlockingQueue queue;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(BlockingQueue queue)</span> &#123;<br>            <span class="hljs-built_in">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt();<br>                    System.out.println(<span class="hljs-string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;生产数据&quot;</span> + i);<br>                    queue.put(i);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> BlockingQueue queue;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(BlockingQueue queue)</span> &#123;<br>            <span class="hljs-built_in">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> (Integer) queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在消费数据&quot;</span> + element);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java多线程相关完结。完全参考：<a href="https://github.com/CL0610/Java-concurrency">https://github.com/CL0610/Java-concurrency</a></p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发工具类</title>
    <link href="/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>业务场景：</strong></p><p>在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务后，主线程才能继续往下执行业务功能。</p><p>解决方案：</p><ul><li>使用Thread类的join方法，让主线程等待被join的线程执行完毕后，主线程才能继续往下执行。</li><li>也可以使用线程间消息通信机制（wait和notify）</li><li>Java并发工具类中为我们提供了类似“倒计时”这样的工具类，也就是CountDownLathch来完成这种业务场景</li></ul><p><strong>CountDownLatch的通俗解释：</strong></p><p>若有6个运动员参与比赛，一个裁判员在终点计时。每个运动员到达终点，裁判员就少一个计时任务，当所有运动员到达终点，裁判员任务完完成，才能继续执行其他操作。6个运动员可以类比为六个线程，裁判员类比为一个主线程，当运动员到达终点时，调用CountDownLatch.countDown()方法对计数器减一，直到计数器为0，裁判员主线程才能继续往下执行。</p><h2 id="CountDownLatch的主要方法"><a href="#CountDownLatch的主要方法" class="headerlink" title="CountDownLatch的主要方法"></a>CountDownLatch的主要方法</h2><p>构造方法：</p><ul><li><p>public CountDownLatch(int count)</p><blockquote><p>构造方法传入一个整数N，之后调用countdown方法会对N减一，当N捡到0时，之前因为调用await方法阻塞的线程会被唤醒会继续执行。</p></blockquote></li></ul><p>使用方法：</p><ul><li><p>await() throws InterruptedException</p><blockquote><p> 调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行</p></blockquote></li><li><p>await(long timeout, TimeUnit unit)</p><blockquote><p>在await方法的基础上，增加了超时等待机制</p></blockquote></li><li><p>countDown()</p><blockquote><p>使CountDownLatch计数值N减1</p></blockquote></li><li><p>long getCount()</p><blockquote><p>获取当前CountDownLatch中的计数值</p></blockquote></li></ul><h2 id="解释示例的代码实现"><a href="#解释示例的代码实现" class="headerlink" title="解释示例的代码实现"></a>解释示例的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br> <span class="hljs-comment">//运动员线程需要关注的起跑信号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//裁判员线程需要关注的六个运动员都到达终点的信号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">endSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//主线程裁判员线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">//创建六个运动员线程并提交给线程池执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 运动员等待裁判员响哨！！！&quot;</span>);<br>                    <span class="hljs-comment">//运动员等待起跑信号</span><br>                    startSignal.await();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在全力冲刺&quot;</span>);<br>                    endSignal.countDown();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  到达终点&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//起跑信号，六个运动员起跑</span><br>        System.out.println(<span class="hljs-string">&quot;裁判员发号施令啦！！！&quot;</span>);<br>        startSignal.countDown();<br>        <span class="hljs-comment">//结束信号，裁判员宣布比赛结束</span><br>        endSignal.await();<br>        System.out.println(<span class="hljs-string">&quot;所有运动员到达终点，比赛结束！&quot;</span>);<br>        executorService.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br>输出结果：<br>    <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 运动员等待裁判员响哨！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span> 运动员等待裁判员响哨！！！<br>裁判员发号施令啦！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  到达终点<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>正在全力冲刺<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  到达终点<br>所有运动员到达终点，比赛结束！<br></code></pre></td></tr></table></figure><p>注意：代码中设置了两个CountDownLatch，一个startSignal用于让裁判员发送开始信号给运动员，一个endSignal用于让裁判员接收结束信号。</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>CyclicBarrier也是一种多线程并发控制的使用工具，和CountDownLatch一样具有等待计数的功能，但是更加强大。</p><p>通俗解释：</p><p>还是上面的运动会例子，模拟运动员入场的情况。假设有6条跑道，需要6个运动员都到达跑到起点后，才能吹哨开始跑步。跑道起点相当于一个barrier，是临界点，6个运动员类比成线程的话，到达临界点的线程会阻塞，需要等待到达临界点的线程到达六个，阻塞在临界点的线程才会解除阻塞继续执行。</p><p>CyclicBarrier在使用一次过后，仍然有效，可以继续当计数器使用，这是和CountDownLatch的区别之一。</p><p>示意图：</p><p><img src="/2022/10/21/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/16334ad72bdd4ca3tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="CyclicBarrier执行示意图.jpg"></p><h2 id="CyclicBarrier的主要方法"><a href="#CyclicBarrier的主要方法" class="headerlink" title="CyclicBarrier的主要方法"></a>CyclicBarrier的主要方法</h2><p>构造方法：</p><p>public CyclicBarrier(int parties, Runnable barrierAction)</p><p>使用方法：</p><ul><li><p>await()</p><blockquote><p>等待所有的线程都到达指定的临界点</p></blockquote></li><li><p>awat(long timeout, TimeUnit unit)</p><blockquote><p>在await方法基础上增加超时等待机制</p></blockquote></li><li><p>int getNumberWaiting()</p><blockquote><p>获取当前有多少个线程阻塞等待在临界点上</p></blockquote></li><li><p>boolean isBroken()</p><blockquote><p>用于查询阻塞等待的线程是否被中断</p></blockquote></li><li><p>void reset()</p><blockquote><p>将屏障重置为初始状态，如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException</p></blockquote></li></ul><h2 id="解释示例的代码实现："><a href="#解释示例的代码实现：" class="headerlink" title="解释示例的代码实现："></a>解释示例的代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-comment">//创建计数为6的CyclicBarrier，并设置线程到齐后的执行函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">6</span>, () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;所有运动员入场，裁判员一声令下！！！！！&quot;</span>);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;运动员准备进场，全场欢呼............&quot;</span>);<br>        <br>        <span class="hljs-comment">//创建六个运动员线程并提交给线程池执行</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">6</span>; i++) &#123;<br>            service.execute(() -&amp;gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 运动员，进场&quot;</span>);<br>                    <span class="hljs-comment">//在barrier阻塞，等待其他线程到齐</span><br>                    barrier.await();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  运动员出发&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>&#125;<br>&#125;<br><br>输出结果：<br>运动员准备进场，全场欢呼............<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 运动员，进场<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span> 运动员，进场<br>所有运动员入场，裁判员一声令下！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  运动员出发<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  运动员出发<br></code></pre></td></tr></table></figure><h2 id="CountDownLatch与CyclicBarrier比较"><a href="#CountDownLatch与CyclicBarrier比较" class="headerlink" title="CountDownLatch与CyclicBarrier比较"></a>CountDownLatch与CyclicBarrier比较</h2><p>二者都是用于控制并发的工具类，都可以理解成维护一个计数器，但是二者的侧重点不同：</p><ul><li>CountDownLatch一般用于某个线程A等待其他若干线程执行完任务后，它才执行（一个线程等多个线程）。而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行（多个线程互相等待）。</li><li>调用CountDownLatch的countDown方法不会阻塞当前线程；而调用CyclicBarrier的await方法会阻塞当前线程，直到CyclicBarrier指定的线程数量到达，才继续往下执行。</li><li>CountDownLatch方法较少，使用简单。而CyclicBarrier提供的方法更多，可以同通过getNumberWaiting()、isBroken()方法获取当前多个线程的状态，并且再构造方法中可以传入barrierAction，指定当所有线程都到达时执行的业务功能。</li><li>CountDownLatch是一次性的，不能复用，而CyclicBarrier可以复用。</li></ul><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Semaphore可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。</p><p>Semaphore就相当于一个许可证，线程需要先通过acquire方法获取该许可证，该线程才能继续执行下去，否则只能在该方法处阻塞等待。当执行完业务功能够，通过release()方法将许可证归还，以便其他线程能够获得许可证继续执行。</p><p>业务场景：</p><p>Semaphore可以用作流量控制，特别是公共资源有限的应用场景，比如数据库连接。加入有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有10个，这个时候就需要使用Semaphore来控制能够并发访问到数据库连接资源的线程数只有10个。在限制资源使用的应用场景下，Semaphore是特别合适的。</p><h2 id="Semaphore的主要方法"><a href="#Semaphore的主要方法" class="headerlink" title="Semaphore的主要方法"></a>Semaphore的主要方法</h2><p>构造方法：</p><ul><li><p>Semaphore(int permits)</p></li><li><p>Semaphore(int permits, boolean fair)</p></li></ul><p>获取与释放许可的方法：</p><ul><li>acquire()</li><li>acquire(int permits)</li><li>release()</li><li>release(int permits)</li><li>boolean tryAcquire()</li><li>boolean tryAcquire(int permits)</li><li>boolean tryAcquire(long timeout, TimeUnit unit)</li><li>Boolean try Acquire(int premits, long timeout, TimeUnit unit)</li></ul><p>获取许可证和阻塞线程信息的方法：</p><ul><li>int availablePermits()</li><li>int getQueueLength()</li><li>boolean hasQueuedThreads()</li><li>Collections<Thread> getQueueThreads()</Thread></li></ul><h2 id="使用示例代码实现"><a href="#使用示例代码实现" class="headerlink" title="使用示例代码实现"></a>使用示例代码实现</h2><p>模拟场景：</p><p>有一天，班主任需要班上10个同学到讲台上来填写一个表格，但是老师只准备了5只笔，因此只能保证同时只有5名同学能够拿到笔填写表格，没有拿到笔的同学需要等待前面拿到笔的同学用完笔放回，才能拿到笔填写表格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-comment">//表示老师只有5支笔</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//表示10个学生</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//创建10个学生线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            service.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  同学准备获取笔......&quot;</span>);<br>                    semaphore.acquire();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  同学获取到笔&quot;</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  填写表格ing.....&quot;</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                    semaphore.release();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;  填写完表格，归还了笔！！！！！！&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        service.shutdown();<br>    &#125;<br>&#125;<br>输出结果<br>    <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  填写表格ing.....<br><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  同学准备获取笔......<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  同学准备获取笔......<br><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  同学获取到笔<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  填写表格ing.....<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span>  填写完表格，归还了笔！！！！！！<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span>  填写完表格，归还了笔！！！！！！<br></code></pre></td></tr></table></figure><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。</p><p>具体交换数据是通过exchange() 方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程都到达同步点，两个线程就可以交换数据。</p><h2 id="Exchanger的主要方法"><a href="#Exchanger的主要方法" class="headerlink" title="Exchanger的主要方法"></a>Exchanger的主要方法</h2><p>构造方法：</p><p>只有一个简单的无参构造方法</p><p>主要方法：</p><ul><li>V exchange(V x)</li><li>V exchange(V x, long timeout, timeUnit unit)</li></ul><h2 id="使用示例代码实现-1"><a href="#使用示例代码实现-1" class="headerlink" title="使用示例代码实现"></a>使用示例代码实现</h2><p>模拟场景：</p><p>在青春洋溢的中学时代，下课期间，男生经常会给走廊里为自己喜欢的女孩送情书。男生会先到女孩教师门口，然后等女孩出来，教师门口就是一个同步点，然后彼此交换信物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//代表男生和女生</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//男生线程</span><br>        service.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//男生对女生说的话</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">girl</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;我其实暗恋你很久了......&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;女孩儿说：&quot;</span> + girl);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//女生线程</span><br>        service.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;女生慢慢的从教室你走出来......&quot;</span>);<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                <span class="hljs-comment">//女生说的话</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">boy</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;我也很喜欢你......&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;男孩儿说：&quot;</span> + boy);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br>输出结果：<br><br>女生慢慢的从教室你走出来......<br>男孩儿说：我其实暗恋你很久了......<br>女孩儿说：我也很喜欢你......<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-atomic包</title>
    <link href="/2022/10/21/Java%E5%B9%B6%E5%8F%91-atomic%E5%8C%85/"/>
    <url>/2022/10/21/Java%E5%B9%B6%E5%8F%91-atomic%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="原子操作类简介"><a href="#原子操作类简介" class="headerlink" title="原子操作类简介"></a>原子操作类简介</h1><p>并发问题：</p><p>并发编程中很容易出现并发安全的例子。比如说多线程执行i++，就可能无法获取正确的结果。常用的解决办法是使用Synchronized进行控制来达到线程安全的目的。但是synchronized采用的是悲观锁策略，并不是特别高效的一种解决方案。</p><p>高效的解决方案：</p><p>在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并且能保证线程安全的更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p><h1 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h1><p>原子更新基本类型的工具类：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>这几个类的用法基本一致，以AtomicInteger为例：</p><ul><li>getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值（a &#x3D; newValue）</li><li>addAndGet(int delta)：原值加上输入数值，返回最后结果（a +&#x3D; delta）</li><li>incrementAndGet()：原值加1，返回自增后的结果（a++）</li><li>getAndIncrement()：原值加1，返回自增前的旧值（++a）</li></ul><p>实现原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AtomicInteger的getAndIncrement方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//AtomicInteger的compareAndSet方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">boolean</span> expect, <span class="hljs-type">boolean</span> update)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> expect ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> update ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, e, u);<br>&#125;<br><span class="hljs-comment">//原子类中Unsafe实例的获取</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br></code></pre></td></tr></table></figure><p>由上面源码可见，这些原子类的方法都是通过调用Unsafe类的CAS操作来实现的。</p><h1 id="原子更新数组类型"><a href="#原子更新数组类型" class="headerlink" title="原子更新数组类型"></a>原子更新数组类型</h1><p>原子更新数组中元素的类：</p><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><p>几个类的用法一致，以AtomicIntegerArray为例：</p><ul><li>addAndGet(int i, int delta)：将数组中索引为i的元素加上delta，并返回相加后的值</li><li>getAndIncrement(int i)：将数组中索引为i的元素自增1，并返回自增前的值</li><li>compareAndSet(int i, int expect, int update)：CAS更新索引为i的元素的值</li></ul><h1 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h1><p>原子更新引用类型变量的类：</p><ul><li>AtomicReference：原子更新引用类型</li><li>AtomicReferenceFieldUpdater：原子更新引用类型中的字段</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型</li></ul><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicReference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>        reference.set(user1);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> reference.getAndSet(user2);<br>        <br>        System.out.println(user);<br>        System.out.println(reference.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String userName;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.userName = userName;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;userName=&#x27;&quot;</span> + userName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>&#125;<br>&#125;<br><br>输出结果：<br>User&#123;userName=<span class="hljs-string">&#x27;a&#x27;</span>, age=<span class="hljs-number">1</span>&#125;<br>User&#123;userName=<span class="hljs-string">&#x27;b&#x27;</span>, age=<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="原子更新字段类型"><a href="#原子更新字段类型" class="headerlink" title="原子更新字段类型"></a>原子更新字段类型</h1><p>原子更新对象字段的类：</p><ul><li>AtomicIntegeFieldUpdater：原子更新对象的整形字段</li><li>AtomicLongFieldUpdater</li><li>AtomicStampedReference：原子更新引用类型。这种更新方式带有版本号，解决了ABA的问题</li></ul><p>使用步骤：</p><ol><li>原子更新字段类都是抽象类，只能通过其静态方法newUpdater来创建一个更新器，并在创建的时候指定要更新的类和属性</li><li>更新类的属性必须使用public volatile进行修饰</li></ol><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicDemo</span> &#123;<br><span class="hljs-comment">//指定类和属性，创建更新器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> <br>        AtomicIntegerFieldUpdater.newUpdater(User.class,<span class="hljs-string">&quot;age&quot;</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//使用更新器更新指定类的指定属性</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> updater.getAndAdd(user, <span class="hljs-number">5</span>);<br>        <br>        System.out.println(oldValue);<br>        System.out.println(updater.get(user));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String userName;<br>     <span class="hljs-comment">//public volatile修饰的属性，可以使用原子更新字段类更新</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.userName = userName;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>    &#125;<br>&#125;<br><br>输出结果：<br><span class="hljs-number">1</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-FutureTask</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p> 在Executors框架体系中，FutureTask用来表示<strong>可获取结果的异步任务</strong>。</p></blockquote><p>FutureTask实现了Future接口，提供的方法：</p><ul><li>启动和取消异步任务</li><li>查询异步任务是否执行完毕</li><li>获取最终的异步任务结果</li></ul><p>FutureTask中定义的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>在《Java并发编程的艺术》一书中，作者根据FutureTask.run()方法的执行时机，将其分了3中状态：</p><ul><li><p>未启动</p><blockquote><p>当创建一个 FutureTask，但是FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态</p></blockquote></li><li><p>已启动</p><blockquote><p>FutureTask.run()方法正在被执行的过程中，FutureTask处于已启动状态</p></blockquote></li><li><p>已完成</p><blockquote><p>FutureTask变为已完成状态的几种情况</p><ul><li>FutureTasl.run()方法正常执行结束</li><li>FutureTask.cancel()方法取消任务</li><li>在执行过程中抛出异常</li></ul></blockquote></li></ul><p>状态变化过程图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/16334a72fd345345tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="FutureTask状态迁移图.jpg"></p><p>不同状态对get和cancel方法的影响：</p><ul><li><p>get方法</p><blockquote><p>未完成状态：会导致线程阻塞</p><p>已完成状态：立即返回结果或抛出异常</p></blockquote></li><li><p>cancel方法</p><blockquote><p>未启动：该任务永远不会再执行</p><p>已启动：</p><p>FutureTask.cancel(true)方法将以中断方式来阻止任务继续执行</p><p>FutureTask.cancel(false)将不会对正在执行任务的线程有影响</p><p>已完成：返回false</p></blockquote></li></ul><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-FutureTask/16334a72fd899d43tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="FutureTask的get和cancel的执行示意图.jpg"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>FutureTask对象的执行：</p><p>FutureTask除了实现了Future接口，还实现了Runnable接口。因此可以将FutureTask交给Executror执行，也可以由调用的线程直接执行FutureTask.run () 。</p><p>FutureTask对象的获取：</p><p>可以通过ExecutorService.submit ()方法返回一个FutureTask对象</p><p>应用场景：</p><ul><li>当一个线程需要等待另一个线程执行完成后它才能继续执行，此时可以使用FutureTask</li><li>若有多个线程执行多个任务，每个任务只能执行一次。当多个线程试图执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完成后才能继续执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ScheduledThreadPoolExecutor</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ScheduledThreadPoolExecutor用途：</p><ul><li>在给定延时后执行异步任务</li><li>周期性执行任务</li></ul><p>相对于任务调度Timer来说，其功能更加强大。Timer只能使用一个后台线程执行任务，而ScheduledThreadPoolExecutor则可以指定后台线程的个数。</p><p>ScheduledThreadPoolExecutor类的UML图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-ScheduledThreadPoolExecutor/16334a21947ee154tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>从UML中可以看出：</p><ul><li><p>继承自ThreadPoolExecutor类</p><blockquote><p>拥有execute()和submit()提交异步任务的基础功能</p></blockquote></li><li><p>实现了ScheduledExecutorService接口</p><blockquote><p>该接口定义了能够延迟执行任务和周期性执行任务的功能</p></blockquote></li><li><p>包含两个重要类：DelayedWorkQueue和ScheduledFutureTask</p></li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), handler);<br>&#125;；<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadPoolExecutor中可以设定的参数：</p><ul><li>maximumPoolSize：线程池能创建线程的最大个数</li><li>keepAliveTime：空闲线程存活时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列</li><li>corePoolSize：核心线程池大小</li><li>threadFactory：创建线程的工厂类</li><li>handler：饱和策略</li></ul><p>ScheduledThreadPoolExecutor是通过调用ThreadPoolExecutor的构造方法进行构造的。</p><p>可定制参数：</p><ul><li>corePoolSize</li><li>threadFactory</li><li>handler</li></ul><p>已指定参数：</p><ul><li>maximumPoolSize：Integer.MAX_VALUE</li><li>keepAliveTime：0</li><li>unit：NANOSECONDS</li><li>workQueue：DelayedWorkQueue</li></ul><h2 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h2><p>ScheduledThreadPoolExexecutor实现了ScheduledExecutorService接口，该接口定义了可延时执行异步任务和可周期性执行异步任务的特有功能。相应方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1 延时执行异步任务</span><br><br><span class="hljs-comment">//这里传入的是实现Runnable接口的任务，因此通过ScheduledFuture.get()获取结果为null</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                       <span class="hljs-type">long</span> delay, TimeUnit unit);<br><span class="hljs-comment">//这里传入的是实现Callable接口的任务，因此，返回的是任务的最终计算结果</span><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">                                           <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br><span class="hljs-comment">//2 周期性执行异步任务</span><br><br><span class="hljs-comment">//当达到延时时间initialDelay后，任务开始执行。</span><br><span class="hljs-comment">//以上一个任务开始的时间计时，period时间过去后，检测上一个任务是否执行完毕</span><br><span class="hljs-comment">//如果上一个任务执行完毕，则当前任务立即执行</span><br><span class="hljs-comment">//如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit);<br><span class="hljs-comment">//当达到延时时间initialDelay后，任务开始执行。</span><br><span class="hljs-comment">//上一个任务执行结束后到下一次任务执行，中间延时时间间隔为delay。</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                     <span class="hljs-type">long</span> initialDelay,<br>                                                     <span class="hljs-type">long</span> delay,<br>                                                     TimeUnit unit);<br></code></pre></td></tr></table></figure><h1 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h1><p>上面特有方法执行，实际上是将提交的任务转换为ScheduledFutureTask类。</p><p>例如schedule方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay,<br>                                   TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//Runable转换为ScheduledFutureTask</span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(<br>        command, <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay, unit))<br>    );<br>    <span class="hljs-comment">//提交执行ScheduledFutureTask</span><br>    delayedExecute(t);<br>    <span class="hljs-comment">//返回ScheduledFutureTask</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程池最大的作用是将任务和线程解耦。</p><p>线程是任务的执行者，任务是ScheduledFutureTask，任何线程执行任务都是通过调用run()方法。为了保证ScheduledThreadPoolExecutor能够延迟执行任务以及周期性执行任务，ScheduledFutureTask重写了run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<br>        cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//1 如果不是周期性执行任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>        <span class="hljs-comment">//直接调用run方法</span><br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();<br><span class="hljs-comment">//2 如果是周期性执行任务的话</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>        <span class="hljs-comment">//重设下一次执行任务的时间</span><br>        setNextRunTime();<br>        <span class="hljs-comment">//将下一次待执行的任务放置到DelayedWorkQueue中</span><br>        reExecutePeriodic(outerTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h1><p>DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。</p><p>在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列任务，执行时间越接近当前时间的任务在队列的前面。</p><p>为什么要使用DelayedWorkQueue？</p><ul><li><p>定时任务执行时需要取出最近要执行的任务，所以每次队列出队的一定钥匙执行时间最靠前的任务。</p></li><li><p>DelayedWorkQueue是一个优先级队列，它基于堆结构，插入和删除操作最坏的时间复杂度都是O(logN)。</p></li></ul><p>DelayedWorkQueue的数据结构（底层采用数组存储任务）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DelayedWorkQueue是由一个大小为16的数组组成</span><br><span class="hljs-comment">//数组元素为实现RunnableScheduleFuture接口的类，实际上为ScheduledFutureTask</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>以ScheduledThreadPoolExecutor的schedule方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay,<br>                                   TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-comment">//1 将提交的任务转换成ScheduledFutureTask</span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(<br>        command,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay, unit))<br>    );<br>    <span class="hljs-comment">//2 延时执行任务ScheduledFutureTask</span><br>delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-comment">//2.1 如果当前线程池已经关闭，拒绝任务</span><br>    <span class="hljs-keyword">if</span> (isShutdown())<br>        reject(task);<br>    <span class="hljs-comment">//2.2 若线程池没有关闭，将任务放入阻塞队列中</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.getQueue().add(task);<br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>            remove(task))<br>            task.cancel(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">else</span><br><span class="hljs-comment">//保证至少有一个线程启动，即使corePoolSize=0</span><br>            ensurePrestart();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取现在的线程数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());<br>    <span class="hljs-comment">//1 若核心线程池没满，新建线程</span><br>    <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//2 若corePoolSize为0，则会保证有一个线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>addWorker()方法就是新建线程：</p><ul><li><p>ensurePrestart()方法的关键在于addWorker()方法，该方法的主要功能：新建Worker类。</p></li><li><p>当执行任务时，会调用被Worker重写的run方法，进而执行runWorker方法。在runWorker方法中会调用getTask方法从阻塞队列中不断获取任务进行执行，直到从阻塞队列中获取的任务为null的时候，线程结束终止。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="ScheduledThreadPoolExecutor的异同"><a href="#ScheduledThreadPoolExecutor的异同" class="headerlink" title="ScheduledThreadPoolExecutor的异同"></a>ScheduledThreadPoolExecutor的异同</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor类，因此整体功能一致：</p><ul><li>线程池主要负责创建线程（Worker类）</li><li>线程从阻塞队列中不断获取新的异步任务，直到阻塞队列为空</li></ul><p>ScheduledThreadPoolExecutor相较于ThreadPoolExecutor类增加了延时执行任务和可周期性执行任务的特性：</p><ul><li>重新设计了任务类ScheduleFutureTash，重写其run方法使其具有上述特性</li><li>通过阻塞队列DelayedWorkQueue保证越靠近当前时间执行的任务先执行</li></ul><h2 id="线程池的解耦"><a href="#线程池的解耦" class="headerlink" title="线程池的解耦"></a>线程池的解耦</h2><p>线程池设计时的三个关键要素是：任务、执行者和任务结果。线程池的设计思想就是将这三个要素解耦：</p><ul><li><p>执行者</p><blockquote><p>任务的执行机制，完全交给Worker类，也就是进一步封装了Thread。</p><p>向线程池提交任务，无论是ThreadPoolExecutor的execute方法和submit方法，还是ScheduledThredPoolExecutor的schedule方法，其执行流程都如下：</p><ol><li>将任务移入阻塞队列</li><li>通过addWork方法新建Work类，并通过runWorker方法启动线程</li><li>不断从阻塞队列中共获取异步任务交给Worker执行，直到阻塞队列为空</li></ol></blockquote></li><li><p>任务</p><blockquote><p>任务是实现了Runnable接口和Callable接口的实现类。</p><p>ThreadPoolExecutor中将任务转换成FutureTask类</p><p>ScheduledThreadPoolExecutor中将任务转换成ScheduleFutureTask类，该类继承自FutureTask，并重写run方法</p></blockquote></li><li><p>任务结果</p><blockquote><p>任务提交过后，可以通过Future接口的类获取任务结果。</p><p>ThreadPoolExecutor中实际为FutureTask类</p><p>ScheduledThreadPoolExecutor中则是ScheduledFutureTask类</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-线程池实现原理</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><p>在实际的使用中，线程池是很占用系统资源的，如果对线程管理不善很容易导致系统问题。所以在大多数并发框架中都会使用线程池来管理线程。</p><p>使用线程池的好处：</p><ul><li><p>降低资源消耗</p><blockquote><p>通过复用已存的线程，来减少线程的创建于销毁</p></blockquote></li><li><p>提高系统响应速度</p><blockquote><p>通过复用线程，省去了创建线程的过程，因此从整体上提升了系统的响应速度</p></blockquote></li><li><p>提高线程的可管理性</p><blockquote><p>线程是稀缺资源，如果无限制地创建线程，不仅会消耗系统资源，还会降低系统的稳定性。所以需要线程池来管理线程</p></blockquote></li></ul><h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><p>并发任务提交给线程池，线程池分配线程去执行任务的过程：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/163349e503061169tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>线程池执行所提交任务的几个阶段：</p><ol><li><p>核心线程池：</p><blockquote><p>先判断线程池中的核心线程池所有的线程是否都在执行任务。若不是，则创建一个核心线程执行刚提交的任务，否则进入第2步</p></blockquote></li><li><p>阻塞队列：</p><blockquote><p>若阻塞队列没有满，则将任务放置于阻塞队列中，否则进入第3步</p></blockquote></li><li><p>线程池：</p><blockquote><p>若线程池中所有线程都在执行任务，则交给饱和策略处理，否则创建一个新的线程来执行任务</p></blockquote></li></ol><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><h2 id="ThreadPoolExecutor的构造方法"><a href="#ThreadPoolExecutor的构造方法" class="headerlink" title="ThreadPoolExecutor的构造方法"></a>ThreadPoolExecutor的构造方法</h2><p>创建线程池主要是通过ThreadPoolExecutor类来完成，其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize,<br>                   <span class="hljs-type">int</span> maximumPoolSize,<br>                   <span class="hljs-type">long</span> keepAliveTime,<br>                   TimeUnit unit,<br>                   BlockingQueue&lt;Runnable&gt; workQueue,<br>                   ThreadFactory threadFactory,<br>                   RejectedExecutionHandler handler)<br></code></pre></td></tr></table></figure><p>参数解析：</p><ul><li><p>corePoolSize：核心线程池大小</p><blockquote><p>当提交一个任务时，如果当前核心线程池的线程个数没有达到corePoolSize，则会创建一个新的线程用于执行所提交的任务，即使核心线程池中有空闲线程。</p><p>如果调用prestartCoreThread()或者prestartAllCoreThreads()，线程池在创建的时候，会创建并启动所有的核心线程。</p></blockquote></li><li><p>maximumPoolSize：线程池能创建线程的最大个数</p><blockquote><p>如果阻塞队列已满（此时核心线程池肯定也已满），但是当前线程个数没有超过允许创建的最大线程数，则会创建一个新的线程用于执行任务。</p></blockquote></li><li><p>keepAliveTime：空闲线程存活时间</p><blockquote><p>当线程池的线程个数超过corePoolSize，并且线程空闲时间超过了keepAliveTime的话，将会销毁这些空闲线程以降低系统资源消耗。</p></blockquote></li><li><p>unit：时间单位</p><blockquote><p>为keepAliveTime指定时间单位</p></blockquote></li><li><p>workQueue：阻塞队列</p><blockquote><p>用于保存任务的阻塞队列。</p></blockquote></li><li><p>threadFactory：创建线程的工厂类</p><blockquote><p>可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字，如果出现并发问题，方便排查。</p></blockquote></li><li><p>handler：饱和策略</p><blockquote><p>当线程池已满，再提交任务需要策略来处理。有如下策略：</p><ul><li><p>AbortPolicy</p><blockquote><p>直接拒绝所提交的任务，并抛出RejectedExecutionException异常</p></blockquote></li><li><p>CallerRunsPlicy</p><blockquote><p>只用调用者所在得线程来执行任务</p></blockquote></li><li><p>DiscardPolicy</p><blockquote><p>不处理直接丢弃提交的任务</p></blockquote></li><li><p>DiscardOldestPolicy</p><blockquote><p>丢弃阻塞队列中存放最久的任务，执行当前任务</p></blockquote></li></ul></blockquote></li></ul><h2 id="线程池执行逻辑"><a href="#线程池执行逻辑" class="headerlink" title="线程池执行逻辑"></a>线程池执行逻辑</h2><p>通过ThreadPoolExecutor创建线程池后，通过其execute方法提交任务给线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-comment">//如果线程池的线程个数少于corePoolSize则创建新线程执行当前任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-comment">//如果线程个数大于corePoolSize或者创建线程失败，则将任务存放在阻塞队列workQueue中</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><span class="hljs-comment">//如果当前任务无法放进阻塞队列中，则创建新的线程来执行任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程示意图：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/163349e50368064btplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="execute执行过程示意图.jpg"></p><p>执行逻辑：</p><ol><li>如果当前运行的线程少于corePoolSize，则创建新的线程来执行新的任务</li><li>如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中</li><li>如果workQueue队列已满的话，则会创建新的线程来执行任务</li><li>如果线程个数已经超过maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来处理</li></ol><h1 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h1><p>关闭线程池有两个方法：</p><ul><li><p>shutdown</p><blockquote><p>只是将线程池的状态设置未SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p></blockquote></li><li><p>shutdownNow</p><blockquote><p>首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表</p></blockquote></li></ul><p>二者的原理都是通过遍历线程池中所有的线程，然后依次中断线程。shutdown方法会将正在执行的任务执行完，而shutdownNow会直接中断正在执行的任务。</p><p>调用任意一个方法，isShutdown方法都会返回true，当所有的线程都关闭成功，才表示线程池成功关闭，这时调用isTerminated方法才会返回true。</p><h1 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h1><p>想要合理配置线程池，首先要分析任务特性，有以下几个角度：</p><ul><li><p>任务的性质：CPU密集型任务、IO密集型任务和混合型任务</p><blockquote><p>CPU密集型任务，因为CPU本身很少空闲，配置尽可能少地线程数量，如Ncpu+1个线程。</p><p>IO密集型任务，因为需要等待IO操作，线程并非一直执行任务，应该配置尽可能多，如2Ncpu。</p><p>混合型任务，如果可以拆分，则将其拆分未一个CPU密集型任务一个IO密集型任务。</p><p>cpu数量可以通过Runtime.getRuntime().availableProcessors()方法获取。</p></blockquote></li><li><p>任务的优先级</p><blockquote><p>优先级不同的任务，可以使用优先队列PriorityBlockingQueue来处理</p><p>它可以让优先级高的任务优先执行，但是优先级低的任务可能会出现“饥饿”永远无法执行</p></blockquote></li><li><p>任务的执行时间</p><blockquote><p>执行时间不同的任务可以交给不同规模的线程池处理。</p><p>或者使用优先队列，让执行时间短的任务先执行。</p></blockquote></li><li><p>任务的依赖性：是否依赖其他系统资源，如数据库连接</p><blockquote><p>依赖数据库连接的任务，因为线程提交SQL后需要等待数据库返回结果，等待中CPU空闲，那么线程数量根据CPU空闲时间越大，设置数量越多，这样更好地利用CPU资源。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-BlockingQueue</title>
    <link href="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/"/>
    <url>/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/</url>
    
    <content type="html"><![CDATA[<h1 id="BlockingQueue简介"><a href="#BlockingQueue简介" class="headerlink" title="BlockingQueue简介"></a>BlockingQueue简介</h1><p>在JDK中的Collection集合框架中的各种容器类如实现List，Map，Queue接口的容器类，但是这些容器类都不是线程安全的，除了使用Collections可以将其转换位线程安全的容器，JDK中的Concurrent包中还提供了线程安全的容器。如实现List接口的CopyOnWriteArrayList，实现了Map接口的ConcurrentHashMap，实现了Queue接口的ConcurrentLinkedQueue。</p><p>阻塞队列的用途：</p><p>在最常见的“生产者-消费者”问题中，队列常常被作为线程间操作的容器，这样可以将生产和消费的业务功能解耦，生产者将生产出来的数据放置在数据容器中，而消费者仅仅需要从数据容器中获取数据即可。阻塞队列提供了可阻塞的插入的移除的方法，当队列容器已满，生产者线程会被阻塞，知道队列未满，当队列容器为空时，消费者线程会被阻塞，知道队列非空为止。</p><h1 id="阻塞队列的基本操作"><a href="#阻塞队列的基本操作" class="headerlink" title="阻塞队列的基本操作"></a>阻塞队列的基本操作</h1><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267ca3fc39tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>插入元素：</p><ul><li><p>add(E e)</p><blockquote><p>队列满时候，插入失败抛出IllegalStateException异常</p></blockquote></li><li><p>offer(E e)</p><blockquote><p>插入成功返回true，否则false</p></blockquote></li><li><p>put(E e)</p><blockquote><p>若阻塞队列已经满了，put线程会被阻塞，知道阻塞队列有空余容量可供使用</p></blockquote></li></ul><p>删除元素：</p><ul><li><p>remove(Object o)</p><blockquote><p>删除成功返回true，否则false</p></blockquote></li><li><p>poll()</p><blockquote><p>删除并返回队头元素，若为空，返回null</p></blockquote></li><li><p>take()</p><blockquote><p>删除并返回队头元素，若为空，take线程阻塞直到阻塞队列不为空</p></blockquote></li><li><p>poll(long timeout, TimeUnit unit)</p><blockquote><p>基本同take方法，增加了超时退出的功能（阻塞超过给定时长，该线程直接退出）</p></blockquote></li></ul><p>查看元素：</p><ul><li><p>element()</p><blockquote><p> 获取头元素，若队列为空，抛出异常NoSuchElementException</p></blockquote></li><li><p>peek()</p><blockquote><p> 获取头元素，若队列为空，抛出异常NoSuchElementException</p></blockquote></li></ul><h1 id="常用的BlockingQueue实现类"><a href="#常用的BlockingQueue实现类" class="headerlink" title="常用的BlockingQueue实现类"></a>常用的BlockingQueue实现类</h1><h2 id="常用实现类简介："><a href="#常用实现类简介：" class="headerlink" title="常用实现类简介："></a>常用实现类简介：</h2><ul><li><p>ArrayBlockingQueue</p><blockquote><p>ArrayBlockingQueue是由<strong>数组</strong>实现的<strong>有界阻塞队列</strong>。</p><p>该队列命令元素<strong>FIFO</strong>。因此，队列中元素按照进入队列时间排序。</p><p>ArrayBlockingQueue可作为“有界数据缓冲区”，一旦被创建，其<strong>容量不能改变</strong>。</p><p>线程访问队列的公平性：</p><ul><li><p>默认是非公平性访问，即一旦ArrauBlockingQueue可以被访问时，长时间阻塞的线程可能依然无法访问到ArrayBlockingQueue。</p></li><li><p>若要保证公平性，则在new ArrayBlockingQueue的时候加上true参数，获取公平性的Array BlockingQueue</p></li></ul></blockquote></li><li><p>LinkedBlockingQueue</p><blockquote><p>LinkedBlockingQueue使用链表实现的有界阻塞队列。</p><p>同样满足FIFO特性。比ArrayBlockingQueue相比具有更高的吞吐量。</p><p>为了防止LinkedBlockingQueue容量迅速增大，损耗大量内存，通常在创建LinkedBlockingQueue对象的时候会指定其大小，若未指定，其容量为Integer.MAX_VALUE</p></blockquote></li><li><p>PriorityBlockingQueue</p><blockquote><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。</p><p>排序方式：</p><ul><li>默认情况下元素采用自然顺序进行排序</li><li>也可以通过自定义类的compareTo()方法指定元素的排序规则</li><li>或则在初始化时通过构造器参数Comparator来指定排序规则</li></ul></blockquote></li><li><p>SynchronousQueue</p><blockquote><p>SynchronousQueue每个插入操作必须等待另一个线程进行相应的删除操作。</p><p>因此，SynchronousQueue实际上没有存储任何数据，删除和插入线程需要相互等待对方。</p><p>SynchronousQueue也可以通过构造器参数为其指定公平性</p></blockquote></li><li><p>LinkedTransferQueue</p><blockquote><p>LinkedTransferQueue是一个由链表数据结构构成的无界阻塞队列。</p><p>该队列实现了TransferQueue接口，与其他阻塞队列的不同方法：</p><ul><li><p>transfer(E e)</p><blockquote><p>如果当前有线程在执行take()方法或可延时的poll()方法进行消费数据，生产者线程可以调用transfer方法将数据直接传递给消费者线程。</p><p>若当前没有消费者线程消费数据，生产者线程会将数据插入队尾，直到有消费者进行消费才能退出</p></blockquote></li><li><p>tryTransfer(E e)</p><blockquote><p>与transfer相比，若当前没有线程在消费数据，则立即返回false。</p></blockquote></li><li><p>tryTransfer(E e, long timeout, timeUnit unit)</p><blockquote><p>与transfer相比，增加了超时特性，若超过规定时间没有消费者消费数据，则返回false</p></blockquote></li></ul></blockquote></li><li><p>LinkedBlockingDequeue</p><blockquote><p>LinkedBlockingDequeue是基于链表数据结构的有界阻塞双端队列。</p><p>LinkedBlockingDeque具有双端队列特性，其基本操作如下：</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267d1586d2tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>LinkedBlockingDque实现的是BlockingDeque接口，而LinkedBlockingQueue实现的是BlockingQueue接口</p><p>两个接口区别如下：（两个接口的功能可以等价使用）</p><p><img src="/2022/10/20/Java%E5%B9%B6%E5%8F%91-BlockingQueue/163349267d5efe67tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p></blockquote></li><li><p>DelayQueue</p><blockquote><p>DelayQueue是一个存放实现Delayed接口数据的无界阻塞队列。</p><p>只有当数据对象的延时时间达到时才能插入到队列进行存储。</p><p>若当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过poll方法获取元素返回null。</p><p>所谓的数据延时期满时，是通过Delayed接口的getDelay()来进行判断的，若返回值小于等于0，说明数据元素的延时期已满。</p></blockquote></li></ul><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>阻塞队列最核心的功能是，可以阻塞式地插入和删除队列元素。当队列为空，会阻塞消费者线程，直至队列非空时，通知被阻塞地消费者线程；当队列满时，会阻塞插入数据地线程，直至队列未满时，通知被阻塞的生产者线程。</p><p>多线程中的消息通知最常用的是lock的condition机制。</p><h4 id="主要属性："><a href="#主要属性：" class="headerlink" title="主要属性："></a>主要属性：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存储数据相关的属性：</span><br><span class="hljs-comment">/** The queued items */</span><br><span class="hljs-keyword">final</span> Object[] items;<br><br><span class="hljs-comment">/** items index for next take, poll, peek or remove */</span><br><span class="hljs-type">int</span> takeIndex;<br><br><span class="hljs-comment">/** items index for next put, offer, or add */</span><br><span class="hljs-type">int</span> putIndex;<br><br><span class="hljs-comment">/** Number of elements in the queue */</span><br><span class="hljs-type">int</span> count;<br><br><span class="hljs-comment">//消息通知相关的属性：</span><br><span class="hljs-comment">/** Main lock guarding all access */</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><br><span class="hljs-comment">/** Condition for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-comment">/** Condition for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br><span class="hljs-comment">//构造方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    <span class="hljs-comment">//创建lock和condition</span><br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put方法："><a href="#put方法：" class="headerlink" title="put方法："></a>put方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//如果当前队列已满，将线程移入到notFull等待队列中</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br><span class="hljs-comment">//满足插入数据的要求，直接进行入队操作</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br><span class="hljs-comment">//1 插入数据</span><br>    items[putIndex] = x;<br>    <span class="hljs-comment">//更新putIndex和count属性</span><br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br><span class="hljs-comment">//2 通知消费者线程，当前队列中有数据可供消费</span><br>    notEmpty.signal();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="take方法："><a href="#take方法：" class="headerlink" title="take方法："></a>take方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//如果队列为空，没有数据，将消费者线程移入等待队列中</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br><span class="hljs-comment">//获取数据</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//1 获取数据</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    <span class="hljs-comment">//置为null，帮助GC</span><br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//更新takeInde和count属性</span><br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>        itrs.elementDequeued();<br>    <span class="hljs-comment">//2 通知被阻塞的生产者线程</span><br>notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><h4 id="主要属性：-1"><a href="#主要属性：-1" class="headerlink" title="主要属性："></a>主要属性：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Current number of elements */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">//头尾节点指针</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><span class="hljs-comment">//读锁与非空等待队列</span><br><span class="hljs-comment">/** Lock held by take, poll, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/** Wait queue for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<br><br><span class="hljs-comment">//写锁与未满等待队列</span><br><span class="hljs-comment">/** Lock held by put, offer, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">/** Wait queue for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<br><br><span class="hljs-comment">//Node节点定义：</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>Node&lt;?&gt; next;<br><br>Node(E x) &#123; item = x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put方法：-1"><a href="#put方法：-1" class="headerlink" title="put方法："></a>put方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//封装数据为Node</span><br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    putLock.lockInterruptibly();<br>    <span class="hljs-comment">//插入Node</span><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//1 如果队列已满，则阻塞当前线程，将其移入等待队列</span><br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br>            notFull.await();<br>        &#125;<br><span class="hljs-comment">//2 入队操作，插入数据</span><br>        enqueue(node);<br>        <span class="hljs-comment">//3 如果入队过后队列还没有满，唤醒其他被阻塞的生产者线程</span><br>        c = count.getAndIncrement();<br>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>            notFull.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        putLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>        signalNotEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="take方法：-1"><a href="#take方法：-1" class="headerlink" title="take方法："></a>take方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    E x;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;<br>    takeLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件</span><br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>            notEmpty.await();<br>        &#125;<br><span class="hljs-comment">//移除队头元素，获取数据</span><br>        x = dequeue();<br>        c = count.getAndDecrement();<br>        <span class="hljs-comment">//如果当前满足移除元素的条件，则通知被阻塞的消费者线程</span><br><span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>            notEmpty.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        takeLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == capacity)<br>        signalNotFull();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ABQ和LBQ比较"><a href="#ABQ和LBQ比较" class="headerlink" title="ABQ和LBQ比较"></a>ABQ和LBQ比较</h3><p>相同点：</p><p>都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性。</p><p>不同点：</p><ul><li>底层实现：ABQ是数组，LBQ是链表</li><li>锁：ABQ插入和删除采用同一个锁，LBQ在插入和删除分别一个锁，降低阻塞，提高并发效率</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ThreadLocal</title>
    <link href="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/"/>
    <url>/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h1><p>加锁的弊端：</p><blockquote><p>多线程编程中通过synchronized或者lock控制对临界区资源的同步顺序从而解决线程安全的问题。</p><p>通过加锁的方式或让未获取锁的线程阻塞等待，这种方式时间效率并不是很好。</p></blockquote><p>空间换时间：</p><blockquote><p>线程安全问题的核心在于多个线程会对同一临界区共享资源进行操作，若让每个线程使用自己的“共享资源”，那么多个线程互相隔离，就不会出现线程安全的问题。这实际上是一种“空间换时间”的方案，每个线程拥有自己的“共享资源”会占用大量内存，但是不需要同步也就避免了阻塞等待的情况。</p></blockquote><p>虽然ThreadLocal并不是在java.util.concurrent包中而在Java.lang包中，但是我更倾向于将其作为一种并发容器（虽然真实存放的数据是ThreadLocalMap）进行归类。</p><p>从ThreadLocal这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量的副本，达到人手一份的效果，各自用各自的就可以避免共享资源的竞争。</p><h1 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h1><h2 id="void-set-T-value"><a href="#void-set-T-value" class="headerlink" title="void set (T value)"></a>void set (T value)</h2><blockquote><p>set方法设置在前线程中的threadLocal变量的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程实例对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//2. 通过当前线程实例获取到ThreadLocalMap对象</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//3. 如果Map不为null,则以当前threadLocl实例为key,值为value进行存入</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br><span class="hljs-comment">//4.map为null,则新建ThreadLocalMap并存入value</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于ThreadLocalMap：</p><ul><li><p>数据真正存放在ThreadLocalMap中，key为当前threadLocal实例</p></li><li><p>ThreadLocalMap的引用作为Thread类的一个属性，被Thread维护</p><ul><li>getMap方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>createMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="T-get"><a href="#T-get" class="headerlink" title="T get()"></a>T get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程的实例对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//2. 获取当前线程的threadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//3. 获取map中当前threadLocal实例为key的值的entry</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//4. 当前entitiy不为null的话，就返回相应的值value</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>map为空时的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//若map已经创建</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-comment">//若map还没创建</span><br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-comment">//initialValue类为protected，表示继承ThreadLocal的类可以通过重写该方法设置默认值</span><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="void-remove"><a href="#void-remove" class="headerlink" title="void remove()"></a>void remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程的threadLocalMap</span><br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br> <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//2. 从map中删除以当前threadLocal实例为key的键值对</span><br>m.remove(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ThreadLocalMap详解"><a href="#ThreadLocalMap详解" class="headerlink" title="ThreadLocalMap详解"></a>ThreadLocalMap详解</h1><p>ThreadLocal类的get、set和remove都是通过调用其属性threadLocals（ThreadLocalMap）的getEntry、set和remove实现的。</p><h2 id="Entry数据结构"><a href="#Entry数据结构" class="headerlink" title="Entry数据结构"></a>Entry数据结构</h2><p>ThreadLocalMap是ThreadLocal的一个静态内部类。和大多数容器一样，其内部维护了一个数组，ThreadLocalMap内部维护了一个Entry类型的tabel数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>    <span class="hljs-comment">//数组会根据需要扩容</span><br>    <span class="hljs-comment">//数组的长度必须是2的幂次方</span><br>    <span class="hljs-keyword">private</span> Entry[] table;<br>    ...<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br>Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>    <span class="hljs-built_in">super</span>(k);<br>    value = v;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Entry是一个以ThreadLocal为key，Object为value的键值对。</p></li><li><p>ThreadLocal是弱引用，因为Entry继承了WeakReference。</p></li><li><p>Entry的构造方法中，调用了super(k)将ThreadLocal实例包装成一个WeakReference</p></li></ul><h2 id="Thread、ThreadLocal、ThreadLocalMap之间的关系"><a href="#Thread、ThreadLocal、ThreadLocalMap之间的关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap之间的关系"></a>Thread、ThreadLocal、ThreadLocalMap之间的关系</h2><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbmNlbnRfd2VuMDc2Ng==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>ThreadLocal数据实际的存放：</p><blockquote><p>每一个线程实例都有一个ThreadLoaclMap实例的属性，ThreadLocalMap中维护了一个Entry数组用于存放不同ThreadLocal实例存放的数据。</p></blockquote><p>通过ThreadLocal存取数据：</p><blockquote><p>ThreadLocal不存储数据，其提供一些方法，操作这些数据。</p><p>通过当前线程实例获取当前线程实例的ThreadLocalMap（在不同的方法中执行，获取的是不同的ThreadLocalMap），然后使用ThreadLocal本身作为key，从ThreadLocalMap中的Entry数组中获取ThreadLocal存放在当前线程中的value。</p></blockquote><p>ThreadLocal根据当前线程获取当前线程对应的ThreadLocalMap（每个线程对应一个ThreadLocalMap），该ThreadLocalMap可以存储多个不同ThreadLocal实例存储在当前线程中的数据（一个ThreadLocal实例可以分别在多个线程中存储一个value）</p><p>ThreadLocal内存泄漏问题：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/16334681776bb805tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="ThreadLocal各引用间的关系"></p><p>Entry中的key是弱引用，当ThreadLocal实例引用被置为null后，这个ThreadLocal实例不可达，会被GC回收，那么ThreadLocalMap中就会出现key为null的额Entry，这个Entry无法被访问，也无法被回收。若线程不结束，这个key为null的Entry会一直存在，无法回收，造成内存泄漏。虽然在线程结束后，线程相关的所有类都会被回收，但是在实际的开发中，会使用线程池，线程为了被复用不会主动结束，这样垃圾也就一直不能被回收。所以在使用完ThreadLocal后，主动的通过remove移除对应的Entry，避免内存泄漏。</p><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><p>ThreadLocalMap通过散列表进行实现。在了解set方法前，先回顾下散列表的相关知识。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。</p><p>理想散列表：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177649b66tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="理想散列表的一个示意图"></p><p>散列冲突：</p><p>在理想状态下，哈希函数可以将关键字均匀地分散到数组地不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称之为散列冲突。</p><p>散列冲突解决：</p><ul><li><p>分离链表法</p><blockquote><p>分离链表法使用链表解决冲突，将散列值相同的元素都保存在一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素。</p><p>典型实现为HashMap和ConcurrentHashMap的拉链法。</p><p>示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177fb894ctplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="分离链表法示意图"></p></blockquote></li><li><p>开放定址法</p><blockquote><p>开放定址法不会创建链表，当关键字散列到的数组单元已经被另一个关键字占用的时候，就会尝试在数组中寻找其他单元，直到找到空的单元。探测数组空单元的方法有很多，最简单的一种为线性探测法。线性探测法就是从发生冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。</p><p>示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ThreadLocal/1633468177ede9abtplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="开放定址法示意图"></p></blockquote></li></ul><p>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用分离链表法。</p><p>因为ThreadLocalMap中打散列值分散十分均匀，很少发生冲突，并且ThreadLocalMap经常要清除无用对象，使用纯数组更方便。</p><h3 id="set方法源码"><a href="#set方法源码" class="headerlink" title="set方法源码"></a>set方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">//根据threadLocal的hashCode确定Entry应该存放的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp;amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//采用开放地址法，hash冲突的时候使用线性探测</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//覆盖旧Entry</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//当key为null时，说明threadLocal强引用已经被释放掉，那么就无法</span><br>        <span class="hljs-comment">//再通过这个key获取threadLocalMap中对应的entry，这里就存在内存泄漏的可能性</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//用当前插入的值替换掉这个key为null的“脏”entry</span><br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//新建entry并插入table中i处</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <br>    <span class="hljs-comment">//插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容</span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><p>set方法中需要注意的点：</p><ol><li><p>ThreadLocal的hashcode？</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the next hash code.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal实例的hashCode是通过nextHashCode()方法实现的，该方法通过一个AtomicInteger加上0x61c88647来实现。0x61c88647这个数可以保证hash表的每个散列桶能均匀分布。</p></blockquote></li><li><p>怎样确定新值插入到哈希表中的位置？</p><blockquote><p>该操作源码为： key.threadLocalHashCode &amp; (len - 1)，同HashMap和ConcurrentHashMap等容器的方式一样，利用当前key的hashCode与哈希表想与（因为哈希表大小总是2的幂次方，所以想与操作等同于一个取模操作），这样就可以通过key分配到具体的哈希桶中。</p></blockquote></li><li><p>怎样解决hash冲突？</p><blockquote><p>源码中通过nextIndex(i, len)方法来解决hash冲突，该方法为((i + 1 &lt; len) ? i + 1 : 0)，也就是线性探测。</p></blockquote></li><li><p>怎样解决“脏”Entry？</p><blockquote><p>在分析ThreadLocal、ThreadLocalMap和Enty的关系的时候，我们知道ThreadLocal可能存在内存泄漏，在源码中针对key为null的Entry称之为“stale entry”，直译为不新鲜的entry，可以理解为“脏entry”。</p><p>set方法的for循环中寻找到和当前key相同的可覆盖entry的时候，若该entry为“脏entry”则通过replaceStaleEntry方法来解决脏entry。若当前table[i]为null，直接插入新entry后也会执行cleanSomeSlots来解决脏entry问题。</p></blockquote></li><li><p>如何进行扩容？</p><blockquote><p>threshold的确定：</p><p>threshold表示当前哈希表的可用容量。</p><p>在第一次对ThreadLocal进行赋值的时候会创建一个大小为16的ThreadLocalMap，并通过setThreshold方法设置threshold 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next size value at which to resize.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Set the resize threshold to maintain at worst a 2/3 load factor.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其值为哈希数组长度乘以2&#x2F;3，也就是说加载因子为2&#x2F;3。（加载因子过小，内存利用率不高但是hash冲突可能性小，过大，hash冲突的可能性增大）</p><p>resize()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Double the capacity of the table.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1 创建新数组，长度为原数组的2倍</span><br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//2 移动旧数组元素到新数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-comment">//遍历过程中如果遇到脏entry的话</span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//直接置value为null,有助于value能够被回收</span><br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//重新确定entry在新数组的位置，然后进行插入</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    .-*<br>                    看，。看来你h90 <span class="hljs-number">798</span> = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>           &#125;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">//3 设置新哈希表的threshHold和size属性</span><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="getEntry方法"><a href="#getEntry方法" class="headerlink" title="getEntry方法"></a>getEntry方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br><span class="hljs-comment">//1. 确定在散列数组中的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//2. 根据索引i获取entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br><span class="hljs-comment">//3. 满足条件则返回该entry</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br><span class="hljs-comment">//4. 未查找到满足条件的entry，额外在做的处理(hash冲突)</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-comment">//找到和查询的key相同的entry则返回</span><br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//解决脏entry的问题</span><br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//继续向后环形查找</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove the entry for key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br><span class="hljs-comment">//将entry的key置为null</span><br>            e.clear();<br><span class="hljs-comment">//将该entry的value也置为null</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Thread-Local的使用场景"><a href="#Thread-Local的使用场景" class="headerlink" title="Thread Local的使用场景"></a>Thread Local的使用场景</h1><p>ThreadLocal不是用来解决共享对象的多线程访问问题的，数据实质上是放在每个thread实例引用的threadLocalMap中，也就是说每个不同的线程都拥有专属于自己的数据容器（threadLcoalMap），彼此不印象。</p><p>因此ThreadLocal只适用于共享对象会造成线程安全问题的业务场景。比如hibernate中通过threadLocal管理Session就是一个典型的案例，不同的请求线程（用户）拥有自己的Session，若将session共享出去被多线程访问，必然带来线程安全问题。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ConcurrentLinkedQueue</title>
    <link href="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/"/>
    <url>/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/</url>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentLinkedQueue简介"><a href="#ConcurrentLinkedQueue简介" class="headerlink" title="ConcurrentLinkedQueue简介"></a>ConcurrentLinkedQueue简介</h1><p>ConcurrentLinkedQueue是一个线程安全的队列，其数据结构是链表。</p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>ConcurrentLinkedQueue的底层节点类Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        <span class="hljs-keyword">volatile</span> E item;<br>        <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br>.......<br>&#125;<br></code></pre></td></tr></table></figure><p>Node包含两个属性：（都使用volatile修饰，保证内存可见性）</p><ul><li><p>一个数据域item，用于保存数据</p></li><li><p>一个next指针，用于构成链式队列</p></li></ul><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;<br></code></pre></td></tr></table></figure><p>ConcurrentLinkedQueue通过持有链表的头尾节点来管理队列。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentLinkedQueue</span><span class="hljs-params">()</span> &#123;<br>    head = tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化示意图：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/1633459982863c26tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="1.ConcurrentLinkedQueue初始化状态.png"></p><h2 id="操作Node的几个CAS操作"><a href="#操作Node的几个CAS操作" class="headerlink" title="操作Node的几个CAS操作"></a>操作Node的几个CAS操作</h2><p>在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更改Node中的数据域item</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casItem</span><span class="hljs-params">(E cmp, E val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, itemOffset, cmp, val);<br>&#125;<br><span class="hljs-comment">//更改Node中的指针域next</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySetNext</span><span class="hljs-params">(Node&lt;E&gt; val)</span> &#123;<br>    UNSAFE.putOrderedObject(<span class="hljs-built_in">this</span>, nextOffset, val);<br>&#125;<br><span class="hljs-comment">//更改Node中的指针域next</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, nextOffset, cmp, val);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些方法实际上通过UNSAFE实例的方式，UNSAFE位sun.misc.Unsafe类，该类是hotspot底层方法。</p><h1 id="offer-方法"><a href="#offer-方法" class="headerlink" title="offer()方法"></a>offer()方法</h1><p>关于offer源码的思考方向：</p><ul><li><p>单线程offer</p></li><li><p>多个线程offer</p></li><li><p>部分线程offer，部分线程poll</p><ul><li><p>offer的速度快于poll</p><blockquote><p>队列长度越来越长，offer在队列尾部操作，poll在队头，两个线程不会互相影响</p></blockquote></li><li><p>poll的速度快于offer</p><blockquote><p>队列会越来越短，offer线程和poll线程会出现“交集”，这一时刻可以称offer线程和poll线程同时操作的节点为临界点。</p><p>对于该临界点poll和offer的发生相对顺序的思考角度：</p><ul><li><p>offer-poll-offer</p><blockquote><p>当offer线程在Node1后扎入Node2时，此时poll线程已经将Node1删除，这种情况需要在offer方法中考虑</p></blockquote></li><li><p>poll-offer-poll</p><blockquote><p>当poll线程准备删除节点（队列为空），此时offer线程插入一个节点使得队列为非空，这种情况应该是poll线程考虑</p></blockquote></li></ul></blockquote></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//null判断</span><br>    checkNotNull(e);<br>    <span class="hljs-comment">//将数据包装成一个Node类</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>    <span class="hljs-comment">//循环直到成功插入Node</span><br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<br>        <span class="hljs-comment">//t为tail,但是tail并不一定指向真正的尾节点，因为tail是被延迟更新的</span><br>        <span class="hljs-comment">//p为指针用于寻找真正尾节点，q用于辅助p判断是否到达尾节点</span><br>        Node&lt;E&gt; q = p.next;<br>        <span class="hljs-comment">//1 p为尾节点，执行插入</span><br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//CAS插入新节点，如果CAS失败会在下一次循环重试</span><br>            <span class="hljs-keyword">if</span> (p.casNext(<span class="hljs-literal">null</span>, newNode)) &#123;<br>                <span class="hljs-comment">//插入节点成功后更新tail（tail延迟更新机制）</span><br>                <span class="hljs-comment">//p为真尾节点，t为tail，如果tail没有指向真尾节点，则更新tail</span><br>                <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// hop two nodes at a time</span><br>                casTail(t, newNode);  <span class="hljs-comment">// Failure is OK.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//2 p不为尾节点，移动p指针直到找到尾节点</span><br>        <span class="hljs-comment">//2.1 p节点其next指向自己，这种节点称之为哨兵节点，说明在本线程执行offer的过程中，p节点被删除了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>            p = (t != (t = tail)) ? t : head;<br>        <span class="hljs-comment">//2.2 如果p指向的不是真正的尾节点</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//移动p指针，寻找真正尾节点</span><br>            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单线程offer分析"><a href="#单线程offer分析" class="headerlink" title="单线程offer分析"></a>单线程offer分析</h2><p>单线程相关代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br></code></pre></td></tr></table></figure><p>在单线程中，条件(p !&#x3D; t &amp;&amp; t !&#x3D; (t &#x3D; tail))一定为false，所以单线程offer中该代码段等价于p &#x3D; q</p><h2 id="多线程offer分析"><a href="#多线程offer分析" class="headerlink" title="多线程offer分析"></a>多线程offer分析</h2><p>多线程offer相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">t != (t = tail))<br></code></pre></td></tr></table></figure><p>若在执行offer操作的过程中，有其他的offer线程执行完毕（tail值可能更新），左边t为旧值压入栈中，右边t被赋予新的tail值，该表达式为真，说明tail更新，直接将tail赋予p</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599933a4aabtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="5.线程A和线程B有可能的执行时序.png"></p><h2 id="offer-poll-offer分析"><a href="#offer-poll-offer分析" class="headerlink" title="offer-poll-offer分析"></a>offer-poll-offer分析</h2><p>初始状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599c2390c2btplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="10.offer和poll相互影响分析时队列初始状态.png"></p><p>在执行offer的时候，有一个线程完成poll：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599cd4cbdabtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="11.线程A和线程B可能存在的执行时序.png"></p><p>另一个线程完成poll后的状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599d7d92981tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="12.线程B进行poll后队列的状态图.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>    p = (t != (t = tail)) ? t : head;<br></code></pre></td></tr></table></figure><p>p &#x3D;&#x3D; q表示在当前线程在执行offer操作的时候，其他线程已经将p设置为哨兵节点了，此时需要重新给p赋值来寻找真正的尾节点</p><p>由前面的多线程分析可知，若t !&#x3D; (t &#x3D; tail))为真，说明在当前线程执行offer期间tail更新了，则将p置为tail，若没有，则将p置为head（因为其他线程设置哨兵节点的时候肯定会更新head）</p><h1 id="poll-方法"><a href="#poll-方法" class="headerlink" title="poll()方法"></a>poll()方法</h1><p>poll方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//标记点</span><br>    restartFromHead: <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//初始化h,p,q</span><br>        <span class="hljs-comment">//p指针用于寻找真正的头节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;; p = q) &#123;<br>            <span class="hljs-keyword">final</span> E item;<br>            <span class="hljs-comment">//1 若p为头节点，CAS将其数据item置为null（若CAS失败，则会等待下一次循环重试）</span><br>            <span class="hljs-keyword">if</span> ((item = p.item) != <span class="hljs-literal">null</span> &amp;&amp; p.casItem(item, <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-comment">//1.1 若真正的头节点不为head，则更新head</span><br>                <span class="hljs-keyword">if</span> (p != h) <span class="hljs-comment">// hop two nodes at a time</span><br>                    <span class="hljs-comment">//若p为尾节点，则将p置为head，若p不为尾节点，则将p.next置为head</span><br>                    updateHead(h, ((q = p.next) != <span class="hljs-literal">null</span>) ? q : p);<br>                <span class="hljs-comment">//1.2 返回头节点数据</span><br>                <span class="hljs-keyword">return</span> item;<br>            &#125;<br>            <span class="hljs-comment">//2 若队列为空，返回null</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                updateHead(h, p);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//3 若p已经被其他线程给poll出去了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>                <span class="hljs-comment">//返回标记点重试poll操作</span><br>                <span class="hljs-keyword">continue</span> restartFromHead;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更新head</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateHead</span><span class="hljs-params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> &#123;<br>    <span class="hljs-keyword">if</span> (h != p &amp;&amp; casHead(h, p))<br>        <span class="hljs-comment">//lazySetNext将h的next设置为其自己</span><br>        h.lazySetNext(h);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="head属性的延迟更新"><a href="#head属性的延迟更新" class="headerlink" title="head属性的延迟更新"></a>head属性的延迟更新</h2><p>初始状态：</p><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599936bd919tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="6.队列初始状态.png"></p><p>第一次poll过后的状态：</p><blockquote><p>只是简单的将head指向的节点item置为null，标记其已经被poll出去了</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/163345999f3d68bbtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="7.队列出队操作后的状态.png"></p><p>第二次poll：</p><ul><li><p>第一次循环结束：</p><blockquote><p>第一次循环p指针指向的不是真正的head，所以第一次循环只是移动p指针</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599bd85583btplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="8.经过一次循环后的状态.png"></p></li><li><p>第二次循环结束：</p><blockquote><p>经过第一次循环移动p指着过后，此时p已经指向真正的头节点，此时执行updateHead设置head</p></blockquote><p><img src="/2022/10/19/Java%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue/16334599be78fddetplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="9.Node2从队列中出队后的状态.png"></p></li></ul><h2 id="单线程poll分析"><a href="#单线程poll分析" class="headerlink" title="单线程poll分析"></a>单线程poll分析</h2><ul><li>若p指向节点的item不为null，说明该节点为真正头节点（待删除节点）<ul><li>若p与head相等，只需要将其item置为null，不需要真正执行删除</li><li>若不相等，则需要使用updateHead更新head，真正执行删除（）</li><li>最后返回item即可。</li></ul></li><li>若p指向的节点item为null，说明该节点并非真正的头节点，那么就需要移动p指针寻找真正头节点（item不为null的节点）</li></ul><h2 id="多线程poll分析"><a href="#多线程poll分析" class="headerlink" title="多线程poll分析"></a>多线程poll分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>    <span class="hljs-keyword">continue</span> restartFromHead;<br></code></pre></td></tr></table></figure><p>p &#x3D;&#x3D; q说明p指向的节点已经称为哨兵节点，即已经被其他线程poll出去了，则需要从restartFromHead重新开始执行poll，重新用到的是最新的head</p><h2 id="poll-offer-poll情况分析"><a href="#poll-offer-poll情况分析" class="headerlink" title="poll-offer-poll情况分析"></a>poll-offer-poll情况分析</h2><p>在执行poll线程的时候，若执行到else if ((q &#x3D; p.next) &#x3D;&#x3D; null) 已经判断队列为空了，这时另一个线程完成了offer操作，此时线程已经判断队列为空，但是实际上队列不为空，该线程仍会返回null</p><p>所以说判断空队列不能通过poll操作返回null进行判断，而是要使用isEmpty方法进行判断。</p><h1 id="HOPS的设计"><a href="#HOPS的设计" class="headerlink" title="HOPS的设计"></a>HOPS的设计</h1><h2 id="tail和head更新触发机制"><a href="#tail和head更新触发机制" class="headerlink" title="tail和head更新触发机制"></a>tail和head更新触发机制</h2><p>通过上面个的offer和poll的分析，我们可知tail和head的更新是延迟的，二者的更新触发机制：</p><ul><li>tail更新：当tail指向的节点的下一个节点不为null的时候（不是真正的尾节点），会执行定位队列真正尾节点的操作，找到尾节点后完成插入操作之后，才会通过casTail进行tail的更新；当tail指向的下一个节点为null的时候，只插入节点不更新tail</li><li>head更新：当head指向的节点的item域为null的时候，会执行定位队列真正头节点的操作，找到头节点后完成删除之后，通过updateHead更新head，当head指向的item不为null的时候，只删除节点不更新head</li></ul><h2 id="延迟更新的目的"><a href="#延迟更新的目的" class="headerlink" title="延迟更新的目的"></a>延迟更新的目的</h2><p>更新tail和head是CAS操作，使用延迟更新可以减少CAS更新的操作。通过p指针定位头尾节点操作，来代替每次都CAS更新头尾节点的操作，提高offer和poll操作的效率。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-CopyOnWriteArrayList</title>
    <link href="/2022/10/18/Java%E5%B9%B6%E5%8F%91-CopyOnWriteArrayList/"/>
    <url>/2022/10/18/Java%E5%B9%B6%E5%8F%91-CopyOnWriteArrayList/</url>
    
    <content type="html"><![CDATA[<h1 id="CopyOnWriteArrayList简介"><a href="#CopyOnWriteArrayList简介" class="headerlink" title="CopyOnWriteArrayList简介"></a>CopyOnWriteArrayList简介</h1><p>ArrayList并不是线程安全的，可以使用Vector，或者Collections的静态方法将ArrayList包装成一个线程安全的类，这两种方式都是使用synchronized加锁的方式，利用独占锁来保证线程安全的，效率低。</p><p>业务场景，很多业务都是读多写少的：</p><ul><li><p>比如系统配置信息，除了在初始进行系统配置的时候需要写入数据，其他大部分时刻都只需要读取配置</p></li><li><p>又比如白名单、黑名单</p></li></ul><p>读多写少的情况可以使用ReentrantReadWriteLock：</p><ul><li>优点：读写分离，读读之间不会阻塞</li><li>局限：写锁被写线程获取后，读线程会被阻塞</li></ul><p>CopyOnWriteArrayList容器可以解决读写锁的局限性。</p><h1 id="COW的设计思想"><a href="#COW的设计思想" class="headerlink" title="COW的设计思想"></a>COW的设计思想</h1><p>COW通俗理解：</p><p>COW通俗的理解是当我们往容器中添加一个元素的时候，不直接往容器中添加，而是先将当前容器进行Copy，复制出来一个新的容器，然后将元素添加到新的容器中，添加完元素后，再将原容器的引用指向新容器。</p><p>对CopyOnWrite容器进行并发读的时候，不用加锁，因为当前容器不会添加新元素。</p><p>对CopyOnWrite容器进行并发写的时候，是在新建的容器中执行写，所以读取到的数据会有延迟，放弃了数据实时性。</p><p>数据实时性：</p><p>若是简单的使用读写锁，在写锁被获取后，读写线程都会被阻塞，只有当写锁释放后，读线程才有机会获取到读锁读取数据。站在读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性。COW通过<strong>牺牲数据实时性</strong>，满足数据的最终一致性来避免读线程的阻塞。</p><h1 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h1><p>数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//该数组只能通过getArray()和setArray()方法访问</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></td></tr></table></figure><ul><li><p>CopyOnWriteArrayList内部维护的是一个数组。</p></li><li><p>该数组引用被volatile修饰，保证其可见性。</p></li></ul><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><span class="hljs-keyword">final</span> Object[] getArray() &#123;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br><span class="hljs-comment">//1. 使用Lock,保证写线程在同一时刻只有一个</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//2. 获取旧数组引用</span><br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br><span class="hljs-comment">//3. 创建新的数组，并将旧数组的数据复制到新数组中</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//4. 往新数组中添加新的数据</span><br>newElements[len] = e;<br><span class="hljs-comment">//5. 将旧数组引用指向新的数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="COW-vs-读写锁"><a href="#COW-vs-读写锁" class="headerlink" title="COW vs 读写锁"></a>COW vs 读写锁</h2><p>相同点：</p><ul><li>两种都是通过读写分离的思想实现</li><li>读线程间是互不阻塞的</li></ul><p>不同点：</p><ul><li>读写锁：为了实现数据实时性，在写锁被获取后，读线程会被阻塞。为了解决“脏读”问题，读锁被获取后，写线程会被阻塞</li><li>COW则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延迟感知的，因此读线程永远不会被阻塞。</li></ul><h2 id="COW的缺点"><a href="#COW的缺点" class="headerlink" title="COW的缺点"></a>COW的缺点</h2><ul><li>内存占用问题：因为COW的运行机制，在写操作的时候，内存中会有两个对象（旧容器和新容器）。</li><li>数据一致性问题：COW容器只能保证数据的最终一致性，不能保证数据的实时一致性。（弱一致性）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-ConcurrentHashMap</title>
    <link href="/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/"/>
    <url>/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashmap简介"><a href="#ConcurrentHashmap简介" class="headerlink" title="ConcurrentHashmap简介"></a>ConcurrentHashmap简介</h1><p>HashMap在多线程情况下扩容可能会陷入死循环。</p><p>线程安全的map使用：</p><ul><li>hashtable类</li><li>Collections提供的方法将map包装成线程安全的map。Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</li><li>concurrentHashMap</li></ul><p>上面两种方式都是通过synchronized关键字来实现线程安全的。</p><p>concurrentHashMap的不同版本：</p><ul><li><p>JDK1.6</p><blockquote><ul><li>segment继承ReentrantLock充当锁的角色,为每一个segement提供线程安全保障</li><li>每个segment维护了哈希散列表的若干个桶,每个桶由HashEntry构成链表</li></ul></blockquote></li><li><p>JDK1.8</p><blockquote><ul><li><p>通过synchronized和CAS无锁操作</p><blockquote><p>1.8中的synchronized引入了锁升级的机制，使得其性能相较于ReentrantLock的性能持平甚至更优</p></blockquote></li><li><p>底层数据结构改变为数组 + 链表 + 红黑树</p></li></ul></blockquote></li></ul><h1 id="关键属性及类"><a href="#关键属性及类" class="headerlink" title="关键属性及类"></a>关键属性及类</h1><h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><ul><li><p>table</p><blockquote><p>volatile Node&lt;K,V&gt;[] table：装载Node的数组</p><p>作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是2的幂次方</p></blockquote></li><li><p>nextTable</p><blockquote><p>volatile Node&lt;K,V&gt; nextTabele：扩容时使用</p><p>平时为null，在扩容的时候为非null</p></blockquote></li><li><p>sizeCtl</p><blockquote><p>volatile int sizeCtl：用于控制table数组的大小</p><p>根据是否初始化和是否正在扩容有集中情况：</p><ul><li><p>值为负：</p><ul><li>-1：正在初始化</li><li>-N：当前正有N-1个线程进行扩容操作</li></ul></li><li><p>值为正：</p><ul><li><p>如果数组为null，表示table正在初始化，sizeCtl表示初始化数组的长度</p></li><li><p>若数组不为null，表示已经初始化完毕，sizeCtl表示临界值</p><blockquote><p>插入节点数超过临界值后需要扩容，具体指数组容量乘以加载因子（loadFactor）</p></blockquote></li><li><p>当值为0时，即数组长度为默认初始长度</p></li></ul></li></ul></blockquote></li><li><p>sun.misc.Unsafe U</p><blockquote><p>ConcurrentHashMap的实现中大量的使用CAS来修改ConcurrentHashMap的一些属性。就是通过调用Unsafe类的compareAndSwapXXXX的方法实现的。</p><p>该类提供了一些可以直接操控内存和线程的底层操作，可以理解为Java中的“指针”。</p><p>该成员变量的获取是在静态代码中执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        U = sun.misc.Unsafe.getUnsafe();<br>        .......<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li><p>Node</p><blockquote><p>Node类实现了Map.Entry接口，主要存放key-value对，且拥有next域，由于链接成链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>TreeNode</p><blockquote><p>继承于Node类。</p><p>而红黑树的操作是针对TreeBin类，TreeNode会被TreeBin封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-type">boolean</span> red;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>TreeBin</p><blockquote><p>TreeBin，不负责包装用户的key-value信息，而是包装很多的TreeNode节点。</p><p>ConcurrentHashMap的“数组”中，存放的是TreeBin对象，而不是TreeNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    TreeNode&lt;K,V&gt; root;<br>    <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<br>    <span class="hljs-keyword">volatile</span> Thread waiter;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lockState;<br>    <span class="hljs-comment">// values for lockState</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WRITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">READER</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>ForwardingNode</p><blockquote><p>该节点在扩容的时候才会出现，其key、value和hash全为null。</p><p>其拥有nextTable指针引用新的table数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;<br>    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.nextTable = tab;<br>    &#125;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h1 id="重点方法解析"><a href="#重点方法解析" class="headerlink" title="重点方法解析"></a>重点方法解析</h1><h2 id="CAS关键操作"><a href="#CAS关键操作" class="headerlink" title="CAS关键操作"></a>CAS关键操作</h2><p>ConcurrentHashMap中会大量使用CAS修改它的属性和一些操作，在理解其他方法之前先了解如下几个常用的CAS算法，用于保障线程安全。</p><ul><li><p>tabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取table数组中索引为i的Node元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>casTabAt</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//CAS操作设置table数组中索引为i的元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i,</span><br><span class="hljs-params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;<br>    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置table数组中索引为i的元素</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;<br>    U.putObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="实例构造器方法"><a href="#实例构造器方法" class="headerlink" title="实例构造器方法"></a>实例构造器方法</h2><h3 id="ConcurrentHashMap提供的构造器方法："><a href="#ConcurrentHashMap提供的构造器方法：" class="headerlink" title="ConcurrentHashMap提供的构造器方法："></a>ConcurrentHashMap提供的构造器方法：</h3><p>构造器方法只是确定了table数组的长度，并未进行table数组的初始化。等到第一次插入数据的时候，table数组才真正进行初始化工作。</p><ul><li><p>ConcurrentHashMap()</p><blockquote><p>默认map大小为16</p></blockquote></li><li><p>ConcurrentHashMap(int initalCapacity)</p><blockquote><p>给定map的大小</p></blockquote></li><li><p>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</p><blockquote><p>给定一个map用于创建ConcurrentHashMap</p></blockquote></li><li><p>ConcurrentHashMap(int initialCapacity, float loadFactor)</p><blockquote><p>给定map的大小和记载因子</p></blockquote></li><li><p>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</p><blockquote><p>给定map的大小、加载因子和并发度（预计同时操作数据的线程）</p></blockquote></li></ul><h3 id="给定map大小的构造器方法解析"><a href="#给定map大小的构造器方法解析" class="headerlink" title="给定map大小的构造器方法解析"></a>给定map大小的构造器方法解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造器的工作只有给sizeCtl赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br><span class="hljs-comment">//1. 小于0直接抛异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ?<br>               MAXIMUM_CAPACITY :<br>               <span class="hljs-comment">//将输入的值转化为一个2的幂次方数</span><br>               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));<br><span class="hljs-comment">//3. 赋值给sizeCtl</span><br>    <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-comment">//若table还未初始化，或者table的长度为0，通过while循环执行初始化</span><br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1 sizeCtl &lt; 0，说明已经有线程在初始化table了</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">//让出CPU时间片</span><br>            Thread.yield();<br>        <span class="hljs-comment">//2 CAS设置sizeCtl状态为-1，表示有线程在执行初始化</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">//2.1 若CAS成功，说明没有其他线程在执行初始化，则当前线程执行初始化工作</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//得出数组的大小</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//这里才真正的初始化数组</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br><span class="hljs-comment">//计算数组中可用的大小：实际大小n*0.75（加载因子）</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//在finally中为sizeCtl赋值，退出初始化状态</span><br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-comment">//初始化完成，退出while循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//2.2 若CAS失败，说明有其他线程在执行初始化且CAS竞争成功，则线程在while循环中spin直到初始化操作完成</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-comment">//计算key的hash值（spread对hashCode进行重哈希，以减小Hash冲突）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br><span class="hljs-comment">//1 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <br>        <span class="hljs-comment">//获取table中索引为i的元素f</span><br><span class="hljs-comment">//2 tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br><span class="hljs-comment">//3 当前正在扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-comment">//4 索引i处已经有数据，将node插入该处的链表或树</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//使用同步代码块的方式，锁定</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br><span class="hljs-comment">//4.1 当前为链表，在链表中插入新的键值对</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">//初始化指针e，每一次循环都会将e后移动，有两个出口</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-comment">//出口一、若节点key与要插入的key相同，则覆盖旧值即可</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-comment">//出口二、e到达链表结尾，新建节点插入链表</span><br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br><span class="hljs-comment">//4.2 当前为红黑树，将新的键值对插入到红黑树中</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">//4.3 插入完键值对后再根据实际大小看是否需要转换成红黑树</span><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//临界值为8</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//5 对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcurrentHashMap是一个哈希桶数组，结构如下：</p><p><img src="/2022/10/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ConcurrentHashMap/163344e982f9eed4tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="ConcurrentHashMap散列桶数组结构示意图"></p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br><span class="hljs-comment">//重hash</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//1. table[i]桶节点的key与查找的key相同，则直接返回</span><br><span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br><span class="hljs-comment">//2. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//3. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br><span class="hljs-comment">//1. 新建Node数组，容量为之前的两倍</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// initiating</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nextTable = nextTab;<br>        transferIndex = n;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br><span class="hljs-comment">//2. 新建forwardingNode引用，在之后会用到</span><br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>        <span class="hljs-comment">// 3. 确定遍历中的索引i</span><br><span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-type">int</span> nextIndex, nextBound;<br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                advance = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                     (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                      nextBound = (nextIndex &gt; stride ?<br>                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//4.将原数组中的元素复制到新数组中去</span><br><span class="hljs-comment">//4.5 for循环退出，扩容结束修改sizeCtl属性</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-type">int</span> sc;<br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                nextTable = <span class="hljs-literal">null</span>;<br>                table = nextTab;<br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    <span class="hljs-keyword">return</span>;<br>                finishing = advance = <span class="hljs-literal">true</span>;<br>                i = n; <span class="hljs-comment">// recheck before commit</span><br>            &#125;<br>        &#125;<br><span class="hljs-comment">//4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符)</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br><span class="hljs-comment">//4.2 如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    Node&lt;K,V&gt; ln, hn;<br>                    <span class="hljs-comment">//4.3 处理当前节点为链表的头结点的情况</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        ...<br>                    <span class="hljs-comment">//4.4 处理当前节点是TreeBin时的情况 </span><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        ...<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于ConcurrentHashmap的size-方法"><a href="#关于ConcurrentHashmap的size-方法" class="headerlink" title="关于ConcurrentHashmap的size()方法"></a>关于ConcurrentHashmap的size()方法</h2><p>对于ConcurrenHashMap来说，这个table中到底装了多少个Node是不确定的，因为多线程的关系。</p><p>不可能像GC时“stop the world”暂停所有线程来统计，所以说这个数量是个估计值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6、7中的ConcurrentHashmap：</p><ul><li>使用Segment来减小锁的颗粒度，分割成若干个Segment，在put的时候锁住对应的Segment，get的时候不加锁</li><li>使用volatile来保证可见性</li><li>当要统计全局时（如size），首先会尝试多次计算modcount，若这几次尝试中没有其他线程进行修改操作，直接返回size，若有，则需要依次锁住所有Segment来计算</li><li>put定位节点：先定位到具体Segment，再在Segment中定位到具体的桶</li></ul><p>JDK8之后：</p><ul><li>不使用Segment而是采用Node，锁住Node来减小锁粒度</li><li>设计了MOVED状态，当resize的过程中，其他执行put的线程会帮助resize</li><li>CAS替代锁，使用了3个CAS操作来确保对Node的一些操作的原子性</li><li>sizeCtl的不同值来代表不同的状态，起到控制作用</li><li>采用synchronized而不是ReentrantLock</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-LockSupport</title>
    <link href="/2022/10/18/Java%E5%B9%B6%E5%8F%91-LockSupport/"/>
    <url>/2022/10/18/Java%E5%B9%B6%E5%8F%91-LockSupport/</url>
    
    <content type="html"><![CDATA[<h1 id="LockSupport简介"><a href="#LockSupport简介" class="headerlink" title="LockSupport简介"></a>LockSupport简介</h1><p>调用LockSupport场景：</p><ul><li><p>AQS的底层实现中</p></li><li><p>锁的实现</p></li><li><p>Condition中，线程的等待&#x2F;通知机制</p></li></ul><p>LockSupport位于java.util.concurrent.locks包下，LockSupport时线程的阻塞原语，用来阻塞和唤醒线程。</p><p>每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可以在线程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用unpark()使其可用。但是注意，许可不可重入，也就是说只能调用一次park()方法，否则会一直阻塞。</p><h1 id="LockSupport方法介绍"><a href="#LockSupport方法介绍" class="headerlink" title="LockSupport方法介绍"></a>LockSupport方法介绍</h1><p>阻塞线程：</p><ul><li><p>void park()</p><blockquote><p>唤醒当前线程，如果调用unpark方法或者当前线程被中断，才能从park()方法中返回</p></blockquote></li><li><p>void park(Object blocker)</p><blockquote><p>功能同park()，入参增加了一个Object对象，用于记录导致线程阻塞的阻塞对象，方便进行问题排查</p></blockquote></li><li><p>void parkNanos(long nanos)</p><blockquote><p>增加了超时返回特性</p></blockquote></li><li><p>void parkNanos(Object blocker, long nanos)</p></li><li><p>void parkUntil(long deadline)</p><blockquote><p>阻塞档期那线程，知道deadline</p></blockquote></li><li><p>void parkUntil(Object blocker, long deadline)</p></li></ul><p>唤醒线程：</p><ul><li><p>void unpark(Thread thread)</p><blockquote><p>唤醒处于阻塞状态的指定线程</p></blockquote></li></ul><h1 id="LockSupport底层"><a href="#LockSupport底层" class="headerlink" title="LockSupport底层"></a>LockSupport底层</h1><p>LockSupport阻塞和唤醒线程的功能都是依赖于sun.misc.Unsafe类实现。</p><p>阻塞线程方法都有一个带Object阻塞对象的重载方法。该阻塞对象用于记录阻塞对象，类似于synchronized阻塞了线程dump线程时，都会有阻塞对象的藐视。在Java5推出LockSupport的时候遗漏了这一点，所以说在Java6中补充了这些带Object阻塞对象的重载方法。</p><p>synchronized与LockSupport阻塞区别：</p><ul><li>synchronized使线程阻塞，线程进入BLOCKED状态</li><li>LockSupport方法阻塞线程，线程进入WAITING状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Condition</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/</url>
    
    <content type="html"><![CDATA[<h1 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h1><p>等待通知机制的实现：</p><ul><li><p>Object：</p><blockquote><p>任何一个Java对象都是继承自Object类，在线程间实现通信往往会使用到Object的的wait()和notify()来实现等待&#x2F;通知机制。</p><p> Object的wait()和notify()是与对象监视器配合完成线程间的等待&#x2F;通知机制</p></blockquote></li><li><p>Condition:</p><blockquote><p>Condition实现和Object类wait()和notify()同样功能。</p><p>Condition是与Lock配合完成等待&#x2F;通知机制</p></blockquote></li></ul><p>前者是java底层级别的，Condition是语言级别的，具有更高的可控性和扩展性。</p><p>Condition支持，但Object方式不支持的功能特性：</p><ul><li>可以不响应中断</li><li>多个等待队列：Condition能够至此多个等待队列（new多个Condition对象）</li><li>设置超时时间</li></ul><p>Condition对应于Object的等待通知机制的方法：</p><ul><li><p>针对Object的wait方法</p><blockquote><p>Condition提供的方法：</p><ul><li>void await() throws InterruptedException</li></ul><blockquote><p>当前线程进入等待状态，如果其他线程调用condition的signal方法，并且当前线程获取锁，从await方法返回，如果在等待状态中被中断会抛出被中断异常</p></blockquote><ul><li>long awaitNanos(long nanosTimeout)</li></ul><blockquote><p>当前线程进入等待状态，直到被通知、中断或超时</p></blockquote><ul><li><p>boolean await(long time, TimeUnit unit) throws InterruptedException</p></li><li><p>boolean awatiUntil(Date deadline) throws InterruptedException</p></li></ul></blockquote></li><li><p>针对Object的notify方法</p><blockquote><p>Conditon提供的方法:</p><ul><li>void signal()</li></ul><blockquote><p>唤醒一个等待在condition上的线程，将该线程从等待队列转移到同步队列中，如果被唤醒的线程能够在同步队列中竞争到锁，则可以从等待方法中返回</p></blockquote><ul><li>void signalAll()</li></ul><blockquote><p>于signal的区别在于，signalAll会唤醒所有等待在condition上的线程</p></blockquote></blockquote></li></ul><h1 id="Condition实现原理"><a href="#Condition实现原理" class="headerlink" title="Condition实现原理"></a>Condition实现原理</h1><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><h3 id="新建condition对象："><a href="#新建condition对象：" class="headerlink" title="新建condition对象："></a>新建condition对象：</h3><p>创建condition对象是通过lock.newConditon()，这个方法实际上会new出一个ConditionObject对象，该类是AQS的一个内部类。condition要配合lock使用，而lock的实现又依赖于AQS，所以说CondetionObject作为AQS的一个内部类比较合理。</p><h3 id="等待队列："><a href="#等待队列：" class="headerlink" title="等待队列："></a>等待队列：</h3><p>在锁机制的实现上，AQS内部维护一个同步队列，若是独占式锁的话，获取锁失败的线程会尾插入同步队列。AQS通过head和tail指针来维护同步队列。</p><p>同样，condition内粗维护一个等待队列，调用condition.await() 方法的线程会加入到等待等待队列中，并将线程状态转换为等待状态。ConditionObject同样通过持有等待队列的头尾指针来管理队列。等待队列是通过复用Node类，使用其nextWaiter属性实现，可知其为单向队列。</p><p>Condition中的头尾节点成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//等待队列头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br><span class="hljs-comment">//等待队列尾节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br></code></pre></td></tr></table></figure><p>Node节点中的关于等待队列的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//后继节点</span><br>Node nextWaiter;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e65f9685tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="AQS持有多个Condition.png"></p><p>ConditionObject是AQS的内部类，因此每个ConditionObject能够访问到AQS提供的方法，相当于每个Condition都拥有所属同步器的引用。</p><h2 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h2><p>当调用condition.await() 方法后会使得当前获取lock的线程进入等待队列，直到被signal唤醒，使得当前线程从等待队列移至同步队列，直到线程获取锁后才从await方法中返回</p><p>awati ()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-comment">// 1. 将当前线程包装成Node，尾插入到等待队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br><span class="hljs-comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">// 3. 当前线程进入到等待状态</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><span class="hljs-comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br><span class="hljs-comment">// 5. 处理被中断的情况</span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将线程添加到等待队列"><a href="#将线程添加到等待队列" class="headerlink" title="将线程添加到等待队列"></a>将线程添加到等待队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br><span class="hljs-comment">//将当前线程包装成Node</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>    <span class="hljs-comment">//若为插入等待队列的一个节点，初始化firstWaiter</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-comment">//否则，尾插入</span><br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br><span class="hljs-comment">//更新lastWaiter</span><br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="释放锁的过程"><a href="#释放锁的过程" class="headerlink" title="释放锁的过程"></a>释放锁的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br><span class="hljs-comment">//成功释放同步状态</span><br>            failed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//不成功释放同步状态抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何从await中退出"><a href="#如何从await中退出" class="headerlink" title="如何从await中退出"></a>如何从await中退出</h3><p>第一次调用condition.await ()方法时，会进入这个while循环中，然后通过LockSupport.park(this)使得当前线程进入等待状态。</p><p>若要退出await方法，前提就是退出这个while循环，有两个出口：</p><ol><li><p>逻辑走到break退出while循环</p></li><li><p>while循环中逻辑判断为false</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//出口1: 若当前节点被移动到同步队列中，退出循环</span><br><span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">//当前线程进入到等待状态</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//出口2：若当前节点对应的线程被中断，break</span><br>    <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出while循环的条件：当前线程被中断或者调用condition.signal方法将当前节点移动到了同步队列。</p><p>退出while循环后会调用acquireQueued(node, savedState)，该方法自旋获取同步状态，直至成功（获取锁）。</p><h3 id="await执行示意图"><a href="#await执行示意图" class="headerlink" title="await执行示意图"></a>await执行示意图</h3><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e74cead3tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="await方法示意图"></p><h3 id="condition特性的实现"><a href="#condition特性的实现" class="headerlink" title="condition特性的实现"></a>condition特性的实现</h3><h4 id="超时机制的支持"><a href="#超时机制的支持" class="headerlink" title="超时机制的支持"></a>超时机制的支持</h4><p>实现基本于AQS中的tryAcquire方法一致。</p><h4 id="不响应中断支持"><a href="#不响应中断支持" class="headerlink" title="不响应中断支持"></a>不响应中断支持</h4><p>想要不响应中断可以调用condition.awaitUninterruptibly()方法，方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法基本于await()方法一致，只不过是减少了对中断的处理，省略了reportInterruptAfterWait方法抛出被中断异常</p><h2 id="signal实现原理"><a href="#signal实现原理" class="headerlink" title="signal实现原理"></a>signal实现原理</h2><p>signal()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 先检测当前线程是否已经获取lock</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//2. 获取等待队列中第一个节点，之后的操作都是针对这个节点</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure><p>doSignal()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>    <span class="hljs-comment">//do-while至少执行一次</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//1. 移动firstWaiter指针，若移动后指向null说明等待队列为空</span><br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//将lastWaiter置null</span><br>            lastWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//2. 将头结点从等待队列中移除，帮助垃圾回收</span><br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//3. while中transferForSignal方法对头结点做真正的处理</span><br>    <span class="hljs-comment">//transferForSignal将头节点插入同步队列</span><br>    <span class="hljs-comment">//若返回true，则表示插入成功，while循环结束</span><br>   <span class="hljs-comment">//若返回false，表示插入失败，while逻辑判断中的（frist = firstWaiter）移动first指针，再重复do-while逻辑</span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>transferForSignal(Node node)源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//传入参数node为等待队列的头节点</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-comment">//1. CAS更新node状态为0</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-comment">//若CAS失败，说明有多线程冲突，返回false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">//2. 将该节点尾插入到同步队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-comment">//看当前线程能否直接获取锁被唤醒</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-comment">//3. 节点插入同步队列成功后，返回true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>signal执行示意图：</p><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e7650d62tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="signal执行示意图"></p><p>signalAll()：</p><p>signalAll()和signal ()方法区别在于doSignalAll()方法：循环将等待队列中的节点移入同步队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;<br>    lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br>        transferForSignal(first);<br>        first = next;<br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="await与signal结合思考"><a href="#await与signal结合思考" class="headerlink" title="await与signal结合思考"></a>await与signal结合思考</h1><p>等待&#x2F;通知机制，这种机制能够解决最经典的问题“生产者与消费者问题”。</p><p>await和signal方法就像是一个开关控制着线程A（等待方）和线程B（通知方）。</p><p>关系示意图：</p><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-Condition/16334382e7911395tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="condition下的等待通知机制.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ReentrantReadWriteLock</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[<h1 id="读写锁简介"><a href="#读写锁简介" class="headerlink" title="读写锁简介"></a>读写锁简介</h1><p>独占锁与共享锁：</p><blockquote><p>独占式获取锁，同一时刻只有一个线程能够获取锁。</p><p>而在一些业务场景中，大部分只是读数据，写数据很少，读数据不会影响数据的正确性，使用独占锁的话会出现性能瓶颈。</p><p>读锁允许同一时刻被多个线程获取，但是写锁会阻塞所有的读写线程。</p></blockquote><ul><li>独占锁：<ul><li>Java关键字synchronized</li><li>concurrents包中实现Lock接口的ReentrantLock</li></ul></li><li>共享锁：<ul><li>concurrents包中实现Lock接口的ReentrantReadWriteLock</li></ul></li></ul><p>读写锁的特性：</p><ul><li>公平性选择：至此非公平（默认）和公平的锁获取方式，非公平吞吐量更优</li><li>重入性：支持重入，读锁获取后能再次获取，写锁获取后能够再次获取写锁，同时也能够获取读锁</li><li>锁降级：遵循获取写锁，获取读锁，再释放写锁的次序，写锁能够降级为读锁</li></ul><p>关于读写锁的的几个问题：</p><ul><li>读写锁是如何是心啊分别记录读写状态的</li><li>写锁是怎样获取去和释放的</li><li>读锁是怎样获取和释放的</li></ul><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><h2 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h2><p>写锁在同一时刻不能被多个线程所获取，所以说写锁是独占式锁。实现写锁的同步语义是通过重写AQS中的tryAcquire方法实现的。</p><h3 id="tryAcquire-源码：（获取写锁）"><a href="#tryAcquire-源码：（获取写锁）" class="headerlink" title="tryAcquire ()源码：（获取写锁）"></a>tryAcquire ()源码：（获取写锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//同步状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">//写锁状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>    <br>    <span class="hljs-comment">//1 锁已经被线程获取，只有重入写锁能够获取锁</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//1.1 判断是否满足重入条件</span><br>        <span class="hljs-comment">//若当前线程不是获取锁的线程，或读锁已经被获取（c != 0 且 w == 0，说明读锁被获取）</span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>            <span class="hljs-comment">//不满足重入条件，获取锁失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">//走到这儿，说明当前线程已经获取读锁</span><br>        <span class="hljs-comment">//1.2 执行重入写锁的操作</span><br>        <span class="hljs-comment">//写锁计数溢出</span><br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br><span class="hljs-comment">//修改写锁同步状态</span><br>        setState(c + acquires);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">//2 锁未被任何线程获取</span><br>    <span class="hljs-comment">//2.1 若被阻塞，或者CAS修改同步状态失败，获取锁失败</span><br>    <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//2.2 否则获取写锁成功，设置当前线程独占锁</span><br>    setExclusiveOwnerThread(current);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于同步状态："><a href="#关于同步状态：" class="headerlink" title="关于同步状态："></a>关于同步状态：</h3><blockquote><p>读锁和写锁的获取次数都保存在同步状态这一个变量中，高16位保存的是读状态，低十六位保存的是写状态</p></blockquote><p><img src="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock/163262ec97ebeac9tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="读写锁的读写状态设计.png"></p><p>获取写状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写状态通过掩码（0x0000FFFF）与同步状态相与获取</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br></code></pre></td></tr></table></figure><p>获取读状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读状态通过同步状态右移16位获取</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;<br></code></pre></td></tr></table></figure><h2 id="写锁释放"><a href="#写锁释放" class="headerlink" title="写锁释放"></a>写锁释放</h2><p>tryRelease()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-comment">//1. 同步状态减去写状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br><span class="hljs-comment">//2. 当前写状态是否为0，为0则释放写锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (free)<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//3. 不为0则更新同步状态</span><br>    setState(nextc);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><h2 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h2><p>tryAcquiredShared()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">//1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前</span><br><span class="hljs-comment">// 线程获取读锁失败返回-1</span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>        getExclusiveOwnerThread() != current)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>        r &lt; MAX_COUNT &amp;&amp;<br><span class="hljs-comment">//2. 当前线程获取读锁</span><br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<br><span class="hljs-comment">//3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法</span><br><span class="hljs-comment">//返回当前获取读锁的次数</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>            firstReader = current;<br>            firstReaderHoldCount = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>            firstReaderHoldCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                cachedHoldCounter = rh = readHolds.get();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                readHolds.set(rh);<br>            rh.count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-comment">//4. 处理在第二步中CAS操作失败的自旋已经实现重入性</span><br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读锁释放"><a href="#读锁释放" class="headerlink" title="读锁释放"></a>读锁释放</h2><p>tryReleaseShared()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 前面还是为了实现getReadHoldCount等新功能</span><br>    <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>        <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;</span><br>        <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)<br>            firstReader = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span><br>            firstReaderHoldCount--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>        <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>            rh = readHolds.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> rh.count;<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>            readHolds.remove();<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> unmatchedUnlockException();<br>        &#125;<br>        --rh.count;<br>    &#125;<br>    <span class="hljs-comment">// 自旋CAS释放读锁</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h1><p>写锁能够降级为读锁，不支持锁升级。写锁在获取读锁后释放写锁，则写锁降级为读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// Must release read lock before acquiring write lock</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck state because another thread might have</span><br>                <span class="hljs-comment">// acquired write lock and changed state before we did.</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>            cacheValid = <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-comment">// Downgrade by acquiring read lock before releasing write lock</span><br>          rwl.readLock().lock();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          rwl.writeLock().unlock(); <span class="hljs-comment">// Unlock write, still hold read</span><br>        &#125;<br>      &#125;<br> <br>      <span class="hljs-keyword">try</span> &#123;<br>        use(data);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        rwl.readLock().unlock();<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-ReentrantLock</title>
    <link href="/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantLock/"/>
    <url>/2022/10/17/Java%E5%B9%B6%E5%8F%91-ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h1 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h1><p>ReentrantLock重入锁，是实现Lock接口的一个类。</p><ul><li><p>支持<strong>重入性</strong>，表示能够对共享资源重复加锁，即当前获取该锁的线程再次获取不会被阻塞。Java关键字synchronized通过获取自增，释放自减的方式实现重入。</p></li><li><p>ReentrantLock还支持<strong>公平锁和非公平锁</strong>两种方式。</p></li></ul><h1 id="重入性的实现原理"><a href="#重入性的实现原理" class="headerlink" title="重入性的实现原理"></a>重入性的实现原理</h1><h2 id="支持重入性需要解决的两个问题"><a href="#支持重入性需要解决的两个问题" class="headerlink" title="支持重入性需要解决的两个问题"></a>支持重入性需要解决的两个问题</h2><ul><li>在获取锁的时候，如果已经获取锁的线程是当前线程的话直接再次获取成功</li><li>由于锁会被获取n次，那么只有在锁同样被释放n次过后，该锁才算完全释放</li></ul><h2 id="实现重入性的核心方法"><a href="#实现重入性的核心方法" class="headerlink" title="实现重入性的核心方法"></a>实现重入性的核心方法</h2><blockquote><p>同步组件通过重写AQS的几个protected方法来表达自己的同步语义</p></blockquote><h3 id="nonfairTryAcquire"><a href="#nonfairTryAcquire" class="headerlink" title="nonfairTryAcquire()"></a>nonfairTryAcquire()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//1 如果该锁未被任何线程占有，该锁能被当前线程获取</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//2 检查占有线程是否是当前线程</span><br>    <span class="hljs-comment">//2.1 若是，锁重入，返回true</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>       <span class="hljs-comment">//计算重入后的锁重入次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-comment">//避免锁重入次数逸出int范围（几乎不会出现，增加程序健壮性）</span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        <span class="hljs-comment">//设置重入后的锁状态</span><br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//2.2 若不是，直接返回false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">//当前没有获取锁的线程不能释放锁</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//1 同步状态减1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">//free表示锁完全被释放（获取n次锁，释放n次锁，即为完全释放。）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//2 只有当同步状态为0时，锁完全被释放</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-comment">//3 返回锁释放状态free（完全释放为true，还没有释放完为false）</span><br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><h2 id="ReentrantLock的构造方法"><a href="#ReentrantLock的构造方法" class="headerlink" title="ReentrantLock的构造方法"></a>ReentrantLock的构造方法</h2><blockquote><p>构造方法的主要内容就是指定同步器。</p><p>ReentrantLock内部有两个实现了AQS的同步器，一个是公平锁，另一个是非公平锁。</p></blockquote><p>无参构造（非公平锁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>传入boolean值指定是否为公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公平锁的tryAcquire-方法"><a href="#公平锁的tryAcquire-方法" class="headerlink" title="公平锁的tryAcquire()方法"></a>公平锁的tryAcquire()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在非公平锁的基础上，增加了前驱节点判断，有前驱节点的话就不能获取锁，保证按照入队顺序获取锁</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//若当前锁没有线程获取</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果有前驱节点，则获取锁失败（公平锁的实现逻辑）</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//若当前线程已经拿到锁</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><ul><li>“饥饿”现象：<ul><li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源上的绝对顺序。</li><li>而非公平锁，刚释放锁的线程再次参与锁竞争，可能继续获取锁，有可能导致其他线程永远获取不到锁，造成“饥饿”现象</li></ul></li><li>性能：<ul><li>公平锁为了保证获取锁的FIFO顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销</li><li>所以ReentrantLock默认选择的是非公平锁，则是为了减少部分上下文切换，保证系统更大的吞吐量</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-AQS深入理解</title>
    <link href="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <url>/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h1><p>在同步组件的实现中，AQS是核心部分</p><p>同步组件的实现者通过AQS提供的模板方法实现同步组件的同步语义</p><p>AQS则实现了对同步状态的管理，以及对阻塞线程的排队、等待和通知等一些底层的实现</p><p>AQS核心：</p><ul><li>同步队列</li><li>独占式锁的获取于释放</li><li>共享锁的获取和释放</li><li>可中断锁、超时等待锁获取</li></ul><p>AQS提供的模板方法：</p><ul><li><p>独占式锁</p><ul><li><p>void acquire(int arg)</p><blockquote><p>独占式获取同步状态，如果获取失败则插入同步队列进行等待</p></blockquote></li><li><p>void acquireInterruptibly(int arg)</p><blockquote><p>与acquire方法相同，但在同步队列中进行等待的时候可以检测中断</p></blockquote></li><li><p>boolean tryAcquireNanos(int arg, long nanosTimeout)</p><blockquote><p>在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获取同步状态返回false</p></blockquote></li><li><p>boolean release(int arg)</p><blockquote><p>释放同步状态，该方法会唤醒在同步队列中的下一个节点</p></blockquote></li></ul></li><li><p>共享式锁</p><ul><li><p>void acquireShared (int arg)</p><blockquote><p>共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态</p></blockquote></li><li><p>void acquireSharedInterruptibly(int arg)</p><blockquote><p>在acquireShared方法基础上增加了能响应中断的功能</p></blockquote></li><li><p>boolean tryAcquireSharedNanos(int arg, long nanoTimeout)</p><blockquote><p>在acquireSharedInterruptibly基础上增加了超时等待的功能</p></blockquote></li><li><p>boolean releaseShared(int arg)</p><blockquote><p>共享式释放同步状态</p></blockquote></li></ul></li></ul><h1 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h1><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。</p><h2 id="同步队列的数据结构"><a href="#同步队列的数据结构" class="headerlink" title="同步队列的数据结构"></a>同步队列的数据结构</h2><p>就数据结构而言，队列的实现有两种：数组、链表</p><p>AQS中的同步队列则是通过<strong>链表</strong>方式进行实现。</p><p>对于AQS同步队列的一些问题：</p><ul><li>节点的数据结构是什么样的？</li><li>同步队列是单项还是双向？</li><li>同步队列带不带头节点？</li></ul><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node是AQS的一个静态内部类，用来保存获取同步状态失败的线程引用以及等待状态信息</p><p>Node的属性：</p><ul><li><p>volatile int waitStatus</p><blockquote><p>节点状态</p><ul><li><p>int CANCELLED &#x3D; 1</p><blockquote><p>节点从同步队列中取消</p></blockquote></li><li><p>int INITIAL  &#x3D; 0</p><blockquote><p>初始状态</p></blockquote></li><li><p>int SIGNAL &#x3D; -1</p><blockquote><p>后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点能都运行</p></blockquote></li><li><p>int CONDITION &#x3D; -2</p><blockquote><p>当前节点进入等待队列</p></blockquote></li><li><p>int PROPAGATE &#x3D; -3</p><blockquote><p>表示下一次共享式同步状态获取将会无条件传播下去</p></blockquote></li></ul></blockquote></li><li><p>volatile Thread thread</p><blockquote><p>当前节点所封装的线程</p></blockquote></li><li><p>volatile Node prev</p><blockquote><p>同步队列前驱动节点</p></blockquote></li><li><p>volatile Node next</p><blockquote><p>同步队列后继节点</p></blockquote></li><li><p>Node nextWatier</p><blockquote><p>等待队列中的下一个节点</p></blockquote></li></ul><h2 id="AQS对同步队列的管理"><a href="#AQS对同步队列的管理" class="headerlink" title="AQS对同步队列的管理"></a>AQS对同步队列的管理</h2><p>AQS通过持有同步队列的头尾节点的指针来对节点进行管理</p><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637bb25796tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对节点和同步队列的了解：</p><ul><li>节点的数据结构，即AQS的静态内部类Node，节点的等待状态等信息</li><li>同步队列是一个双向队列，AQS通过持有头尾节点的指针管理同步队列</li></ul><p>同步队列和锁的关系：</p><p>节点的入队和出队实际上对应着锁的获取和释放两个操作获取锁失败进行入队操作，获取锁成功进行出队操作。</p><h1 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h1><p>方法分析层级（数字表示层级）：</p><ul><li><p>1 lock()</p><blockquote><p>实现Lock接口的锁的获取锁的方法</p></blockquote><ul><li><p>2 acquire()</p><blockquote><p>lock ()方法通过调用锁中的继承自AQS的内部类的acqure方法来获取锁</p></blockquote><ul><li><p>3 addWaiter()</p><blockquote><p>将当前线程打包成Node插入同步队列</p></blockquote><ul><li><p>4 enq()</p><blockquote><p>完成同步队列头节点初始化，并将Node插入同步队列</p></blockquote></li></ul></li><li><p>3 acquireQueued()</p><blockquote><p>阻塞排队获取锁</p></blockquote><ul><li><p>4 shouldParkAfterFailedAcquire()</p><blockquote><p>将前置节点状态设置为SIGNAL</p></blockquote></li><li><p>4 parkAndCheckInterrupt()</p><blockquote><p>阻塞当前线程，并检测当前线程是否被中断</p></blockquote></li></ul></li></ul></li></ul></li></ul><h2 id="独占式锁的获取（acquire）"><a href="#独占式锁的获取（acquire）" class="headerlink" title="独占式锁的获取（acquire）"></a>独占式锁的获取（acquire）</h2><p>在使用lock.lock()方法获取独占式锁的时候，获取失败就将当前线程加入同步队列，成功则线程执行。</p><p>lock()实际调用的是AQS的acquire()方法。</p><p>acquire ()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><span class="hljs-comment">//先看同步状态是否获取成功，如果成功则方法结束返回</span><br><span class="hljs-comment">//若失败则先调用addWaiter()方法再调用acquireQueued()方法</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>源码通过逻辑运算的短路特性来精简语句，以下是我写的逻辑更清晰一点的啰嗦语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//1 如果获取同步状态失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg))&#123;<br>        <span class="hljs-comment">//1.1 将当前线程打包成Node节点插入同步队列，并返回打包好的Node节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>        <span class="hljs-comment">//1.2 Node节点排队获取锁</span><br>        <span class="hljs-keyword">if</span>(acquireQueued(node, arg))&#123;<br>            selfInterupt();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2 如果获取成功，方法结束返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="addWaiter-方法"><a href="#addWaiter-方法" class="headerlink" title="addWaiter() 方法"></a>addWaiter() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">//1 将当前线程打包成Node类型</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">//2 将Node插入同步队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//2.1 尾节点不为null，当前节点尾插入的方式插入同步队列中</span><br>        node.prev = pred;<br>        <span class="hljs-comment">//如果CAS插入成功，则直接返回，若CAS失败则通过enq()方法插入</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2.2 尾节点为null，说明当前线程是第一个加入同步队列进行等待的线</span><br>    enq(node);<br>    <span class="hljs-comment">//3 返回打包好的node节点</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//获取tail的指针</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">//tail为null，在未插入节点之前需要初始化头节点</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">//1 初始化头结点。通过CAS设置头节点，避免因为多线程竞争导致重复初始化头节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        <span class="hljs-comment">//tail不为null，</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//2 尾插入，若CAS操作失败，可通过for循环不断进行CAS插入</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acquireQueued（）方法"><a href="#acquireQueued（）方法" class="headerlink" title="acquireQueued（）方法"></a>acquireQueued（）方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//1 获得当前节点的先驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">//2 当前节点能否获取独占式锁</span><br>            <span class="hljs-comment">//2.1 获取锁成功，获取锁的节点出队</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">//队列头指针用指向当前节点</span><br>                setHead(node);<br>                <span class="hljs-comment">//释放前驱节点，帮助GC回收</span><br>                p.next = <span class="hljs-literal">null</span>;<br>                <br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">//2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span><br>            <span class="hljs-comment">//使用CAS将前驱节点状态由INITIAL设置成SIGNAL，若CAS失败则通过for循环不断重试</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node))&#123;<br>                <span class="hljs-comment">//当节点状态设置成功，则阻塞当前线程</span><br>                <span class="hljs-keyword">if</span>(parkAndCheckInterrupt()))&#123;<br>                    interrupted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;  <br>            <span class="hljs-comment">/*上面一段代码的源码</span><br><span class="hljs-comment">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="hljs-comment">                    parkAndCheckInterrupt())</span><br><span class="hljs-comment">                    interrupted = true;</span><br><span class="hljs-comment">            */</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">//若前驱节点状态已经为SIGNAL，直接返回true</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//若前驱节点状态为CANCELLED，往前寻找状态不为CANCELLED的节点作为前驱节点</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    <span class="hljs-comment">//其他情况，使用CAS将前驱动节点状态改为SIGNAL</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//使得该线程阻塞</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//返回当前线程是否被中断</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acquire-方法流程图"><a href="#acquire-方法流程图" class="headerlink" title="acquire ()方法流程图"></a>acquire ()方法流程图</h3><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637c891cc2tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="独占式锁获取（acquire()方法）流程图.png"></p><h2 id="独占式锁的释放（release）"><a href="#独占式锁的释放（release）" class="headerlink" title="独占式锁的释放（release）"></a>独占式锁的释放（release）</h2><p>release()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//如果释放锁成功</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//唤醒后继节点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">//1 若当前要释放锁的node状态为负数，则将其状态置0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//2 唤醒后续节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">//若后继节点为null或状态为CANCELLED</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//从尾节点往前寻找一个没有被CANCELLED的节点</span><br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">//若s为null说明没有有效后继节点了，则不需要唤醒线程</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//后继节点不为null时唤醒后继节点对应的线程</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="独占式锁小结"><a href="#独占式锁小结" class="headerlink" title="独占式锁小结"></a>独占式锁小结</h3><ul><li>线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头节点初始化工作以及CAS操作失败的重试</li><li>线程获取锁是一个自旋的过程，当且仅当当前线程的前驱节点是头节点并且成功获取同步状态时，节点出队，即该节点引用的线程获得锁，否则，当不满足条件时就会调用LockSupport.park()方法使得线程阻塞</li><li>释放锁得时候会唤醒后继节点</li></ul><p>总的来说：在获取同步状态时，AQS维护一个同步队列，获取同步状态失败得线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是*<em>前驱节点是头节点并且成功获得了同步状态</em>。在释放同步状态时，同步器会调用unparkSuucessor()方法唤醒后继节点。</p><h2 id="可中断式获取锁（acquireInterruptibly）"><a href="#可中断式获取锁（acquireInterruptibly）" class="headerlink" title="可中断式获取锁（acquireInterruptibly）"></a>可中断式获取锁（acquireInterruptibly）</h2><p>acquireInterruptilbly()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//若线程已经被中断，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">//尝试获取锁。若获取锁成功，直接方法结束</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>        <span class="hljs-comment">//获取锁失败，进行可中断式获取锁</span><br>        doAcquireInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-comment">//将节点插入到同步队列中</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">//获取锁出队</span><br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br><span class="hljs-comment">//线程中断抛异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>acquireInterruptibly()与acquire()的关系：</p><ul><li>该方法与acquire方法逻辑几乎一致</li><li>唯一的区别在于，当parkAndCheckInterrupt()返回true时的处理<ul><li>acquire()将interrupted属性置为true</li><li>acquireInterruptilbly()直接抛出异常</li></ul></li></ul><h2 id="超时等待式获取锁（tryAcquireNanos）"><a href="#超时等待式获取锁（tryAcquireNanos）" class="headerlink" title="超时等待式获取锁（tryAcquireNanos）"></a>超时等待式获取锁（tryAcquireNanos）</h2><p>调用lock.tryLock()方式达到超时等待式获取锁，该方法只有在如下情况下才会返回：</p><ul><li>在超时时间内，成功获取锁</li><li>在超时时间内，被中断</li><li>超时时间结束，仍未获得锁</li></ul><p>tryAcquireNanos()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//若线程被中断，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">//若能直接获取锁，则返回true</span><br>    <span class="hljs-keyword">if</span>(tryAcquire(arg))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//若获取锁失败，尝试超时等待式获取锁</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> doAcquireNanos(arg, nanosTimeout);<br>    &#125;<br>    <span class="hljs-comment">//上面一小段的源码：return tryAcquire(arg) || (arg, nanosTimeout);</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//1. 根据超时时间和当前时间计算出截止时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><span class="hljs-comment">//2. 当前线程获得锁出队列</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">// 3.1 重新计算超时时间</span><br>            nanosTimeout = deadline - System.nanoTime();<br>            <span class="hljs-comment">// 3.2 已经超时返回false</span><br><span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 3.3 线程阻塞等待 </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                nanosTimeout &gt; spinForTimeoutThreshold)<br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>            <span class="hljs-comment">// 3.4 线程被中断抛出被中断异常</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序逻辑：</p><p><img src="/2022/10/16/Java%E5%B9%B6%E5%8F%91-AQS%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/163261637d087f5etplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="超时等待式获取锁（doAcquireNanos()方法）"></p><p>程序逻辑同可响应中断式独占锁基本一致，唯一不同在于，获取锁失败后的超时时间处理。</p><ul><li>理论截至时间计算：根据当前系统内和时间超时时间计算出截至时间</li><li>超时判断：截至时间减去系统当前时间<ul><li>若为负，超时直接返回false</li><li>若为正，调用LockSupport.parkNanos()阻塞当前线程</li></ul></li></ul><p>增加了独立的中断检测。</p><h1 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h1><h2 id="共享锁的获取（acquireShared）"><a href="#共享锁的获取（acquireShared）" class="headerlink" title="共享锁的获取（acquireShared）"></a>共享锁的获取（acquireShared）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//tryAcquireShared返回值大于等于0的话表示获取锁成功</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//获取锁失败，执行共享式获取锁</span><br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; ) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//当该节点的前驱节点是头结点且成功获取同步状态</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享锁的释放（releaseShared）"><a href="#共享锁的释放（releaseShared）" class="headerlink" title="共享锁的释放（releaseShared）"></a>共享锁的释放（releaseShared）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">     * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">     * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">     * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">     * fails, if so rechecking.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                 <span class="hljs-comment">// loop to recheck cases</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;           <br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-comment">// loop on failed CAS</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <br>        &#125;<br>        <span class="hljs-comment">// loop if head changed</span><br>        <span class="hljs-keyword">if</span> (h == head)                   <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理"><a href="#可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理" class="headerlink" title="可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理"></a>可中断（acquireSharedInterruptibly）、超时等待（tryAcquireSharedNanos）同理</h2>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Lock与AQS初识</title>
    <link href="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/"/>
    <url>/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h1><h2 id="包结构："><a href="#包结构：" class="headerlink" title="包结构："></a>包结构：</h2><ul><li>atomic子包</li><li>locks子包</li><li>阻塞队列以及executors</li></ul><h2 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h2><blockquote><p>底层依赖volatile和CAS</p></blockquote><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff7cb847ctplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><h1 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h1><p>锁使用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</p><h2 id="Lock接口与syncronized"><a href="#Lock接口与syncronized" class="headerlink" title="Lock接口与syncronized"></a>Lock接口与syncronized</h2><p>在Lock接口出现之前，Java程序主要靠synchronized关键字实现锁。</p><p>Lock拥有比synchronized更多的同步特性：</p><ul><li>主动控制锁获取与释放</li><li>可中断获取锁</li><li>超时获取锁</li></ul><p>注意：synchronized同步块执行完成或者遇到异常，锁会自动释放，而Lock需要主动调用unlock()方法释放锁，所以需要在finally块中释放。</p><h2 id="Lock接口API"><a href="#Lock接口API" class="headerlink" title="Lock接口API"></a>Lock接口API</h2><ul><li><p>void lock()</p><blockquote><p>阻塞式获取锁</p></blockquote></li><li><p>void lockInterruptibly() throws InterruptedException</p><blockquote><p>阻塞式获取锁，获取锁的过程能够响应中断</p></blockquote></li><li><p>boolean tryLock()</p><blockquote><p>非阻塞式、响应中断、立即返回，获取锁返回true，失败返回false</p></blockquote></li><li><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</p><blockquote><p>超时获取锁，未超时且未中断能够获取锁</p></blockquote></li><li><p>Condition newCondition()</p><blockquote><p>获取与lock绑定的等待通知组件（当前线程必须获取了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回）</p></blockquote><h2 id="Lock接口的实现"><a href="#Lock接口的实现" class="headerlink" title="Lock接口的实现"></a>Lock接口的实现</h2></li></ul><p>concurrent.locks包中实现了Lock接口的类的实现方式</p><ul><li>类中包含一个继承自AQS的静态内部类</li><li>通过调用该类的方法实现Lock接口的方法</li></ul><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><blockquote><p>AQS全称AbstractQueuedSynchronizer，简称同步器。</p></blockquote><p>作用：同步器用来构建锁和其他同步组件的基础框架</p><p>实现：依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列</p><p>子类需要重写的方法：</p><ul><li>修改同步状态的方法<ul><li>getState</li><li>setState</li><li>compareAndSetState</li></ul></li><li>实现排队和阻塞机制的方法</li></ul><p>同步器和锁的关系：</p><ul><li><p>同步器是实现锁的关键，锁聚合同步器，利用同步器实现锁的语义</p></li><li><p>锁面向使用者，定义使用者与锁交互的接口，隐藏了实现的细节</p></li><li><p>同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理、线程的排队、等待和唤醒等底层操作</p></li><li><p>二者分别屏蔽了使用者和实现者所需要关注的领域</p></li></ul><h2 id="AQS的模板方法设计模式"><a href="#AQS的模板方法设计模式" class="headerlink" title="AQS的模板方法设计模式"></a>AQS的模板方法设计模式</h2><blockquote><p>AQS开放一些方法给子类进行重写。同步组件调用同步器的方法，而这些方法又会调用子类重写的方法。</p></blockquote><ul><li>同步组件（锁和同步工具）的实现依赖于同步器AQS，在同步器的实现中，使用AQS的方式推荐被定义未继承了AQS的静态内部类</li><li>AQS采用模板方法进行设计，AQS的peotected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法的时候就会调用被重写的方法</li><li>AQS负责同步状态的管理，线程的排队、等待和唤醒等底层操作，而Lock等同步组件主要专注于实现同步语义</li><li>在重写AQS的方法是，使用AQS提供的getState()、setState()、compareAndSetState()方法进行同步状态的修改</li></ul><p>可重写的方法：</p><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff7d16b38tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>AQS为同步组件提供的模板方法（大概分为三类）：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中等待线程情况</li></ul><p><img src="/2022/10/15/Java%E5%B9%B6%E5%8F%91-Lock%E4%B8%8EAQS%E5%88%9D%E8%AF%86/163260cff87fe8bftplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p><strong>同步组件通过AQS提供的模板方法实现自己的同步语义</strong></p><h1 id="同步组件与AQS的关系"><a href="#同步组件与AQS的关系" class="headerlink" title="同步组件与AQS的关系"></a>同步组件与AQS的关系</h1><h2 id="同步组件实现者的角度："><a href="#同步组件实现者的角度：" class="headerlink" title="同步组件实现者的角度："></a>同步组件实现者的角度：</h2><p>通过可重写的方法：</p><ul><li>独占式：<ul><li>tryAcquire()</li><li>tryRelease()</li></ul></li><li>共享式：<ul><li>tryAcquireShared()</li><li>tryReleaseShared()</li></ul></li></ul><p>通过这些方法告诉AQS如何判断当前同步状态是否成功获取或者失败。</p><p>同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。</p><h2 id="AQS的角度"><a href="#AQS的角度" class="headerlink" title="AQS的角度"></a>AQS的角度</h2><p>对于AQS来所，只需要同步组件返回的true和false即可，因为AQS会对true和false有不同的操作，true会认为当前线程获取同步组件成功而直接返回，若为falseAQS也会执行将当前线程插入同步队列等一系列方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步组件通过重写AQS的方法实现字节想要表达的同步语义，而AQS只需要同步组件表达的true和false来执行不同的处理。</p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发关键字</title>
    <link href="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a>synchronized简介</h2><p>线程安全问题的主要来源于JMM的设计，集中在</p><ul><li>主内存和工作内存导致内存可见性问题</li><li>重排序导致的有序性问题</li></ul><p>多线程的意义在于多个线程协作共同完成一件事情，那么多个线程就必然需要访问共享数据。</p><p>如何保证共享数据的线程安全问题？即每个线程依次访问该共享变量，synchronize关键字具有让每个线程依次访问共享数据的功能。它是并发容器实现的基础。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>sychronized使用场景</p><ul><li><p>方法</p><blockquote><p>可以作用于实例方法和静态方法</p><p>区别在于被锁对象一个是实例对象，一个是类对象</p></blockquote></li><li><p>代码块（锁住方法相当于锁住整个方法的代码块）</p><blockquote><p>可以使用各种对象作为锁</p><p>this：使用类的实例对象作为锁</p><p>.class：使用类对象作为锁</p><p>Object：使用任意实例对象作为锁</p></blockquote></li></ul><h3 id="对象锁（moniter）机制"><a href="#对象锁（moniter）机制" class="headerlink" title="对象锁（moniter）机制"></a>对象锁（moniter）机制</h3><h4 id="获取与释放对象锁："><a href="#获取与释放对象锁：" class="headerlink" title="获取与释放对象锁："></a>获取与释放对象锁：</h4><p>在编译后的字节码中使用monitorenter指令获取到monitor（对象锁）后才能继续执行代码块中的指令，最后通过monitorexit指令释放所持有的monitor。</p><p>正常执行return退出代码块或者抛出异常退出代码块都能够执行monitorexit释放持有的对象锁</p><h4 id="对象锁（monitor）"><a href="#对象锁（monitor）" class="headerlink" title="对象锁（monitor）"></a>对象锁（monitor）</h4><p>每个对象都存在一个与之关联的monitor，线程对monitor持有的方式以及持有时机决定了synchronized的锁状态以及synchronized的状态升级方式</p><p>monitor是通过C++中的ObjectMonitor实现的：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/%E5%AF%B9%E8%B1%A1%E9%94%81.drawio.png" alt="对象锁.drawio"></p><ul><li>ObjectMonitor维护WaitSet和EntryList两个队列来保存ObjectWaiter对象</li><li>EntryList：阻塞等待获取锁的线程会被封装成ObjectWaiter进入EntryList队列，等待锁释放后竞争锁，获取锁后线程执行完成后退出并释放锁。</li><li>WaitSet：获取锁的线程若调用wait方法后会进入WaitSet中等待被唤醒，若被唤醒，则线程会进入EntryList中</li></ul><h3 id="synchronized与happens-before的关系"><a href="#synchronized与happens-before的关系" class="headerlink" title="synchronized与happens-before的关系"></a>synchronized与happens-before的关系</h3><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/5c09eea06aa64329bdae63dc31aa9622tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p><p>箭头表示happens-before</p><ul><li>程序顺序规则：黑色箭头顺序</li><li>监视器锁队则：红色箭头顺序</li><li>传递性规则：由上面两个推导出来的蓝色箭头顺序</li></ul><h3 id="获取锁和释放锁的内存语义"><a href="#获取锁和释放锁的内存语义" class="headerlink" title="获取锁和释放锁的内存语义"></a>获取锁和释放锁的内存语义</h3><p>释放锁：释放锁的时候会将线程对共享变量的修改写回主内存</p><p>获取锁：会强制从主内存中获取共享变量的新值</p><p>所以从横向看，线程之间基于主内存中的共享变量互相感知对方的数据操作，基于共享变量完成并发实体中的协作工作，整个过程就像是线程发送数据变更的“通知”，这种通知机制就是基于共享内存的并发模型导致的。</p><h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>synchronized最大特征就是同一时刻只能有一个线程能够获取对象的monitor，从何确保线程同步，对于线程之间表现为<strong>互斥性（排他性）</strong></p><p>优化的方向：</p><ul><li>让获取锁的速度变快</li><li>降低阻塞等待的概率</li></ul><p>对于优化需要先了解：</p><ul><li>CAS</li><li>Java对象头</li></ul><p>具体的优化：（锁升级）</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><h4 id="CAS概念"><a href="#CAS概念" class="headerlink" title="CAS概念"></a>CAS概念</h4><p>悲观锁：线程获取锁是一种悲观锁策略，即假设每次执行临界区代码都会产生冲突，所以当前线程获取锁的同时会阻塞其他线程获取该锁</p><p>乐观锁：CAS操作（又称无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，那么线程之间就不会出现阻塞。CAS操作会检测是否发生了冲突，则发生冲突，CAS会重试直到没有冲突</p><h4 id="CAS操作过程"><a href="#CAS操作过程" class="headerlink" title="CAS操作过程"></a>CAS操作过程</h4><p>CAS比较交换的过程可以大概理解为CAS(V, O, N)</p><ul><li>V（vary）：变量</li><li>O（old）：旧值</li><li>N（new）：新值</li></ul><p>过程：（整个过程是基于硬件指令级实现，具有原子性）</p><blockquote><p>读取V的值，若V &#x3D;&#x3D; O，那么说明内存中的值没有别其他线程修改过，就没有线程冲突，那么即可将N写入V。若V !&#x3D; O，说明该值已经被修改过了，CAS失败。</p></blockquote><p>Synchronized VS CAS:</p><blockquote><p>synchronized在存在线程竞争的情况下，会出现线程阻塞和唤醒带来的性能问题，这是一种<strong>阻塞同步</strong></p><p>CAS会在CAS操作失败后进行一定的尝试，而不是进行耗时的挂起唤醒操作，因此也叫做<strong>非阻塞同步</strong></p></blockquote><h4 id="CAS的应用场景"><a href="#CAS的应用场景" class="headerlink" title="CAS的应用场景"></a>CAS的应用场景</h4><ul><li><p>concurrency包的实现</p></li><li><p>Lock实现中CAS该百年state变量</p></li><li><p>atomic包的实现</p></li></ul><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><ul><li><p>ABA问题</p><blockquote><p>问题：</p><p>CAS通过检查旧值是否变化来检测变量是否改变，若变量变化如下A-&gt;B-&gt;A，那么CAS则无法检测到变量的变化</p><p>解决方法：</p><p>加上版本号1A-&gt;2B-&gt;3A</p><p>Java在atomic包中提供了AtomicStampedReference来解决ABA问题</p></blockquote></li><li><p>自旋对CPU的占用带来的性能消耗</p><blockquote><p>CAS若失败不会将线程挂起释放CPU资源，会进行自旋（死循环）进行重试直到CAS成功，自旋时间过程的话会对性能造成很大消耗</p><p>若JVM支持处理器提供的pause指令，可以在效率上有一定提升</p></blockquote></li><li><p>只能保证一个共享变量的原子操作</p><blockquote><p>问题：</p><p>对一个变量执行CAS操作可以保证器原子性，若对多个共享便变量进行操作，CAS就不能保证这个操作的原子性</p><p>解决办法：</p><p>利用对象整合多个共享变量，对对象执行CAS操作。</p><p>atomic包中提供了AtomicReference来保证引用对象之间的原子性</p></blockquote></li></ul><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>如何理解对象锁：</p><p>对象锁是对象的一个标志，这个标志存放在Java对象的对象头的Mark Word中。</p><p>Mark Word：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315cff10307a29tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315d056598e4c2tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>锁在大多数情况下不存在多线程竞争，并且总是由同一线程多次获得，为减少同一线程获取锁的代价而引入偏向锁</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxODMyMjU1,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="偏向锁逻辑"><a href="#偏向锁逻辑" class="headerlink" title="偏向锁逻辑"></a>偏向锁逻辑</h4><p>通用逻辑：</p><ol><li>检测锁标志位。若为01，说明处于无锁或偏向锁状态，才能进行偏向锁逻辑判断。</li><li>检测偏向锁标志位。若为0，说明是无锁（无锁不可偏向），进入轻量级锁逻辑（CAS竞争锁），若是1说明是偏向锁，进入偏向锁逻辑。</li></ol><p>偏向锁逻辑：</p><ol start="3"><li>检查Mark Word中的Thread Id。若为当前线程ID说明当前线程已经获取锁，不需要再获取锁，而是往自己的线程栈中添加一条Displaced Mark Word为空的Lock Record，用于重入统计。</li></ol><blockquote><p>偏向锁的释放与偏向锁的撤销：</p><p>偏向锁的释放：</p><ul><li>时机：退出同步代码块</li><li>操作：删除线程栈中的Lock Word（不会修改对象头中的锁状态）</li></ul><p>偏向锁的撤销：</p><ul><li>时机：发生锁竞争</li><li>操作：锁升级或者重偏向</li></ul></blockquote><ol start="4"><li>若Mark Word中的Thread Id不是当前线程ID，则进行CAS操作替换Thread Id。若当前对象锁处于匿名偏向状态（Thread Id为0，无锁可偏向）CAS会成功，则获取锁，并插入Lock Word到当前线程栈，执行同步代码块</li></ol><p>锁撤销逻辑：</p><ol start="5"><li>若CAS失败，说明对象锁已经被其他线程占用，进入偏向锁撤销逻辑。</li><li>等到全局安全点，暂停持有对象锁的线程，检测其状态，若其存活且在执行同步块代码，则将锁升级为轻量级锁。</li><li>若线线程未存活或者存活但未执行同步块代码。若开启重偏向，则将锁置为匿名偏向状态然后CAS获取偏向锁，若没开启重偏向，将锁置为无锁状态，然后升级为轻量级锁。</li><li>最后唤醒暂停的线程，从安全点继续执行代码</li></ol><h4 id="批量重偏向与批量撤销"><a href="#批量重偏向与批量撤销" class="headerlink" title="批量重偏向与批量撤销"></a>批量重偏向与批量撤销</h4><p>为什么有该机制：</p><blockquote><p>在出现锁竞争，即执行锁撤销逻辑的时候，需要暂停线程，并等到safe point，再撤销锁或升级锁，会消耗一定性能。若多线程竞争频繁，那么偏向锁不会提高性能，反而导致性能下降。</p></blockquote><p>解决的场景：</p><blockquote><p> 批量重偏向机制：一个线程创建大量对象，并执行了初始的同步操作，后面另一个线程也将这些对象作为锁对象进行操作，这样就会导致大量的锁撤销操作</p><p>批量撤销机制：再多线程竞争激烈的场景下竞争使用偏向锁</p></blockquote><p>原理：</p><blockquote><p>偏向锁撤销计数器：以class为单位，为每个class维护一个偏向锁撤销计数器，每次次该class的对象发生偏向撤销操作，该计数器+1</p><p>当计数器达到批量重偏向阈值（20）：</p><blockquote><p>epoch字段：</p><p>每个class对象会有一个epoch字段（可以理解为第几代偏向锁），处于偏向锁状态的对象的Mark Word中也有该字段，初始值为创建该对象时class中的epoch值。</p><p>批量重偏向操作：</p><p>将class中的epoch值+1（表示之前那一代的偏向锁失效）</p><p>被线程持有的该class类的锁对象，将其epoch值+1（保证已加锁的线程继续持有锁）（该操作需要等到全局安全点）</p><p>已经被线程释放的锁对象，其epoch值没有更新，其他线程去申请锁时，发现对象锁的epoch值与class中的epoch值不一致，则会进行自动重偏向（即不会进行锁撤销，而是直接通过CAS将其MarkWord中的Thread Id改为当前线程）</p></blockquote><p>当计数器达到批量撤销阈值（40）：</p><blockquote><p>直接标记该class为不可偏向，之后该class的锁直接走轻量级锁的逻辑</p></blockquote></blockquote><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><ol><li><p>复制Mark Word。</p><blockquote><p>线程再执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称之为<strong>Displaced Mark Word</strong>。</p></blockquote></li><li><p>CAS替换Mark Word。</p><blockquote><p>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获取锁。</p></blockquote></li><li><p>自旋获取锁。</p><blockquote><p>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</p></blockquote></li></ol><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>使用CAS操作将Displaced Mark Word替换回对象头</p><ul><li>成功：说明没有竞争发生</li><li>失败：说明当前锁存在竞争，锁回膨胀为重量级锁</li></ul><h3 id="锁比较"><a href="#锁比较" class="headerlink" title="锁比较"></a>锁比较</h3><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16315cb91da523d9tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="各种锁的对比"></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="volatile简介"><a href="#volatile简介" class="headerlink" title="volatile简介"></a>volatile简介</h2><blockquote><p>被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p></blockquote><p>synchronized是阻塞式同步，在线程竞争激烈的情况下回升级成重量级锁，会执行线程的挂起和唤醒操作。而volatile就可以说是JVM提供的<strong>最轻量级</strong>的同步机制。</p><h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><blockquote><p>在生成汇编代码的时候会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀指令</strong></p></blockquote><h3 id="Lock前缀指令对多核处理器产生的影响"><a href="#Lock前缀指令对多核处理器产生的影响" class="headerlink" title="Lock前缀指令对多核处理器产生的影响"></a>Lock前缀指令对多核处理器产生的影响</h3><ul><li>将当前CPU核心缓存行的数据写回系统内存</li><li>使其他CPU核心内缓存了该内存地址的数据无效</li></ul><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>缓存一致性协议的意义：</p><blockquote><p>一个CPU核心将更新后的数据写回系统内存，但是其他核心中的数据还是旧的，若使用旧值执行计算就会有问题，缓存一致性协议能够保证个个CPU核心中的缓存是一致的。</p></blockquote><p>缓存一致性协议的实现：</p><blockquote><p> 每个核心通过嗅探总线上传播的数据来检查自己缓存的数据是否已经过期。若核心发现缓存行对应的内存地址上数据发生修改，就会将对应缓存行设置为无效状态，当核心需要该数据时，会重新从系统内存中加载数据。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Lock前缀指令会引起处理器缓存写回内存</li><li>一个处理器的缓存写回内存会导致其他处理器中的缓存失效</li><li>处理器读取变量数据，发现本地缓存失效，会从内存中读取最新值</li></ul><h2 id="volatile的happens-before关系"><a href="#volatile的happens-before关系" class="headerlink" title="volatile的happens-before关系"></a>volatile的happens-before关系</h2><h3 id="并发分析的切入点"><a href="#并发分析的切入点" class="headerlink" title="并发分析的切入点"></a>并发分析的切入点</h3><h4 id="两个核心："><a href="#两个核心：" class="headerlink" title="两个核心："></a>两个核心：</h4><ul><li>JMM内存模型</li><li>happens-before</li></ul><h4 id="三大性质："><a href="#三大性质：" class="headerlink" title="三大性质："></a>三大性质：</h4><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="volatile的happens-befores规则"><a href="#volatile的happens-befores规则" class="headerlink" title="volatile的happens-befores规则"></a>volatile的happens-befores规则</h3><blockquote><p>对一个volatile域的写，happens-befors于任意后续对这个volatile域的读</p></blockquote><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span>&#123;<br>        a = <span class="hljs-number">1</span>;          <span class="hljs-comment">//1</span><br>        flag = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//2</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(flag)&#123;      <span class="hljs-comment">//3</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">//4</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码实例的happens-before关系图：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796b904658tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="VolatileExample的happens-before关系推导"></p><p>happens-before分析：</p><p>加锁线程A先执行writer方法，然后线程B执行reader方法。</p><p>黑色箭头：程序顺序规则</p><p>红色箭头：volatile读写顺序规则</p><p>蓝色箭头：传递性规则</p><p>线程A happen-before 线程B，操作2 happensbefore 操作3，所以在线程A中的操作flag &#x3D; true可以马上被线程B感知，并且根据传递性规则，操作1 happens-before操作4，保证线程A对a的修改可以被线程B感知。</p><h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>还是针对上述代码进行分析，假设线程A执行writer方法，线程B随后执行reader方法，初始线程flag和a为初始状态。</p><p>线程A执行volatile写后的状态图：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796b8acbd7tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="线程A执行volatile写后的内存状态图"></p><p>线程B读取volatile变量的内存变化：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796bd467fbtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="线程B读volatile后的内存状态图"></p><p>从横向看，线程A和线程B之间进行了依次通信，线程A在写volatile变量时，就像是给线程B发送了一个消息，告诉线程B它对应的变量过期了，线程B得知自己的变量过期了，那么线程B需要读取变量的时候就去主存中加载最新值。</p><h2 id="volatile的内存语义实现"><a href="#volatile的内存语义实现" class="headerlink" title="volatile的内存语义实现"></a>volatile的内存语义实现</h2><blockquote><p>为了性能优化，在不改变正确语义的前提下，允许编译器和处理器的指令重排序，为了实现volatile的内存语义，就需要禁止一些重排序。通过添加<strong>内存屏障</strong>实现</p></blockquote><p>内存屏障分类：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e1471c0tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="内存屏障分类表"></p><p>JMM针对编译器制定的volatile重排序规则表：</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e2f06datplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="volatile重排序规则表"></p><p>对于上述规则的简述：</p><ul><li>禁止volatile读后的任何操作与之重排序</li><li>禁止volatile写前的任何操作与之重排序</li><li>禁止volatile写于volatile读重排序</li></ul><p>JMM实现上述规则采用的内存屏障策略：</p><ul><li>对于volatile写<ul><li>写前插入StoreSore屏障</li><li>写后插入StoreLoad屏障</li></ul></li><li>对于volatile读<ul><li>读后插入LoadLoad屏障</li><li>读后插入LoadLoad屏障</li></ul></li></ul><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e796e03b351tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320e799b76d34ctplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="final的具体使用场景"><a href="#final的具体使用场景" class="headerlink" title="final的具体使用场景"></a>final的具体使用场景</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h4><p>每个类的成员变量可以分为<strong>类变量、实例变量</strong>。</p><p>final变量必须初始化，系统不会进行隐式初始化。</p><p>成员变量的赋初值时机：</p><ul><li>类变量：<ul><li>在声明的时候直接赋初值</li><li>在静态代码块中给类变量赋初值</li></ul></li><li>实例变量：<ul><li>声明变量的时候给实例变量赋初值</li><li>在非静态代码块中赋初值</li><li>在构造器中赋初值</li></ul></li></ul><h4 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h4><p>final局部变量在方法中定义，<strong>形参或者方法体内</strong></p><p>若final变量未在定义的时候初始化，可以在方法体内有一次赋值机会，赋值之后再次赋值就会出错。</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320f7dbcfd83a2tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><h4 id="final基本数据类型-VS-final引用数据类型"><a href="#final基本数据类型-VS-final引用数据类型" class="headerlink" title="final基本数据类型 VS final引用数据类型"></a>final基本数据类型 VS final引用数据类型</h4><p>final保证其修饰的变量有且只有一次赋值机会，赋值过后不会再该改变。</p><p>基本数据类型：</p><p>变量保存的是数据本身，所以数据不能修改。</p><p>引用数据类型：</p><p>变量保存的是对象的引用，就是说这个变量保存的应用不能变，即变量只能指向该对象，不能指向其他对象。但是对象本身的属性是可以改变的。</p><h4 id="宏变量"><a href="#宏变量" class="headerlink" title="宏变量"></a>宏变量</h4><blockquote><p>宏变量即常量，在程序中使用到宏变量的地方，编译器会直接将宏变量替换未该变量的字面值</p></blockquote><p>成为宏变量需要满足的三个条件：</p><ul><li>使用final修饰符修饰</li><li>在定义变量的时候就指定了初始值</li><li>该初始值在编译时就能唯一确定</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>被final修饰的方法不能够被子类重写</p></li><li><p>被final修饰的方可以重载</p></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>当一个类被final修饰的时候，表示该类时不能被子类继承的。</p><p>子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此当一个类希望不被继承的时候就可以使用final修饰。</p><h3 id="final使用的例子"><a href="#final使用的例子" class="headerlink" title="final使用的例子"></a>final使用的例子</h3><h4 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h4><p>定义：</p><p>不变类的意思时创建该类的实例后，该实例的实例变量时不可改变的。</p><p>成为不变类需要满足的条件：</p><ul><li>使用private和final修饰符修饰该类的成员变量</li><li>提供带参的构造器用于初始化类的成员变量</li><li>仅为该类的成员变量提供getter方法，不提供setter方法</li><li>有必要的话重写hashCode()和equals()方法，保证用equals判断相同的两个对象其Hashcode值也是相等的</li></ul><h4 id="JDK中提供的不变类"><a href="#JDK中提供的不变类" class="headerlink" title="JDK中提供的不变类"></a>JDK中提供的不变类</h4><p>String类、八个包装类 </p><h2 id="多线程中的final域重排序"><a href="#多线程中的final域重排序" class="headerlink" title="多线程中的final域重排序"></a>多线程中的final域重排序</h2><h3 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h3><h4 id="写final域重排序规则"><a href="#写final域重排序规则" class="headerlink" title="写final域重排序规则"></a>写final域重排序规则</h4><blockquote><p> 禁止对final域的写重排序到构造函数之外。</p></blockquote><p>实现：</p><ul><li>对于编译器：JMM禁止编译器把final域的写重排序到构造函数之外</li><li>对于处理器：编译器在final域写之后，构造函数return之前，插入一个storestore屏障。该屏障可以禁止处理器把final域的写重排序到构造函数之外</li></ul><p>该规则确保：</p><p>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具备这个保证。</p><h4 id="读final域重排序规则"><a href="#读final域重排序规则" class="headerlink" title="读final域重排序规则"></a>读final域重排序规则</h4><blockquote><p> 在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。（这个规则针对处理器）</p></blockquote><p>实现：</p><p>编译器在读final域操作前插入LoadLoad屏障。（实际上，读对象的引用和对该对象的final域存在简介依赖性，一般处理不会重排序这两个操作，但是有些处理器会，这个禁止重排序规则就是针对这些处理器而设定的）</p><p>该规则确保：</p><p>在读一个对象的final域之前，一定会先读这个包含final域的对象的引用</p><h3 id="final域为引用类"><a href="#final域为引用类" class="headerlink" title="final域为引用类"></a>final域为引用类</h3><h4 id="对final修饰的成员域写操作"><a href="#对final修饰的成员域写操作" class="headerlink" title="对final修饰的成员域写操作"></a>对final修饰的成员域写操作</h4><blockquote><p>在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作不能重排序</p></blockquote><h4 id="对final修饰的对象的成员域读操作"><a href="#对final修饰的对象的成员域读操作" class="headerlink" title="对final修饰的对象的成员域读操作"></a>对final修饰的对象的成员域读操作</h4><p>JMM不保证单独对final修饰对象的成员域的修改，与读取final修饰对象的成员域之间的重排序</p><h2 id="final的实现原理"><a href="#final的实现原理" class="headerlink" title="final的实现原理"></a>final的实现原理</h2><ul><li>final域写后插入StoreStore屏障</li><li>final域读前插入LoadLoad屏障</li></ul><h2 id="为什么final引用不能从构造函数中“逸出”"><a href="#为什么final引用不能从构造函数中“逸出”" class="headerlink" title="为什么final引用不能从构造函数中“逸出”"></a>为什么final引用不能从构造函数中“逸出”</h2><p>final域写重排序规则确保在使用一个对象引用的时候该对象的final域已经在构造函数中被初始化过了。</p><p>但是这儿其实有一个前提条件：</p><p>在构造函数结束之前，不能让这个被构造的对象被其他线程可件，也就是说该对象引用不能再构造函数中“逸出”</p><p>逸出的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalReferenceEscapeDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> FinalReferenceEscapeDemo referenceDemo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalReferenceEscapeDemo</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>;  <span class="hljs-comment">//1</span><br>        referenceDemo = <span class="hljs-built_in">this</span>; <span class="hljs-comment">//2</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalReferenceEscapeDemo</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (referenceDemo != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//3</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> referenceDemo.a; <span class="hljs-comment">//4</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程A执行writer方法，线程B执行reader方法</p><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/16320f7de16b0ec0tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="final域引用可能的执行时序"></p><p>在线程A中操作1和操作2没有依赖关系，所以操作2可以排在操作1前（操作2是让自己引用自己），这样在构造函数还没结束的时候，线程B已经拿到了构造的对象，但是这个对象还没有构造完成（构造函数还没有结束），此时线程B读final域会读到还未初始化的final域值。</p><h1 id="三大性质"><a href="#三大性质" class="headerlink" title="三大性质"></a>三大性质</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote><p>一个操作时不可中断的，要么全部执行成功，要么全部执行失败，有着“同生共死”的感觉</p></blockquote><h3 id="JMM中的8个原子操作"><a href="#JMM中的8个原子操作" class="headerlink" title="JMM中的8个原子操作"></a>JMM中的8个原子操作</h3><ul><li>lock</li><li>unlock</li><li>read</li><li>load</li><li>use</li><li>assign</li><li>store</li><li>write</li></ul><h3 id="JVM提供的原子性保证："><a href="#JVM提供的原子性保证：" class="headerlink" title="JVM提供的原子性保证："></a>JVM提供的原子性保证：</h3><ul><li><p>基本数据类型的访问读写具有原子性（除了long和double）</p><blockquote><p>原子性变量操作 read、load、use、assign、store、write</p></blockquote></li><li><p>synchronized满足原子性</p><blockquote><p>lock和unlock虽然没有开放使用，但是反映到JVM则是以monitorenter和monitorexit指令开放使用，反映到Java代码中则是synchronized关键字</p></blockquote></li><li><p>volatile不能保证原子性</p><blockquote><p>若要让volatile保证原子性需要符合两条规则</p><ul><li>运算结果不依赖于变量的当前值，或者确保只有一个线程修改便变量的值</li><li>变量不需要域其他的状态变量共同参与不变约束</li></ul></blockquote></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>锁被占用后其他线程只能等待，所以synchronized具有有序性</p></blockquote><h3 id="volatile-1"><a href="#volatile-1" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>volatile包含禁止指令重排序的语义，器具有有序性</p></blockquote><h4 id="Java程序的天然有序性可以总结为："><a href="#Java程序的天然有序性可以总结为：" class="headerlink" title="Java程序的天然有序性可以总结为："></a>Java程序的天然有序性可以总结为：</h4><p>如过在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。即as-if-serial语义。</p><h4 id="DCL（双重检查锁定-Double-Checked-Locking）例子："><a href="#DCL（双重检查锁定-Double-Checked-Locking）例子：" class="headerlink" title="DCL（双重检查锁定 Double-Checked Locking）例子："></a>DCL（双重检查锁定 Double-Checked Locking）例子：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-keyword">public</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重点在于为什么对instance加volatile</strong></p><blockquote><p>instance &#x3D; new Singleton();</p><p>该语句实际包含三个操作：</p><ol><li><p>分配对象的内存空间</p></li><li><p>初始化对象</p></li><li><p>设置instance指向刚分配的内存地址</p></li></ol></blockquote><p>重排序带来的问题：</p><p>重排序可能会导致操作3发生在操作2之前，即对象还没有初始化，instance对象的引用已经可以获取。相当于其他线程可能会拿到还没有初始化完成的instance对象的引用。</p><p>volatile解决：</p><p>使用volatile修饰instance对象，可以禁止2和3的重排序，避免上述问题。</p><ul><li><p>1、2、3操作在单线程中要满足as-if-serial语义</p></li><li><p>为volatile变量instance赋值happens-before读instance变量</p></li><li><p>传递性原则可以推导出，在对instance的初始化发生于对instance对象的访问前</p></li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>synchronized锁释放会将共享变量写回主内存，锁获取会从主内存获取共享变量的最新值。</p><p>volatile变量的读写都会立即更新</p><p>所以说synchronized和volatile都具有见性</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>synchronized：具有原子性、有序性和可见性</li><li>volatile：具有有序性和可见性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-Java内存模型</title>
    <link href="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>线程不安全：</p><blockquote><p>在多线程中代码执行的结果与预期正确的结果不一致，那么这个线程就是线程不安全的</p></blockquote><p>线程安全：</p><blockquote><p>当多个线程访问同一个对象时，如果：</p><ul><li><p>不用考虑这些线程在运行时环境下的调度和交替运行</p></li><li><p>不需要进行额外的同步</p></li><li><p>不需要在调用方进行任何其他的协调操作</p></li></ul><p>调用这个对象的行为都可以获取正确的结果，那么这个对象是线程安全的</p></blockquote><h2 id="出现线程不安全的原因"><a href="#出现线程不安全的原因" class="headerlink" title="出现线程不安全的原因"></a>出现线程不安全的原因</h2><ul><li><p>主内存和工作内存数据不一致</p><blockquote><p>多线程通信</p></blockquote></li><li><p>重排序</p><blockquote><p>性能优化：编译器和处理器指令重排序</p></blockquote></li></ul><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="关于并发编程"><a href="#关于并发编程" class="headerlink" title="关于并发编程"></a>关于并发编程</h2><h3 id="并发编程需要解决的两个问题："><a href="#并发编程需要解决的两个问题：" class="headerlink" title="并发编程需要解决的两个问题："></a>并发编程需要解决的两个问题：</h3><ol><li><p>线程之间如何通信</p><ul><li><p>消息传递</p></li><li><p>共享内存</p></li></ul></li><li><p>线程之间如何同步</p></li></ol><h3 id="Java内存模型是共享内存的并发模型"><a href="#Java内存模型是共享内存的并发模型" class="headerlink" title="Java内存模型是共享内存的并发模型"></a>Java内存模型是<strong>共享内存</strong>的并发模型</h3><blockquote><p>线程之间主要通过读-写共享变量来完成隐式通信</p><p>共享变量：（堆内存数据）</p><ul><li>实例域</li><li>静态域</li><li>数组元素</li></ul><p>局部变量：（栈内存数据）</p><ul><li>方法定义参数</li><li>异常处理参数</li></ul></blockquote><h2 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h2><p>为什么会有内存模型：</p><blockquote><p>CPU和主存的读写速度不在一个数量级别，所以CPU有多级缓存，用于平衡这种差距，内存模型用于抽象这种模式</p></blockquote><p>内存模型的工作方式：</p><blockquote><p>共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且把位于主存中的共享变量拷贝到自己的工作内存中，之后线程对共享变量的而读写均作用于该副本，并在某个时刻将修改过的副本写回主存</p></blockquote><p>内存模型的任务：</p><blockquote><p>JMM决定了一个线程对共享变量的写入何时对其他线程可见（何时将工作内存中修改的副本写回主内存）</p></blockquote><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b2410a9e3ebtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p>Java内存模型下的线程通信：</p><blockquote><p>A线程和B线程的通信过程：</p><ol><li>线程A从主内存中将共享变量读入线程A的工作内存，并对其进行修改，修改过后将数据重新写回主内存中覆盖旧数据</li><li>线程B从主内存中读取最新的共享变量</li></ol><p>可能遇见的问题:</p><ul><li>“脏读”现象：线程A修改数据后还没有写回主内存，此时线程B读到的是过期的数据</li></ul><p>如何解决脏读：</p><ul><li>同步机制：通过同步机制控制不同线程操作发生的相对顺序来保证读写的顺序</li><li>volatile关键字：使用volatile关键字强制刷新到主内存，使得每次对volatile变量的修改立即对每个线程可见</li></ul></blockquote><h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><h2 id="重排序简介"><a href="#重排序简介" class="headerlink" title="重排序简介"></a>重排序简介</h2><p>重排序的目的：</p><blockquote><p>一个好的内存模型要放松对处理器和编译器队则的束缚。</p><p>软件和硬件的共同目标：在不改变程序执行结果的前提下，尽可能提高并行度</p></blockquote><p>重排序分类：</p><ul><li><p>编译器重排序</p><blockquote><p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序</p></blockquote></li><li><p>处理器重排序</p><ul><li><p>指令级并行重排序</p><blockquote><p>现代处理器采用指令级并行技术将多条指令重叠执行。</p><p>如果<strong>不存在数据依赖性</strong>，处理器可以改变语句对应机器指令的执行顺序</p></blockquote></li><li><p>内存系统重排序</p><blockquote><p>由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去是乱序执行</p></blockquote></li></ul></li></ul><p>针对重排序JMM做了什么：</p><ul><li><p>针对编译器重排序</p><blockquote><p>禁止一些特定类型的编译器重排序：</p><p>JMM的编译器重排序规则会禁止一些特定类型的编译器重排序</p></blockquote></li><li><p>针对处理器重排序</p><blockquote><p>内存屏障指令：</p><p>编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序</p></blockquote></li></ul><h2 id="重排序规则"><a href="#重排序规则" class="headerlink" title="重排序规则"></a>重排序规则</h2><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p>as-if-serial语义：</p><blockquote><p>对于程序员来说单线程程序是按照顺序执行的</p></blockquote><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before语义：</p><blockquote><p>一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</p></blockquote><p>八项规则：</p><ol><li><p>程序顺序规则（as-if-serial）</p><blockquote><p>一个线程中的每个操作，happens-before于该线程中的任意后续操作</p></blockquote></li><li><p>监视器锁规则</p><blockquote><p>对一个锁的解锁，happens-before于随后对于这个锁的加锁</p></blockquote></li><li><p>volatile变量规则</p><blockquote><p>对于一个volatile域的写，happens-befors于任意后续对这个volatile域的读</p></blockquote></li><li><p>传递性</p><blockquote><p>若A happens-before B，B happens-before C，那么A happens-before C</p></blockquote></li><li><p>start()规则</p><blockquote><p>如果A线程启动线程B，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作</p></blockquote></li><li><p>join()规则</p><blockquote><p>如果线程A执行ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作返回</p></blockquote></li><li><p>程序中断规则</p><blockquote><p>对线程的interrupted()方法的调用先行于被中断函数的代码检测到中断时间的发生</p></blockquote></li><li><p>对象finalize规则</p><blockquote><p>一个对象的初始化完成（构造函数执行结束）先于发生它的finalize()方法的执行</p></blockquote></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h2><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b3505fe3170tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="JMM层级图"></p><p>JMM是语言级的内存模型，JMM处于中间层：</p><p>向上面向程序员：</p><ul><li>提供基于JMM的关键字和J.U.C包下的一些具体类方便程序员进行并发编程</li><li>happens-before语义为程序员提供易于理解、易于编程的内存模型</li></ul><p>向下面向编译器和处理器：</p><ul><li><p>禁止编译器特定重排序，处理器内存屏障指令，实现happens-before语义</p></li><li><p>允许不改变程序执行结果的优化</p><blockquote><ul><li>允许不改变happens-before语义的重排序</li><li>编译器分析一个锁只会被单个线程访问，可以消除锁</li><li>编译器分析一个volatile变量只会被单个线程访问，编译器将其作为普通变量处理</li></ul></blockquote></li></ul><h2 id="happens-before与JMM的关系"><a href="#happens-before与JMM的关系" class="headerlink" title="happens-before与JMM的关系"></a>happens-before与JMM的关系</h2><p><img src="/2022/10/14/Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16315b4732a0ed2ctplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="happens-before与JMM的关系"></p><ul><li><p>一个happens-before规则对应一个或多个编译器和处理器重排序规则。</p></li><li><p>对于Java程序员来说，只需要根据happens-before规则进行多线程编程即可</p></li><li><p>JMM为程序员提供内存可见性保证，以及实现复杂的重排序规则</p></li></ul><h2 id="后续可能需要关注的问题"><a href="#后续可能需要关注的问题" class="headerlink" title="后续可能需要关注的问题"></a>后续可能需要关注的问题</h2><ul><li>可见性问题：数据“脏读”现象</li><li>有序性问题：DCL（双重检查锁）问题，需要使用volatile禁止重排序</li><li>原子性问题：i++，可能跟出现线程安全问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发-并发基础</title>
    <link href="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="并发缺点"><a href="#并发缺点" class="headerlink" title="并发缺点"></a>并发缺点</h2><h3 id="1-频繁的上下文切换"><a href="#1-频繁的上下文切换" class="headerlink" title="1. 频繁的上下文切换"></a>1. 频繁的上下文切换</h3><h4 id="为什么会有频繁的多线程切换："><a href="#为什么会有频繁的多线程切换：" class="headerlink" title="为什么会有频繁的多线程切换："></a>为什么会有频繁的多线程切换：</h4><ul><li><p>真多线程：多核CPU，每个线程在不同的CPU上执行</p></li><li><p>宏观多线程：CPU分配给每个线程一定的时间片，CPU通过不断切换线程，宏观上就是多个线程同时执行</p><blockquote><p>每次切换线程需要保存线程当前状态，加载下一个线程之前保存的状态，这就是上下文切换，每个线程执行的时间很短，所以说上下文切换就很频繁。</p></blockquote></li></ul><h4 id="减少上下文切换的方法："><a href="#减少上下文切换的方法：" class="headerlink" title="减少上下文切换的方法："></a>减少上下文切换的方法：</h4><ul><li><p>无锁并发编程</p><blockquote><p>参考concurrentHashMap锁分段思想，减少多线程竞争</p></blockquote></li><li><p>CAS算法</p><blockquote><p>使用乐观锁，减少锁竞争带来的上下文切换</p></blockquote></li><li><p>使用最少线程</p><blockquote><p>避免创建不必要的线程</p></blockquote></li><li><p>协程</p><blockquote><p>在单线程中实现多任务调度</p></blockquote></li></ul><h3 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2. 线程安全问题"></a>2. 线程安全问题</h3><h4 id="线程安全问题：死锁"><a href="#线程安全问题：死锁" class="headerlink" title="线程安全问题：死锁"></a>线程安全问题：死锁</h4><h5 id="如何避免死锁："><a href="#如何避免死锁：" class="headerlink" title="如何避免死锁："></a>如何避免死锁：</h5><ul><li>避免一个线程获得多个锁&#x2F;多个资源</li><li>使用定时锁</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则可能会解锁失败</li></ul><h4 id="JMM内存模型中的问题"><a href="#JMM内存模型中的问题" class="headerlink" title="JMM内存模型中的问题"></a>JMM内存模型中的问题</h4><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步和异步通常用来形容一次方法调用。</p><ul><li>同步方法：调用者必须等待同步方法结束后，才会执行后面的代码。</li><li>异步方法：调用者调用方法后会直接继续执行后续代码，被调用的代码执行完毕后会通知调用者</li></ul><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li>并发：一个CPU核心分时执行多个线程</li><li>并行：多个CPU核心同时分别执行一个线程</li></ul><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><ul><li>阻塞：若一个线程占有了临界区的资源，其他线程若要访问，那么就需要等待这个线程释放该资源，会导致等待的线程挂起，这就叫阻塞</li><li>非阻塞：强调没有线程可以阻塞其他线程，所有线程都会尝试地往前运行</li></ul><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用，但是同一时刻只能由一个线程占有</p><h2 id="线程状态转换及其基本操作"><a href="#线程状态转换及其基本操作" class="headerlink" title="线程状态转换及其基本操作"></a>线程状态转换及其基本操作</h2><h3 id="1-新建线程"><a href="#1-新建线程" class="headerlink" title="1. 新建线程"></a>1. 新建线程</h3><blockquote><p>Java程序天生就是多线程的，包含：</p><ol><li>分发处理发送个JVM信号的线程</li><li>调用对象finalize方法的线程</li><li>清除Reference的线程</li><li>main线程，用户线程的入口</li></ol></blockquote><ul><li><p>方法一、继承Thread类，重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        Sytem.out.println(<span class="hljs-string">&quot;通过继承Thread&quot;</span>)<br>        <span class="hljs-built_in">super</span>.run();<br>    &#125;<br>&#125;;<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p>方法二、实现runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;通过实现runnable接口&quot;</span>)<br>    &#125;<br>&#125;);<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p>方法三、实现callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecuterService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;String&gt; future = service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>()&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;通过实现Callable接口&quot;</span><br>    &#125;<br>&#125;);<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get();<br>    System.out.println(result);<br>&#125;<span class="hljs-keyword">catch</span>(Exception)&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意事项：</strong></p><ul><li><p>优先考虑通过实现接口创建线程（Java只能单一继承）</p></li><li><p>可以将callable包装成FutureTask</p><blockquote><p>FutureTask同时实现Future接口和Runnable接口，所以将FutureTask提交给ExecutorService执行后，可以直接从FutureTask获取异步结果</p><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159b250b111f7tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p></blockquote></li><li><p>可以将runnable包装成callable</p><blockquote><p>runnable执行不会返回结果，callable执行后会返回结果</p></blockquote></li></ul><h3 id="2-线程状态转换"><a href="#2-线程状态转换" class="headerlink" title="2. 线程状态转换"></a>2. 线程状态转换</h3><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159b8a740b329tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><p>六个状态：</p><ul><li><p>NEW</p><blockquote><p>线程创建后即为NEW状态</p></blockquote></li><li><p>RUNNABLE</p><blockquote><p>线程执行start()过后进入RUNNABLE状态，此时线程由系统调度分配时间片，线程也可以使用yeild()主动放弃时间片</p><p>使用Object.notify()或Object.notifyAll()方法可以将WAITING和TIME_WAITING状态的线程切换至RUNNABLE状态</p></blockquote></li><li><p>BLOCKED</p><blockquote><p>当线程出现资源竞争，即进入synchronized方法或代码块时需要获取锁，若没有获取锁则进入阻塞状态</p></blockquote></li><li><p>WAITING</p><blockquote><ul><li><p>调用锁对象的wait()、join ()方法</p></li><li><p>LockSupport.lock()</p></li><li><p>调用juc包中的锁对象进行加锁（因为其底层调用的是LockSupport的方法）</p></li></ul></blockquote></li><li><p>TIME_WAITING</p><blockquote><ul><li>wait(long)</li><li>sleep(long)</li><li>join(long)</li><li>LockSupport.parkNanos()</li><li>LockSupport.parkUtil()</li></ul></blockquote></li><li><p>TERMINATID</p></li></ul><h3 id="3-线程的基本操作"><a href="#3-线程的基本操作" class="headerlink" title="3. 线程的基本操作"></a>3. 线程的基本操作</h3><ol><li><p>interrupted</p><blockquote><p>中断可以理解为线程的一个标志位，它表示一个运行中的线程是否被其他线程执行了中断操作。</p><ul><li><p>其他线程可以通过interrupt()方法打断某线程</p></li><li><p>线程可以在线程内部调用isInterrupted()来感知是否被其他线程中断</p></li><li><p>Thread的静态方法可以对档期那线程进行中断操作，同时该操作会清除中断标志位</p></li></ul></blockquote><p><img src="/2022/10/13/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/163159c1a4cc499dtplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="img"></p><blockquote><p>中断可以看作是线程间的一种简便的交互方式。在结束线程时通过中断标志位，使线程由机会清理资源，相较于直接结束线程，这种方式更加优雅和安全。</p></blockquote></li><li><p>join</p><blockquote><p>join方法可以看作是线程间协作的一种方式。</p><p>A执行threadB.join()语义：表示线程A需要等待另线程B执行完毕后才能继续执行</p></blockquote></li><li><p>sleep</p><blockquote><p>方法签名：public static native void sleep(long millis)</p><p>由上可看出sleep时Thread的静态方法，本地实现，让当前线程睡眠指定时间</p></blockquote><p>sleep()与wait()区别：</p><ul><li>sleep()是Thread的静态方法，而wait()是Object的实例方法</li><li>wait必须要在同步方法或同步方法块中调用，即调用前该线程必须已经获得对象锁。sleep没有限制</li><li>wait会释放CPU资源和线程占有的对象锁，使得该线程进入该对象锁的等待队列。sleep只会释放CPU资源，不会释放对象锁</li><li>sleep休眠固定时间后唤醒，等待CPU时间片。wait等待对象锁notify唤醒后离开等待队列，等待CPU时间片</li></ul></li><li><p>yield</p><blockquote><p>方法签名：public static native void yield()</p><p>yield是Thread的静态方法</p><ul><li>当前线程主动让出CPU时间片</li><li>让出的时间片只会分配给与当前线程优先级相同的线程</li><li>当前线程让出CPU时间片后还会参与CPU时间片的竞争</li></ul></blockquote></li></ol><h3 id="4-守护线程Daemon"><a href="#4-守护线程Daemon" class="headerlink" title="4. 守护线程Daemon"></a>4. 守护线程Daemon</h3><blockquote><p>守护线程：守护线程是在后台默默守护一些系统服务，比如垃圾回收线程、JIT线程</p><p>用户线程：用户线程就是系统的工作线程，完成整个系统的业务操作</p></blockquote><ul><li><p>用户线程代表整个系统的业务任务全部完成，因此系统没有对象需要守护，守护线程自然也就结束。</p></li><li><p>当一个Java应用中只剩下守护线程的时候，虚拟机就会退出。</p></li><li><p>守护线程不会执行finnaly块中的代码</p></li><li><p>在线程调用start()前对调用setDaemon (true)将线程设置为守护线程</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鼎桥面试预习</title>
    <link href="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/"/>
    <url>/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>A</p><ol><li><p>TCP和UDP的区别 </p><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>可靠性</td><td>不可靠传输</td><td>可靠传输，流量控制和拥塞控制</td></tr><tr><td>连接对象数量</td><td>一对N，N对一，多对多</td><td>只能一对一</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>小，8字节</td><td>大，20-60字节</td></tr><tr><td>使用场景</td><td>实时应用：IP电话、视频会议、直播</td><td>要求可靠传输的应用：文件传输</td></tr></tbody></table><ul><li>TCP（可靠性：文件下载，查看网页，邮件）<ul><li>面向连接：三次握手，四次挥手</li><li>仅支持单播传输</li><li>面向字节流：TCP对于来自应用层的报文可能会拆分后分别加上TCP头传输</li><li>可靠传输：TCP段编码和确认号可以进行<strong>丢包判断</strong>，和保证包的<strong>按序接收</strong></li><li>拥塞控制</li><li>全双工通信：TCP允许通信双方的应用程序在任何时候都能发数据，且双方都有缓存，TCP可以立即发送报文，也可以缓存后一次发送多个报文。</li></ul></li><li>UDP（实时性：电话会议）<ul><li>面向<strong>无连接</strong>：UDP只会在收发数据的时候增加或去除一个协议头</li><li><strong>面向报文</strong>：UDP对应用层发送来的报文不做处理，保留边界（不合并，不拆分）。所以应用程序必须自己选择合适大小的报文。</li><li><strong>单播、多播和广播</strong>功能</li><li><strong>不可靠</strong>性：UDP不管发送的数据是否被接收到；UDP没有拥塞控制，发送速度取决于上层，在网络拥堵的时候会丢包，但是在实时性要求高的场景需要使用UDP</li><li>头部小，效率高</li></ul></li></ul></li><li><p>UDP不可靠，为什么还要用UDP</p><ul><li>UDP头部开销小，无连接的特性使其传输效率高</li><li>实时性应用更关心数据的实时性，可以牺牲一定的可靠性</li></ul></li><li><p>UDP采取什么措施来提高正确率</p><ul><li>有两字节的检验和，用于判断数据在传输中是否出错，有错就丢弃</li></ul></li></ol><p>B</p><ol><li><p>Zoo<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>er的原理有了解吗？为什么要用Zoo<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>er做服务注册</p></li><li><p>Http和Https的区别，证书有什么用？</p><ul><li><p>HTTPS可以理解位HTTP + SSL&#x2F;TLS</p></li><li><p>TLS的前身是SSL：SSl协议位于TCP和各种应用层协议之间，为数据传输提供安全支持</p></li><li><p>数字证书：CA使用自己的私钥将服务器公钥进行加密生成数字签名，然后将（公钥信息+公钥+数字签名）打包成数字证书。服务器在发送内容时，使用私钥对内容进行签名，连同证书一起发给客户端，客户端拿到（私钥加密的内容+数字证书）后，向CA请求数字证书真伪，然后CA使用私钥解密，将公钥发送给客户端。</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程"></p></li></ul></li><li><p>Http的传输协议是什么？</p><ul><li>TCP</li></ul></li><li><p>MySQL 插入一条<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>，会直接更新到磁盘中吗？（change pool）</p><p>不会，WAL技术（Write-Ahead Logging）先写日志（redo log），再写磁盘（服务器空闲的时候）</p></li><li><p>MySQL宕机了怎么保证事务？（redo log）</p><p>redo log两阶段提交：（保证两个log的一致性）</p><ol><li>redo log写入日志处于prepare状态</li><li>binlog写入日志后redo log处于commit状态</li><li>后面服务器会根据redolog将数据真正写入数据库中</li></ol><p>宕机：</p><ol><li>在redolog写入前宕机，没有日志，且没有提交事务，不需要处理</li><li>在redolog的prepare状态后宕机，可以根据redolog来继续提交或者回滚</li><li>在redolog的commit状态后宕机，根据redolog把数据写入磁盘</li></ol></li><li><p>TCP和UDP的区别</p></li><li><p>TCP的<a href="https://www.nowcoder.com/jump/super-jump/word?word=keep">keep</a>-live是什么？</p><ul><li><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p></li><li><p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p></li></ul></li><li><p>索引失效的例子？</p><ul><li><p>联合索引不满足左前缀法则</p><blockquote><p>联合索引:（a，b）先根据a排序，在a相同的情况下，使用b排序</p><p>最左前缀原则：若索引有多列，查询要从最左前列开始并且不跳过索引中的列</p></blockquote><ul><li>直接查找where b &#x3D; xxx；</li><li>like索引失效</li><li>范围查询右边失效原理。where a &gt; xxx and b &#x3D; xxx;</li></ul></li><li><p>在索引列参与运算，或使用了函数</p></li><li><p>使用select *</p></li><li><p>类型隐式转换</p></li><li><p>使用or操作：or左右是不同的列，且其中一个是全表扫描；或者or左右是相同列，同时使用&gt;和&lt;</p></li><li><p>两列做比较</p></li><li><p>is not null，not in，not exists</p></li><li><p>order by</p></li><li><p>DBMS针对不同参数优化：若全表扫描比索引快，则使用全表扫描</p></li></ul></li><li><p>遇到慢查询，你怎么解决？</p><ul><li>升级硬件。CPU和IO</li><li>软件排查<ul><li>使用EXPLAIN查看执行计划关注key和extra</li><li>查询没有命中任何索引，优化表索引结构</li><li>查询、排序没有命中覆盖索引，考虑添加联合索引</li></ul></li><li>优化建议<ul><li>select数据太多（分页控制、分批查询、精简查询列）</li><li>索引失效的解决</li><li>可能未定义索引</li><li>查询语句过于复杂（拆分为多个简单查询，放于同一事务）</li></ul></li></ul></li><li><p>索引为什么用B+树不用B树</p><ul><li>单一节点存储更多元素，查询IO次数会更少</li><li>所有查询都要查找叶子节点，查找性能稳定</li><li>所有子节点形成有序链表，便于范围查询</li></ul></li><li><p>聚集索引和非聚集索引的区别是啥？</p><ul><li>聚集索引和非聚集索引的<strong>根本区别</strong>是表记录的排列顺序和与索引的排列顺序是否一致。</li></ul></li></ol><p>C</p><ol><li><p>重载和重写区别</p><ul><li>重载：一个类的多态性的表现，在一个类中定义了多个方法名相同，参数数量或种类和次序不同的方法。</li><li>重写：子类与父类的以一种多态性表现，子类中存在和父类方法名、参数、返回值均相同的方法。</li></ul></li><li><p>GC算法有那些</p><ul><li><p>复制算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916203852553.png" alt="img"></p></li><li><p>标记 - 清除算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204202965.png" alt="img"></p></li><li><p>标记 - 整理算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204205977.png" alt="img"></p></li><li><p>分代回收算法</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/20200916204228959.png" alt="img"></p></li></ul></li></ol><p>D</p><ol><li><p>springBoot启动流程</p><ol><li>new SpringApplication对象。从main中找到run()方法前new一个SpringApplication对象</li><li>创建应用监听器。进入run()方法，创建SpringApplicationRunListeners开始监听</li><li>加载配置环境。加载ConfigurableEnvironment，然后把配置Environment加入监听对象</li><li>加载应用上下文。加载ConfigurableApplicationContext，作为run方法的返回对象</li><li>创建Spring容器、refreshContext（context），实现starter自动化配置和bean的实例化等工作</li></ol></li><li><p>springAOP（Aspect-oriented Programming）</p><p>为什么引入AOP</p><ul><li><p>OOP的局限性</p><blockquote><p>静态化语言：类结构一旦定义，不容易被修改</p><p>侵入式扩展：通过继承或组合组织新的类结构</p></blockquote></li><li><p>通过AOP抽离非业务逻辑代码</p><blockquote><p> 通过AOP可以将一些非业务逻辑的代码从业务中抽离出来，以非入侵的方式与原方法进行协同。这样可以使原方法更专注于业务逻辑，代码接口更加清晰，便于维护</p></blockquote></li></ul><p>AOP使用场景</p><ul><li>日志</li><li>统计</li><li>安防</li><li>性能</li></ul><p>AOP中的重要概念</p><ul><li><p>AspectJ：切面。</p><blockquote><p>（Join point + Advice + Pointcut）三者的统称。只是一个概念，没有具体的接口或类与之对应。</p></blockquote></li><li><p>Join point：连接点。</p><blockquote><p>指程序执行过程中的一个点，例如方法调用、异常处理等。在Spring AOP中，仅支持方法级别的连接点。</p></blockquote></li><li><p>Advice：通知。</p><blockquote><p>我们定义的一个切面中的横切逻辑，有”around“，”before“和”after“三种类型。在很多的AOP实现框架中，Advice通常作为一个拦截器，也可以包含多个拦截器作为一个链路围绕着Join point进行处理。</p></blockquote></li><li><p>Pointcut：切点。</p><blockquote><p>用于匹配连接点,一个AspectJ中包含哪些Join point需要由Pointcut进行筛选 。</p></blockquote></li><li><p>Introduction：引介。</p><blockquote><p>让一个切面可以被声明被通知的对象实现任何他们没有真正实现的额外接口。例如让一个代理对象代理两个目标类</p></blockquote></li><li><p>Weaving：织入。</p><blockquote><p>在有了连接点、切点、通知以及切面，如何将让门应用到程序中呢？就是使用织入，在切点的引导下，将通知逻辑插入到目标方法上，使得我们的通知逻辑在方法调用时得以执行。</p></blockquote></li><li><p>AOP proxy：AOP代理。</p><blockquote><p>指在AOP实现框架中实现切面协议的对象。在Spring AOP中有两种代理，JDK动态代理和CGLIB动态代理。</p></blockquote></li><li><p>Target object：目标对象。</p><blockquote><p>被代理的对象。</p></blockquote></li></ul></li><li><p>springAop是基于哪两种动态代理</p><ul><li>JDK动态代理</li><li>CGLIB动态代理</li></ul></li><li><p>SpringMVC一次请求的过程</p><p><img src="/2022/09/16/%E9%BC%8E%E6%A1%A5%E9%9D%A2%E8%AF%95%E9%A2%84%E4%B9%A0/5220087-3c0f59d3c39a12dd.png" alt="img"></p></li><li><p>springBean默认是什么模式（单例）</p></li><li><p>如何将其改为非单例</p></li><li><p>mybatis如何防止sql注入</p><ul><li><p>SQL注入发生在SQL预编译阶段</p></li><li><p>PreparedStatement预编译对象</p></li><li><p>预编译，替换占位符</p></li></ul></li><li><p>mysql隔离级别、事务特性</p><p>事务特性：</p><ul><li>原子性</li><li>一致性</li><li>隔离性<ul><li>读未提交</li><li>读提交</li><li>可重复度</li><li>串行化</li></ul></li><li>持久性</li></ul></li><li><p>可重复读是怎么解决不可重复读问题的（间隙锁）</p><p>在事务开始的时候创建快照，并对更新的行加上行锁</p></li><li><p>Java集合类</p></li><li><p>JVM内存模型</p><p>线程共享：</p><ul><li><p>方法区</p><blockquote><p>类信息、常量、静态变量、JIT编译后的代码</p><p>运行时常量池：编译期间生成的各种字面常量和符号引用</p></blockquote></li><li><p>堆</p><blockquote><p>实例对象</p></blockquote></li></ul><p>线程私有：</p><ul><li><p>虚拟机栈、本地方法栈</p><blockquote><p>栈帧：局部变量表、操作数表</p></blockquote></li><li><p>程序计数器</p></li></ul></li><li><p>垃圾回收过程</p></li><li><p>redis基本类型</p></li><li><p>redis的持久化</p></li><li><p>redis的发布订阅</p></li><li><p>kafka如何保证数据不丢失</p></li><li><p>kafka消费者采用的是哪种模式</p></li></ol><p>E</p><ol><li><p>&#x3D;&#x3D;和equals的区别</p></li><li><p>GC如何判断一个对象可回收</p><ul><li>引用计数法</li><li>可达性分析</li></ul></li><li><p>常用的GC roots对象</p><ul><li>虚拟机栈中的引用对象</li><li>本地方法栈中JNI的引用对象</li><li>方法区中的<strong>类静态属性</strong>引用对象</li><li>方法区中<strong>常量</strong>引用的对象</li></ul></li><li><p>volatile关键字</p><ul><li>变量可见性问题</li><li>指令重排序，Happens-Before</li></ul></li><li><p>为什么会有线程可见性问题</p><ul><li>工作内存中的是主内存的副本，线程之间的工作内存不共享</li><li>A修改后作用在A的工作内存，B看不到</li></ul></li><li><p>线程安全的方式</p><ul><li>synchronized关键字（互斥锁，悲观锁）</li><li>使用Lock接口下的实现类（悲观锁）</li><li>使用线程本地存储ThreadLocal</li><li>使用乐观锁机制，使用版本控制判断实现</li></ul></li><li><p>synchronized在普通方法和静态方法的区别</p></li><li><p>数据库的隔离级别</p></li><li><p>可重复读和读提交哪个性能更好</p></li><li><p>select for update和select区别</p><ul><li>select for update会对查询的行添加排他锁</li></ul></li><li><p>Spring中事务传播属性</p></li><li><p>线程死锁的例子</p></li><li><p>left jon和inner join区别</p><ul><li><p>left join以左表为基础，右表中有不匹配的行直接置为null</p></li><li><p>innerjoin，若有左右表不匹配的行，直接去除</p></li></ul></li><li><p>数据库结果集去重</p><ul><li>DISTINCT（多条记录的每一个字段值完全相同）</li><li>GROUP BY（只有部分字段值重复，但是表存在主键）</li><li>复制到临时表，再查询（只有部分字段重复，但是表没有主键，复制到临时表中就是为了给记录添加自增增长的id）</li></ul></li><li><p>客户端如何实现认证已登录</p><ul><li>cookie+session</li><li>Token</li></ul></li><li><p>同一条url,已登录和未登录为什么不同</p></li><li><p>IOC原理</p><ul><li>Java反射机制</li><li>被调用者实例本来由调用者创建</li><li>IOC使得将对象全部交给Spring管理</li></ul></li><li><p>java异常</p><ul><li>Error<ul><li>OutOfMemoryError</li><li>IOError</li></ul></li><li>Exception<ul><li>IOException</li><li>RuntimeException</li></ul></li></ul></li><li><p>常用的线程安全类</p></li><li><p>设计一个线程安全的HashSet</p></li><li><p>设计模式及其作用</p></li><li><p>SQL注入问题,解决</p></li><li><p>两台tomcat服务器,你已经登录上一台,但是随机访问到另一台要重新登录,如何解决这个问题</p></li></ol><p>F</p><ol><li>JVM新生代和老年代</li><li>线程池的建立</li><li>用过那些数据库</li><li>http和https的区别</li><li>抽象类和接口的区别</li><li>集合类相关</li><li>java中栈和链表是如何实现</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务隔离级别及其实现原理</title>
    <link href="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><ol><li><p>是什么</p><p>数据库事务指的是一组数据操作，事务内的操作要么全部成功，要么全部失败，什么都不做。（实际上事务中可能部分操作已经完成，但是有一部分失败，事务的作用就是回滚已经成功的所有操作）</p></li><li><p>作用</p><p>每一次操作由一系列动作组成，若其中某一个环节异常，那么整个操作都要撤回。</p><p>例如：网购付款，付款后的两个操作，订单更新、库存更新，这两个操作要么都完成，要么都不完成，如果只有一个操作执行，那么订单的数据和库存的数据就不一致。</p></li><li><p>事务特性（<strong>ACID</strong>）</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li><strong>隔离性（Isolation）</strong></li><li>持久性（Durability）</li></ul></li></ol><h2 id="事务隔离要解决的问题"><a href="#事务隔离要解决的问题" class="headerlink" title="事务隔离要解决的问题"></a>事务隔离要解决的问题</h2><ul><li><p><strong>脏读</strong>（未提交的数据（可能会回滚而失效）被其他事务读取）</p><blockquote><p>脏读指读到其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。</p><p>读到了并不一定存在的数据，这就是脏读。</p></blockquote></li><li><p><strong>不可重复读</strong>（同一事务不同时刻同样的查询条件，查出来的数据不同）</p><blockquote><p>通常针对数据<strong>更新（UPDATE）</strong>操作。</p><p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。</p><p>对比可重复读，不可重复读指的是在同一事务内，不同时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。</p></blockquote></li><li><p><strong>幻读</strong>（更新了数据但是好像未生效）</p><blockquote><p>幻读针对数据<strong>插入（INSERT）</strong>操作来说。</p><p>例如：</p><p>事务A对某行内容做了更改，未提交，</p><p>此时事务B插入了与A修改前记录相同的行，并在A事务提交之前提交了，</p><p>此时在A事务中查询，发现刚才做的更改好像未生效（其实是事务B刚插入的），</p><p>这就叫幻读。</p></blockquote></li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>读未提交（READ UNCOMMITTED）</li><li>读提交（READ COMMITTED）解决脏读</li><li>可重复读（REPEATABLE READ）解决不可重复读 <strong>默认</strong></li><li>串行化（SERIALIZABEL）解决幻读</li></ul><h3 id="查看与设置隔离级别"><a href="#查看与设置隔离级别" class="headerlink" title="查看与设置隔离级别"></a>查看与设置隔离级别</h3><ul><li>查看隔离级别</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW variables LIKE &#x27;transaction_isolation&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20220913223306947.png" alt="image-20220913223306947"></p><ul><li>修改隔离级别</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET 作用域 TRANSACTION ISOLATION LEVEL 事务隔离级别;<br></code></pre></td></tr></table></figure><blockquote><p>作用域：</p><ul><li>SESSION：指针对当前会话窗口</li><li>GLOBAL：全局</li></ul><p>事务隔离级别</p><ul><li>READ UNCOMMITTED</li><li>READ COMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li></ul></blockquote><h3 id="在MySQL中执行事务"><a href="#在MySQL中执行事务" class="headerlink" title="在MySQL中执行事务"></a>在MySQL中执行事务</h3><p>事务流程：开始事务–》执行操作–》结束事务（提交&#x2F;回滚）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">BEGIN;/START TANSACTION;#事务开始于BEGIN命令后的第一条语句<br>#执行操作<br>COMMIT;<br></code></pre></td></tr></table></figure><p>查看正在运行的事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.innodb_trx;<br></code></pre></td></tr></table></figure><h3 id="隔离级别分析"><a href="#隔离级别分析" class="headerlink" title="隔离级别分析"></a>隔离级别分析</h3><h4 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h4><p>脏读问题：</p><blockquote><p>A更新的数据还未提交，B直接读取，若A进行回滚，那么A刚才更新的数据就是无效的，B获取到了无效的数据，即脏读。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-77225da0805e43183c076c24f270e75b_720w.jpg" alt="img"></p><h4 id="读提交（READ-COMMITTED）"><a href="#读提交（READ-COMMITTED）" class="headerlink" title="读提交（READ COMMITTED）"></a>读提交（READ COMMITTED）</h4><p>解决脏读问题：</p><blockquote><p>一个事务只能读取到其他事务已经提交过的数据。这样脏读问题就解决了。</p></blockquote><p>不可重复读问题：</p><blockquote><p>B某一时刻读取了数据之后，A对其作了更新，B在同一事务中再去读同一数据，读取到的和第一次读取到的不一样，即为不可重复读。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-90289243339a900aaf3f87d9c9930258_720w.jpg" alt="img"></p><h4 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h4><p>解决不可重复读问题：</p><blockquote><p>事务不会读到其他事务对已有的数据的<strong>修改</strong>，即使其他事务已提交。也就是说事务开始读到的已有数据到事务提交之前都是不会变的。</p><p>但是，对于其他事务插入的数据是可以读到的。这也就引发了幻读问题。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-85fd2da20ae7cf219bf55d8b81f8bd94_720w.jpg" alt="img"></p><p>幻读问题：</p><blockquote><p>事务B对某行做了修改，事务A插入了一行，并且这行与B进行修改的行的原始数据一致，然后B再进行查询，发现读取到和未修改行一样的数据，就好像B做的修改没有生效一样，即幻读。</p><p>MySQL中的可重复度隔离解决了幻读问题。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-457f695ba253674e7a998297660c1a01_720w.jpg" alt="img"></p><h4 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h4><p>串行化相当于单线程，事务逐一执行，自然就不会存在因为并发而引起的脏读、不可重复读、幻读的问题。</p><h2 id="MySQL中事务隔离的实现"><a href="#MySQL中事务隔离的实现" class="headerlink" title="MySQL中事务隔离的实现"></a>MySQL中事务隔离的实现</h2><p>读未提交：性能最好，相当于没加锁。</p><p>串行化：读时加共享锁，可并发读，写时加排他锁，其他事务不能进行读写。</p><h3 id="读提交和可重复读的实现"><a href="#读提交和可重复读的实现" class="headerlink" title="读提交和可重复读的实现"></a>读提交和可重复读的实现</h3><p>采用MVVC（多版本并发控制）的方法</p><h4 id="行记录版本和事务id"><a href="#行记录版本和事务id" class="headerlink" title="行记录版本和事务id"></a>行记录版本和事务id</h4><p>概述：</p><blockquote><p>我们在数据库中看到的一条行记录可能实际上有多个版本，每个版本除了记录数据外，还有一个表示版本的字段，记未row trx_id，而整个字段就是使其产生的事务的id，事务id记为transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p></blockquote><p>图解：</p><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-114dd6691636883a92e7c1060210a014_720w.jpg" alt="img"></p><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>读提交和可重复读实现的关键就是快照，学名叫做一致性视图。</p><blockquote><ul><li><p>可重复读是在事务开始的时候生成一个当前事务全局性的快照。</p></li><li><p>而读提交是每次执行语句的时候都重新生成一次快照。</p></li></ul></blockquote><p>快照能够读取到的版本：</p><blockquote><ul><li>当前事务内的更新，可以读到；</li><li>快照创建前未提交的版本不可读；</li><li>快照创建后的提交的版本不可读</li></ul></blockquote><p>综上：可重复读和读提交二者<strong>唯一的区别就是快照的创建</strong></p><h3 id="并发写的问题"><a href="#并发写的问题" class="headerlink" title="并发写的问题"></a>并发写的问题</h3><p>问题：</p><blockquote><p>两个事务对同一数据做修改。最终的结果应该时间靠后的哪个事务。</p><p>并且在更新之前要先读数据，这里所说的读和上面说到的读不一样，更新之前的读叫做“当前读”，总是当前版本的数据，也就是多版本中最新一次提交的那版。</p></blockquote><p>例子：</p><blockquote><p>若A执行UPDATE操作，在UPDATE执行期间，要对所修改的行加<strong>行锁</strong>，这个行锁在提交过后才释放。在A提交之前，B若想UPDATE这行数据，需要先申请锁，但是锁已经被A占有，所以B需要等到A提交并释放锁过后才能获取锁继续执行。</p></blockquote><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-da32a0f82e9585e39c655ac490c6f3d8_720w.jpg" alt="img"></p><p>两种加锁过程：</p><ol><li><p>有索引（只锁对应行）</p><blockquote><p>例如：<code>UPDATE user SET age=11 WHERE id = 1;</code></p><p>id是这张表的主键，是有索引的情况，那么MySQL直接就在索引数中找到这行数据，让后将该行上行锁。</p></blockquote></li><li><p>无索引（全锁，在解锁留下对应行）</p><blockquote><p>例如：&#96;UPDATE user SET age&#x3D;11 WHERE age&#x3D;10;</p><p>age并非索引，所以MySQL无法直接定位该行（或者多行）数据。然后MySQL就对表中的所有行加行锁（并非表锁），然后分局条件过滤，释放掉不满足条件的行的行锁。</p><p>这个加锁和解锁的过程非常影响性能，所以对于大表需要合理的设计索引来避免这种情况。</p></blockquote></li></ol><h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><p> 并发写问题 的解决方式是行锁，而解决幻读的方式则是间隙锁。MySQL将行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做Next-Key锁</p><p>间隙锁：</p><ul><li>表：</li></ul><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-6a7c4b03297309813d57213a2a2d7366_720w.jpg" alt="img"></p><ul><li>间隙锁：</li></ul><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-f07516da40274690e8ece9bc415eab88_720w.jpg" alt="img"></p><blockquote><p>MySQL会在筛选的索引列和其两端的索引列之间加上间隙锁。</p><p>例如执行：<code>UPDATE user SET name = ‘风筝2号’ WHERE age = 10; </code></p><p>（其中age是索引列，唯一）那么MySQL就会在age为[负无穷，10）、（10，30）这两个区间加上间隙锁，那么所有age在这两个区间的数据在此期间就无法插入。（30之后的区间插入数据不会有幻读问题，所以不需要加间隙锁）</p></blockquote><ul><li><p>加锁过程</p><p><img src="/2022/09/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-3ce9ac24fb6fdf3ff60d03e070136175_720w.jpg" alt="img"></p><blockquote><p>在A提交之前，因为事务B插入的数据age&#x3D;10，由于age&#x3D;10的行添加了行锁，两边有间隙锁，所以插入操作无法完成，需要等到A提交后才能插入。这样就不存在幻读问题了。（age  &gt; 30的行插入不受影响）</p></blockquote><blockquote><p>若age不是索引列，那么数据库将为整个表加上间隙锁，那么不管age为何值均要等到事务A提交才能成功插入。</p></blockquote></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法</title>
    <link href="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h2><h3 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h3><ul><li>平方阶：冒泡排序、插入排序、选择排序</li><li>n^(1.3-2)阶：希尔排序</li><li>线性对数阶：快速排序、归并排序、堆排序</li><li>线性阶：计数排序、桶排序、基数排序、</li></ul><h3 id="稳定度："><a href="#稳定度：" class="headerlink" title="稳定度："></a>稳定度：</h3><blockquote><p>算法稳定指的是两个相等键值的顺序和排序之前它们的顺序相同</p></blockquote><ul><li>稳定排序：冒泡排序、插入排序、归并排序、计数排序、桶排序、基数排序</li><li>不稳定排序：选择排序、希尔排序、快速排序、堆排序</li></ul><p><strong>注意：算法稳定与否和具体的实现有关！！！</strong></p><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><blockquote><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个。每一次将最大的元素放到合适的位置。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" alt="img"></p><h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><blockquote><p>每次遍历寻找最小&#x2F;大元素放到首&#x2F;尾</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" alt="img"></p><h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><blockquote><p>将未排序元素依次插入到已排序序列合适位置（初始化第一个元素未已排序序列）</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertionSort.gif" alt="img"></p><h2 id="四、希尔排序（插入排序-缩小增量）"><a href="#四、希尔排序（插入排序-缩小增量）" class="headerlink" title="四、希尔排序（插入排序|缩小增量）"></a>四、希尔排序（插入排序|缩小增量）</h2><p>又叫（缩小增量排序），是插入排序改进版</p><p>基于插入排序特性进行优化:</p><blockquote><ul><li>插入排序在对几乎已经拍好序的数据操作时，效率高。</li><li>但是一般来说插入排序是低效的，因为每次插入只能将数据移动一位。</li></ul></blockquote><p>希尔排序的基本思想：</p><blockquote><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1024555-20161128110416068-1421707828.png" alt="img"></p><h2 id="五、归并排序（分治法）"><a href="#五、归并排序（分治法）" class="headerlink" title="五、归并排序（分治法）"></a>五、归并排序（分治法）</h2><ul><li><p><strong>分治法</strong>的典型应用。</p></li><li><p>问题分解：要将数组排序，先将数组分解成两份，将两份分别排好序后，再将两份数组合并，合并后的数组就排好序了。</p></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1024555-20161218163120151-452283750.png" alt="img"></p><h2 id="六、快速排序（分治法-冒泡排序）"><a href="#六、快速排序（分治法-冒泡排序）" class="headerlink" title="六、快速排序（分治法|冒泡排序）"></a>六、快速排序（分治法|冒泡排序）</h2><ul><li><p><strong>分治法</strong>的典型应用。</p></li><li><p>从本质上看，快速排序算是<strong>在冒泡排序基础上的递归分治法</strong></p></li><li><p>算法思想：</p><blockquote><p>选择一个基准元素，然后以它为基准将数组分为两个区。然后将比基准值小的都放到基准值左边，大的放到基准值右边，然后对两个区域分别递归排序排序。</p><p>划区的操作就相当于是冒泡操作，每一层递归，一个元素就放置到了它该在的位置。</p></blockquote></li><li><p>算法实现：</p><blockquote><p>在单独的一层递归中，选择首元素作为基准元素，然后使用双指针，从第二个元素和末尾元素向中间遍历，左指针找比基准元素小的元素，右指针找比基准元素大的值，然后交换，最后将基准元素与左指针指向元素互换，这样基准元素左边都比它小，右边都比他大，此时他已经到了该在的位置。</p></blockquote></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" alt="img"></p><h2 id="七、堆排序（选择排序-堆）"><a href="#七、堆排序（选择排序-堆）" class="headerlink" title="七、堆排序（选择排序|堆）"></a>七、堆排序（选择排序|堆）</h2><ul><li><p>基于堆这种数据结构而设计</p><blockquote><p>堆是具有一下性质的<strong>完全二叉树</strong>：每个节点的值都大于或等于其左右子节点的值，称为大顶堆。反之为小顶堆。</p></blockquote></li><li><p>堆排序是一种<strong>选择排序</strong></p></li><li><p>堆排序的基本思想：</p><blockquote><p>1、将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。</p><p>2、将其与末尾元素进行交换，此时末尾就为最大值，然后将剩余的n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。</p><p>如此反复执行，就能得到一个有序序列。</p></blockquote></li></ul><h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><ul><li><p>计数排序的思想：</p><blockquote><p>将输入的数值转换为键存储在额外开辟的数组空间中。要求输入的数据是有确定范围的整数</p></blockquote></li><li><p>计数排序不是比较排序。用于计数的数组大小取决于数据的范围，所以说计数排序只适合于数据范围较小的数组。</p></li><li><p>但是计数排序可以用在基数排序中，用来排序数据范围很大的数组。</p></li></ul><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/countingSort.gif" alt="img"></p><h2 id="九、桶排序（计数排序-桶）"><a href="#九、桶排序（计数排序-桶）" class="headerlink" title="九、桶排序（计数排序|桶）"></a>九、桶排序（计数排序|桶）</h2><ul><li><p>桶排序是计数排序的升级版。</p><blockquote><ul><li><p>计数排序是将每个值占用一个数组位置（相当于桶大小为1），然后直接顺序取值后全部元素就已拍好序列。</p></li><li><p>而桶排序则是将一定范围内的值放入一个桶中，然后对每个桶中元素单独排序（可以使用各种算法，一般采用插入排序，若桶内已经有元素，则新来的元素使用插入排序放入桶中），最后依次从桶中取出拍好序的元素归位。</p></li></ul></blockquote><ol><li>将元素分配到桶中</li></ol><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Bucket_sort_1.svg_.png" alt="img"></p><ol start="2"><li>将每个桶中元素进行排序</li><li>然后依次将每个桶中的元素取出归位</li></ol><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Bucket_sort_2.svg_.png" alt="img"></p></li></ul><h2 id="十、基数排序（桶排序-按位分配桶）"><a href="#十、基数排序（桶排序-按位分配桶）" class="headerlink" title="十、基数排序（桶排序|按位分配桶）"></a>十、基数排序（桶排序|按位分配桶）</h2><blockquote><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位切割成不同的数字，然后根据每个位上数字来分配桶（1-9共十个桶）。</p><p>基数排序还可以用于字符串和浮点数的排序。</p></blockquote><p><img src="/2022/09/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/radixSort.gif" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/09/04/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/04/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="1-Java语言特点"><a href="#1-Java语言特点" class="headerlink" title="1. Java语言特点"></a>1. Java语言特点</h3><ul><li>面向对象（封装、继承、多态）</li><li>平台无关性（Java虚拟机）</li><li>多线程（语言级支持）</li><li>网络编程（Java诞生就是为了简化网络编程设计）</li><li>编译与解释并存</li><li>简单易学、可靠性、安全性</li></ul><h3 id="2-JVM、JRE、JDK"><a href="#2-JVM、JRE、JDK" class="headerlink" title="2. JVM、JRE、JDK"></a>2. JVM、JRE、JDK</h3><ul><li><p>JVM</p><blockquote><p>JVM是运行Java字节码的虚拟机，JVM针对不同的系统的特定实现，目的是使用相同的字节码，在不同平台的JVM上运行都能产生相同结果。</p></blockquote><ul><li><p>什么是字节码？采用字节码的好处？</p><blockquote><p>在Java中，JVM可以理解的代码就是字节码（.class文件）、它不面向特定处理器，只面向虚拟机。Java通过字节码的方式，一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释性语言可移植的特点。所以因为采用字节码，Java程序运行比较高效，而且由于字节码不针对特定机器，所以Java程序无需重新编译即可在不同操作系统上运行。</p></blockquote></li><li><p>Java程序从源代码到运行的流程</p><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/image-20220904193326678.png" alt="image-20220904193326678"></p><blockquote><p>.class -&gt; 机器码，由JVM进行转换。有两种转换方式：</p><ul><li>一是解释执行，先加载字节码文件，经过解释器解释执行；</li><li>二是编译执行，对于热点代码，由编译器完成一次编译过后将字节码对应的机器码保存下来，下次直接使用。</li></ul></blockquote></li></ul></li><li><p>JRE</p><blockquote><p>JRE是Java与模型时环境，它时运行已编译Java程序所需的所有内容的集合，包括JVM、Java类库、java命令和一些其他的基础构件。但是，它不能用于创建新程序。</p></blockquote></li><li><p>JDK</p><blockquote><p>JRE + 编译器（javac）+ 工具（如javadoc和jdb）。它能创建和编译程序。</p></blockquote></li></ul><p>   总结：</p><ul><li>JVM：（执行java字节码文件）</li><li>JRE：JVM + java类库 + java命令 + 基础构件（运行java程序）</li><li>JDK：JRE + 编译器 + 工具（创建和编译程序）</li></ul><h3 id="3-Oracle-JDK-和-OpenJDK"><a href="#3-Oracle-JDK-和-OpenJDK" class="headerlink" title="3. Oracle JDK 和 OpenJDK"></a>3. Oracle JDK 和 OpenJDK</h3><ul><li>OpenJDK完全开源，作为一个参考模型。Oracle JDK是OpenJDK的一个实现，包含自己的商业内容，不完全开源。</li><li>Oracle更稳定，有更多的类和一些错误修复。性能更好。</li></ul><h3 id="4-Java和C-的区别"><a href="#4-Java和C-的区别" class="headerlink" title="4. Java和C++的区别"></a>4. Java和C++的区别</h3><ul><li><p>都是面向对象的语言，都支持封装、继承和多态</p></li><li><p><strong>指针</strong>，Java不提供指针用来直接访问内存，程序内存更安全</p></li><li><p><strong>继承</strong>，Java的类是单继承的，C++支持多继承。虽然Java的类不能多继承，但是接口可以多继承（实现）</p></li><li><p><strong>内存管理</strong>，Java通过JVM自动管理内存，不需要程序员手动释放无用内存</p></li><li><p><strong>字符串结束符</strong>，C语言中字符串和字符数组随后都有额外字符 ‘\0’ 来表示结束。Java语言中没有结束符这一概念。</p><blockquote><p>Java是面向对象的，字符串和数组均是对象，对象有属性length来记录长度，所以说再额外使用结束符来标识末尾。</p></blockquote></li></ul><h3 id="5-什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#5-什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="5. 什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>5. 什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><blockquote><p>一个程序可以有很多个类，但是只能由一个类是主类。再Java应用程序中，这个主类是指包含main方法的类。</p></blockquote><blockquote><p>在小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是pulic类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p></blockquote><h3 id="6-Java应用程序（Application）和小程序（Applet）之间的差别"><a href="#6-Java应用程序（Application）和小程序（Applet）之间的差别" class="headerlink" title="6. Java应用程序（Application）和小程序（Applet）之间的差别"></a>6. Java应用程序（Application）和小程序（Applet）之间的差别</h3><ul><li>（1）运行方式不同。Java Application是完整的程序，可以独立运行；Java Applet程序不能单独运行，<br>它必须嵌入到用HTML语言编写的Web页面中，通过与Java兼容的浏览器来控制执行。</li><li>（2）运行工具不同。Java Application程序被编译以后，用普通的Java解释器就可以使其边解释边执行，<br>而Java Applet必须通过网络浏览器或者Applet观察器才能执行。</li><li>（3）程序结构不同。每个Java Application程序必定含有一个并且只有一个main方法，程序执行时<br>首先寻找main方法，并以此为入口点开始运行。含有main方法的那个类，常被称为主类，也就是说<br>Java Application程序都含有一个主类。而Applet程序则没有含main方法的主类，这也正是Applet程序不能独立运行的原因。<br>尽管Applet没有含main方法的主类，但Applet一定有一个从 java.applet.Applet派生的类，它是由Java系统提供的。</li><li>（4）受到的限制不同Java Application程序可以设计成能进行各种操作的程序，包括读／写文件的操作<br>但是 Java Applet 对站点的磁盘文件既不能进行读操作，也不能进行写 操作。然而，由于Applet的引入<br>使Web页面具有动态多媒体效果和可交互性能，这使由名为超文本、实为纯文本的HTML语言编写成的Web页面真正具有了超文本功能</li></ul><h3 id="7-import-java-x2F-javax有啥区别"><a href="#7-import-java-x2F-javax有啥区别" class="headerlink" title="7. import java&#x2F;javax有啥区别"></a>7. import java&#x2F;javax有啥区别</h3><blockquote><p>刚开始的时候JavaAPI所需的包均以是以java开头的包，javax作为扩展API包使用。随着时间的推移，javax逐渐成为JavaAPI的一部分，但是将javax包移动到java包中太麻烦，且会破坏一堆现有代码，所以直接将javax纳入为JavaAPI的一部分</p></blockquote><h3 id="8-为什么说Java语言“编译与解释并存”？"><a href="#8-为什么说Java语言“编译与解释并存”？" class="headerlink" title="8. 为什么说Java语言“编译与解释并存”？"></a>8. 为什么说Java语言“编译与解释并存”？</h3><blockquote><p>高级程序语言按照程序的执行方式分为编译型和解释型。</p><ul><li>编译型语言指编译器针对特定操作系统将源代码一次性翻译成可被该平台执行的机器码</li><li>解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</li></ul></blockquote><blockquote><p>Java语言既有编译型语言特征，也有解释型语言特征。java源码先编译成字节码，字节码再由解释器解释执行（同时也有编译器对热点代码进行编译）</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="1-字符型常量和字符串常量的区别？"><a href="#1-字符型常量和字符串常量的区别？" class="headerlink" title="1. 字符型常量和字符串常量的区别？"></a>1. 字符型常量和字符串常量的区别？</h3><ul><li>形式：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干字符</li><li>含义：字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串再内存中的存放地址）</li><li>占用内存：字符常量只占2个字节；字符串常量占若干字节</li></ul><h3 id="2-关于注释？"><a href="#2-关于注释？" class="headerlink" title="2. 关于注释？"></a>2. 关于注释？</h3><blockquote><p>注释并非越详细越好，好的代码本身就是注释，尽量通过规范和美化代码来减少不必要的注释。</p></blockquote><ul><li><p>注释种类</p><ul><li><p>单行注释</p><blockquote><p>&#x2F;&#x2F;注释</p></blockquote></li><li><p>多行注释</p><blockquote><p> &#x2F;*</p><p>注释</p><p>注释</p><p>*&#x2F;</p></blockquote></li><li><p>文档注释</p><blockquote><p>&#x2F;**</p><p>*文档注释</p><p>*&#x2F;</p></blockquote></li></ul></li></ul><h3 id="3-标识符和关键字的区别？"><a href="#3-标识符和关键字的区别？" class="headerlink" title="3. 标识符和关键字的区别？"></a>3. 标识符和关键字的区别？</h3><blockquote><p>在编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符。简单来说标识符就是一个名字。</p></blockquote><blockquote><p>但是有一些标识符，Java语言已经赋予其特殊含义，只能又在特定地地方，这种特殊的标识符就是关键字。因此关键字是被赋予特殊含义的标识符。</p></blockquote><h3 id="4-常见关键字"><a href="#4-常见关键字" class="headerlink" title="4. 常见关键字"></a>4. 常见关键字</h3><ul><li><p>访问控制：private、protected、public</p></li><li><p>类、方法和变量的修饰符：abstract、static、interface、final、extends、implments、new、native、strictfp、synchronized、transient、volatile、class</p></li><li><p>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</p></li><li><p>错误处理：try、catch、throw、throws、finally</p></li><li><p>包相关：import、package</p></li><li><p>基本类型：boolean、byte、char、double、float、int、long、short、null、true、false</p></li><li><p>变量引用：super、this、void</p></li><li><p>保留字：goto、const</p></li></ul><h3 id="5-continue、break和return区别"><a href="#5-continue、break和return区别" class="headerlink" title="5. continue、break和return区别"></a>5. continue、break和return区别</h3><ul><li>提前终止循环<ul><li>continue：跳出当前这一次循环（此次循环中continue后的语句不执行，直接跳到循环的开头进行循环的条件判断，执行下一次循环）</li><li>break：跳出当前所在的整个循环体，执形循环后的语句</li></ul></li><li>结束方法的运行<ul><li>return：直接结束方法的执行，用于没有返回值的方法</li><li>return value：返回一个特定值，并结束方法的执行</li></ul></li></ul><h3 id="6-泛型、类型擦除、通配符？"><a href="#6-泛型、类型擦除、通配符？" class="headerlink" title="6. 泛型、类型擦除、通配符？"></a>6. 泛型、类型擦除、通配符？</h3><ul><li><p>泛型：泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数</p><blockquote><p>泛型的三种使用方法：</p><ul><li><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> T key;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span>&#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实例化泛型类</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure></li><li><p>泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//实现泛型接口，不指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实现泛型接口，指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(E[] inputArray)</span>&#123;<br>    <span class="hljs-keyword">for</span>(E element : inputArray)&#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s&quot;</span>, element);<br>    &#125;<br>    System.out.println();<br>&#125;<br><span class="hljs-comment">//创建不同类型的数组，使用同一泛型方法打印</span><br>Integer[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>String[] stringArray = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br>printArray(intArray);<br>printArray(stringArray);<br></code></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>常用通配符：T、E、K、V、？</p><ul><li>？标识不确定的java类型</li><li>T（type）标识具体的一个java类型</li><li>K V（key value）分别标识java键值中的Key Value</li><li>E（element）标识数组中的元素类型</li></ul></blockquote></li><li><p>类型擦除：Java的泛型是<strong>伪泛型</strong>，因为Java在编译期间，所有的泛型信息都会被擦除，这就是通常所说的类型擦除。 所有的泛型在编译过后均为Object，所以说，在运行期间通过反射可以向Integer泛型的List中添加String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>list.add(<span class="hljs-number">12</span>);<br><span class="hljs-comment">//直接往Integer的list中添加string会在编译器报错</span><br>list.add(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-comment">//通过反射获取运行期，list的add方法</span><br>Class&lt;? extend List&gt; clazz = list.getClass();<br><span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br><span class="hljs-comment">//通过反射获取的add方法可以往Integer的list中添加string</span><br>add.invoke(list, <span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-x3D-x3D-和equals-的区别"><a href="#7-x3D-x3D-和equals-的区别" class="headerlink" title="7. &#x3D;&#x3D;和equals()的区别"></a>7. &#x3D;&#x3D;和equals()的区别</h3><ul><li><p>&#x3D;&#x3D;：比较的是值，若是基本数据类型，即直接比较它们的值是否相等；若是比较对象，因为引用变量的值是对象的地址，即比较的是对象的地址是否相同。</p></li><li><p>equals：它的作用是比较两个对象是否相等，不能用于比较基本数据类型变量。equals方法存在于Object类中，而Object类是所有类的父类，所有说所有的类都有equals方法。</p><blockquote><p>类的equals方法可以重写，重写即是定义规则使用&#x3D;&#x3D;比较对象的属性，来判断两个对象是否相等。</p><p>若没有重写则使用Object的默认equals方法，比较两个对象的地址，即和&#x3D;&#x3D;一样。</p></blockquote></li></ul><h3 id="8-hashCode-与equals"><a href="#8-hashCode-与equals" class="headerlink" title="8. hashCode()与equals()"></a>8. hashCode()与equals()</h3><ol><li><p>hashCode()介绍：</p><blockquote><p>hashCode()的作用是获取哈希码，也称为散列码；它返回一个int整数，用于确定对象在哈希表中的索引位置。</p></blockquote></li><li><p>为什么要有hashCode？</p><blockquote><p> 减少equals的使用次数。若要将对象加入HashSet，首先会计算对象的hashcode，与其他已加入的对象的hashcode值比较，若没有重复的hashcode，则没有重复的对象。若有重复的hashcode，则使用equals方法来确定对象是否真的相同。若是hashcode相同的不同对象，则会将后加入的对象散列到其他位置</p></blockquote></li><li><p>为什么重写equals时必须重写hashCode方法？</p><blockquote><p>hashCode方法要实现equals方法认定相等的对象返回相同的hashcode值。若是默认的hashCode方法，使用的是对象地址转换的hashcode值，但是两个不同的对象地址不同，但是它们可以是相等的。若使用默认的Object类的hashCode方法则相等的对象有不同的hashcode值</p></blockquote></li><li><p>为什么hashcode值相等的对象不一定相等？</p><blockquote><p>hash碰撞</p></blockquote></li></ol><h3 id="9-获取键盘输入"><a href="#9-获取键盘输入" class="headerlink" title="9. 获取键盘输入"></a>9. 获取键盘输入</h3><ol><li><p>通过Scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> input.nextLine();<br>input.close();<br></code></pre></td></tr></table></figure></li><li><p>通过BufferedReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferReader</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> input.readLine();<br></code></pre></td></tr></table></figure></li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="1-Java中有几种基本数据类型-以及其对应的包装类是什么-各自占用多少字节"><a href="#1-Java中有几种基本数据类型-以及其对应的包装类是什么-各自占用多少字节" class="headerlink" title="1. Java中有几种基本数据类型?以及其对应的包装类是什么?各自占用多少字节?"></a>1. Java中有几种基本数据类型?以及其对应的包装类是什么?各自占用多少字节?</h3><table><thead><tr><th>基本类型</th><th>包装类</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>short</td><td>Short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>int</td><td>Integer</td><td>32</td><td>4</td><td>0</td></tr><tr><td>long</td><td>Long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>float</td><td>Float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>Double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>char</td><td>Character</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>boolean</td><td>Boolean</td><td>1</td><td></td><td>false</td></tr></tbody></table><blockquote><p>long类型的数值一定要在数值后加上<strong>L</strong>，否则作为整型解析；</p><p>对于boolean，不同JVM不同实现，逻辑上是占一位，但实际中会考虑在计算机中的高效存储。</p></blockquote><h3 id="2-自动拆装箱"><a href="#2-自动拆装箱" class="headerlink" title="2.自动拆装箱"></a>2.自动拆装箱</h3><ul><li><p>是什么</p><blockquote><p>装箱：Integer i &#x3D; 10;</p><p>拆箱：int n &#x3D; i;</p></blockquote></li><li><p>原理</p><blockquote><p>在编译的时候自动调用包装类对应的方法来进行拆装箱</p><p>装箱：Integer.valueOf(int)</p><p>拆箱：Integer.intValue()</p></blockquote></li></ul><h3 id="3-包装类的常量池"><a href="#3-包装类的常量池" class="headerlink" title="3.包装类的常量池"></a>3.包装类的常量池</h3><p>常量池技术的意义：</p><blockquote><p>在缓存数据范围内的包装类，新建的多个相同数值的包装类会指向同一个地址</p><p>浮点数类型包装类并没有实现常量池技术</p></blockquote><ul><li><p>整型：Byte、Short、Integer、Long</p><blockquote><p>这四种包装类拆创建了数值[-128, 127]的相应类型的缓存数据</p></blockquote></li><li><p>Character</p><blockquote><p>创建了[0, 127]范围的缓存数据</p></blockquote></li><li><p>Boolean</p><blockquote><p>直接返回True Or False</p></blockquote></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-为什么Java中只有值传递？"><a href="#1-为什么Java中只有值传递？" class="headerlink" title="1.为什么Java中只有值传递？"></a>1.为什么Java中只有值传递？</h3><p>程序设计语言中的一些术语：</p><blockquote><ul><li><p>按值调用（call by value）：表示方法接收的是调用者提供的值</p></li><li><p>按引用调用（call by reference）：表示方法接收的是调用者提供的变量地址</p></li></ul></blockquote><p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p>Java中方法参数的使用情况：</p><blockquote><ul><li>一个方法不能修改一个基本数据类型的参数（数值型或布尔型）</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用另一个新的对象</li></ul></blockquote><h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h3><blockquote><p>重载：同一个方法名，根据不同的输入数据，做出不同的处理</p><p>重写：子类继承父类的方法，若子类要对于相同的数据，做出与父类不同的响应的时候，要重写父类方法</p></blockquote><h4 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h4><ul><li><strong>方法的签名</strong>包括方法名和参数类型</li><li>重载发生在同一个类中，方法名相同，参数不同（类型、个数、顺序），重载的方法可以有不同的返回值和访问修饰符</li><li>方法签名不包括方法的返回类型，所以说不能存在方法签名相同，但是返回类型不同的方法。</li></ul><h4 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h4><ul><li>重写发生在运行期</li><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围不超过父类，访问修饰符范围不低于父类。</li><li>若父类方法范文修饰符为 private&#x2F;final&#x2F;static 则子类不能重写该方法，但是被static修饰的方法能够被再次声明</li><li>构造方法无法被重写</li></ul><table><thead><tr><th>区别点</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类中</td><td>子类中</td></tr><tr><td>参数</td><td>必须修改</td><td>一定不能改</td></tr><tr><td>返回类型</td><td>可修改</td><td>一定不能改</td></tr><tr><td>异常</td><td>可修改</td><td>可以减少或删除，一定不能抛出更广的异常</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>可以扩大范围吧范围，一定不能缩小</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table><h3 id="3-深拷贝VS浅拷贝"><a href="#3-深拷贝VS浅拷贝" class="headerlink" title="3.深拷贝VS浅拷贝"></a>3.深拷贝VS浅拷贝</h3><p>对于基本数据类型都一样进行值传递</p><p>对与引用数据类型：</p><ul><li>浅拷贝：拷贝原对象的引用</li><li>深拷贝：创建一个新的对象，并对原引用对象的数据进行复制，将新对象的引用拷贝</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h3><blockquote><p>面向过程就是分析出解决问题所需的步骤，然后使用函数把这些步骤一步一步实现，使用的时候依次调用。</p><p>面向对象就是把问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</p></blockquote><h3 id="2-构造器能够被重写"><a href="#2-构造器能够被重写" class="headerlink" title="2. 构造器能够被重写"></a>2. 构造器能够被重写</h3><blockquote><p>构造器不能被重写，但是可以被重载，所以说一个类中可以有多个构造器</p></blockquote><h3 id="3-关于构造方法"><a href="#3-关于构造方法" class="headerlink" title="3. 关于构造方法"></a>3. 关于构造方法</h3><h4 id="3-1-构造方法的作用？若类没有声明构造方法会怎样？"><a href="#3-1-构造方法的作用？若类没有声明构造方法会怎样？" class="headerlink" title="3.1 构造方法的作用？若类没有声明构造方法会怎样？"></a>3.1 构造方法的作用？若类没有声明构造方法会怎样？</h4><blockquote><p>构造方法的主要作用是完成类对象的初始化工作</p></blockquote><blockquote><p>若一个类没有声明构造方法，也就生成一个默认得无参构造方法，我们在创建对象得时候加一个空括号就是在调用这个无参构造方法。若我们添加了类的构造方法，那么就不会生成默认得无参构造方法。</p></blockquote><h4 id="3-2在调用子类构造方法之前会先调用父类的构造方法，其目的是？"><a href="#3-2在调用子类构造方法之前会先调用父类的构造方法，其目的是？" class="headerlink" title="3.2在调用子类构造方法之前会先调用父类的构造方法，其目的是？"></a>3.2在调用子类构造方法之前会先调用父类的构造方法，其目的是？</h4><blockquote><p>帮助子类完成初始化工作</p></blockquote><h4 id="3-3-在Java中定义一个无参构造方法的意义"><a href="#3-3-在Java中定义一个无参构造方法的意义" class="headerlink" title="3.3 在Java中定义一个无参构造方法的意义"></a>3.3 在Java中定义一个无参构造方法的意义</h4><blockquote><p>Java程序在执行子类的构造方法之前，若没有使用super显式地调用父类地构造方法，就会调用父类中地无参构造方法。若父类中没有无参构造方法，而且子类没有用super调用父类中特定的构造方法，则编译的时候就会出错。</p></blockquote><h4 id="3-4-构造方法的特性"><a href="#3-4-构造方法的特性" class="headerlink" title="3.4 构造方法的特性"></a>3.4 构造方法的特性</h4><ul><li>名字与类名相同</li><li>没有返回值，但是不能用void声明构造函数</li><li>构造方法子啊生成类时自动执行，无需调用</li></ul><h3 id="4-成员变量和局部变量的区别"><a href="#4-成员变量和局部变量的区别" class="headerlink" title="4. 成员变量和局部变量的区别"></a>4. 成员变量和局部变量的区别</h3><ul><li>语法形式：<ul><li>成员变量属于类，局部变量属于方法；</li><li>成员变量可以被public、private、static等修饰符修饰，局部变量不能。但是二者都可以被final修饰</li></ul></li><li>存储形式：<ul><li>若成员变量被static修饰，那么这个成员变量属于类，若没有，那么这个成员变量属于实例。</li><li>对象存储在堆内存，局部变量存储在栈内存</li></ul></li><li>生存时间：<ul><li>成员变量属于对象，随着对象的创建而存在</li><li>局部变量随着方法的调用而消失</li></ul></li><li>默认值：<ul><li>成员变量若没有被初值，则会以类型的默认值赋值（被final修饰的成员变量必须显式的赋值）</li><li>局部变量不会自动赋值</li></ul></li></ul><h3 id="5-对象实体与对象引用有何不同？"><a href="#5-对象实体与对象引用有何不同？" class="headerlink" title="5. 对象实体与对象引用有何不同？"></a>5. 对象实体与对象引用有何不同？</h3><ul><li>使用new运算符创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用在栈内存中）</li><li>一个对象引用可以指向0或1个对象；一个对象可以有n个引用指向它</li></ul><h3 id="6-对象相等与指向它们的引用相等的区别"><a href="#6-对象相等与指向它们的引用相等的区别" class="headerlink" title="6. 对象相等与指向它们的引用相等的区别"></a>6. 对象相等与指向它们的引用相等的区别</h3><p>对象相等比较的是对象的内容是否相等。而引用相等比较的是它们指向的内存地址时候相等。</p><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><p>封装就是把一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。可以提供一些可以被外界访问的方法来操作属性。</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h3><p>不同类型的对象，相互之间经常有一定数量的共同点，与此同时每个对象还拥有自己的额外特性。例如小红同学和小明同学，它们都是学生拥有学生的特征（学号，班级等），但是每个同学由有各自不同的优点，比如小红数学好，小明力气大。</p><p>继承是使用已经存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，但是不能选择性地继承父类。</p><p>通过使用继承，可以快速地创建新地类，可以提高代码地重用，程序的可维护性，节省大量创建新类的时间，提高开发效率。</p><p>关于继承：</p><ul><li><strong>继承</strong>，子类拥有父类对象的所有属性和方法（包括私有的属性和方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。</li><li><strong>拓展</strong>，子类可以拥有自己的属性和方法，即子类可以对父类进行拓展。</li><li><strong>重写</strong>，子类可以用自己的方式实现父类的方法。</li></ul><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h3><p>多态表示一个对象具有多种状态。具体表现为父类的引用指向子类的实例。</p><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有 <strong>继承&#x2F;实现</strong> 的关系；</li><li>对象类型不可变，引用类型可变；</li><li>方法具有多态性，属性不具有多态性；</li><li>引用类型不能调用 ”只在子类存在但是在父类不存在的“ 方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆写的方法。</li></ul><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h4 id="1-为什么在静态方法内调用一个非静态成员是非法的？"><a href="#1-为什么在静态方法内调用一个非静态成员是非法的？" class="headerlink" title="1. 为什么在静态方法内调用一个非静态成员是非法的？"></a>1. 为什么在静态方法内调用一个非静态成员是非法的？</h4><p>因为静态方法可以不通过类调用，不通过对象调用，而非静态成员存在与对象中，所以说在静态方法中，不能访问&#x2F;调用其他非静态成员。</p><h4 id="2-静态方法和实例方法的区别"><a href="#2-静态方法和实例方法的区别" class="headerlink" title="2. 静态方法和实例方法的区别"></a>2. 静态方法和实例方法的区别</h4><ul><li>调用，在外部调用静态方法时，可以使用 ”类名.方法名“ 和 ”对象名.方法名” 的方式访问。也就是说，静态方法的调用无需创建对象。</li><li>类成员访问范围，静态方法只能访问本类的静态成员，即（静态成员变量和静态方法）。</li></ul><h4 id="3-常见修饰符总结"><a href="#3-常见修饰符总结" class="headerlink" title="3.常见修饰符总结"></a>3.常见修饰符总结</h4><p><strong>3.1 修饰类：</strong></p><ul><li><p>访问权限修饰符</p><ul><li><p>public：完全开放</p></li><li><p>protected：同包及子类访问</p></li><li><p>default：同包访问</p></li><li><p>private：只能本类访问</p></li></ul></li><li><p>限定符</p><ul><li>abstract：指定为抽象类</li><li>final：指定为最终类，不可被继承</li></ul></li></ul><p><strong>3.2 修饰成员变量：</strong></p><ul><li><p>限定符</p><ul><li><p>static：类属性，可直接通过类名调用</p><blockquote><p>static 不能修饰普通类，但是可以用来<strong>修饰内部类</strong>，因为内部类时类的成员变量。若用static修饰内部类，可以直接使用new OuterClass.InnerClass()直接创建出来。</p></blockquote></li><li><p>final：该成员不能不重写，即定义常量</p><blockquote><p>final修饰的<strong>属性变量</strong>必须在定义或者构造函数中初始化</p><p>final修饰的<strong>局部变量</strong>在使用前赋值即可</p><p>通常与static一起使用以创建<strong>类常量</strong>，此时该变量必须在定义的时候进行初始化</p></blockquote></li><li><p><del>transient</del>：不许列化</p></li><li><p><del>volatile</del>：同步变量</p></li></ul></li></ul><p><strong>3.3修饰成员方法：</strong></p><ul><li><p>限定符</p><ul><li><p>static：类方法，可通过类名直接调用</p></li><li><p>final：方法不能被重写</p></li><li><p>abstract：抽象方法，没有方法体</p><blockquote><p>抽象方法不能被声明为final和static</p></blockquote></li><li><p><del>synchronized</del>：同步方法</p></li><li><p><del>native</del>：本地方法（集成其他语言的代码）</p></li></ul></li></ul><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范。</p><ul><li>接口的方法默认是public，抽象类可以有非抽象方法，抽象方法可以有的访问修饰符不能是privat，因为抽象方法就是为了被重写的，而private修饰的方法是无法被子类访问的，更不用说重写了。</li><li>接口中只能有static、final变量，不能有其他变量，抽象类中不一定。</li><li>一个类可以实现多个接口，但是只能继承一个类。接口本身可以实现多个接口。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-String、StringBuffer、StringBuilder区别？String为什么不可变？"><a href="#1-String、StringBuffer、StringBuilder区别？String为什么不可变？" class="headerlink" title="1. String、StringBuffer、StringBuilder区别？String为什么不可变？"></a>1. String、StringBuffer、StringBuilder区别？String为什么不可变？</h3><p>存储：</p><ul><li>String：使用final修饰的字符数组来保存字符串，因此String不可变。</li><li>StringBuilder和StringBuffer都继承自AbstractStringBuilder，使用字符串数组保存字符串，但是没有使用final修饰，所有保存的字符串可变</li></ul><p>线程安全：</p><ul><li><p>String不可变，可以理解为常量，所以说线程安全</p></li><li><p>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以说线程安全</p></li><li><p>StringBuilder没有对方法加锁，是非线程安全的</p><blockquote><p>String类型改变时会生成新的String对象，然后将指针指向新的String对象。</p><p>StringBuilder直接对对象本身修改。用多线程不安全的风险换10%左右的性能提升。</p></blockquote></li></ul><h3 id="2-Object类的常见方法"><a href="#2-Object类的常见方法" class="headerlink" title="2. Object类的常见方法"></a>2. Object类的常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于返回当前运行时对象的Class对象，使用final关键词修饰，故不允许子类重写</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br><br><span class="hljs-comment">//返回对象的哈希码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//默认比较两个对象地址是否相等，可重写自定义对象相等比较</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br><span class="hljs-comment">//用于创建并返回当前对象的一份拷贝。使用必须重写，Object类没有实现Cloneable接口，直接使用会抛错。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br><br><span class="hljs-comment">//默认返回类名@实例的哈希码的16进制的字符串</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//---------------------------线程相关-------------------------------------</span><br><br><span class="hljs-comment">//唤醒一个在此对象监视器上等待的线程</span><br>notify();<br><br><span class="hljs-comment">//唤醒所有在此对象监视器上等待的线程</span><br>notifyAll();<br><br><span class="hljs-comment">//暂停线程的执行。sleep方法没有释放锁，wait方法在暂停期间释放锁。</span><br>wait();<br><br><span class="hljs-comment">//实例被垃圾回收期回收的时候触发的操作</span><br>finalize();<br></code></pre></td></tr></table></figure><h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/gailan-01.png" alt="img"></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="/2022/09/04/Java%E5%9F%BA%E7%A1%80/npe-1.jpg" alt="img"></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-程序、线程、进程的基本概念和它们之间的关系"><a href="#1-程序、线程、进程的基本概念和它们之间的关系" class="headerlink" title="1. 程序、线程、进程的基本概念和它们之间的关系"></a>1. 程序、线程、进程的基本概念和它们之间的关系</h3><ul><li><p>程序：</p><blockquote><p>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中,也就是说程序是静态的代码。</p></blockquote></li><li><p>进程：（资源分配的最小单位）</p><blockquote><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此<strong>进程是动态的</strong>。</p><p>系统运行一个程序即是一个进程从创建、运行到消亡的过程。简单来看，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行，同时每个进程还占有某些系统资源，比如说CPU时间，内存空间，文件，输入输出设备的使用权等。</p></blockquote></li><li><p>线程：（系统调度的最小单位）</p><blockquote><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小很多，也正因为如此，线程也被称为轻量级进程。</p></blockquote></li></ul><p>关系：</p><p>当程序被执行时，将会被操作系统载入内存中。线程时进程划分成的更小的运行单位。线程和进程的最大不同在于基本各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一个角度来说进程属于操作系统的范畴，主要是同段时间内，可以同时执行一个以上的程序，而线程则是在一个同一程序内几乎同时执行一个以上的程序段</p><h3 id="2-线程的基本状态"><a href="#2-线程的基本状态" class="headerlink" title="2. 线程的基本状态"></a>2. 线程的基本状态</h3><blockquote><ul><li><p>NEW：初始状态</p><blockquote><p>线程被构建，但是还没调用start()方法</p></blockquote></li><li><p>RUNNABLE：运行状态</p><blockquote><p>Java线程将操作系统中的就绪和运行两种状态笼统地称为“运行中”</p></blockquote></li><li><p>BLOCKED：阻塞状态</p><blockquote><p>表示线程阻塞与锁</p></blockquote></li><li><p>WAITING：等待状态</p><blockquote><p>表示线程进入等待状态，进入该状态表示档期那线程需要等待其他线程做出一些特定动作（通知或中断）</p></blockquote></li><li><p>TIME_WAITING：超时等待状态</p><blockquote><p>该状态不同于WAITING，它是可以在指定地时间自行返回地</p></blockquote></li><li><p>TERMINATED：终止状态</p><blockquote><p>表示当前线程已经执行完毕</p></blockquote></li></ul></blockquote><h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="1-Java中的IO流分为几种"><a href="#1-Java中的IO流分为几种" class="headerlink" title="1. Java中的IO流分为几种"></a>1. Java中的IO流分为几种</h3><p>划分方式：</p><blockquote><p><strong>流的流向分</strong>：输入流和输出流</p><p><strong>操作单元</strong>：字节流和字符流</p><p><strong>流的角色</strong>：节点流和处理流</p></blockquote><p>IO流的派生抽象基类</p><blockquote><p>InputStream&#x2F;Reader：输入流 + 字节流&#x2F;字符流</p><p>OutputStream&#x2F;Writer：输出流 + 字节流&#x2F;字符流</p></blockquote><h3 id="2-有了字节流为什么还要有字符流"><a href="#2-有了字节流为什么还要有字符流" class="headerlink" title="2. 有了字节流为什么还要有字符流"></a>2. 有了字节流为什么还要有字符流</h3><p>问题本质：</p><blockquote><p>不管是文件读写还是网络发送接收，信息的最小存储单位都是字节，那为什么I&#x2F;O流操作要分为字节流操作和字符流操作？</p></blockquote><p>回答：</p><blockquote><p>字符流是由Java虚拟机将字节转换得到的，问题就出在这个过程非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以，I&#x2F;O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果有音频、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p></blockquote><h3 id="3-BIO，BIO，AIO有什么区别"><a href="#3-BIO，BIO，AIO有什么区别" class="headerlink" title="3. BIO，BIO，AIO有什么区别"></a>3. BIO，BIO，AIO有什么区别</h3><ul><li><p>BIO（Blocking I&#x2F;O）：同步阻塞IO</p><blockquote><p>数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每个连接专注于自己的I&#x2F;O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的来连接或请求。但是，当面对十万甚至是百万级连接的时候，传统的BIO模型无能为力。因此需要一种更高效的I&#x2F;O处理模型来应对更高的并发量。</p></blockquote></li><li><p>NIO（Non-blocking&#x2F;New I&#x2F;O）：同步非阻塞IO</p><blockquote><p>在Java1.4引入NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持<strong>面向缓冲</strong>的，<strong>基于通道</strong>的I&#x2F;O操作方法。NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。</p></blockquote></li><li><p>AIO（Asynchronous I&#x2F;O）：异步非阻塞IO</p><blockquote><p>在Java7中引入了NIO的改进版NIO2，它是异步非阻塞的IO模型。异步IO是<strong>基于事件和回调机制实现</strong>的也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成、操作系统会通知相应的线程进行后续的操作。AIO是异步IO的许哦谢，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。</p><p><strong>AIO应用还不广泛。</strong></p></blockquote></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题 - 蜗牛大师 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://juejin.cn/post/6844903917835419661">聊一聊-JAVA 泛型中的通配符 T，E，K，V，？ - 掘金 (juejin.cn)</a></p></li><li><p><a href="https://developer.aliyun.com/article/799160#:~:text=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87,%E6%93%8D%E4%BD%9C%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E3%80%82">怎么理解面向对象和面向过程到底的本质区别？ .-阿里云开发者社区 (aliyun.com)</a></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL进阶</title>
    <link href="/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>在安装MySQL时已经指定了默认编码为UTF8，所以在创建数据库、创建表的时候都无需指定编码。</p><ul><li><p>几个关于编码的参数：</p><ul><li><p>character_set_client</p><blockquote><p>服务器用来解读用户发来数据所使用的编码</p></blockquote></li><li><p>character_set_results</p><blockquote><p>服务器发送给客户数据的编码</p></blockquote></li><li><p>character_set_connection</p></li><li><p>character_set_database</p></li><li><p>character_set_server</p></li><li><p>character_set_system</p></li></ul></li><li><p>查看数据库当前编码设置：<code>SHOW VARIABLES LIKE &#39;char%&#39;</code>;<img src="/2022/09/03/MySQL%E8%BF%9B%E9%98%B6/image-20220903103244158.png" alt="image-20220903103244158"></p></li><li><p>编码的修改：</p><ol><li><p>命令行临时修改</p><blockquote><p><code>set character_set_client=gbk;</code></p></blockquote></li><li><p>配置文件永久修改</p><blockquote><p>可以在my.ini配置文件中修改</p><p>default-character-set&#x3D;gbk</p><p>该项目会同时修改三个变量的编码：client、results、connection</p></blockquote></li></ol><p>注意：修改后要重启MySQL服务</p><ul><li><code>net stop mysql</code></li><li><code>net start mysql</code></li></ul></li></ul><h1 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h1><blockquote><p>备份：数据库 –&gt; SQL脚本</p><p>恢复：SQL脚本 –&gt; 数据库</p></blockquote><ol><li><p>数据库导出SQL脚本（备份数据库内容）</p><ul><li>命令：<code>mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本文件路径</code></li><li>注意:<ul><li>不要打分号，不要登录mysql，直接在cmd下运行</li><li>生成的脚本文件中不包含create database语句</li></ul></li></ul></li><li><p>从SQL脚本恢复至数据库</p><blockquote><p>方法一、不用登录数据库</p><p>命令：<code>mysql -u用户名 -p密码 数据库名&lt;用于恢复的脚本文件路径</code></p></blockquote><blockquote><p>方法二、登录数据库，并在选择对应数据库</p><p>命令：<code>source 用于恢复的脚本文件路径</code></p></blockquote></li></ol><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>  约束是添加到列上的，用来约束列</p><h2 id="一、主键约束：PRIMARY-KEY"><a href="#一、主键约束：PRIMARY-KEY" class="headerlink" title="一、主键约束：PRIMARY KEY"></a>一、主键约束：PRIMARY KEY</h2><ul><li>主键特点：<strong>非空、唯一、被引用</strong></li></ul><blockquote><p>当表的某一列被指定为主键后，该列就不能为空，不能有重复着值出现。</p></blockquote><ul><li><p>主键的创建与删除</p><ul><li><p>创建表时指定主键：(指定sid为主键列，即为sid列添加主键约束)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE stu(<br>sidCHAR(6) PRIMARY KEY,<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE stu(<br>sidCHAR(6),<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>PRIMARY KEY(sid)<br>);<br></code></pre></td></tr></table></figure></li><li><p>修改表时指定主键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE stu ADD PRIMARY KEY(sid);<br></code></pre></td></tr></table></figure></li><li><p>删除主键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE stu DROP PRIMARY KEY;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>主键自增长</p><ul><li><p>设置主键自增长</p><ol><li><p>在创建表时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE stu(<br>sidINT PRIMARY KEY AUTO_INCREMENT,<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10),<br>);<br></code></pre></td></tr></table></figure></li><li><p>在修改表时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE stu MODIFY sid INT AUTO_INCREMENT;<br></code></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h2 id="二、非空约束：NOT-NULL"><a href="#二、非空约束：NOT-NULL" class="headerlink" title="二、非空约束：NOT NULL"></a>二、非空约束：NOT NULL</h2><h2 id="三、唯一约束：UNIQUE"><a href="#三、唯一约束：UNIQUE" class="headerlink" title="三、唯一约束：UNIQUE"></a>三、唯一约束：UNIQUE</h2><h2 id="四、外键约束：CONSTRAINT-FOREIGN-KEY-REFERENCES"><a href="#四、外键约束：CONSTRAINT-FOREIGN-KEY-REFERENCES" class="headerlink" title="四、外键约束：CONSTRAINT | FOREIGN KEY | REFERENCES"></a>四、外键约束：CONSTRAINT | FOREIGN KEY | REFERENCES</h2><ul><li><p>添加外键约束：</p><ul><li><p>创建时添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CREATE TABLE 表名(<br>    主键列名 INT PRIMARY KEY AUTO_INCREMENT,<br>    列名1 VARCHAR(50),<br>    外键列名 INT,<br>    CONSTRAINT 外键约束名 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表中的关联列)<br>);<br></code></pre></td></tr></table></figure></li><li><p>更新时添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">ALTER TABLE 表名 ADD CONSTRAINT 外键约束名 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表中的关联列);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>外键特点：</p><ul><li>可为NULL</li><li>可重复</li><li>必须在关联表中关联列中存在。</li></ul></li></ul><h1 id="模型与关系"><a href="#模型与关系" class="headerlink" title="模型与关系"></a>模型与关系</h1><h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><ul><li><p>对象模型：</p><ul><li>在java中是domain</li><li>可以双向关联，而且引用的是对象，而不是一个主键</li></ul></li><li><p>关系模型：</p><ul><li>在数据库中是表</li><li>只能多方引用一方，而且引用的只是主键，而不是一整行记录</li></ul></li></ul><p>当我们要完成一个软件系统时，需要把系统中的实体抽取出来，形成概念模型。例如部门、员工都是系统中的实体。</p><ul><li><p><strong>实体之间的关系：</strong></p><ul><li><p>一对多（最常见）</p><blockquote><p>部门与员工，一个部门中有多个员工，而每个员工只属于一个部门。其中员工是多方，部门是一方。</p></blockquote></li><li><p>一对一</p><blockquote><p>夫妻，老公、老婆之间就是一对一的关系。</p></blockquote></li><li><p>多对多</p><blockquote><p>老师与学生，一个老师对应对个学生，一个学生也有多个老师</p></blockquote></li></ul></li></ul><p>概念模型中的实体最终会成为Java中的类、数据库中的表。类使用成员变量来完成关系，一般都是<strong>双向关联</strong>。</p><ul><li><p>一对多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> Department department;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span> &#123;<br><span class="hljs-keyword">private</span> List&lt;Employee&gt; employee;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>一对一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br>    <span class="hljs-keyword">private</span> Wife wife;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wife</span> &#123;<br>    <span class="hljs-keyword">private</span> Husband husband;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多对多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Teacher&gt; teacher;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Student&gt; student;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul><li><p>一对一关系：</p><blockquote><p>从表的主键作为外键关联主表的主键</p></blockquote><p>husband不做处理，将wife中的主键作为外键关联到husband的主键。从而实现一对一的关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE husband(<br>hid INT PRIMARY AUTO_INCREMENT,<br>    hname VARCHAR(50)<br>);<br><br>CREATE TABLE wife(<br>wid INT PRIMARY KEY AUTO_INCREMENT,<br>    wname VARCHAR(50),<br>    CONSTRAINT fk_wife_husband FOREIGN KEY(wid) REFERENCES husband(hid);<br>);<br></code></pre></td></tr></table></figure></li><li><p>多对多关系</p><blockquote><p>使用中间表 (关联表)</p></blockquote><p>师生关系，创建一个学生表，一个老师表，在创建一个师生关系表，其中一个键为学生，一个键为老师，分别使用外键关联到学生表，老师表。相当与将师生关系抽离出来单独使用一张表来存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE student(<br>sid INT PRIMARY KEY,<br>    ...<br>);<br>CREATE TABLE teacher(<br>tid INT PRIMARY KEY,<br>    ...<br>);<br><br>CREATE TABLE stu_tea(<br>sid INT,<br>    tid INT,<br>    ADD CONSTRAINT fk_stu_tea_sid FOREIGN KEY(sid) REFERENCES student(sid),<br>    ADD CONSTRAINT fk_stu_tea_tid FOREIGN KEY(tid) REFERENCES teacher(tid)<br>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="一、合并结果集"><a href="#一、合并结果集" class="headerlink" title="一、合并结果集"></a>一、合并结果集</h2><blockquote><ul><li>要求被合并的表，列的类型和列数相同（即两张表结构完全相同）</li><li>合并结果集语法<ul><li>UNION，在合并的时候去除重复行</li><li>UNION，不去除重复行</li></ul></li></ul></blockquote><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM a<br>UNION ALL<br>SELECT * FROM b;<br></code></pre></td></tr></table></figure><h2 id="二、连接查询"><a href="#二、连接查询" class="headerlink" title="二、连接查询"></a>二、连接查询</h2><ul><li><p><strong>内连接</strong></p><ul><li><p>方言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * <br>FROM 表1 别名一，表2 别名2 <br>WHERE 别名1.xx=别名2.xx;<br></code></pre></td></tr></table></figure><blockquote><ul><li>若没有WHERE子句，那么查询出来的结果个数成为笛卡尔积，即表一中的每一项分别与表二中的每一项匹配生成表，即最终共的结果数目为：表一数据个数*表二数据个数</li><li>WHERE子句的作用就是去笛卡尔积，一般使用表一中对应的连接的内键和外键来去笛卡尔积</li></ul></blockquote></li><li><p>标准：<strong>INNER JOIN | ON</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * <br>FROM 表1 别名一 INNER JOIN 表2 别名2 <br>ON 别名1.xx=别名2.xx;<br></code></pre></td></tr></table></figure></li><li><p>自然：<strong>NATRURAL JOIN</strong></p><blockquote><p>自然连接会在两张表中寻找名字相同的列自动进行匹配，相当于自动完成<code>ON 别名1.xx=别名2.xx</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * <br>FROM 表1 别名一 NATURAL JOIN 表2 别名2;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>外连接</strong></p><blockquote><p>外连接有一主一次，主表中的所有记录不论是否满足条件，都会打印出来，主表中没有对应的次表项，那么对应的次表条目使用NULL填充</p></blockquote><ul><li>左外连接：<strong>LEFT OUTER JOIN</strong></li><li>右外连接：<strong>RIGHT OUTER JOIN</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT e.ename, e.sal IFNULL(d.dname, &#x27;无部门&#x27;) AS dname<br>FROM emp e LEFT OUTER JOIN dept d<br>ON e.deptno=d.depton;<br></code></pre></td></tr></table></figure></li></ul><h2 id="三、子查询"><a href="#三、子查询" class="headerlink" title="三、子查询"></a>三、子查询</h2><ul><li><p>不同子查询结果的应用：</p><ul><li><p>多行多列</p><blockquote><p>FROM后，子查询的结果作为用于查询的表</p></blockquote></li><li><p>单行单列</p><blockquote><p>WHERE后，子查询的结果作为过滤条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT *<br>FROM emp<br>WHERE sal=(SELECT MAX(SAL) FROM emp);<br></code></pre></td></tr></table></figure><p>查询本公司工资最高的员工的详细信息，条件为工资最高，最高工资要使用MAX()查询</p></blockquote></li><li><p>多行单列：<strong>IN | ALL | ANY</strong></p><blockquote><p>WHERE后，与IN\ALL\ANY一起，作为搜索条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">    &gt;SELECT *<br>FROM emp<br>WHERE sal &gt; ALL (SELECT sal FROM emp WHERE deptno=30);<br></code></pre></td></tr></table></figure><p>搜索工资大于30部门所有员工工资的员工</p></blockquote></li><li><p>单行多列</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT *<br>FROM emp<br>WHERE (job, depno) IN (SELECT job, depno FROM emp WHERE ename=&#x27;殷天正&#x27;)；<br></code></pre></td></tr></table></figure><p>查询工资和部门与殷天正完全相同的员工</p></blockquote></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL入门笔记</title>
    <link href="/2022/09/02/MySQL%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/02/MySQL%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><ol><li><p>什么是 SQL</p><blockquote><p>结构化查询语言（Structured Query Language）</p></blockquote></li><li><p>SQL 的作用</p><blockquote><p>客户端使用SQL来操作服务器</p></blockquote></li><li><p>语法规范</p><blockquote><ul><li>SQL语句可以在单行或多行书写, 以<strong>分号结尾</strong></li><li>可以使用空格和缩进来增强语句的<strong>可读性</strong></li><li>MySQL不区分大小写, 但是<strong>建议使用大写</strong></li></ul></blockquote></li><li><p>SQL语句分类</p><blockquote><ul><li><p>DDL(Data Definition Language): 数据定义语言</p><blockquote><p>创建、删除、修改：库、表结构</p></blockquote></li><li><p>DML(Data Manipulation Language): 数据操作语言</p><blockquote><p>增、删、改：表记录</p></blockquote></li><li><p>DQL(Data Query Language):  数据查询语言</p><blockquote><p>用来查询记录（数据）</p></blockquote></li><li><p>DCL(Data Control Language): 数据控制语言</p><blockquote><p>用来定义访问权限和安全级别（用户创建，以及用户的权限管理）</p></blockquote></li></ul></blockquote></li></ol><h1 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h1><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><ul><li>查看所有数据库：<code>SHOW DATABASES</code></li><li>切换（选择要操作的）数据库：<code>USE 数据库名</code></li><li>创建数据库：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名</code> </li><li>删除数据库：<code>DROP DATABASE [IF EXISTS] 数据库名</code></li><li>修改数据库编码：<code>ALTER DATABASE 数据库名CHARACTER SET 编码名</code></li></ul><h2 id="数据类型（列数据类型）"><a href="#数据类型（列数据类型）" class="headerlink" title="数据类型（列数据类型）"></a>数据类型（列数据类型）</h2><ul><li><p>int：整型</p></li><li><p>double：浮点型</p><blockquote><p>double(5, 2)表示最多5位，其中必须有两位小数</p></blockquote></li><li><p>decimal：浮点型</p><blockquote><p>十进制浮点类型，不会出现浮点数精度丢失问题，在跟钱相关的方面使用该类</p></blockquote></li><li><p>char：固定长度字符串</p><blockquote><p>char(255)，数据长度不足，则会补足到指定长度</p></blockquote></li><li><p>varchar：可变长字符串类型</p><blockquote><ul><li><p>varchar(65535)，最大指定长度为65535，当数据长度不足指定长度的时候，不用补足到指定长度。</p></li><li><p>需要使用额外的一个字节来记录数据长度</p></li></ul></blockquote></li><li><p>text：字符串类型</p><blockquote><p>MySQL的方言，在标准SQL中为clob</p></blockquote><ul><li>tinytext：256B</li><li>text：64K</li><li>mediumtext：16M</li><li>longtext：4G</li></ul></li><li><p>blob：字节类型</p><ul><li>varblob</li><li>tinyblob</li><li>blob</li><li>mediumblob</li><li>longblob</li></ul></li><li><p>时间相关</p><ul><li>date：日期类型，格式：yyyy- MM-dd;</li><li>time：时间类型， 格式：hh:mm:ss；</li><li>timestamp：时间戳类型：</li></ul></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><p><strong>注意：所有对表的操作都要在选定数据库之后</strong></p><ol><li><p>创建表</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE [IF NOT EXISTS] 表名(<br>列名 列类型,<br>    ...<br>    列名 列类型,<br>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>查看表</p><blockquote><ul><li><p>查看当前数据库中左右表名称：<code>SHOW TABLES;</code></p></li><li><p>查看指定表的创建语句：<code>SHOW CREATE TABLE 表名;</code>(了解)</p></li><li><p>查看表结构： <code>DESC 表名;</code></p></li></ul></blockquote></li><li><p>删除表：<code>DROP TABLE 表名;</code></p></li><li><p>修改表：<strong>ALTER</strong></p><ul><li><p>添加列：<strong>ADD</strong></p><blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD(<br>列名 列类型,<br>    ...<br>    列名 列类型,<br>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>删除列：<strong>DROP</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 DROP 列名;<br><br>  - 修改列类型：**MODIFY**<br><br>```mysql<br>ALTER TABLE 表名 MODIFY 列名 列类型;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>修改列名：<strong>CHANGE</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 CHANGE  原列名 新列名 列类型；<br></code></pre></td></tr></table></figure></blockquote></li><li><p>修改表名称：<strong>RENAME</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 原表名 RENAME TO 新表名<br></code></pre></td></tr></table></figure></blockquote></li></ul></li></ol><h1 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h1><blockquote><p>先了解一个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SLEECT * FROM 表名<br></code></pre></td></tr></table></figure><ul><li>显示所有数据库：<code>SHOW DATABASES;</code></li><li>选择数据库：<code>USE 数据库名;</code></li><li>显示数据库中所有表：<code>SHOW TABLES;</code></li></ul></blockquote><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><ol><li>给出插入列</li></ol><blockquote><ul><li>列名与列值对应，不一定要按照表中列顺序，若插入的是部分列，那么未填写的列为null值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 表名(<br>列名1,列名2，列名3<br>)<br>VALUES(<br> 列对应值1，列对应值2，对应列值3<br>);<br></code></pre></td></tr></table></figure></blockquote><ol start="2"><li>不给出插入列</li></ol><blockquote><ul><li>默认插入所有列，必须根据表中列的排序给出所有列值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INT 表名 VALUES(<br>列值1，列值2，列值3<br>);<br></code></pre></td></tr></table></figure></blockquote><p><strong>注意：</strong>MySQL中的字符串<strong>必须使用单引号</strong></p><h2 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h2><p>基本语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UPDATE</span> 表名 SET 列名<span class="hljs-number">1</span>=列值<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span>=列值<span class="hljs-number">2</span><span class="hljs-meta"> [WHERE 条件]</span><br></code></pre></td></tr></table></figure><p>注意：若没有WHERE条件，那么这个表中的所有行都会被修改。WHERE 条件用于选择需要修改的行。</p><p>条件：</p><blockquote><p>运算符</p><ul><li>**&#x3D;**、!&#x3D;(&lt;&gt;等价)&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;</li><li>区间：BETWEEN…AND…</li><li>枚举：IN(…)</li><li>IS NULL</li><li>连接多个条件：NOT、OR、AND</li></ul></blockquote><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>基本语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM 表名 [WHERE 条件]<br></code></pre></td></tr></table></figure><p>注意：不加WHERE整个表中数据都会被删除（表还在）</p><h1 id="DCL（数据控制语言）"><a href="#DCL（数据控制语言）" class="headerlink" title="DCL（数据控制语言）"></a>DCL（数据控制语言）</h1><p>对于DCL的理解：</p><blockquote><ul><li>一个项目创建一个用户，一个项目对应的数据库只有一个</li><li>这个用户只拥有该数据库的权限，无法操作其他数据库</li></ul></blockquote><h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1. 创建用户"></a>1. 创建用户</h2><p>用户只能在指定IP登录</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 用户名@IP地址 IDENTIFIED BY &#x27;密码&#x27;;<br></code></pre></td></tr></table></figure></blockquote><p>用户可以在任意IP登录</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 用户名@IP&#x27;*&#x27; IDENTIFIED BY &#x27;密码&#x27;;<br></code></pre></td></tr></table></figure></blockquote><h2 id="2-给用户授权"><a href="#2-给用户授权" class="headerlink" title="2. 给用户授权"></a>2. 给用户授权</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">GRANT 权限1,...,权限n ON 数据库.* TO 用户名@IP地址;<br></code></pre></td></tr></table></figure><ul><li><p>将<strong>指定数据库</strong>的<strong>指定权限</strong>赋予<strong>指定用户</strong></p></li><li><p>要素：权限、数据库、用户</p><blockquote><p>权限：</p><ul><li><p>CREATE、ALTER、DROP、INSERT、UPDATE、DELETE、SELECT</p></li><li><p>ALL表示所有权限</p></li></ul></blockquote></li></ul><h2 id="3-撤销授权"><a href="#3-撤销授权" class="headerlink" title="3. 撤销授权"></a>3. 撤销授权</h2><p>操作基本同授权一样，使用REVOKE替换GRANT即可</p><h2 id="4-查看权限"><a href="#4-查看权限" class="headerlink" title="4. 查看权限"></a>4. 查看权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GRANTS FOR 用户名@IP地址;<br></code></pre></td></tr></table></figure><h2 id="5-删除用户"><a href="#5-删除用户" class="headerlink" title="5. 删除用户"></a>5. 删除用户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP USER 用户名@IP地址<br></code></pre></td></tr></table></figure><h1 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h1><h2 id="一、基础查询"><a href="#一、基础查询" class="headerlink" title="一、基础查询"></a>一、基础查询</h2><ul><li><strong>查询所有列（整张表）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名;<br></code></pre></td></tr></table></figure><h3 id="1-列控制"><a href="#1-列控制" class="headerlink" title="1. 列控制"></a>1. 列控制</h3><ol><li>查询指定列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT 列名1,列名2 FROM 表名;<br></code></pre></td></tr></table></figure><ol start="2"><li>完全重复的记录只有一次</li></ol><blockquote><p>当查询结果中多行记录一摸一样时，只显示一行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT DISTINCT 列名 FROM 表名;<br></code></pre></td></tr></table></figure><ol start="3"><li>列运算</li></ol><ul><li><p>数量类型的列可以做加减乘除运算</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名*1.5 FROM 表名;<br>SELECT 列名1+列名2 FROM 表名;<br></code></pre></td></tr></table></figure></li><li><p>字符串类型的列可以做连续运算</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT CONCAT(&#x27;S&#x27;, 列名) FROM 表名;<br></code></pre></td></tr></table></figure></li></ul><blockquote><ul><li>转换NULL值</li></ul>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT IFNULL (列名1,0)+1000 FROM 表名;<br></code></pre></td></tr></table></figure><blockquote><p>IFNULL(列名1，0) 表示，如果列1中的值为NULL，则当为0计算</p></blockquote><ul><li>给列起别名</li></ul><blockquote><p>在使用列运算后自动生成的列名称不直观，可以给列名起个别名(<strong>AS可省略</strong>)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT IFNULL (列名1,0)+1000 AS 奖学金 FROM 表名;<br></code></pre></td></tr></table></figure></blockquote><h3 id="2-行控制"><a href="#2-行控制" class="headerlink" title="2. 行控制"></a>2. 行控制</h3><ol><li><p>条件查询: <strong>WHERE</strong></p><blockquote><p>同前面的UPDATE和DELETE语句一样，使用WHERE子句来控制记录</p></blockquote></li><li><p>模糊查询: <strong>LIKE</strong></p><blockquote><p>用来对<strong>字符串列</strong>进行模糊查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WHERE 列名 LIKE &#x27;李_&#x27;;<br></code></pre></td></tr></table></figure><ul><li>_下划线，用来匹配一个字符</li><li>%百分号，用来匹配0-n个字符</li></ul></blockquote></li></ol><h3 id="二、排序：ORDER-BY"><a href="#二、排序：ORDER-BY" class="headerlink" title="二、排序：ORDER BY"></a>二、排序：ORDER BY</h3><ol><li><p>默认升序: <strong>ASC</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名；<br></code></pre></td></tr></table></figure></li><li><p>降序排序: <strong>DESC</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名 DESC;<br></code></pre></td></tr></table></figure></li><li><p>多条件排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 ORDER BY 列名1 DESC, 列名2 ASC;<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、聚合函数"><a href="#三、聚合函数" class="headerlink" title="三、聚合函数"></a>三、聚合函数</h2><ol><li><p>查询有效行数：<strong>COUNT()</strong></p><blockquote><p>括号中可以是列名、*、数字，其中*和数字等效</p></blockquote></li><li><p>计算</p><blockquote><p> 计算中的括号中只能填写数字列</p></blockquote><ul><li>总和：<strong>SUM()</strong></li><li>最大值：<strong>MAX()</strong></li><li>平均值：<strong>AVG()</strong></li></ul></li><li><p>综合计算</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT COUNT(*),SUM(列名1)，MAX(列名2) FROM 表名;<br></code></pre></td></tr></table></figure></li></ol><h2 id="四、分组查询：GROUP-BY-HAVING"><a href="#四、分组查询：GROUP-BY-HAVING" class="headerlink" title="四、分组查询：GROUP BY|HAVING"></a>四、分组查询：GROUP BY|HAVING</h2><blockquote><ul><li>分组</li></ul><blockquote><p>将一列中值相同的行分为一组</p></blockquote><ul><li>查询</li></ul><blockquote><p>分组查询不能使用个人信息查询，都是使用聚合信息进行查询</p></blockquote></blockquote><p>分组查询过滤</p><ul><li><p>分组前过滤条件（对整张表进行过滤）</p><blockquote><p>WHERE</p><p>在GROUP BY之前</p></blockquote></li><li><p>分组后过滤条件（对分组查询的结果过滤）</p><blockquote><p>HAVING</p><p>在GROUP BY之后</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名1(展示列), 聚合函数 FROM 表名 WHERE 分组前条件 GROUP BY 列名2(分组列) HAVING 分组后条件 ORDER BY 列名3(排序列)<br></code></pre></td></tr></table></figure><blockquote><p>同一SQL语句中，关键字使用顺序(执行顺序也是如此)：</p><ol><li>SELECT</li><li>FROM</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>ORDER BY</li></ol></blockquote><h2 id="五、LIMIT方言"><a href="#五、LIMIT方言" class="headerlink" title="五、LIMIT方言"></a>五、LIMIT方言</h2><p>LIMIT作用：</p><blockquote><ul><li>用来限定查询结果的起始行，以及总行数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM 表名 LIMIT a,b;<br></code></pre></td></tr></table></figure><p>从第a行开始查b行数据</p></blockquote><p>LIMIT应用：</p><blockquote><ul><li>用于分页查询</li></ul><p>若每页十行数据，那么如果要查第三页，语句如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM 表名 LIMIT 20,10;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL45讲笔记</title>
    <link href="/2022/09/02/MySQL45%E8%AE%B2/"/>
    <url>/2022/09/02/MySQL45%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="学习MySQL原理的意义"><a href="#学习MySQL原理的意义" class="headerlink" title="学习MySQL原理的意义"></a>学习MySQL原理的意义</h1><p>即使是MySQL的使用者，而非开发者，也需要理解MySQL的原理</p><ul><li>提升数据库的性能</li><li>更快速的定位并解决问题</li></ul><h1 id="一条MySQL语句是怎么执行的"><a href="#一条MySQL语句是怎么执行的" class="headerlink" title="一条MySQL语句是怎么执行的"></a>一条MySQL语句是怎么执行的</h1><h2 id="MySQL的基本架构"><a href="#MySQL的基本架构" class="headerlink" title="MySQL的基本架构"></a>MySQL的基本架构</h2><p><img src="/2022/09/02/MySQL45%E8%AE%B2/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p><h3 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><blockquote><p>管理连接，权限验证</p></blockquote><ul><li><p>数据库<strong>连接命令</strong>:  <code>mysql -h$ip -P$port -u$user -p</code></p></li><li><p>用户的<strong>权限</strong>在建立连接的时候获取, 对于已经成功建立连接的用户, 管理员再修改其权限, 不会影响当前连接的权限</p></li><li><p>连接没有操作就会处于**休眠(Sleep)**状态, 超过8个小时休眠, 会自动断开连接, 右参数wait_timeout控制</p></li><li><p>长连接与短连接</p><ul><li><p>长连接不需要频繁的建立连接, 而建立连接的过程比较复杂, 所以说<strong>尽量使用长连接</strong></p></li><li><p>MySQL在执行过程中临时使用的内存是管理在连接对象中的, 这些资源在连接断开的时候才会释放, 若全部使用长连接, 可能会导致内存占用过大, 被系统强行杀掉(OOM), 从现象上看就是MySQL异常重启</p><blockquote><p>解决办法:</p><ol><li>定期断开长连接。使用一段时间或者执行一个内存占用较大的查询后,断开连接，下一次查询的时候再重连。</li><li>重新初始化连接资源。在执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将来连接恢复至刚刚创建完时的状态。</li></ol></blockquote></li></ul></li></ul><h4 id="缓存器"><a href="#缓存器" class="headerlink" title="缓存器"></a>缓存器</h4><blockquote><p>已经被淘汰</p></blockquote><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><blockquote><p>词法分析，语法分析</p></blockquote><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><blockquote><p>执行计划生成,索引选择</p></blockquote><p>优化器实在表中有<strong>多个索引</strong>的时候，决定使用哪个索引，或者在一个语句有<strong>多个表关联</strong>的时候，决定各个表的连接顺序。</p><p>不同的执行顺序，执行的效率有所不同，优化器的作用就是选择执行顺序。</p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><blockquote><p>操作引擎, 返回结果</p></blockquote><ol><li><p>检查权限</p></li><li><p>打开表，根据表的引擎定义，区使用该引擎提供的接口</p></li></ol><p>执行器执行流程:</p><blockquote><ul><li>命令: <code>select * from T where ID=10;</code></li></ul><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</li></ol></blockquote><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul><li>InnoDB (默认)</li><li>MyISAM</li><li>Memory</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>表T没有字段K，但是执行<code>select * from T where k=1</code>，肯定会报错”不存在这个列”，这个错误实在哪个阶段报出来的？</p><blockquote><p>分析器阶段。在分析阶段，会判断语句是否正确，表是否存在，列是否存在。</p></blockquote></li></ul><h2 id="MySQL的日志系统"><a href="#MySQL的日志系统" class="headerlink" title="MySQL的日志系统"></a>MySQL的日志系统</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown入门</title>
    <link href="/2022/09/01/MarkDownBase/"/>
    <url>/2022/09/01/MarkDownBase/</url>
    
    <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. <strong>标题</strong></h3><blockquote><p># H1 </p><p>## H2</p><p>### H3</p><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3></blockquote><h3 id="2-粗体"><a href="#2-粗体" class="headerlink" title="2. 粗体"></a>2. <strong>粗体</strong></h3><blockquote><p>*<em>bold text</em>*</p><p><strong>bold text</strong></p></blockquote><h3 id="3-斜体"><a href="#3-斜体" class="headerlink" title="3. 斜体"></a>3. <strong>斜体</strong></h3><blockquote><p>*italicized text*</p><p><em>italicized text</em></p></blockquote><h3 id="4-引用块"><a href="#4-引用块" class="headerlink" title="4. 引用块"></a>4. <strong>引用块</strong></h3><blockquote><p>&gt; blockquote</p><blockquote><p>blockquote</p></blockquote></blockquote><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. <strong>有序列表</strong></h3><blockquote><ol><li>First item</li><li>Second item</li><li>Third item</li></ol></blockquote><h3 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6. 无序列表"></a>6. <strong>无序列表</strong></h3><blockquote><p>- First item</p><p>- Second item</p><p>- Third item</p><ul><li>First item</li><li>Second item</li><li>Third item</li></ul></blockquote><h3 id="7-代码"><a href="#7-代码" class="headerlink" title="7. 代码"></a>7. <strong>代码</strong></h3><blockquote><p>`code&#96;</p><p><code>code</code></p></blockquote><h3 id="8-分隔线"><a href="#8-分隔线" class="headerlink" title="8. 分隔线"></a>8. <strong>分隔线</strong></h3><blockquote><p>-–</p><hr></blockquote><h3 id="9-链接"><a href="#9-链接" class="headerlink" title="9. 链接"></a>9. <strong>链接</strong></h3><blockquote><p>[title](<a href="http://www.example.com/">http://www.example.com</a>)</p><p><a href="http://www.example.com/">title</a></p></blockquote><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10. 图片"></a>10. <strong>图片</strong></h3><blockquote><p>![alt text](<a href="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot;picture">https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot;picture</a> title”)</p><p><img src="/2022/09/01/MarkDownBase/googlelogo_color_272x92dp.png" alt="alt text" title="picture title"></p></blockquote><h2 id="二、扩展语法"><a href="#二、扩展语法" class="headerlink" title="二、扩展语法"></a>二、扩展语法</h2><h3 id="1-表格"><a href="#1-表格" class="headerlink" title="1. 表格"></a>1. <strong>表格</strong></h3><blockquote><p>| Syntax    | Description |<br>| ——— | ———– |<br>| Header    | Title       |<br>| Paragraph | Text        |</p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></blockquote><h3 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2. 代码块"></a>2. <strong>代码块</strong></h3><blockquote><p>`&#96;&#96;json<br>{<br>“firstname”: “John”,<br>“lastname”: “Smith”,<br>“age”: 25<br>}<br>`&#96;&#96;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;firstname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;lastname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="3-脚注"><a href="#3-脚注" class="headerlink" title="3. 脚注"></a>3. <strong>脚注</strong></h3><blockquote><p>Here’ s a sentence with a footnote.[^1]</p><p>[^1]:This is the footnote.</p></blockquote><p>Here’ s a sentence with a footnote.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="This is the footnote.">[1]</span></a></sup></p><h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4. 删除线"></a>4. <strong>删除线</strong></h3><blockquote><p>~~The world is flat.~~</p><p><del>The world is flat.</del></p></blockquote><h3 id="5-任务列表"><a href="#5-任务列表" class="headerlink" title="5. 任务列表"></a>5. <strong>任务列表</strong></h3><blockquote><p>- [x] Write the press release</p><p>- [ ] Update the website</p><p>- [ ] Contact the media</p><ul><li><input checked disabled type="checkbox"> Write the press release</li><li><input disabled type="checkbox"> Update the website</li><li><input disabled type="checkbox"> Contact the media</li></ul></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>This is the footnote.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="/2022/09/01/HexoBlogBuild/"/>
    <url>/2022/09/01/HexoBlogBuild/</url>
    
    <content type="html"><![CDATA[<ol><li><h1 id="Hexo博客-搭建-美化-使用"><a href="#Hexo博客-搭建-美化-使用" class="headerlink" title="Hexo博客 搭建+美化+使用"></a>Hexo博客 搭建+美化+使用</h1><h2 id="一、搭建"><a href="#一、搭建" class="headerlink" title="一、搭建"></a>一、搭建</h2><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h3><h4 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a>1.1 注意事项</h4><ul><li>命令可以使用Windows的<strong>cmd</strong>和<strong>git bash</strong>来完成，cmd可能会有一些问题，建议全部使用git bash执行</li><li>hexo版本差异大，网上一些配置信息基于2.x，注意区别</li><li>hexo中有两种_config.yml文件，一个hexo根目录下的,一个是各个theme目录下的</li></ul><h4 id="1-2-安装所需软件"><a href="#1-2-安装所需软件" class="headerlink" title="1.2 安装所需软件"></a>1.2 安装所需软件</h4><ul><li>node.js<ul><li>官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装后验证：<code>node -v</code></li></ul></li><li>git<ul><li>官网：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li><li>安装后验证：<code>git -v</code></li></ul></li><li>cnpm<ul><li>安装命令： <code>npm install -g cnpm –registry==https://registry.npm.taobao.org</code></li><li>安装后验证：<code>cnpm -v</code></li></ul></li><li>hexo<ul><li>安装命令：<code>cnpm install -g hexo-cli</code></li><li>安装后验证：<code>hexo -v</code></li></ul></li></ul><h3 id="2-配置GitHub"><a href="#2-配置GitHub" class="headerlink" title="2. 配置GitHub"></a>2. 配置GitHub</h3><h4 id="2-1-在GitHub上创建仓库"><a href="#2-1-在GitHub上创建仓库" class="headerlink" title="2.1 在GitHub上创建仓库"></a>2.1 在GitHub上创建仓库</h4><ol><li>创建一个以<strong>你的用户名.github.io</strong>的仓库</li><li>注意：我的用户名为xiang-4422，所以仓库为xiang-4422.githun.io，网站的访问地址就是<a href="http://xiang-4422.github.io/">http://xiang-4422.github.io</a>。由此可见，每个github账户只能创建一个这样可以直接使用域名访问的仓库。</li></ol><h4 id="2-2-绑定域名（可选）"><a href="#2-2-绑定域名（可选）" class="headerlink" title="2.2 绑定域名（可选）"></a>2.2 绑定域名（可选）</h4><ol><li>注册域名<ul><li>godaddy</li><li>阿里云</li></ul></li><li>绑定域名<ul><li>带www</li><li>不带www</li><li>无论域名是否带www，在访问的时候使用两种方式都能跳转</li></ul></li><li>域名配置<ul><li>方式一、CNAME<ul><li>CNAME填写域名，即<strong>用户名.github.io</strong></li></ul></li><li>方式二、A记录<ul><li>A记录填写IP</li><li>不带www的方式只能采用A记录，所以需要先ping一下网站的IP，然后到域名DNS设置页中，将A记录指向ping出来的IP</li></ul></li></ul></li></ol><h3 id="3-配置SSH免密登录"><a href="#3-配置SSH免密登录" class="headerlink" title="3. 配置SSH免密登录"></a>3. 配置SSH免密登录</h3><h4 id="3-1-获取本地的SSH公钥"><a href="#3-1-获取本地的SSH公钥" class="headerlink" title="3.1 获取本地的SSH公钥"></a>3.1 获取本地的SSH公钥</h4><ol><li>打开电脑文件夹，找到 C:\Users\用户名\.ssh 文件夹并删除</li><li>在 C:\Users\用户名 目录下右键打开Git Bash Here，输入命令<code>ssh-keygen -t rsa -C github邮件地址</code>生成.ssh密钥，输入后连敲三次回车</li><li>生成.ssh文件夹后，打开该文件夹，打开id_rsa.pub文件，复制其中内容</li></ol><h4 id="3-2-在GitHub中添加公钥"><a href="#3-2-在GitHub中添加公钥" class="headerlink" title="3.2 在GitHub中添加公钥"></a>3.2 在GitHub中添加公钥</h4><ol start="4"><li>GitHub主页 -&gt; SSH and GPG keys -&gt; New SSH key，将复制的内容粘贴进去，设置一个title，并保存</li></ol><h4 id="3-3-检查是否配置成功"><a href="#3-3-检查是否配置成功" class="headerlink" title="3.3 检查是否配置成功"></a>3.3 检查是否配置成功</h4><ul><li><p>命令：<code>$ ssh -T git@github.com</code></p></li><li><p>成功后的提示信息：Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.即配置成功</p></li></ul><h4 id="3-4-配置Git信息"><a href="#3-4-配置Git信息" class="headerlink" title="3.4 配置Git信息"></a>3.4 配置Git信息</h4><ul><li>命令：<code>$ git config –global user.name “GitHub用户名”</code></li><li>命令：<code>$ git config –global user.email “GitHub注册邮箱&quot;</code></li></ul><h3 id="4-使用hexo搭建博客"><a href="#4-使用hexo搭建博客" class="headerlink" title="4. 使用hexo搭建博客"></a>4. 使用hexo搭建博客</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><ol><li>在电脑中创建一个文件夹用于存放hexo的代码，作为hexo的根目录</li><li>在该文件夹中右键打开Git Bash Here，输入一下命令<ul><li><code>hexo init</code>: 初始化</li><li><code>hexo g</code>: 在public文件夹中生成相关html文件</li><li><code>hexo s</code>: 启动服务</li></ul></li><li>hexo g开启了本地预览服务，访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看。<ul><li>端口冲突问题解决：<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">https://www.runoob.com/w3cnote/windows-finds-port-usage.html</a></li></ul></li></ol><h4 id="4-2部署到GitHub个人主页"><a href="#4-2部署到GitHub个人主页" class="headerlink" title="4.2部署到GitHub个人主页"></a>4.2部署到GitHub个人主页</h4><ol><li>在hexo根目录下安装hexo-deployer-git插件<ul><li>安装命令：<code>npm install hexo-deployer-git -save</code></li></ul></li><li>编辑hexo根目录下的_config.yml文件，在文件末尾添加如下内容</li></ol><p><img src="/2022/09/01/HexoBlogBuild/8.png" alt="img"></p><ul><li>注意：其中repo中的内容为GitHub个人主页链接地址，如图：</li></ul><p><img src="/2022/09/01/HexoBlogBuild/9.png" alt="img"></p><ol start="3"><li>在根目录下使用命令：<code>hexo d</code>将本地blog推动到GitHub仓库<ul><li>可能需要username &amp; pwd</li><li>推送成功后，即可在浏览器中通过域名访问 <a href="https://xiang-4422.github.io/">https://xiang-4422.github.io/</a></li></ul></li></ol><h2 id="二、美化"><a href="#二、美化" class="headerlink" title="二、美化"></a>二、美化</h2><h3 id="1-更换主题"><a href="#1-更换主题" class="headerlink" title="1. 更换主题"></a>1. 更换主题</h3><ol><li><p>主题下载：</p><ul><li><p><a href="https://hexo.io/themes/">hexo官网</a>上有很多主题，我使用的是 fluid：<a href="https://github.com/fluid-dev/hexo-theme-fluid">GitHub仓库地址</a> | <a href="https://github.com/fluid-dev/hexo-theme-fluid">用户手册</a></p></li><li><p>到hexo根目录下使用Git Bash Here，输入命令<code>$ git clone 主题http链接 themes/主题名称</code>下载主题</p><p><img src="/2022/09/01/HexoBlogBuild/10.png" alt="img"></p></li><li><p>根目录中theme文件下就是博客的主题，可以下载多个，具体选择哪一个可以在hexo配置文件中配置</p></li></ul></li></ol><h3 id="2-使用主题"><a href="#2-使用主题" class="headerlink" title="2. 使用主题"></a>2. 使用主题</h3><ol><li>修改hexo配置文件<ul><li>打开hexo根目录下的_config.yml文件</li><li>找到theme: landscape项目，改为theme: 对应主题名</li><li>执行<code>hexo g</code>重新生成</li></ul></li><li>若出现问题依次执行下面命令<ul><li><code>hexo clean</code>清理public内容</li><li><code>hexo g</code>重新生成</li><li><code>hexo s</code>重新部署</li></ul></li></ol><h3 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h3><ul><li>根据使用主题对对应的配置文档进行主题配置</li><li>我使用过的是fluid：<a href="https://github.com/fluid-dev/hexo-theme-fluid">GitHub仓库地址</a> | <a href="https://github.com/fluid-dev/hexo-theme-fluid">用户手册</a></li></ul><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="1-写博客的步骤"><a href="#1-写博客的步骤" class="headerlink" title="1. 写博客的步骤"></a>1. 写博客的步骤</h3><h4 id="1-1-创建-md文件"><a href="#1-1-创建-md文件" class="headerlink" title="1.1 创建.md文件"></a>1.1 创建.md文件</h4><ul><li><p>方法一、使用hexo命令创建</p><ul><li><p>在hexo根目录，在Git Bash Here中执行命令：<code>hexo new &#39;文章名称&#39;</code></p></li><li><p>hexo会自动在对应位置生成.md文件，且自动在 新建的.md文件中生成如下内容</p><p><img src="/2022/09/01/HexoBlogBuild/16.png" alt="img"></p></li></ul></li><li><p>方法二、直接在hexo根目录\source\_posts文件夹下直接创建.md文件</p></li></ul><h4 id="1-2-编写并保存"><a href="#1-2-编写并保存" class="headerlink" title="1.2 编写并保存"></a>1.2 编写并保存</h4><ul><li>使用typora打开该文件，编写博客，写完后Ctrl+S保存关闭即可</li></ul><h4 id="1-3-推送博客"><a href="#1-3-推送博客" class="headerlink" title="1.3  推送博客"></a>1.3  推送博客</h4><ul><li>在hexo根目录下，在Git Bash Here中依次执行以下命令<ul><li><code>hexo clean</code>清理</li><li><code>hexo g</code>生成</li><li><code>hexo d</code>部署</li></ul></li></ul><h3 id="2-注意使用的文章-Front-matter-语法"><a href="#2-注意使用的文章-Front-matter-语法" class="headerlink" title="2. 注意使用的文章 Front-matter 语法"></a>2. 注意使用的文章 Front-matter 语法</h3><ul><li>不同主题有所不同，在主题的使用文档中查找。<a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5">hexo中的说明</a></li><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5">fluid主题对应文档</a></li></ul><h3 id="3-向hexo博客中插入图片"><a href="#3-向hexo博客中插入图片" class="headerlink" title="3. 向hexo博客中插入图片"></a>3. 向hexo博客中插入图片</h3><h4 id="3-1-常规路径设置，及其问题"><a href="#3-1-常规路径设置，及其问题" class="headerlink" title="3.1 常规路径设置，及其问题"></a>3.1 常规路径设置，及其问题</h4><ul><li><p>md中插入图片的语法为：![]()</p><ul><li><p>[]为图片描述 | ()为图片路径:  路径分为三种</p><ul><li><p>相对路径</p><blockquote><p>在hexo配置文件中启用 post_asset_folder: true</p><p>使用hexo new命令创建文章的时候会生成同名的文件夹用于存放文件资源</p><p>引入图片：![](image.jpg)</p><p>问题：</p><ol><li><p>在Typora中无法显示</p><ul><li><p>在Typora引入相对路径图片：![](文章名&#x2F;image.jpg)</p></li><li><p>在Hexo中引入相对路径图片：![](image.jpg)</p></li></ul></li><li><p>在首页显示</p><ul><li>解决办法：使用标签插件语法 </li></ul></li></ol></blockquote></li><li><p>绝对路径</p><blockquote><p>将图片文件放在：hexo根目录&#x2F;source&#x2F;images&#x2F;image.jpg</p><p>引入图片：![图片描述](&#x2F;images&#x2F;image.jpg)</p><p>问题：</p><ul><li>所有文章的图片都在 source&#x2F;images 目录下，图片资源杂乱</li></ul></blockquote></li><li><p>网络路径</p><blockquote><p>问题：图片链接可能失效</p></blockquote></li></ul></li></ul></li></ul><h4 id="3-2-图片插入的解决办法"><a href="#3-2-图片插入的解决办法" class="headerlink" title="3.2 图片插入的解决办法"></a>3.2 图片插入的解决办法</h4><ol><li><p>asset-image插件</p><ul><li><p>安装: <code>npm install https://github.com/CodeFalling/hexo-asset-image</code></p></li><li><p>修改Hexo配置文件</p><blockquote><p>post_asset_folder: true</p></blockquote></li><li><p>设置好后在Hexo中就可以使用 ![](文章名&#x2F;image.jpg) 插入图片</p></li></ul></li><li><p>asset-image插件+Typora结合</p><ul><li><p>在Typora中， 文件-&gt;偏好设置-&gt;图像中设置<img src="/2022/09/01/HexoBlogBuild/21.png" alt="img"></p></li><li><p>复制网络图片</p><blockquote><p>在网页中复制图片后，粘贴到Typora中，会直接复制该图片到文章资源文件夹中，同时自动更改路径</p><p>如：图片 https:&#x2F;&#x2F;…&#x2F;image.jpg 粘贴到Typora中叫文章名的文章中后，图片的路径自动变为(文章名&#x2F;image.jpg)，同时图片资源自动存入对应文章资源文件夹中</p></blockquote></li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://reclusew.github.io/2021/08/12/blog-setup/">2021年最全搭建+美化+使用博客教程</a></li><li><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li><li><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册 (fluid-dev.com)</a></li><li><a href="http://codecook.site/2020/12/05/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/">hexo图片路径设置</a></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
